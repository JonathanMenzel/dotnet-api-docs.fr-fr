<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="EventWaitHandle.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac504ca1c444cfd772670659b4609b267628b38c728.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04ca1c444cfd772670659b4609b267628b38c728</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Represents a thread synchronization event.</source>
          <target state="translated">Représente un événement de synchronisation de threads.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class allows threads to communicate with each other by signaling.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> classe permet aux threads de communiquer entre eux par la signalisation.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Typically, one or more threads block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> until an unblocked thread calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, releasing one or more of the blocked threads.</source>
          <target state="translated">En général, un ou plusieurs threads se bloquent sur un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> jusqu'à ce qu’un thread débloqué appelle la <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> méthode et libère un ou plusieurs des threads bloqués.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>A thread can signal an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> and then block on it, by calling the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un thread peut signaler un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> et bloquer ensuite sur celui-ci, en appelant le <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class provides access to named system synchronization events.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> classe fournit l’accès aux événements de synchronisation système nommé.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The behavior of an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> that has been signaled depends on its reset mode.</source>
          <target state="translated">Le comportement d’un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> qui a été signalé dépend de son mode de réinitialisation.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag resets automatically when signaled, after releasing a single waiting thread.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> indicateur réinitialise automatiquement quand il est signalé, après avoir libéré un seul thread en attente.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag remains signaled until its <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> indicateur reste signalé jusqu'à ce que son <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Automatic reset events provide exclusive access to a resource.</source>
          <target state="translated">Événements de réinitialisation automatique fournissent un accès exclusif à une ressource.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</source>
          <target state="translated">Si un événement à réinitialisation automatique est signalé alors qu’aucun thread n’attend, il reste signalé jusqu'à ce qu’un thread tente de l’attendre.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The event releases the thread and immediately resets, blocking subsequent threads.</source>
          <target state="translated">L’événement libère le thread et est immédiatement réinitialisé, ce qui bloque les threads suivants.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Manual reset events are like gates.</source>
          <target state="translated">Les événements sont comme des portes de réinitialisation manuelle.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>When the event is not signaled, threads that wait on it will block.</source>
          <target state="translated">Lorsque l’événement n’est pas signalé, les threads qui l’attendent se bloquent.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Lorsque l’événement est signalé, tous les threads en attente sont libérés et l’événement reste signalé (c'est-à-dire que les attentes suivantes ne se bloquent pas) jusqu'à ce que son <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Manual reset events are useful when one thread must complete an activity before other threads can proceed.</source>
          <target state="translated">Événements de réinitialisation manuelle sont utiles lorsqu’un thread doit terminer une activité avant de procéder des autres threads.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects can be used with the <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objets peuvent être utilisés avec la <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> en Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>For more information about thread synchronization mechanisms, see <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les mécanismes de synchronisation de threads, consultez <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">Le code suivant exemple utilise le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">L’exemple démarre cinq threads et leur permet de bloquer sur un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant une <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour définir l'état initial comme étant signalé ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour le définir comme étant non signalé.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">L’une des valeurs <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, en spécifiant si le handle d'attente est signalé initialement et s'il se réinitialise automatiquement ou manuellement.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Si l’état initial de l’événement est "non signalé", les threads qui attendent que l’événement se bloquent.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Si l’état initial est signalé et le <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> indicateur est spécifié pour <ph id="ph2">`mode`</ph>, les threads qui attendent que l’événement se bloquent pas.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Si l’état initial est signalé, et <ph id="ph1">`mode`</ph> est <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, le premier thread qui attend l’événement est libéré immédiatement, après laquelle l’événement va réinitialiser et bloquent les threads suivants.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">Le code suivant exemple utilise le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses ENTER key.</source>
          <target state="translated">L’exemple démarre cinq threads et leur permet de bloquer sur un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant une <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour le définir sur non signalé.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">L’une des valeurs <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">Le nom d’un événement de synchronisation à l’échelle du système.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, en spécifiant si le handle d'attente est signalé initialement s'il a été créé à la suite de cet appel, s'il se réinitialise automatiquement ou manuellement, ainsi que le nom d'un événement de synchronisation du système.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If <ph id="ph1">`name`</ph> is <ph id="ph2">`null`</ph> or an empty string, a local <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is created.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> est <ph id="ph2">`null`</ph> ou une chaîne vide, une variable locale <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> est créé.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Si un événement système avec le nom spécifié pour le <ph id="ph1">`name`</ph> paramètre existe déjà, le <ph id="ph2">`initialState`</ph> paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>When using this constructor for named system events, specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initialState`</ph>.</source>
          <target state="translated">Lorsque vous utilisez ce constructeur pour des événements système nommé, spécifiez <ph id="ph1">`false`</ph> pour <ph id="ph2">`initialState`</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</source>
          <target state="translated">Ce constructeur ne fournit aucun moyen de déterminer si un événement système nommé a été créé, vous ne pouvez pas faire d’hypothèses concernant l’état de l’événement nommé.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>To determine whether a named event was created, use the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> constructor.</source>
          <target state="translated">Pour déterminer si un événement nommé a été créé, utilisez la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructeur ou <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Si l’état initial de l’événement est "non signalé", les threads qui attendent que l’événement se bloquent.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Si l’état initial est signalé et le <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> indicateur est spécifié pour <ph id="ph2">`mode`</ph>, les threads qui attendent que l’événement se bloquent pas.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Si l’état initial est signalé, et <ph id="ph1">`mode`</ph> est <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, le premier thread qui attend l’événement est libéré immédiatement, après laquelle l’événement va réinitialiser et bloquent les threads suivants.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Une erreur Win32 s’est produite.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> fait plus de 260 caractères.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour le définir sur non signalé.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">L’une des valeurs <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">Le nom d’un événement de synchronisation à l’échelle du système.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local event was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system event was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system event already existed.</source>
          <target state="translated">Cette méthode retourne <ph id="ph1">&lt;see langword="true" /&gt;</ph> si un événement local a été créé (en d’autres termes, si <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> est <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou une chaîne vide) ou si l’événement système nommé spécifié a été créé ; <ph id="ph3">&lt;see langword="false" /&gt;</ph> si l’événement système nommé spécifié existait déjà.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, spécifiant si le handle d’attente est signalé initialement s’il est créé suite à cet appel, s’il se réinitialise automatiquement ou manuellement, le nom d’un événement de synchronisation du système et une variable booléenne dont la valeur après l’appel indique si l’événement système nommé a été créé.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Si un événement système avec le nom spécifié pour le <ph id="ph1">`name`</ph> paramètre existe déjà, le <ph id="ph2">`initialState`</ph> paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic)<ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
          <target state="translated">Après l’appel de ce constructeur, utilisez la valeur de la variable spécifiée pour le <ph id="ph1">`ref`</ph> paramètre (<ph id="ph2">`ByRef`</ph> paramètre en Visual Basic)<ph id="ph3">`createdNew`</ph> pour déterminer si l’événement système nommé existait déjà ou a été créé.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Si l’état initial de l’événement est "non signalé", les threads qui attendent que l’événement se bloquent.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Si l’état initial est signalé et le <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> indicateur est spécifié pour <ph id="ph2">`mode`</ph>, les threads qui attendent que l’événement se bloquent pas.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Si l’état initial est signalé, et <ph id="ph1">`mode`</ph> est <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, le premier thread qui attend l’événement est libéré immédiatement, après laquelle l’événement va réinitialiser et bloquent les threads suivants.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Une erreur Win32 s’est produite.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> fait plus de 260 caractères.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour le définir sur non signalé.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">L’une des valeurs <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">Le nom d’un événement de synchronisation à l’échelle du système.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local event was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system event was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system event already existed.</source>
          <target state="translated">Cette méthode retourne <ph id="ph1">&lt;see langword="true" /&gt;</ph> si un événement local a été créé (en d’autres termes, si <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> est <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou une chaîne vide) ou si l’événement système nommé spécifié a été créé ; <ph id="ph3">&lt;see langword="false" /&gt;</ph> si l’événement système nommé spécifié existait déjà.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> qui représente la sécurité de contrôle d’accès à appliquer à l’événement système nommé.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, spécifiant si le handle d’attente est signalé initialement s’il est créé suite à cet appel, s’il se réinitialise automatiquement ou manuellement, le nom d’un événement de synchronisation du système et une variable booléenne dont la valeur après l’appel indique si l’événement système nommé a été créé, et la sécurité de contrôle d’accès à appliquer à l’événement nommé s’il est créé.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</source>
          <target state="translated">Utilisez ce constructeur pour appliquer la sécurité de contrôle d’accès à un événement système nommé lors de sa création, en empêchant l’autre code de prendre le contrôle de l’événement.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This constructor initializes an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object that represents a system event.</source>
          <target state="translated">Ce constructeur initialise un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objet qui représente un événement système.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects that represent the same system event.</source>
          <target state="translated">Vous pouvez créer plusieurs <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objets qui représentent le même événement système.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the system event does not exist, it is created with the specified access control security.</source>
          <target state="translated">Si l’événement système n’existe pas, il est créé avec la sécurité de contrôle d’accès spécifié.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event exists, the specified access control security is ignored.</source>
          <target state="translated">Si l’événement existe, la sécurité de contrôle d’accès spécifié est ignorée.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object even if <ph id="ph2">`eventSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">L’appelant a un contrôle total sur nouvellement créé <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objet même si <ph id="ph2">`eventSecurity`</ph> refuse ou ne parvient pas à accorder des droits d’accès à l’utilisateur actuel.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object to represent the same named event, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">Toutefois, si l’utilisateur actuel tente d’obtenir un autre <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> pour représenter le même événement nommé, en utilisant un constructeur de l’objet ou le <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> (méthode), Windows de sécurité de contrôle d’accès est appliquée.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Si un événement système avec le nom spécifié pour le <ph id="ph1">`name`</ph> paramètre existe déjà, le <ph id="ph2">`initialState`</ph> paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic) <ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
          <target state="translated">Après l’appel de ce constructeur, utilisez la valeur de la variable spécifiée pour le <ph id="ph1">`ref`</ph> paramètre (<ph id="ph2">`ByRef`</ph> paramètre en Visual Basic) <ph id="ph3">`createdNew`</ph> pour déterminer si l’événement système nommé existait déjà ou a été créé.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Si l’état initial de l’événement est "non signalé", les threads qui attendent que l’événement se bloquent.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Si l’état initial est signalé et le <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> indicateur est spécifié pour <ph id="ph2">`mode`</ph>, les threads qui attendent que l’événement se bloquent pas.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Si l’état initial est signalé, et <ph id="ph1">`mode`</ph> est <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, le premier thread qui attend l’événement est libéré immédiatement, après laquelle l’événement va réinitialiser et bloquent les threads suivants.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> la surcharge de méthode pour tester l’existence d’un événement nommé.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">L’exception est interceptée et l’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour l’attendre et le signaler.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Une erreur Win32 s’est produite.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> fait plus de 260 caractères.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security for the named system event represented by the current <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object.</source>
          <target state="translated">Obtient un objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> qui représente la sécurité de contrôle d'accès pour l'événement système nommé représenté par l'objet <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security for the named system event.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> qui représente la sécurité de contrôle d'accès pour l'événement système nommé.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> méthode utilise la combinaison d’indicateurs (combinées à l’aide de l’opération OR au niveau du bit) suivante pour rechercher des autorisations : <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, et <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">L’utilisateur doit avoir <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> droits pour appeler cette méthode et l’événement doivent avoir été ouvert avec le <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> la surcharge de méthode pour tester l’existence d’un événement nommé.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">L’exception est interceptée et l’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>After the permissions have been read, using the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method, and changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Une fois que les autorisations ont été lus, à l’aide de la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> (méthode), et modifié, l’événement est ouvert avec les droits requis pour attendre et le signaler.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object represents a named system event, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">L'objet <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> actuel représente un événement système nommé et l'utilisateur n'a pas de droits <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object represents a named system event, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">L'objet <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> actuel représente un événement système nommé ; il n'a pas été ouvert avec <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Non pris en charge par Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> a été précédemment appelée sur ce <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Opens a specified named synchronization event, if it already exists.</source>
          <target state="translated">Ouvre un événement de synchronisation nommé spécifié s'il existe déjà.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">Nom de l’événement de synchronisation système à ouvrir.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Opens the specified named synchronization event, if it already exists.</source>
          <target state="translated">Ouvre l'événement de synchronisation nommé spécifié s'il existe déjà.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>An  object that represents the named system event.</source>
          <target state="translated">Objet qui représente l’événement système nommé.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open the specified named system event.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> méthode essaie d’ouvrir l’événement système nommé spécifié.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
          <target state="translated">Si l’événement système n’existe pas, cette méthode lève une exception au lieu de créer l’événement système.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructeurs qui a un <ph id="ph2">`name`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Plusieurs appels à cette méthode qui utilisent la même valeur pour <ph id="ph1">`name`</ph> ne retournent pas nécessairement le même <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> de l’objet, même si les objets retournés représentent le même événement système nommé.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> surcharge de méthode et en spécifiant <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> des droits, combinés à l’aide de l’opération OR au niveau du bit.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">En spécifiant le <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> indicateur permet à un thread d’attendre l’événement système nommé et en spécifiant le <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> indicateur permet à un thread d’appeler le <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> et <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> la surcharge de méthode pour tester l’existence d’un événement nommé.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">L’exception est interceptée et l’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour l’attendre et le signaler.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne vide.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> fait plus de 260 caractères.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The named system event does not exist.</source>
          <target state="translated">L'événement de système nommé n'existe pas.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Une erreur Win32 s’est produite.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The named event exists, but the user does not have the security access required to use it.</source>
          <target state="translated">L'événement nommé existe, mais l'utilisateur ne possède pas l'accès de sécurité requis pour l'utiliser.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">Nom de l’événement de synchronisation système à ouvrir.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access.</source>
          <target state="translated">Ouvre l'événement de synchronisation nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>An object that represents the named system event.</source>
          <target state="translated">Objet qui représente l'événement système nommé.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">Le <ph id="ph1">`rights`</ph> paramètre doit inclure le <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> indicateur pour permettre aux threads d’attendre l’événement et le <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> indicateur pour permettre aux threads d’appeler le <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> et <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open an existing named system event.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> méthode essaie d’ouvrir un événement système nommé existant.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
          <target state="translated">Si l’événement système n’existe pas, cette méthode lève une exception au lieu de créer l’événement système.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructeurs qui a un <ph id="ph2">`name`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Plusieurs appels à cette méthode qui utilisent la même valeur pour <ph id="ph1">`name`</ph> ne retournent pas nécessairement le même <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> de l’objet, même si les objets retournés représentent le même événement système nommé.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> la surcharge de méthode pour tester l’existence d’un événement nommé.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">L’exception est interceptée et l’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour l’attendre et le signaler.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne vide.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> fait plus de 260 caractères.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The named system event does not exist.</source>
          <target state="translated">L'événement de système nommé n'existe pas.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Une erreur Win32 s’est produite.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source>Sets the state of the event to nonsignaled, causing threads to block.</source>
          <target state="translated">Définit l’état de l’événement à “non signalé”, ce qui entraîne le blocage des threads.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération aboutit ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> a été précédemment appelée sur ce <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</source>
          <target state="translated">Définit l’état de l’événement à Signalé, ce qui permet à un ou plusieurs threads en attente de continuer.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération aboutit ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method releases a single thread.</source>
          <target state="translated">Pour un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> avec <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> (y compris <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), la <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> méthode libère un thread unique.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">S’il n’y a pas de threads en attente, le handle d’attente reste signalé jusqu'à ce qu’un thread tente d’attendre sur celui-ci, ou jusqu'à ce que son <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>There is no guarantee that every call to the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method will release a thread from an <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> whose reset mode is <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il n’existe aucune garantie que chaque appel à la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> libère un thread d’une <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> dont le mode de réinitialisation est <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</source>
          <target state="translated">Si deux appels sont trop proches, afin que le deuxième appel se produit avant qu’un thread a été publié, un seul thread est libéré.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>It is as if the second call did not happen.</source>
          <target state="translated">Il s’agit comme si le deuxième appel n’est pas possible.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>Also, if <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> is called when there are no threads waiting and the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is already signaled, the call has no effect.</source>
          <target state="translated">En outre, si <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> est appelée lorsqu’il n’y a aucune threads en attente et le <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> est déjà signalé, l’appel n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), calling the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method leaves the wait handle in a signaled state until its <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Pour un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> avec <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> (y compris <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), l’appel du <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> méthode laisse le handle d’attente dans un état signalé jusqu'à ce que son <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">Le code suivant exemple utilise le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">L’exemple démarre cinq threads et leur permet de bloquer sur un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant une <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> a été précédemment appelée sur ce <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> qui représente la sécurité de contrôle d’accès à appliquer à l’événement système nommé.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Sets the access control security for a named system event.</source>
          <target state="translated">Définit la sécurité de contrôle d’accès pour un événement système nommé.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">L’utilisateur doit avoir <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> droits pour appeler cette méthode et l’événement doivent avoir été ouvert avec le <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> la surcharge de méthode pour tester l’existence d’un événement nommé.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">L’exception est interceptée et l’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.SetAccessControl%2A&gt;</ph> method, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Une fois que les autorisations sont modifiées, à l’aide de la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.SetAccessControl%2A&gt;</ph> méthode, l’événement est ouvert avec les droits requis pour l’attendre et le signaler.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;paramref name="eventSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventSecurity" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">L'utilisateur ne détient pas d'autorisations <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The event was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">L'événement n'a pas été ouvert avec <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object does not represent a named system event.</source>
          <target state="translated">L'objet <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> actuel ne représente pas un événement système nommé.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> a été précédemment appelée sur ce <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Ouvre un événement de synchronisation nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">Nom de l’événement de synchronisation système à ouvrir.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Quand cette méthode est retournée, contient un objet <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> qui représente l’événement de synchronisation nommé si l’appel a réussi, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si l’appel a échoué.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Ce paramètre est traité comme étant non initialisé.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Ouvre l’événement de synchronisation nommé spécifié, s’il existe déjà, et retourne une valeur indiquant si l’opération a réussi.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l’événement de synchronisation nommé a été ouvert ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
          <target state="translated">Si l’événement de synchronisation nommé n’existe pas, cette méthode ne crée pas il.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructeurs qui a un <ph id="ph2">`name`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
          <target state="translated">Si vous n’êtes pas certain qu’il existe un événement de synchronisation nommé, utilisez cette surcharge de méthode à la place de la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> surcharge de méthode qui lève une exception si l’événement de synchronisation n’existe pas.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> surcharge de méthode et en spécifiant <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> des droits, combinés à l’aide de l’opération OR au niveau du bit.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">En spécifiant le <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> indicateur permet à un thread d’attendre l’événement système nommé et en spécifiant le <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> indicateur permet à un thread d’appeler le <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> et <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Plusieurs appels à cette méthode qui utilisent la même valeur pour <ph id="ph1">`name`</ph> ne retournent pas nécessairement le même <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> de l’objet, même si les objets retournés représentent le même événement système nommé.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne vide.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> fait plus de 260 caractères.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Une erreur Win32 s’est produite.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">Nom de l’événement de synchronisation système à ouvrir.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Quand cette méthode est retournée, contient un objet <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> qui représente l'événement de synchronisation nommé si l'appel a réussi, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si l'appel a échoué.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Ce paramètre est traité comme étant non initialisé.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Ouvre l'événement de synchronisation nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité, puis retourne une valeur indiquant si l'opération a réussi.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l’événement de synchronisation nommé a été ouvert ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
          <target state="translated">Si l’événement de synchronisation nommé n’existe pas, cette méthode ne crée pas il.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructeurs qui a un <ph id="ph2">`name`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
          <target state="translated">Si vous n’êtes pas certain qu’il existe un événement de synchronisation nommé, utilisez cette surcharge de méthode à la place de la <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> surcharge de méthode qui lève une exception si l’événement de synchronisation n’existe pas.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">Le <ph id="ph1">`rights`</ph> paramètre doit inclure le <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> indicateur pour permettre aux threads d’attendre l’événement et le <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> indicateur pour permettre aux threads d’appeler le <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> et <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Plusieurs appels à cette méthode qui utilisent la même valeur pour <ph id="ph1">`name`</ph> ne retournent pas nécessairement le même <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> de l’objet, même si les objets retournés représentent le même événement système nommé.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne vide.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> fait plus de 260 caractères.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Une erreur Win32 s’est produite.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>