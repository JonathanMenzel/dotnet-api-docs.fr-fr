<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8e0f8abfca02365da96c9660c5011b3e5ad6d861" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39829502" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="26b12-101">Fournit des opérations atomiques pour des variables partagées par plusieurs threads.</span>
      <span class="sxs-lookup">
        <span data-stu-id="26b12-101">Provides atomic operations for variables that are shared by multiple threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-102">Les méthodes de cette classe vous protéger contre les erreurs qui peuvent se produire lorsque le planificateur change de contexte pendant un thread est mise à jour une variable qui est accessible par d’autres threads ou lorsque deux threads sont exécutent simultanément sur des processeurs distincts.</span><span class="sxs-lookup"><span data-stu-id="26b12-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="26b12-103">Les membres de cette classe ne lèvent pas d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="26b12-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="26b12-104">Le <xref:System.Threading.Interlocked.Increment%2A> et <xref:System.Threading.Interlocked.Decrement%2A> méthodes incrémentent ou décrémentent une variable et stocker la valeur obtenue en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="26b12-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="26b12-105">Sur la plupart des ordinateurs, l’incrémentation d’une variable n’est pas une opération atomique, nécessitant les étapes suivantes :</span><span class="sxs-lookup"><span data-stu-id="26b12-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="26b12-106">Charger une valeur d’une variable d’instance dans un Registre.</span><span class="sxs-lookup"><span data-stu-id="26b12-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="26b12-107">Incrémenter ou décrémenter la valeur.</span><span class="sxs-lookup"><span data-stu-id="26b12-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="26b12-108">Store la valeur dans la variable d’instance.</span><span class="sxs-lookup"><span data-stu-id="26b12-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="26b12-109">Si vous n’utilisez pas <xref:System.Threading.Interlocked.Increment%2A> et <xref:System.Threading.Interlocked.Decrement%2A>, un thread peut être interrompu après l’exécution les deux premières étapes.</span><span class="sxs-lookup"><span data-stu-id="26b12-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="26b12-110">Un autre thread peut alors exécuter ces trois étapes.</span><span class="sxs-lookup"><span data-stu-id="26b12-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="26b12-111">Lorsque le premier thread reprend l’exécution, il remplace la valeur dans la variable d’instance, et l’effet de l’incrémentation ou la décrémentation effectuée par le deuxième thread est perdu.</span><span class="sxs-lookup"><span data-stu-id="26b12-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  
  
 <span data-ttu-id="26b12-112">Le <xref:System.Threading.Interlocked.Exchange%2A> méthode échange les valeurs des variables spécifiées de manière atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-112">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="26b12-113">Le <xref:System.Threading.Interlocked.CompareExchange%2A> méthode combine deux opérations : comparaison de deux valeurs et stockage d’une troisième valeur dans l’une des variables, en fonction du résultat de la comparaison.</span><span class="sxs-lookup"><span data-stu-id="26b12-113">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="26b12-114">Les opérations de comparaison et d’échange sont effectuées comme une opération atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-114">The compare and exchange operations are performed as an atomic operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26b12-115">L’exemple de code suivant montre un mécanisme de verrouillage de ressources thread-safe.</span><span class="sxs-lookup"><span data-stu-id="26b12-115">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="26b12-116">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="26b12-116">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26b12-117">Ajoute deux entiers et remplace le premier entier par la somme, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-117">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-118">Variable qui contient la première valeur à ajouter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-118">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="26b12-119">La somme des deux valeurs est stockée dans <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-119">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-120">Valeur à ajouter à l’entier à <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-120">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-121">Ajoute deux entiers 32 bits et remplace le premier entier par la somme, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-121">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-122">La nouvelle valeur stockée à <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-122">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-123">Cette méthode gère une condition de dépassement de capacité en encapsulant : si la valeur à `location1` est <xref:System.Int32.MaxValue?displayProperty=nameWithType> et `value` est 1, le résultat est <xref:System.Int32.MinValue?displayProperty=nameWithType>; si `value` est 2, le résultat est (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1) ; et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="26b12-123">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="26b12-124">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="26b12-124">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-125">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-125">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-126">Variable qui contient la première valeur à ajouter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-126">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="26b12-127">La somme des deux valeurs est stockée dans <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-127">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-128">Valeur à ajouter à l’entier à <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-128">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-129">Ajoute deux entiers 64 bits et remplace le premier entier par la somme, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-129">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-130">La nouvelle valeur stockée à <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-130">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-131">Cette méthode gère une condition de dépassement de capacité en encapsulant : si la valeur à `location1` est <xref:System.Int64.MaxValue?displayProperty=nameWithType> et `value` est 1, le résultat est <xref:System.Int64.MinValue?displayProperty=nameWithType>; si `value` est 2, le résultat est (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1) ; et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="26b12-131">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="26b12-132">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="26b12-132">No exception is thrown.</span></span>  
  
 <span data-ttu-id="26b12-133">Le <xref:System.Threading.Interlocked.Read%2A> (méthode) et les surcharges 64 bits de la <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, et <xref:System.Threading.Interlocked.Add%2A> méthodes sont véritablement atomiques que sur les systèmes où un <xref:System.IntPtr?displayProperty=nameWithType> est de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="26b12-133">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="26b12-134">Sur d’autres systèmes, ces méthodes sont atomiques par rapport à l’autre, mais pas par rapport à d’autres moyens d’accéder aux données.</span><span class="sxs-lookup"><span data-stu-id="26b12-134">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="26b12-135">Par conséquent, pour être thread-safe sur les systèmes 32 bits, tout accès à une valeur 64 bits doit être effectuée via les membres de la <xref:System.Threading.Interlocked> classe.</span><span class="sxs-lookup"><span data-stu-id="26b12-135">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-136">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-136">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26b12-137">Compare deux valeurs et remplace la première valeur en cas d'égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-137">Compares two values for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-138">Destination dont la valeur est comparée à <c>comparand</c> et qui peut être remplacée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-138">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-139">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-139">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="26b12-140">Valeur qui est comparée à la valeur se trouvant à l’emplacement <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-140">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-141">Compare deux nombres à virgule flottante double précision et remplace le premier en cas d'égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-141">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-142">Valeur d’origine dans <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-142">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-143">Si `comparand` et la valeur dans `location1` sont égales, puis `value` est stocké dans `location1`.</span><span class="sxs-lookup"><span data-stu-id="26b12-143">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="26b12-144">Dans le cas contraire, aucune opération n'est effectuée.</span><span class="sxs-lookup"><span data-stu-id="26b12-144">Otherwise, no operation is performed.</span></span> <span data-ttu-id="26b12-145">Les opérations de comparaison et d’échange sont effectuées comme une opération atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-145">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="26b12-146">La valeur de retour de <xref:System.Threading.Interlocked.CompareExchange%2A> est la valeur d’origine dans `location1`, que l’échange a lieu ou non.</span><span class="sxs-lookup"><span data-stu-id="26b12-146">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26b12-147">L’exemple de code suivant montre une méthode thread-safe qui accumule un résultat cumulé des <xref:System.Double> valeurs.</span><span class="sxs-lookup"><span data-stu-id="26b12-147">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="26b12-148">Deux threads ajoutent une série de <xref:System.Double> des valeurs en utilisant la méthode thread-safe et addition ordinaire, et lorsque les threads se terminent les totaux sont comparées.</span><span class="sxs-lookup"><span data-stu-id="26b12-148">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="26b12-149">Sur un ordinateur biprocesseur, il existe une différence significative dans les totaux.</span><span class="sxs-lookup"><span data-stu-id="26b12-149">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="26b12-150">Dans la méthode thread-safe, la valeur initiale du total cumulé est enregistrée, puis le <xref:System.Threading.Interlocked.CompareExchange%2A> méthode est utilisée pour échanger le total qui vient d’être calculé avec l’ancien total.</span><span class="sxs-lookup"><span data-stu-id="26b12-150">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="26b12-151">Si la valeur de retour n’est pas égale à la valeur enregistrée du total en cours d’exécution, puis un autre thread a mis à jour le total entre-temps.</span><span class="sxs-lookup"><span data-stu-id="26b12-151">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="26b12-152">Dans ce cas, la tentative de mise à jour le total cumulé doit être répétée.</span><span class="sxs-lookup"><span data-stu-id="26b12-152">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-153">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-153">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-154">Destination dont la valeur est comparée à <c>comparand</c> et qui peut être remplacée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-154">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-155">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-155">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="26b12-156">Valeur qui est comparée à la valeur se trouvant à l’emplacement <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-156">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-157">Compare deux entiers signés de 32 bits et remplace la première valeur en cas d'égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-157">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-158">Valeur d’origine dans <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-158">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-159">Si `comparand` et la valeur dans `location1` sont égales, puis `value` est stocké dans `location1`.</span><span class="sxs-lookup"><span data-stu-id="26b12-159">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="26b12-160">Dans le cas contraire, aucune opération n'est effectuée.</span><span class="sxs-lookup"><span data-stu-id="26b12-160">Otherwise, no operation is performed.</span></span> <span data-ttu-id="26b12-161">Les opérations de comparaison et d’échange sont effectuées comme une opération atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-161">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="26b12-162">La valeur de retour de <xref:System.Threading.Interlocked.CompareExchange%2A> est la valeur d’origine dans `location1`, que l’échange a lieu ou non.</span><span class="sxs-lookup"><span data-stu-id="26b12-162">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26b12-163">L’exemple de code suivant montre une méthode thread-safe qui cumule un total en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="26b12-163">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="26b12-164">La valeur initiale du total cumulé est enregistrée, puis le <xref:System.Threading.Interlocked.CompareExchange%2A> méthode est utilisée pour échanger le total qui vient d’être calculé avec l’ancien total.</span><span class="sxs-lookup"><span data-stu-id="26b12-164">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="26b12-165">Si la valeur de retour n’est pas égale à la valeur enregistrée du total en cours d’exécution, puis un autre thread a mis à jour le total entre-temps.</span><span class="sxs-lookup"><span data-stu-id="26b12-165">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="26b12-166">Dans ce cas, la tentative de mise à jour le total cumulé doit être répétée.</span><span class="sxs-lookup"><span data-stu-id="26b12-166">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26b12-167">Le <xref:System.Threading.Interlocked.Add%2A> méthode, introduite dans la version 2.0 du .NET Framework, offre un moyen plus commode de cumuler les totaux en cours d’exécution de thread-safe pour les entiers.</span><span class="sxs-lookup"><span data-stu-id="26b12-167">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-168">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-168">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-169">Destination dont la valeur est comparée à <c>comparand</c> et qui peut être remplacée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-169">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-170">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-170">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="26b12-171">Valeur qui est comparée à la valeur se trouvant à l’emplacement <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-171">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-172">Compare deux entiers signés de 64 bits et remplace la première valeur en cas d'égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-172">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-173">Valeur d’origine dans <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-173">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-174">Si `comparand` et la valeur dans `location1` sont égales, puis `value` est stocké dans `location1`.</span><span class="sxs-lookup"><span data-stu-id="26b12-174">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="26b12-175">Dans le cas contraire, aucune opération n'est effectuée.</span><span class="sxs-lookup"><span data-stu-id="26b12-175">Otherwise, no operation is performed.</span></span> <span data-ttu-id="26b12-176">Les opérations de comparaison et d’échange sont effectuées comme une opération atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-176">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="26b12-177">La valeur de retour de <xref:System.Threading.Interlocked.CompareExchange%2A> est la valeur d’origine dans `location1`, que l’échange a lieu ou non.</span><span class="sxs-lookup"><span data-stu-id="26b12-177">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-178">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-178">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-179">
            <see cref="T:System.IntPtr" /> de destination, dont la valeur est comparée à celle de <c>comparand</c> et qui peut être remplacée par <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-179">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <c>comparand</c> and possibly replaced by <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-180">Valeur <see cref="T:System.IntPtr" /> qui remplace la valeur de destination si la comparaison conclut à une égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-180">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="26b12-181">
            <see cref="T:System.IntPtr" /> qui est comparée à la valeur se trouvant à l’emplacement <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-181">The <see cref="T:System.IntPtr" /> that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-182">Compare deux handles ou pointeurs spécifiques à la plateforme et remplace le premier en cas d'égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-182">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-183">Valeur d’origine dans <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-183">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-184">Si `comparand` et la valeur dans `location1` sont égales, puis `value` est stocké dans `location1`.</span><span class="sxs-lookup"><span data-stu-id="26b12-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="26b12-185">Dans le cas contraire, aucune opération n'est effectuée.</span><span class="sxs-lookup"><span data-stu-id="26b12-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="26b12-186">Les opérations de comparaison et d’échange sont effectuées comme une opération atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="26b12-187">La valeur de retour de cette méthode est la valeur d’origine dans `location1`, que l’échange a lieu ou non.</span><span class="sxs-lookup"><span data-stu-id="26b12-187">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26b12-188"><xref:System.IntPtr> est un type spécifique à la plateforme.</span><span class="sxs-lookup"><span data-stu-id="26b12-188"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-189">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-189">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-190">Objet de destination comparé à <c>comparand</c> et qui peut être remplacé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-190">The destination object that is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-191">Objet qui remplace l'objet destination si la comparaison conclut à une égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-191">The object that replaces the destination object if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="26b12-192">Objet qui est comparé à l’objet se trouvant à <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-192">The object that is compared to the object at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-193">Compare deux objets et remplace le premier en cas d'égalité des références.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-193">Compares two objects for reference equality and, if they are equal, replaces the first object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-194">Valeur d’origine dans <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-194">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-195">Si `comparand` et l’objet dans `location1` sont égales, puis `value` est stocké dans `location1`.</span><span class="sxs-lookup"><span data-stu-id="26b12-195">If `comparand` and the object in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="26b12-196">Dans le cas contraire, aucune opération n'est effectuée.</span><span class="sxs-lookup"><span data-stu-id="26b12-196">Otherwise, no operation is performed.</span></span> <span data-ttu-id="26b12-197">Les opérations de comparaison et d’échange sont effectuées comme une opération atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-197">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="26b12-198">La valeur de retour de <xref:System.Threading.Interlocked.CompareExchange%2A> est la valeur d’origine dans `location1`, que l’échange a lieu ou non.</span><span class="sxs-lookup"><span data-stu-id="26b12-198">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="26b12-199">À partir de .NET Framework version 2.0, le <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> surcharge de méthode fournit une alternative de type sécurisé pour les types référence.</span><span class="sxs-lookup"><span data-stu-id="26b12-199">Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26b12-200">Les objets à comparer l’égalité des références, plutôt que <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="26b12-200">The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="26b12-201">Par conséquent, deux instances boxed du même type de valeur (par exemple, l’entier 3) toujours semblent être inégaux, et aucune opération n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="26b12-201">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed.</span></span> <span data-ttu-id="26b12-202">N’utilisez pas cette surcharge avec les types valeur.</span><span class="sxs-lookup"><span data-stu-id="26b12-202">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26b12-203">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-203">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-204">Destination dont la valeur est comparée à <c>comparand</c> et qui peut être remplacée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-204">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-205">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-205">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="26b12-206">Valeur qui est comparée à la valeur se trouvant à l’emplacement <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-206">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-207">Compare deux nombres à virgule flottante simple précision et remplace le premier en cas d'égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-207">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-208">Valeur d’origine dans <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-208">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-209">Si `comparand` et la valeur dans `location1` sont égales, puis `value` est stocké dans `location1`.</span><span class="sxs-lookup"><span data-stu-id="26b12-209">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="26b12-210">Dans le cas contraire, aucune opération n'est effectuée.</span><span class="sxs-lookup"><span data-stu-id="26b12-210">Otherwise, no operation is performed.</span></span> <span data-ttu-id="26b12-211">Les opérations de comparaison et d’échange sont effectuées comme une opération atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-211">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="26b12-212">La valeur de retour de <xref:System.Threading.Interlocked.CompareExchange%2A> est la valeur d’origine dans `location1`, que l’échange a lieu ou non.</span><span class="sxs-lookup"><span data-stu-id="26b12-212">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26b12-213">L’exemple de code suivant montre une méthode thread-safe qui accumule un résultat cumulé des <xref:System.Single> valeurs.</span><span class="sxs-lookup"><span data-stu-id="26b12-213">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="26b12-214">Deux threads ajoutent une série de <xref:System.Single> des valeurs en utilisant la méthode thread-safe et addition ordinaire, et lorsque les threads se terminent les totaux sont comparées.</span><span class="sxs-lookup"><span data-stu-id="26b12-214">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="26b12-215">Sur un ordinateur biprocesseur, il existe une différence significative dans les totaux.</span><span class="sxs-lookup"><span data-stu-id="26b12-215">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="26b12-216">Dans la méthode thread-safe, la valeur initiale du total cumulé est enregistrée, puis le <xref:System.Threading.Interlocked.CompareExchange%2A> méthode est utilisée pour échanger le total qui vient d’être calculé avec l’ancien total.</span><span class="sxs-lookup"><span data-stu-id="26b12-216">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="26b12-217">Si la valeur de retour n’est pas égale à la valeur enregistrée du total en cours d’exécution, puis un autre thread a mis à jour le total entre-temps.</span><span class="sxs-lookup"><span data-stu-id="26b12-217">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="26b12-218">Dans ce cas, la tentative de mise à jour le total cumulé doit être répétée.</span><span class="sxs-lookup"><span data-stu-id="26b12-218">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-219">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-219">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="26b12-220">Le type à utiliser pour <c>location1</c>, <c>valeur</c>, et <c>comparand</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-220">The type to be used for <c>location1</c>, <c>value</c>, and <c>comparand</c>.</span>
          </span>
          <span data-ttu-id="26b12-221">Ce type doit être un type référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-221">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="26b12-222">Destination dont la valeur est comparée à <c>comparand</c> et qui peut être remplacée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-222">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
          <span data-ttu-id="26b12-223">Il s’agit d’un paramètre de référence (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-223">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-224">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-224">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="26b12-225">Valeur qui est comparée à la valeur se trouvant à l’emplacement <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-225">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-226">Compare deux instances du type référence spécifié <paramref name="T" /> et remplace la première en cas d’égalité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-226">Compares two instances of the specified reference type <paramref name="T" /> for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-227">Valeur d’origine dans <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-227">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-228">Si `comparand` et la valeur dans `location1` sont égales, puis `value` est stocké dans `location1`.</span><span class="sxs-lookup"><span data-stu-id="26b12-228">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="26b12-229">Dans le cas contraire, aucune opération n'est effectuée.</span><span class="sxs-lookup"><span data-stu-id="26b12-229">Otherwise, no operation is performed.</span></span> <span data-ttu-id="26b12-230">La comparaison et l’échange sont effectuées comme une opération atomique.</span><span class="sxs-lookup"><span data-stu-id="26b12-230">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="26b12-231">La valeur de retour de cette méthode est la valeur d’origine dans `location1`, que l’échange a lieu ou non.</span><span class="sxs-lookup"><span data-stu-id="26b12-231">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="26b12-232">Cette méthode prend uniquement en charge les types référence.</span><span class="sxs-lookup"><span data-stu-id="26b12-232">This method only supports reference types.</span></span> <span data-ttu-id="26b12-233">Il existe des surcharges de la <xref:System.Threading.Interlocked.CompareExchange%2A> méthode pour les types valeur <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, et <xref:System.Double>, mais il n’existe aucune prise en charge pour les autres types de valeur.</span><span class="sxs-lookup"><span data-stu-id="26b12-233">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26b12-234">Cette surcharge de méthode est préférable à la <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> surcharge de méthode, car ces dernières nécessitent l’accès à liaison tardive à l’objet destination.</span><span class="sxs-lookup"><span data-stu-id="26b12-234">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-235">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-235">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26b12-236">Décrémente une variable spécifiée et stocke le résultat, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-236">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="26b12-237">Variable dont la valeur doit être décrémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-237">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-238">Décrémente une variable spécifiée et stocke le résultat, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-238">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-239">Valeur décrémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-239">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-240">Cette méthode gère une condition de dépassement de capacité en encapsulant : si `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="26b12-240">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="26b12-241">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="26b12-241">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26b12-242">L’exemple suivant détermine le nombre de numéros aléatoire comprises entre 0 et 1 000 est requises pour générer les 1 000 nombres aléatoires avec une valeur du milieu.</span><span class="sxs-lookup"><span data-stu-id="26b12-242">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="26b12-243">Pour suivre le nombre de valeurs du milieu, une variable, `midpointCount`, est égal à 1 000 et décrémenté chaque fois que le Générateur de nombres aléatoires retourne une valeur du milieu.</span><span class="sxs-lookup"><span data-stu-id="26b12-243">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="26b12-244">Étant donné que trois threads génèrent des nombres aléatoires, les <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> méthode est appelée pour s’assurer que plusieurs threads ne mettez à jour `midpointCount` simultanément.</span><span class="sxs-lookup"><span data-stu-id="26b12-244">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="26b12-245">Notez qu’un verrou est également utilisé pour protéger le Générateur de nombres aléatoires et qui un <xref:System.Threading.CountdownEvent> objet est utilisé pour vous assurer que le `Main` méthode ne termine pas l’exécution avant les trois threads.</span><span class="sxs-lookup"><span data-stu-id="26b12-245">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="26b12-246">L’exemple suivant est similaire au précédent, sauf qu’elle utilise le <xref:System.Threading.Tasks.Task> classe au lieu d’une procédure de thread pour générer des entiers aléatoires milieu 50 000.</span><span class="sxs-lookup"><span data-stu-id="26b12-246">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="26b12-247">Dans cet exemple, une expression lambda remplace le `GenerateNumbers` procédure de thread et l’appel à la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> méthode élimine le besoin du <xref:System.Threading.CountdownEvent> objet.</span><span class="sxs-lookup"><span data-stu-id="26b12-247">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26b12-248">L’adresse de <paramref name="location" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-248">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="26b12-249">Variable dont la valeur doit être décrémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-249">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-250">Décrémente la variable spécifiée et stocke le résultat sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-250">Decrements the specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-251">Valeur décrémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-251">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-252">Cette méthode gère une condition de dépassement de capacité en encapsulant : si `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="26b12-252">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="26b12-253">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="26b12-253">No exception is thrown.</span></span>  
  
 <span data-ttu-id="26b12-254">Le <xref:System.Threading.Interlocked.Read%2A> (méthode) et les surcharges 64 bits de la <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, et <xref:System.Threading.Interlocked.Add%2A> méthodes sont véritablement atomiques que sur les systèmes où un <xref:System.IntPtr?displayProperty=nameWithType> est de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="26b12-254">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="26b12-255">Sur d’autres systèmes, ces méthodes sont atomiques par rapport à l’autre, mais pas par rapport à d’autres moyens d’accéder aux données.</span><span class="sxs-lookup"><span data-stu-id="26b12-255">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="26b12-256">Par conséquent, pour être thread-safe sur les systèmes 32 bits, tout accès à une valeur 64 bits doit être effectuée via les membres de la <xref:System.Threading.Interlocked> classe.</span><span class="sxs-lookup"><span data-stu-id="26b12-256">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26b12-257">L’adresse de <paramref name="location" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-257">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26b12-258">Affecte une valeur spécifiée à une variable sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-258">Sets a variable to a specified value as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-259">Variable à laquelle affecter la valeur spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-259">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-260">Valeur affectée au paramètre <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-260">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-261">Affecte une valeur spécifiée à un nombre à virgule flottante double précision, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-261">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-262">Valeur d’origine de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-262">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-263">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-263">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-264">Variable à laquelle affecter la valeur spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-264">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-265">Valeur affectée au paramètre <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-265">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-266">Affecte un entier signé 32 bits à une valeur spécifiée, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-266">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-267">Valeur d’origine de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-267">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="26b12-268">L’exemple de code suivant montre un mécanisme de verrouillage de ressources thread-safe.</span><span class="sxs-lookup"><span data-stu-id="26b12-268">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26b12-269">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-269">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-270">Variable à laquelle affecter la valeur spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-270">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-271">Valeur affectée au paramètre <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-271">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-272">Affecte une valeur spécifiée à un entier signé 64 bits, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-272">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-273">Valeur d’origine de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-273">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-274">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-274">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-275">Variable à laquelle affecter la valeur spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-275">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-276">Valeur affectée au paramètre <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-276">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-277">Affecte une valeur spécifiée à un handle ou un pointeur spécifique à la plateforme, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-277">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-278">Valeur d’origine de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-278">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-279">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-279">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-280">Variable à laquelle affecter la valeur spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-280">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-281">Valeur affectée au paramètre <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-281">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-282">Affecte une valeur spécifiée à un objet, puis retourne une référence à l'objet d'origine sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-282">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-283">Valeur d’origine de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-283">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!NOTE]
> <span data-ttu-id="26b12-284">À partir de .NET Framework version 2.0, le <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> surcharge de méthode fournit une alternative de type sécurisé pour les types référence.</span><span class="sxs-lookup"><span data-stu-id="26b12-284">Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26b12-285">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-285">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="26b12-286">Variable à laquelle affecter la valeur spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-286">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-287">Valeur affectée au paramètre <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-287">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-288">Affecte une valeur spécifiée à un nombre à virgule flottante simple précision, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-288">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-289">Valeur d’origine de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-289">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-290">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-290">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="26b12-291">Le type à utiliser pour <c>location1</c> et <c>valeur</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-291">The type to be used for <c>location1</c> and <c>value</c>.</span>
          </span>
          <span data-ttu-id="26b12-292">Ce type doit être un type référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-292">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="26b12-293">Variable à laquelle affecter la valeur spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-293">The variable to set to the specified value.</span>
          </span>
          <span data-ttu-id="26b12-294">Il s’agit d’un paramètre de référence (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-294">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="26b12-295">Valeur affectée au paramètre <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-295">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-296">Affecte une valeur spécifiée à la variable de type spécifié <paramref name="T" /> et retourne la valeur d’origine, sous la forme d’une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-296">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-297">Valeur d’origine de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-297">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-298">Cette méthode prend uniquement en charge les types référence.</span><span class="sxs-lookup"><span data-stu-id="26b12-298">This method only supports reference types.</span></span> <span data-ttu-id="26b12-299">Il existe des surcharges de la <xref:System.Threading.Interlocked.Exchange%2A> méthode pour le <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, et <xref:System.Double> des types valeur, mais il n’existe aucune prise en charge pour les autres types de valeur.</span><span class="sxs-lookup"><span data-stu-id="26b12-299">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26b12-300">Cette surcharge de méthode est préférable à la <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> surcharge de méthode, car ces dernières nécessitent l’accès à liaison tardive à l’objet de destination.</span><span class="sxs-lookup"><span data-stu-id="26b12-300">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-301">L’adresse de <paramref name="location1" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-301">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26b12-302">Incrémente une variable spécifiée et stocke le résultat sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-302">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="26b12-303">Variable dont la valeur doit être incrémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-303">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-304">Incrémente une variable spécifiée et stocke le résultat sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-304">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-305">Valeur incrémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-305">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-306">Cette méthode gère une condition de dépassement de capacité en encapsulant : si `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="26b12-306">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="26b12-307">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="26b12-307">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26b12-308">L’exemple suivant détermine le nombre de numéros aléatoire comprises entre 0 et 1 000 est requises pour générer les 1 000 nombres aléatoires avec une valeur du milieu.</span><span class="sxs-lookup"><span data-stu-id="26b12-308">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="26b12-309">Pour suivre le nombre de valeurs du milieu, une variable, `midpointCount`, est égal à 0 et incrémentée chaque fois que le Générateur de nombres aléatoires retourne une valeur du milieu jusqu'à ce qu’il atteigne 10 000.</span><span class="sxs-lookup"><span data-stu-id="26b12-309">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="26b12-310">Étant donné que trois threads génèrent des nombres aléatoires, les <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> méthode est appelée pour s’assurer que plusieurs threads ne mettez à jour `midpointCount` simultanément.</span><span class="sxs-lookup"><span data-stu-id="26b12-310">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="26b12-311">Notez qu’un verrou est également utilisé pour protéger le Générateur de nombres aléatoires et qui un <xref:System.Threading.CountdownEvent> objet est utilisé pour vous assurer que le `Main` méthode ne termine pas l’exécution avant les trois threads.</span><span class="sxs-lookup"><span data-stu-id="26b12-311">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="26b12-312">L’exemple suivant est similaire au précédent, sauf qu’elle utilise le <xref:System.Threading.Tasks.Task> classe au lieu d’une procédure de thread pour générer des entiers aléatoires milieu 50 000.</span><span class="sxs-lookup"><span data-stu-id="26b12-312">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="26b12-313">Dans cet exemple, une expression lambda remplace le `GenerateNumbers` procédure de thread et l’appel à la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> méthode élimine le besoin du <xref:System.Threading.CountdownEvent> objet.</span><span class="sxs-lookup"><span data-stu-id="26b12-313">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-314">L’adresse de <paramref name="location" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-314">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="26b12-315">Variable dont la valeur doit être incrémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-315">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-316">Incrémente une variable spécifiée et stocke le résultat sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-316">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-317">Valeur incrémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-317">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-318">Cette méthode gère une condition de dépassement de capacité en encapsulant : si `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="26b12-318">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="26b12-319">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="26b12-319">No exception is thrown.</span></span>  
  
 <span data-ttu-id="26b12-320">Le <xref:System.Threading.Interlocked.Read%2A> (méthode) et les surcharges 64 bits de la <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, et <xref:System.Threading.Interlocked.Add%2A> méthodes sont véritablement atomiques que sur les systèmes où un <xref:System.IntPtr?displayProperty=nameWithType> est de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="26b12-320">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="26b12-321">Sur d’autres systèmes, ces méthodes sont atomiques par rapport à l’autre, mais pas par rapport à d’autres moyens d’accéder aux données.</span><span class="sxs-lookup"><span data-stu-id="26b12-321">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="26b12-322">Par conséquent, pour être thread-safe sur les systèmes 32 bits, tout accès à une valeur 64 bits doit être effectuée via les membres de la <xref:System.Threading.Interlocked> classe.</span><span class="sxs-lookup"><span data-stu-id="26b12-322">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="26b12-323">L’adresse de <paramref name="location" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-323">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26b12-324">Synchronise l'accès à la mémoire comme suit : le processeur qui exécute le thread actuel ne peut pas réorganiser les instructions de sorte que les accès à la mémoire avant l'appel de <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> s'exécutent après les accès à la mémoire postérieurs à l'appel de <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-324">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-325">Cette méthode a été ajoutée à la <xref:System.Threading.Interlocked> classe dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour des raisons pratiques ; il s’agit d’un wrapper pour le <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="26b12-325">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="26b12-326"><xref:System.Threading.Interlocked.MemoryBarrier%2A> est requis uniquement sur les systèmes multiprocesseurs qui ont un classement faible mémoire (par exemple, un système qui utilise plusieurs processeurs Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="26b12-326"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="26b12-327">La plupart des cas, le C# `lock` instruction, Visual Basic `SyncLock` instruction, ou la <xref:System.Threading.Monitor> classe fournissent des moyens plus simples pour synchroniser les données.</span><span class="sxs-lookup"><span data-stu-id="26b12-327">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="26b12-328">Valeur 64 bits à charger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-328">The 64-bit value to be loaded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26b12-329">Retourne une valeur 64 bits chargée sous la forme d'une opération atomique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-329">Returns a 64-bit value, loaded as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26b12-330">Valeur chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26b12-330">The loaded value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26b12-331">Le <xref:System.Threading.Interlocked.Read%2A> (méthode) n’est pas nécessaire sur les systèmes 64 bits, car les opérations de lecture 64 bits sont déjà atomiques.</span><span class="sxs-lookup"><span data-stu-id="26b12-331">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="26b12-332">Sur les systèmes 32 bits, les opérations de lecture 64 bits ne sont pas atomiques, sauf si effectué à l’aide de <xref:System.Threading.Interlocked.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="26b12-332">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 <span data-ttu-id="26b12-333">Le <xref:System.Threading.Interlocked.Read%2A> (méthode) et les surcharges 64 bits de la <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, et <xref:System.Threading.Interlocked.Add%2A> méthodes sont véritablement atomiques que sur les systèmes où un <xref:System.IntPtr?displayProperty=nameWithType> est de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="26b12-333">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="26b12-334">Sur d’autres systèmes, ces méthodes sont atomiques par rapport à l’autre, mais pas par rapport à d’autres moyens d’accéder aux données.</span><span class="sxs-lookup"><span data-stu-id="26b12-334">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="26b12-335">Par conséquent, pour être thread-safe sur les systèmes 32 bits, tout accès à une valeur 64 bits doit être effectuée via les membres de la <xref:System.Threading.Interlocked> classe.</span><span class="sxs-lookup"><span data-stu-id="26b12-335">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26b12-336"><xref:System.IntPtr> est un type spécifique à la plateforme.</span><span class="sxs-lookup"><span data-stu-id="26b12-336"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
      </Docs>
    </Member>
  </Members>
</Type>