<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fc1a0c88765040869d8ad919aeb575e304c71bde" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531033" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Définit un verrou qui prend en charge les writers uniques et les lecteurs multiples.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] a deux verrous de lecteur-writer, à savoir <xref:System.Threading.ReaderWriterLockSlim> et <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> est recommandé pour tout nouveau développement. <xref:System.Threading.ReaderWriterLockSlim> est similaire à <xref:System.Threading.ReaderWriterLock>, mais a des règles simplifiées pour la récursivité ainsi que la mise à niveau et la rétrogradation de l’état de verrou. <xref:System.Threading.ReaderWriterLockSlim> évite de nombreux cas d’interblocage potentiel. En outre, les performances de <xref:System.Threading.ReaderWriterLockSlim> sont considérablement meilleures que celles de <xref:System.Threading.ReaderWriterLock>.  
  
 <xref:System.Threading.ReaderWriterLock> est utilisé pour synchroniser l’accès à une ressource. À un moment donné, il permet un accès en lecture simultané de plusieurs threads, ou un accès en écriture pour un seul thread. Dans une situation où une ressource est rarement modifiée, un `ReaderWriterLock` fournit de meilleurs résultats que d’un verrou une-à la fois simple, tel que <xref:System.Threading.Monitor>.  
  
 `ReaderWriterLock` fonctionne mieux lorsqu’il accède à la plupart des lectures, n’est en écriture sont rares et de courte durée. Les lecteurs multiples alternent avec les writers uniques afin que les lecteurs, ni enregistreurs sont bloquées pendant de longues périodes.  
  
> [!NOTE]
>  Maintenir des verrous de lecteur ou de writer pendant de longues périodes retarde l’exécution d’autres threads. Pour de meilleures performances, envisagez de restructurer votre application afin de réduire la durée des écritures.  
  
 Un thread peut contenir un lecteur de verrou ou un verrou de writer, mais pas les deux en même temps. Au lieu de libérer un verrou de lecteur pour acquérir le verrou de writer, vous pouvez utiliser <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> et <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.  
  
 Demandes de verrou récursives augmentent le nombre de verrous sur un verrou.  
  
 Lecteurs et writers sont en file d’attente séparément. Lorsqu’un thread libère le verrou de writer, tous les threads en attente dans la file d’attente de lecteur à cet instant bénéficient de verrous de lecteur. Lorsque tous ces verrous de lecteur ont été publiées, l’attente du thread suivant dans l’enregistreur de file d’attente, si elle existe, est accordé le verrou de writer et ainsi de suite. En d’autres termes, `ReaderWriterLock` alterne entre une collection de lecteurs et un writer.  
  
 Lorsqu’un thread dans la file d’attente de l’enregistreur est en attente de libération de verrous lecteur actif, threads demandant de nouveaux verrous de lecteur s’accumulent dans la file d’attente du lecteur. Leurs demandes ne sont pas accordées, même s’ils peuvent partager un accès simultané avec titulaires de verrou de lecteur ; Cela permet de protéger des enregistreurs par rapport à un blocage indéfini par les lecteurs.  
  
 La plupart des méthodes d’acquisition de verrous sur une `ReaderWriterLock` accepte les valeurs de délai d’attente. Délais d’attente permet d’éviter les blocages dans votre application. Par exemple, un thread peut acquérir le verrou de writer sur une ressource et ensuite demander un verrou de lecteur sur un deuxième ressource ; entre-temps, un autre thread peut acquérir le verrou de writer sur la deuxième ressource et demande un verrou de lecteur sur le premier. Sauf si les délais d’attente sont utilisés, le blocage des threads.  
  
 Si l’intervalle de délai d’attente expire et que la demande de verrou n’a pas été accordée, la méthode retourne le contrôle au thread appelant en levant une <xref:System.ApplicationException>. Un thread peut intercepter cette exception et déterminer l’action à entreprendre.  
  
 Délais d’attente sont exprimées en millisecondes. Si vous utilisez un <xref:System.TimeSpan?displayProperty=nameWithType> pour spécifier le délai d’attente, la valeur utilisée est le nombre total de millisecondes entières représenté par le <xref:System.TimeSpan>. Le tableau suivant indique les valeurs valides de délai d’attente en millisecondes.  
  
|Value|Description |  
|-----------|-----------------|  
|-1|Le thread attend jusqu'à ce que le verrou est acquis, quelle que soit la durée. Pour les méthodes qui spécifient des délais d’expiration entiers, la constante <xref:System.Threading.Timeout.Infinite> peut être utilisé.|  
|0|Le thread n’attend pas acquérir le verrou. Si le verrou ne peut pas être acquis immédiatement, la méthode retourne.|  
|>0|Nombre de millisecondes à attendre.|  
  
 À l’exception de -1, les délais d’attente négatifs ne sont pas autorisés. Si vous spécifiez un entier négatif autre que -1, une valeur égale à zéro est utilisée à la place. (Autrement dit, la méthode retourne sans attendre, si le verrou ne peut pas être acquis immédiatement.) Si vous spécifiez un <xref:System.TimeSpan> qui représente un nombre négatif de millisecondes autre que -1, <xref:System.ArgumentOutOfRangeException> est levée.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Threading.ReaderWriterLock> pour protéger une ressource partagée, un entier nommé `resource`, qui est lue simultanément et est écrite exclusivement par plusieurs threads. Notez que le <xref:System.Threading.ReaderWriterLock> est déclarée au niveau de la classe afin qu’il soit visible pour tous les threads.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple de code suivant illustre la création d'une nouvelle instance de la classe <xref:System.Threading.ReaderWriterLock>.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acquiert un verrou de lecteur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Délai en millisecondes.</param>
        <summary>Acquiert un verrou de lecteur en utilisant une valeur <see cref="T:System.Int32" /> comme délai d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> bloque si un autre thread détient le verrou de writer ou si au moins un thread est en attente pour le verrou de writer.  
  
> [!NOTE]
>  Si le thread actuel a déjà le verrou de writer, aucun verrou de lecteur n’est acquis. Au lieu de cela, le nombre de verrous sur le verrou de writer est incrémenté. Cela empêche un thread de se bloquer sur son propre verrou de writer. Le résultat est exactement le même que l’appel <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>et un appel supplémentaire à <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> est requise lors de la libération du verrou de writer.  
  
 `AcquireReaderLock` prend en charge les demandes de verrou de lecteur récursives. Autrement dit, un thread peut appeler AcquireReaderLock plusieurs fois, ce qui augmente le nombre de verrous chaque fois. Vous devez appeler <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> une fois pour chaque fois que vous appelez `AcquireReaderLock`. Vous pouvez également appeler <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> afin de réduire le nombre de verrous immédiatement à zéro.  
  
 Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente du lecteur. Utilisez les verrous récursifs avec précaution, pour éviter de bloquer les demandes de verrou de writer pendant de longues périodes.  
  
 Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment acquérir et libérer un verrou de lecteur et comment gérer l’exception levée lorsqu’une demande arrive à expiration.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="millisecondsTimeout" /> expire avant que la demande de verrou soit accordée.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</param>
        <summary>Acquiert un verrou de lecteur en utilisant une valeur <see cref="T:System.TimeSpan" /> comme délai d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> bloque si un autre thread détient le verrou de writer ou si au moins un thread est en attente pour le verrou de writer.  
  
> [!NOTE]
>  Si le thread actuel a déjà le verrou de writer, aucun verrou de lecteur n’est acquis. Au lieu de cela, le nombre de verrous sur le verrou de writer est incrémenté. Cela empêche un thread de se bloquer sur son propre verrou de writer. Le résultat est exactement le même que l’appel <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>et un appel supplémentaire à <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> est requise lors de la libération du verrou de writer.  
  
 `AcquireReaderLock` prend en charge les demandes de verrou de lecteur récursives. Autrement dit, un thread peut appeler AcquireReaderLock plusieurs fois, ce qui augmente le nombre de verrous chaque fois. Vous devez appeler <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> une fois pour chaque fois que vous appelez `AcquireReaderLock`. Vous pouvez également appeler <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> afin de réduire le nombre de verrous immédiatement à zéro.  
  
 Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente du lecteur. Utilisez les verrous récursifs avec précaution, pour éviter de bloquer les demandes de verrou de writer pendant de longues périodes.  
  
 Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acquiert le verrou de writer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Délai en millisecondes.</param>
        <summary>Acquiert un verrou de writer en utilisant une valeur <see cref="T:System.Int32" /> comme délai d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée si un autre thread a un verrou de lecteur ou un verrou de writer. Pour obtenir une description de la façon dont le verrou de writer alterne avec plusieurs verrous de lecteurs simultanés, consultez la <xref:System.Threading.ReaderWriterLock> classe.  
  
 Un thread qui a déjà un verrou de lecteur peut acquérir le verrou de writer de deux façons : en libérant le verrou de lecteur avant d’appeler <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou en appelant <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Si un thread appelle `AcquireWriterLock` alors qu’il détient toujours un verrou de lecteur, il se bloque sur son propre verrou de lecteur ; si un délai d’attente infini est spécifié, le thread de blocage. Pour éviter ces blocages, utilisez <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> pour déterminer si le thread actuel a déjà un verrou de lecteur.  
  
 `AcquireWriterLock` prend en charge les demandes de verrou de writer récursives. Autrement dit, un thread peut appeler `AcquireWriterLock` plusieurs fois, ce qui augmente le nombre de verrous chaque fois. Vous devez appeler <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> une fois pour chaque fois que vous appelez `AcquireWriterLock`. Vous pouvez également appeler <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> afin de réduire le nombre de verrous immédiatement à zéro.  
  
 Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente de l’enregistreur.  
  
 Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment acquérir et libérer un verrou de writer et comment gérer l’exception levée lorsqu’une demande arrive à expiration.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</param>
        <summary>Acquiert un verrou de writer en utilisant une valeur <see cref="T:System.TimeSpan" /> comme délai d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée si un autre thread a un verrou de lecteur ou un verrou de writer. Pour obtenir une description de la façon dont le verrou de writer alterne avec plusieurs verrous de lecteurs simultanés, consultez la <xref:System.Threading.ReaderWriterLock> classe.  
  
 Un thread qui a déjà un verrou de lecteur peut acquérir le verrou de writer de deux façons : en libérant le verrou de lecteur avant d’appeler <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou en appelant <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Si un thread appelle `AcquireWriterLock` alors qu’il détient toujours un verrou de lecteur, il se bloque sur son propre verrou de lecteur ; si un délai d’attente infini est spécifié, le thread de blocage. Pour éviter ces blocages, utilisez <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> pour déterminer si le thread actuel a déjà un verrou de lecteur.  
  
 `AcquireWriterLock` prend en charge les demandes de verrou de writer récursives. Autrement dit, un thread peut appeler `AcquireWriterLock` plusieurs fois, ce qui augmente le nombre de verrous chaque fois. Vous devez appeler <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> une fois pour chaque fois que vous appelez `AcquireWriterLock`. Vous pouvez également appeler <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> afin de réduire le nombre de verrous immédiatement à zéro.  
  
 Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente de l’enregistreur.  
  
 Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">Numéro de séquence.</param>
        <summary>Indique si le verrou de writer a été accordé à un thread depuis l'obtention du numéro de séquence.</summary>
        <returns>
          <see langword="true" /> si le verrou de writer a été accordé à un thread depuis l'obtention du numéro de séquence ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> et `AnyWritersSince` pour améliorer les performances de l’application. Par exemple, un thread peut mettre en cache les informations obtenues pendant la détention d’un verrou de lecteur. Après avoir libéré puis acquis à nouveau le verrou, le thread peut utiliser `AnyWritersSince` pour déterminer si d’autres threads ont écrit à la ressource dans l’intervalle ; sinon, les informations mises en cache peuvent être utilisées. Cette technique est utile lorsque la lecture des informations protégées par le verrou est coûteuse. par exemple, exécuter une requête de base de données.  
  
 L’appelant doit contenir un verrou de lecteur ou un verrou de writer dans l’ordre pour le numéro de séquence être utile.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> (méthode) et le <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propriété pour déterminer si un autre thread a acquis le verrou de writer sur la ressource protégée depuis que le thread actuel a détenu le verrou de writer.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">
          <see cref="T:System.Threading.LockCookie" /> retourné par <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
        <summary>Restaure le verrou du thread à l'état qu'il avait avant l'appel à <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Libère le verrou de writer, quel que soit le nombre de verrous récursifs et restaure le verrou de lecteur détenu par le thread avant la mise à niveau vers le verrou de writer. Le nombre de verrous sur le verrou de lecteur est restauré.  
  
> [!NOTE]
>  `DowngradeFromWriterLock` accepte un <xref:System.Threading.LockCookie> obtenu en appelant <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>. N’utilisez pas un `LockCookie` retourné par <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.  
  
 Un thread ne bloque pas lors de la mise à niveau de verrou de writer, même si d’autres threads sont en attente pour le verrou de writer, étant donné que toutes les demandes de verrou de lecteur sont accordées lorsque le verrou de writer est libéré.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment demander un verrou de lecteur, mettre à niveau le verrou de lecteur vers un verrou de writer et rétrograder à nouveau vers un verrou de lecteur.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Le thread n'a pas de verrou de writer.</exception>
        <exception cref="T:System.NullReferenceException">L’adresse de <paramref name="lockCookie" /> est un pointeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'objet <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le garbage collector appelle <xref:System.Threading.ReaderWriterLock.Finalize%2A> lorsque actuel <xref:System.Threading.ReaderWriterLock> objet est prêt à être finalisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le thread actif détient un verrou de lecteur.</summary>
        <value>
          <see langword="true" /> si le thread actif détient un verrou de lecteur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment utiliser `IsReaderLockHeld` pour éviter les blocages.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le thread actif détient le verrou de writer.</summary>
        <value>
          <see langword="true" /> si le thread actif détient le verrou de writer ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre que lorsqu’une tentative est faite pour acquérir un verrou de lecteur sur un thread qui dispose un verrou de writer `ReaderWriterLock` n’accorde pas le verrou de lecteur et incrémente le nombre de verrous sur le verrou de writer.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère le verrou quel que soit le nombre de fois où il a été acquis par le thread.</summary>
        <returns>Valeur <see cref="T:System.Threading.LockCookie" /> représentant le verrou libéré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Libère le verrou de lecteur ou un verrou de writer, quel que soit le nombre de verrous récursifs. Pour restaurer l’état du verrou, y compris le nombre de verrous, passez le <xref:System.Threading.LockCookie> à <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser la <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> méthode pour libérer le verrou, quel que soit le nombre de fois qu’il a été acquis par le thread et la façon de restaurer l’état du verrou plus tard.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Décrémente le nombre de verrous.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Décrémente le nombre de verrous. Lorsque le décompte atteint zéro, le verrou est libéré.  
  
> [!NOTE]
>  Si un thread possède le verrou de writer, l’appel `ReleaseReaderLock` a le même effet que l’appel <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>. Si un thread n’a aucun verrou, l’appel `ReleaseReaderLock` lève une <xref:System.ApplicationException>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment acquérir et libérer un verrou de lecteur et comment gérer l’exception levée lorsqu’une demande arrive à expiration.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Le thread n'a pas de verrous de writer ou de lecteur.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Décrémente le nombre de verrous sur le verrou de writer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Décrémente le verrou de writer nombre. Lorsque le décompte atteint zéro, le verrou de writer est libéré.  
  
> [!NOTE]
>  Si un thread a un verrou de lecteur ou aucun verrou, l’appel `ReleaseWriterLock` lève une <xref:System.ApplicationException>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment acquérir et libérer un verrou de writer et comment gérer l’exception levée lorsqu’une demande arrive à expiration.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Le thread n'a pas de verrou de writer.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">
          <see cref="T:System.Threading.LockCookie" /> retourné par <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
        <summary>Restaure l'état de verrou du thread au moment précédant l'appel à <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’état restauré par `RestoreLock` inclut le nombre de verrous récursifs.  
  
 Un thread se bloque si elle tente de restaurer un verrou de lecteur après qu’un autre thread a acquis le verrou de writer ou si elle tente de restaurer le verrou de writer après qu’un autre thread a acquis un verrou de lecteur ou un verrou de writer. Étant donné que `RestoreLock` n’accepte pas un délai d’attente, vous devez veiller à éviter les blocages possibles.  
  
> [!CAUTION]
>  Avant d’appeler `RestoreLock`, assurez-vous que vous avez libéré tous les verrous acquis depuis l’appel à <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>. Par exemple, un thread se bloque s’il acquiert un verrou de lecteur, puis tente de restaurer un verrou de writer précédent. Utilisez <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> et <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> pour détecter ces verrous supplémentaires.  
  
 N’utilisez pas un <xref:System.Threading.LockCookie> retourné par <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser la <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> méthode pour libérer le verrou, quel que soit le nombre de fois qu’il a été acquis par le thread et la façon de restaurer l’état du verrou plus tard.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">L’adresse de <paramref name="lockCookie" /> est un pointeur null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met à niveau un verrou de lecteur vers le verrou de writer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Délai en millisecondes.</param>
        <summary>Met à niveau un verrou de lecteur vers le verrou de writer en utilisant une valeur <see langword="Int32" /> pour définir le délai d'attente.</summary>
        <returns>Valeur <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un thread appelle `UpgradeToWriterLock` le verrou de lecteur est libéré, quel que soit le nombre de verrous, et le thread se place à la fin de la file d’attente pour le verrou de writer. Par conséquent, les autres threads peuvent écrire dans la ressource avant que le thread qui a demandé que la mise à niveau est accordé le verrou de writer.  
  
> [!IMPORTANT]
>  L’exception de délai d’attente n’est pas levée tant que le thread qui a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> méthode peut acquérir le verrou de lecteur. S’il n’y a pas d’autres threads qui attendent le verrou de writer, cela se produit immédiatement. Toutefois, si un autre thread est en attente pour le verrou de writer, le thread qui a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> méthode ne peut pas acquérir le verrou de lecteur tant que tous les lecteurs actuels ont libéré leurs verrous, et un thread a acquis et libéré le verrou de writer. Cela est vrai même si l’autre thread qui a demandé le verrou de writer a demandé une fois que le thread actuel a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> (méthode).  
  
 Pour restaurer l’état du verrou, appelez <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> à l’aide de la <xref:System.Threading.LockCookie> retourné par `UpgradeToWriterLock`. N’utilisez pas cette `LockCookie` avec <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Lorsqu’un thread n’a aucun verrou de lecteur, n’utilisez pas `UpgradeToWriterLock`. Utilisez plutôt <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.  
  
 Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment demander un verrou de lecteur, mettre à niveau le verrou de lecteur vers un verrou de writer et rétrograder à nouveau vers un verrou de lecteur.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="millisecondsTimeout" /> expire avant que la demande de verrou soit accordée.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</param>
        <summary>Met à niveau un verrou de lecteur vers le verrou de writer en utilisant une valeur <see langword="TimeSpan" /> pour définir le délai d'attente.</summary>
        <returns>Valeur <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un thread appelle `UpgradeToWriterLock` le verrou de lecteur est libéré, quel que soit le nombre de verrous, et le thread se place à la fin de la file d’attente pour le verrou de writer. Par conséquent, les autres threads peuvent écrire dans la ressource avant que le thread qui a demandé que la mise à niveau est accordé le verrou de writer.  
  
> [!IMPORTANT]
>  L’exception de délai d’attente n’est pas levée tant que le thread qui a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> méthode peut acquérir le verrou de lecteur. S’il n’y a pas d’autres threads qui attendent le verrou de writer, cela se produit immédiatement. Toutefois, si un autre thread est en attente pour le verrou de writer, le thread qui a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> méthode ne peut pas acquérir le verrou de lecteur tant que tous les lecteurs actuels ont libéré leurs verrous, et un thread a acquis et libéré le verrou de writer. Cela est vrai même si l’autre thread qui a demandé le verrou de writer a demandé une fois que le thread actuel a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> (méthode).  
  
 Pour restaurer l’état du verrou, appelez <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> à l’aide de la <xref:System.Threading.LockCookie> retourné par `UpgradeToWriterLock`. N’utilisez pas cette `LockCookie` avec <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Lorsqu’un thread n’a aucun verrou de lecteur, n’utilisez pas `UpgradeToWriterLock`. Utilisez plutôt <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.  
  
 Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le numéro de séquence actuel.</summary>
        <value>Numéro de séquence actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le numéro de séquence augmente chaque fois qu’un thread acquiert le verrou de writer. Vous pouvez enregistrer le numéro de séquence et le passer à <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> ultérieurement, si vous souhaitez déterminer si d’autres threads ont acquis le verrou de writer dans l’intervalle.  
  
 Vous pouvez utiliser `WriterSeqNum` pour améliorer les performances de l’application. Par exemple, un thread peut mettre en cache les informations obtenues pendant la détention d’un verrou de lecteur. Après avoir libéré puis acquis à nouveau le verrou, le thread peut déterminer si les autres threads ont écrit dans la ressource en appelant `AnyWritersSince`; si non, les informations mises en cache peuvent être utilisées. Cette technique est utile lors de la lecture des informations protégées par le verrou est coûteuse. par exemple, exécuter une requête de base de données.  
  
 L’appelant doit contenir un verrou de lecteur ou un verrou de writer dans l’ordre pour le numéro de séquence être utile.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propriété et la <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> méthode pour déterminer si un autre thread a acquis le verrou de writer sur la ressource protégée depuis que le thread actuel a détenu le verrou de writer.  
  
 Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>