<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ReaderWriterLock.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5fc1a0c88765040869d8ad919aeb575e304c71bde.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fc1a0c88765040869d8ad919aeb575e304c71bde</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLock">
          <source>Defines a lock that supports single writers and multiple readers.</source>
          <target state="translated">Définit un verrou qui prend en charge les writers uniques et les lecteurs multiples.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> has two reader-writer locks, <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> a deux verrous de lecteur-writer, à savoir <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> et <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is recommended for all new development.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> est recommandé pour tout nouveau développement.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> est similaire à <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, mais a des règles simplifiées pour la récursivité ainsi que la mise à niveau et la rétrogradation de l’état de verrou.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> avoids many cases of potential deadlock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> évite de nombreux cas d’interblocage potentiel.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>In addition, the performance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is significantly better than <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">En outre, les performances de <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> sont considérablement meilleures que celles de <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> is used to synchronize access to a resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> est utilisé pour synchroniser l’accès à une ressource.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</source>
          <target state="translated">À un moment donné, il permet un accès en lecture simultané de plusieurs threads, ou un accès en écriture pour un seul thread.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>In a situation where a resource is changed infrequently, a <ph id="ph1">`ReaderWriterLock`</ph> provides better throughput than a simple one-at-a-time lock, such as <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph>.</source>
          <target state="translated">Dans une situation où une ressource est rarement modifiée, un <ph id="ph1">`ReaderWriterLock`</ph> fournit de meilleurs résultats que d’un verrou une-à la fois simple, tel que <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source><ph id="ph1">`ReaderWriterLock`</ph> works best where most accesses are reads, while writes are infrequent and of short duration.</source>
          <target state="translated"><ph id="ph1">`ReaderWriterLock`</ph> fonctionne mieux lorsqu’il accède à la plupart des lectures, n’est en écriture sont rares et de courte durée.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</source>
          <target state="translated">Les lecteurs multiples alternent avec les writers uniques afin que les lecteurs, ni enregistreurs sont bloquées pendant de longues périodes.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Holding reader locks or writer locks for long periods will starve other threads.</source>
          <target state="translated">Maintenir des verrous de lecteur ou de writer pendant de longues périodes retarde l’exécution d’autres threads.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>For best performance, consider restructuring your application to minimize the duration of writes.</source>
          <target state="translated">Pour de meilleures performances, envisagez de restructurer votre application afin de réduire la durée des écritures.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>A thread can hold a reader lock or a writer lock, but not both at the same time.</source>
          <target state="translated">Un thread peut contenir un lecteur de verrou ou un verrou de writer, mais pas les deux en même temps.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Instead of releasing a reader lock in order to acquire the writer lock, you can use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</ph>.</source>
          <target state="translated">Au lieu de libérer un verrou de lecteur pour acquérir le verrou de writer, vous pouvez utiliser <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Recursive lock requests increase the lock count on a lock.</source>
          <target state="translated">Demandes de verrou récursives augmentent le nombre de verrous sur un verrou.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Readers and writers are queued separately.</source>
          <target state="translated">Lecteurs et writers sont en file d’attente séparément.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</source>
          <target state="translated">Lorsqu’un thread libère le verrou de writer, tous les threads en attente dans la file d’attente de lecteur à cet instant bénéficient de verrous de lecteur. Lorsque tous ces verrous de lecteur ont été publiées, l’attente du thread suivant dans l’enregistreur de file d’attente, si elle existe, est accordé le verrou de writer et ainsi de suite.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>In other words, <ph id="ph1">`ReaderWriterLock`</ph> alternates between a collection of readers, and one writer.</source>
          <target state="translated">En d’autres termes, <ph id="ph1">`ReaderWriterLock`</ph> alterne entre une collection de lecteurs et un writer.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</source>
          <target state="translated">Lorsqu’un thread dans la file d’attente de l’enregistreur est en attente de libération de verrous lecteur actif, threads demandant de nouveaux verrous de lecteur s’accumulent dans la file d’attente du lecteur.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</source>
          <target state="translated">Leurs demandes ne sont pas accordées, même s’ils peuvent partager un accès simultané avec titulaires de verrou de lecteur ; Cela permet de protéger des enregistreurs par rapport à un blocage indéfini par les lecteurs.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Most methods for acquiring locks on a <ph id="ph1">`ReaderWriterLock`</ph> accept time-out values.</source>
          <target state="translated">La plupart des méthodes d’acquisition de verrous sur une <ph id="ph1">`ReaderWriterLock`</ph> accepte les valeurs de délai d’attente.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Use time-outs to avoid deadlocks in your application.</source>
          <target state="translated">Délais d’attente permet d’éviter les blocages dans votre application.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</source>
          <target state="translated">Par exemple, un thread peut acquérir le verrou de writer sur une ressource et ensuite demander un verrou de lecteur sur un deuxième ressource ; entre-temps, un autre thread peut acquérir le verrou de writer sur la deuxième ressource et demande un verrou de lecteur sur le premier.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Unless time-outs are used, the threads deadlock.</source>
          <target state="translated">Sauf si les délais d’attente sont utilisés, le blocage des threads.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <ph id="ph1">&lt;xref:System.ApplicationException&gt;</ph>.</source>
          <target state="translated">Si l’intervalle de délai d’attente expire et que la demande de verrou n’a pas été accordée, la méthode retourne le contrôle au thread appelant en levant une <ph id="ph1">&lt;xref:System.ApplicationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>A thread can catch this exception and determine what action to take next.</source>
          <target state="translated">Un thread peut intercepter cette exception et déterminer l’action à entreprendre.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Time-outs are expressed in milliseconds.</source>
          <target state="translated">Délais d’attente sont exprimées en millisecondes.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>If you use a <ph id="ph1">&lt;xref:System.TimeSpan?displayProperty=nameWithType&gt;</ph> to specify the time-out, the value used is the total number of whole milliseconds represented by the <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>.</source>
          <target state="translated">Si vous utilisez un <ph id="ph1">&lt;xref:System.TimeSpan?displayProperty=nameWithType&gt;</ph> pour spécifier le délai d’attente, la valeur utilisée est le nombre total de millisecondes entières représenté par le <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>The following table shows the valid time-out values in milliseconds.</source>
          <target state="translated">Le tableau suivant indique les valeurs valides de délai d’attente en millisecondes.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Value</source>
          <target state="translated">Value</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>-1</source>
          <target state="translated">-1</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>The thread waits until the lock is acquired, regardless of how long it takes.</source>
          <target state="translated">Le thread attend jusqu'à ce que le verrou est acquis, quelle que soit la durée.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>For methods that specify integer time-outs, the constant <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> can be used.</source>
          <target state="translated">Pour les méthodes qui spécifient des délais d’expiration entiers, la constante <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> peut être utilisé.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>The thread does not wait to acquire the lock.</source>
          <target state="translated">Le thread n’attend pas acquérir le verrou.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>If the lock cannot be acquired immediately, the method returns.</source>
          <target state="translated">Si le verrou ne peut pas être acquis immédiatement, la méthode retourne.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>&gt;0</source>
          <target state="translated">&gt;0</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>The number of milliseconds to wait.</source>
          <target state="translated">Nombre de millisecondes à attendre.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>With the exception of -1, negative time-out values are not allowed.</source>
          <target state="translated">À l’exception de -1, les délais d’attente négatifs ne sont pas autorisés.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>If you specify a negative integer other than -1, a time-out value of zero is used instead.</source>
          <target state="translated">Si vous spécifiez un entier négatif autre que -1, une valeur égale à zéro est utilisée à la place.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> that represents a negative number of milliseconds other than -1, <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> is thrown.</source>
          <target state="translated">(Autrement dit, la méthode retourne sans attendre, si le verrou ne peut pas être acquis immédiatement.) Si vous spécifiez un <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> qui représente un nombre négatif de millisecondes autre que -1, <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>The following example demonstrates how to use a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> to protect a shared resource, an integer value named <ph id="ph2">`resource`</ph>, that is read concurrently and written exclusively by multiple threads.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> pour protéger une ressource partagée, un entier nommé <ph id="ph2">`resource`</ph>, qui est lue simultanément et est écrite exclusivement par plusieurs threads.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>Note that the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> is declared at the class level so that it is visible to all threads.</source>
          <target state="translated">Notez que le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> est déclarée au niveau de la classe afin qu’il soit visible pour tous les threads.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLock">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLock" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLock" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.#ctor">
          <source>The following code example demonstrates how to create a new instance of the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">L'exemple de code suivant illustre la création d'une nouvelle instance de la classe <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.#ctor">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLock">
          <source>Acquires a reader lock.</source>
          <target state="translated">Acquiert un verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>The time-out in milliseconds.</source>
          <target state="translated">Délai en millisecondes.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>Acquires a reader lock, using an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value for the time-out.</source>
          <target state="translated">Acquiert un verrou de lecteur en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> comme délai d'attente.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</ph> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</ph> bloque si un autre thread détient le verrou de writer ou si au moins un thread est en attente pour le verrou de writer.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">Si le thread actuel a déjà le verrou de writer, aucun verrou de lecteur n’est acquis.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">Au lieu de cela, le nombre de verrous sur le verrou de writer est incrémenté.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">Cela empêche un thread de se bloquer sur son propre verrou de writer.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>The result is exactly the same as calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>, and an additional call to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> is required when releasing the writer lock.</source>
          <target state="translated">Le résultat est exactement le même que l’appel <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>et un appel supplémentaire à <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> est requise lors de la libération du verrou de writer.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph> prend en charge les demandes de verrou de lecteur récursives.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">Autrement dit, un thread peut appeler AcquireReaderLock plusieurs fois, ce qui augmente le nombre de verrous chaque fois.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>You must call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</ph> once for each time you call <ph id="ph2">`AcquireReaderLock`</ph>.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</ph> une fois pour chaque fois que vous appelez <ph id="ph2">`AcquireReaderLock`</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>Alternatively, you can call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> to reduce the lock count to zero immediately.</source>
          <target state="translated">Vous pouvez également appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> afin de réduire le nombre de verrous immédiatement à zéro.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente du lecteur.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">Utilisez les verrous récursifs avec précaution, pour éviter de bloquer les demandes de verrou de writer pendant de longues périodes.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>For valid time-out values, see <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Pour les valeurs de délai d’attente valides, consultez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</source>
          <target state="translated">L’exemple de code suivant montre comment acquérir et libérer un verrou de lecteur et comment gérer l’exception levée lorsqu’une demande arrive à expiration.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> expire avant que la demande de verrou soit accordée.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see langword="TimeSpan" /&gt;</ph> specifying the time-out period.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TimeSpan" /&gt;</ph> spécifiant la durée du délai d'attente.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>Acquires a reader lock, using a <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> value for the time-out.</source>
          <target state="translated">Acquiert un verrou de lecteur en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> comme délai d'attente.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</ph> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt;</ph> bloque si un autre thread détient le verrou de writer ou si au moins un thread est en attente pour le verrou de writer.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>If the current thread already has the writer lock, no reader lock is acquired.</source>
          <target state="translated">Si le thread actuel a déjà le verrou de writer, aucun verrou de lecteur n’est acquis.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>Instead, the lock count on the writer lock is incremented.</source>
          <target state="translated">Au lieu de cela, le nombre de verrous sur le verrou de writer est incrémenté.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>This prevents a thread from blocking on its own writer lock.</source>
          <target state="translated">Cela empêche un thread de se bloquer sur son propre verrou de writer.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>The result is exactly the same as calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>, and an additional call to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> is required when releasing the writer lock.</source>
          <target state="translated">Le résultat est exactement le même que l’appel <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>et un appel supplémentaire à <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> est requise lors de la libération du verrou de writer.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source><ph id="ph1">`AcquireReaderLock`</ph> supports recursive reader-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireReaderLock`</ph> prend en charge les demandes de verrou de lecteur récursives.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</source>
          <target state="translated">Autrement dit, un thread peut appeler AcquireReaderLock plusieurs fois, ce qui augmente le nombre de verrous chaque fois.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>You must call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</ph> once for each time you call <ph id="ph2">`AcquireReaderLock`</ph>.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</ph> une fois pour chaque fois que vous appelez <ph id="ph2">`AcquireReaderLock`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>Alternatively, you can call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> to reduce the lock count to zero immediately.</source>
          <target state="translated">Vous pouvez également appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> afin de réduire le nombre de verrous immédiatement à zéro.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</source>
          <target state="translated">Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente du lecteur.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</source>
          <target state="translated">Utilisez les verrous récursifs avec précaution, pour éviter de bloquer les demandes de verrou de writer pendant de longues périodes.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source>For valid time-out values, see <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Pour les valeurs de délai d’attente valides, consultez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> expire avant que la demande de verrou soit accordée.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> spécifie une valeur négative autre que -1 milliseconde.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLock">
          <source>Acquires the writer lock.</source>
          <target state="translated">Acquiert le verrou de writer.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>The time-out in milliseconds.</source>
          <target state="translated">Délai en millisecondes.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>Acquires the writer lock, using an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value for the time-out.</source>
          <target state="translated">Acquiert un verrou de writer en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> comme délai d'attente.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">Cette méthode est bloquée si un autre thread a un verrou de lecteur ou un verrou de writer.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Pour obtenir une description de la façon dont le verrou de writer alterne avec plusieurs verrous de lecteurs simultanés, consultez la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>, or by calling <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph>.</source>
          <target state="translated">Un thread qui a déjà un verrou de lecteur peut acquérir le verrou de writer de deux façons : en libérant le verrou de lecteur avant d’appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>, ou en appelant <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>If a thread calls <ph id="ph1">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">Si un thread appelle <ph id="ph1">`AcquireWriterLock`</ph> alors qu’il détient toujours un verrou de lecteur, il se bloque sur son propre verrou de lecteur ; si un délai d’attente infini est spécifié, le thread de blocage.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>To avoid such deadlocks, use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</ph> to determine whether the current thread already has a reader lock.</source>
          <target state="translated">Pour éviter ces blocages, utilisez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</ph> pour déterminer si le thread actuel a déjà un verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph> prend en charge les demandes de verrou de writer récursives.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">Autrement dit, un thread peut appeler <ph id="ph1">`AcquireWriterLock`</ph> plusieurs fois, ce qui augmente le nombre de verrous chaque fois.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>You must call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> once for each time you call <ph id="ph2">`AcquireWriterLock`</ph>.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> une fois pour chaque fois que vous appelez <ph id="ph2">`AcquireWriterLock`</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>Alternatively, you can call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> to reduce the lock count to zero immediately.</source>
          <target state="translated">Vous pouvez également appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> afin de réduire le nombre de verrous immédiatement à zéro.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente de l’enregistreur.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>For valid time-out values, see <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Pour les valeurs de délai d’attente valides, consultez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</source>
          <target state="translated">L’exemple de code suivant montre comment acquérir et libérer un verrou de writer et comment gérer l’exception levée lorsqu’une demande arrive à expiration.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> expire avant que la demande de verrou soit accordée.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see langword="TimeSpan" /&gt;</ph> specifying the time-out period.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TimeSpan" /&gt;</ph> spécifiant la durée du délai d'attente.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>Acquires the writer lock, using a <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> value for the time-out.</source>
          <target state="translated">Acquiert un verrou de writer en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> comme délai d'attente.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>This method blocks if another thread has a reader lock or writer lock.</source>
          <target state="translated">Cette méthode est bloquée si un autre thread a un verrou de lecteur ou un verrou de writer.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Pour obtenir une description de la façon dont le verrou de writer alterne avec plusieurs verrous de lecteurs simultanés, consultez la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>, or by calling <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph>.</source>
          <target state="translated">Un thread qui a déjà un verrou de lecteur peut acquérir le verrou de writer de deux façons : en libérant le verrou de lecteur avant d’appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>, ou en appelant <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>If a thread calls <ph id="ph1">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</source>
          <target state="translated">Si un thread appelle <ph id="ph1">`AcquireWriterLock`</ph> alors qu’il détient toujours un verrou de lecteur, il se bloque sur son propre verrou de lecteur ; si un délai d’attente infini est spécifié, le thread de blocage.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>To avoid such deadlocks, use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</ph> to determine whether the current thread already has a reader lock.</source>
          <target state="translated">Pour éviter ces blocages, utilisez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</ph> pour déterminer si le thread actuel a déjà un verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source><ph id="ph1">`AcquireWriterLock`</ph> supports recursive writer-lock requests.</source>
          <target state="translated"><ph id="ph1">`AcquireWriterLock`</ph> prend en charge les demandes de verrou de writer récursives.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>That is, a thread can call <ph id="ph1">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.</source>
          <target state="translated">Autrement dit, un thread peut appeler <ph id="ph1">`AcquireWriterLock`</ph> plusieurs fois, ce qui augmente le nombre de verrous chaque fois.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>You must call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> once for each time you call <ph id="ph2">`AcquireWriterLock`</ph>.</source>
          <target state="translated">Vous devez appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> une fois pour chaque fois que vous appelez <ph id="ph2">`AcquireWriterLock`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>Alternatively, you can call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> to reduce the lock count to zero immediately.</source>
          <target state="translated">Vous pouvez également appeler <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> afin de réduire le nombre de verrous immédiatement à zéro.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</source>
          <target state="translated">Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente de l’enregistreur.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source>For valid time-out values, see <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Pour les valeurs de délai d’attente valides, consultez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> expire avant que la demande de verrou soit accordée.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> spécifie une valeur négative autre que -1 milliseconde.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>The sequence number.</source>
          <target state="translated">Numéro de séquence.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</source>
          <target state="translated">Indique si le verrou de writer a été accordé à un thread depuis l'obtention du numéro de séquence.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le verrou de writer a été accordé à un thread depuis l'obtention du numéro de séquence ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</ph> and <ph id="ph2">`AnyWritersSince`</ph> to improve application performance.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</ph> et <ph id="ph2">`AnyWritersSince`</ph> pour améliorer les performances de l’application.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">Par exemple, un thread peut mettre en cache les informations obtenues pendant la détention d’un verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>After releasing and later reacquiring the lock, the thread can use <ph id="ph1">`AnyWritersSince`</ph> to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</source>
          <target state="translated">Après avoir libéré puis acquis à nouveau le verrou, le thread peut utiliser <ph id="ph1">`AnyWritersSince`</ph> pour déterminer si d’autres threads ont écrit à la ressource dans l’intervalle ; sinon, les informations mises en cache peuvent être utilisées.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">Cette technique est utile lorsque la lecture des informations protégées par le verrou est coûteuse. par exemple, exécuter une requête de base de données.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">L’appelant doit contenir un verrou de lecteur ou un verrou de writer dans l’ordre pour le numéro de séquence être utile.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>The following code example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</ph> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</ph> (méthode) et le <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</ph> propriété pour déterminer si un autre thread a acquis le verrou de writer sur la ressource protégée depuis que le thread actuel a détenu le verrou de writer.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph> returned by <ph id="ph2">&lt;see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph> retourné par <ph id="ph2">&lt;see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>Restores the lock status of the thread to what it was before <ph id="ph1">&lt;see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /&gt;</ph> was called.</source>
          <target state="translated">Restaure le verrou du thread à l'état qu'il avait avant l'appel à <ph id="ph1">&lt;see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</ph> releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</ph> Libère le verrou de writer, quel que soit le nombre de verrous récursifs et restaure le verrou de lecteur détenu par le thread avant la mise à niveau vers le verrou de writer.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>The lock count on the reader lock is restored.</source>
          <target state="translated">Le nombre de verrous sur le verrou de lecteur est restauré.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source><ph id="ph1">`DowngradeFromWriterLock`</ph> accepts a <ph id="ph2">&lt;xref:System.Threading.LockCookie&gt;</ph> obtained by calling <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`DowngradeFromWriterLock`</ph> accepte un <ph id="ph2">&lt;xref:System.Threading.LockCookie&gt;</ph> obtenu en appelant <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>Do not use a <ph id="ph1">`LockCookie`</ph> returned by <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph>.</source>
          <target state="translated">N’utilisez pas un <ph id="ph1">`LockCookie`</ph> retourné par <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</source>
          <target state="translated">Un thread ne bloque pas lors de la mise à niveau de verrou de writer, même si d’autres threads sont en attente pour le verrou de writer, étant donné que toutes les demandes de verrou de lecteur sont accordées lorsque le verrou de writer est libéré.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</source>
          <target state="translated">L’exemple de code suivant montre comment demander un verrou de lecteur, mettre à niveau le verrou de lecteur vers un verrou de writer et rétrograder à nouveau vers un verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">Le thread n'a pas de verrou de writer.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
          <source>The address of <ph id="ph1">&lt;paramref name="lockCookie" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L’adresse de <ph id="ph1">&lt;paramref name="lockCookie" /&gt;</ph> est un pointeur null.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLock" /&gt;</ph> object.</source>
          <target state="translated">Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'objet <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLock" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.Finalize">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.Finalize%2A&gt;</ph> when the current <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> object is ready to be finalized.</source>
          <target state="translated">Le garbage collector appelle <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.Finalize%2A&gt;</ph> lorsque actuel <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> objet est prêt à être finalisé.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
          <source>Gets a value indicating whether the current thread holds a reader lock.</source>
          <target state="translated">Obtient une valeur indiquant si le thread actif détient un verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread holds a reader lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le thread actif détient un verrou de lecteur ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
          <source>The following code example demonstrates how to use <ph id="ph1">`IsReaderLockHeld`</ph> to avoid deadlocks.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser <ph id="ph1">`IsReaderLockHeld`</ph> pour éviter les blocages.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
          <source>Gets a value indicating whether the current thread holds the writer lock.</source>
          <target state="translated">Obtient une valeur indiquant si le thread actif détient le verrou de writer.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread holds the writer lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le thread actif détient le verrou de writer ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
          <source>The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, <ph id="ph1">`ReaderWriterLock`</ph> does not grant the reader lock but instead increments the lock count on the writer lock.</source>
          <target state="translated">L’exemple de code suivant montre que lorsqu’une tentative est faite pour acquérir un verrou de lecteur sur un thread qui dispose un verrou de writer <ph id="ph1">`ReaderWriterLock`</ph> n’accorde pas le verrou de lecteur et incrémente le nombre de verrous sur le verrou de writer.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.ReleaseLock">
          <source>Releases the lock, regardless of the number of times the thread acquired the lock.</source>
          <target state="translated">Libère le verrou quel que soit le nombre de fois où il a été acquis par le thread.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.ReleaseLock">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph> value representing the released lock.</source>
          <target state="translated">Valeur <ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph> représentant le verrou libéré.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseLock">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> releases the reader lock or writer lock, regardless of the recursive lock count.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> Libère le verrou de lecteur ou un verrou de writer, quel que soit le nombre de verrous récursifs.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseLock">
          <source>To restore the state of the lock, including the lock count, pass the <ph id="ph1">&lt;xref:System.Threading.LockCookie&gt;</ph> to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</ph>.</source>
          <target state="translated">Pour restaurer l’état du verrou, y compris le nombre de verrous, passez le <ph id="ph1">&lt;xref:System.Threading.LockCookie&gt;</ph> à <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseLock">
          <source>The following code example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> méthode pour libérer le verrou, quel que soit le nombre de fois qu’il a été acquis par le thread et la façon de restaurer l’état du verrou plus tard.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
          <source>Decrements the lock count.</source>
          <target state="translated">Décrémente le nombre de verrous.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</ph> decrements the lock count.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt;</ph> Décrémente le nombre de verrous.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
          <source>When the count reaches zero, the lock is released.</source>
          <target state="translated">Lorsque le décompte atteint zéro, le verrou est libéré.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
          <source>If a thread has the writer lock, calling <ph id="ph1">`ReleaseReaderLock`</ph> has the same effect as calling <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph>.</source>
          <target state="translated">Si un thread possède le verrou de writer, l’appel <ph id="ph1">`ReleaseReaderLock`</ph> a le même effet que l’appel <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
          <source>If a thread has no locks, calling <ph id="ph1">`ReleaseReaderLock`</ph> throws an <ph id="ph2">&lt;xref:System.ApplicationException&gt;</ph>.</source>
          <target state="translated">Si un thread n’a aucun verrou, l’appel <ph id="ph1">`ReleaseReaderLock`</ph> lève une <ph id="ph2">&lt;xref:System.ApplicationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
          <source>The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</source>
          <target state="translated">L’exemple de code suivant montre comment acquérir et libérer un verrou de lecteur et comment gérer l’exception levée lorsqu’une demande arrive à expiration.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
          <source>The thread does not have any reader or writer locks.</source>
          <target state="translated">Le thread n'a pas de verrous de writer ou de lecteur.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
          <source>Decrements the lock count on the writer lock.</source>
          <target state="translated">Décrémente le nombre de verrous sur le verrou de writer.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> decrements the writer lock count.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;</ph> Décrémente le verrou de writer nombre.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
          <source>When the count reaches zero, the writer lock is released.</source>
          <target state="translated">Lorsque le décompte atteint zéro, le verrou de writer est libéré.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
          <source>If a thread has a reader lock, or no locks, calling <ph id="ph1">`ReleaseWriterLock`</ph> throws an <ph id="ph2">&lt;xref:System.ApplicationException&gt;</ph>.</source>
          <target state="translated">Si un thread a un verrou de lecteur ou aucun verrou, l’appel <ph id="ph1">`ReleaseWriterLock`</ph> lève une <ph id="ph2">&lt;xref:System.ApplicationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
          <source>The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</source>
          <target state="translated">L’exemple de code suivant montre comment acquérir et libérer un verrou de writer et comment gérer l’exception levée lorsqu’une demande arrive à expiration.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
          <source>The thread does not have the writer lock.</source>
          <target state="translated">Le thread n'a pas de verrou de writer.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph> returned by <ph id="ph2">&lt;see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph> retourné par <ph id="ph2">&lt;see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>Restores the lock status of the thread to what it was before calling <ph id="ph1">&lt;see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /&gt;</ph>.</source>
          <target state="translated">Restaure l'état de verrou du thread au moment précédant l'appel à <ph id="ph1">&lt;see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>The state restored by <ph id="ph1">`RestoreLock`</ph> includes the recursive lock count.</source>
          <target state="translated">L’état restauré par <ph id="ph1">`RestoreLock`</ph> inclut le nombre de verrous récursifs.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</source>
          <target state="translated">Un thread se bloque si elle tente de restaurer un verrou de lecteur après qu’un autre thread a acquis le verrou de writer ou si elle tente de restaurer le verrou de writer après qu’un autre thread a acquis un verrou de lecteur ou un verrou de writer.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>Because <ph id="ph1">`RestoreLock`</ph> does not accept a time-out, you should take care to avoid possible deadlocks.</source>
          <target state="translated">Étant donné que <ph id="ph1">`RestoreLock`</ph> n’accepte pas un délai d’attente, vous devez veiller à éviter les blocages possibles.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>Before calling <ph id="ph1">`RestoreLock`</ph>, make sure you have released all locks acquired since the call to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph>.</source>
          <target state="translated">Avant d’appeler <ph id="ph1">`RestoreLock`</ph>, assurez-vous que vous avez libéré tous les verrous acquis depuis l’appel à <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</source>
          <target state="translated">Par exemple, un thread se bloque s’il acquiert un verrou de lecteur, puis tente de restaurer un verrou de writer précédent.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt;</ph> to detect such additional locks.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt;</ph> pour détecter ces verrous supplémentaires.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>Do not use a <ph id="ph1">&lt;xref:System.Threading.LockCookie&gt;</ph> returned from <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph>.</source>
          <target state="translated">N’utilisez pas un <ph id="ph1">&lt;xref:System.Threading.LockCookie&gt;</ph> retourné par <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>The following code example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;</ph> méthode pour libérer le verrou, quel que soit le nombre de fois qu’il a été acquis par le thread et la façon de restaurer l’état du verrou plus tard.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
          <source>The address of <ph id="ph1">&lt;paramref name="lockCookie" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L’adresse de <ph id="ph1">&lt;paramref name="lockCookie" /&gt;</ph> est un pointeur null.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLock">
          <source>Upgrades a reader lock to the writer lock.</source>
          <target state="translated">Met à niveau un verrou de lecteur vers le verrou de writer.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>The time-out in milliseconds.</source>
          <target state="translated">Délai en millisecondes.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>Upgrades a reader lock to the writer lock, using an <ph id="ph1">&lt;see langword="Int32" /&gt;</ph> value for the time-out.</source>
          <target state="translated">Met à niveau un verrou de lecteur vers le verrou de writer en utilisant une valeur <ph id="ph1">&lt;see langword="Int32" /&gt;</ph> pour définir le délai d'attente.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph> value.</source>
          <target state="translated">Valeur <ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`UpgradeToWriterLock`</ph> le verrou de lecteur est libéré, quel que soit le nombre de verrous, et le thread se place à la fin de la file d’attente pour le verrou de writer.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">Par conséquent, les autres threads peuvent écrire dans la ressource avant que le thread qui a demandé que la mise à niveau est accordé le verrou de writer.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>The time-out exception is not thrown until the thread that called the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> method can reacquire the reader lock.</source>
          <target state="translated">L’exception de délai d’attente n’est pas levée tant que le thread qui a appelé le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> méthode peut acquérir le verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">S’il n’y a pas d’autres threads qui attendent le verrou de writer, cela se produit immédiatement.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>However, if another thread is queued for the writer lock, the thread that called the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">Toutefois, si un autre thread est en attente pour le verrou de writer, le thread qui a appelé le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> méthode ne peut pas acquérir le verrou de lecteur tant que tous les lecteurs actuels ont libéré leurs verrous, et un thread a acquis et libéré le verrou de writer.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> method.</source>
          <target state="translated">Cela est vrai même si l’autre thread qui a demandé le verrou de writer a demandé une fois que le thread actuel a appelé le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>To restore the lock state, call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</ph> using the <ph id="ph2">&lt;xref:System.Threading.LockCookie&gt;</ph> returned by <ph id="ph3">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">Pour restaurer l’état du verrou, appelez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</ph> à l’aide de la <ph id="ph2">&lt;xref:System.Threading.LockCookie&gt;</ph> retourné par <ph id="ph3">`UpgradeToWriterLock`</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</ph>.</source>
          <target state="translated">N’utilisez pas cette <ph id="ph1">`LockCookie`</ph> avec <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">Lorsqu’un thread n’a aucun verrou de lecteur, n’utilisez pas <ph id="ph1">`UpgradeToWriterLock`</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph> instead.</source>
          <target state="translated">Utilisez plutôt <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>For valid time-out values, see <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Pour les valeurs de délai d’attente valides, consultez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</source>
          <target state="translated">L’exemple de code suivant montre comment demander un verrou de lecteur, mettre à niveau le verrou de lecteur vers un verrou de writer et rétrograder à nouveau vers un verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> expire avant que la demande de verrou soit accordée.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see langword="TimeSpan" /&gt;</ph> specifying the time-out period.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TimeSpan" /&gt;</ph> spécifiant la durée du délai d'attente.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>Upgrades a reader lock to the writer lock, using a <ph id="ph1">&lt;see langword="TimeSpan" /&gt;</ph> value for the time-out.</source>
          <target state="translated">Met à niveau un verrou de lecteur vers le verrou de writer en utilisant une valeur <ph id="ph1">&lt;see langword="TimeSpan" /&gt;</ph> pour définir le délai d'attente.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph> value.</source>
          <target state="translated">Valeur <ph id="ph1">&lt;see cref="T:System.Threading.LockCookie" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>When a thread calls <ph id="ph1">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`UpgradeToWriterLock`</ph> le verrou de lecteur est libéré, quel que soit le nombre de verrous, et le thread se place à la fin de la file d’attente pour le verrou de writer.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</source>
          <target state="translated">Par conséquent, les autres threads peuvent écrire dans la ressource avant que le thread qui a demandé que la mise à niveau est accordé le verrou de writer.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>The time-out exception is not thrown until the thread that called the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> method can reacquire the reader lock.</source>
          <target state="translated">L’exception de délai d’attente n’est pas levée tant que le thread qui a appelé le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> méthode peut acquérir le verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>If there are no other threads waiting for the writer lock, this happens immediately.</source>
          <target state="translated">S’il n’y a pas d’autres threads qui attendent le verrou de writer, cela se produit immédiatement.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>However, if another thread is queued for the writer lock, the thread that called the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</source>
          <target state="translated">Toutefois, si un autre thread est en attente pour le verrou de writer, le thread qui a appelé le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> méthode ne peut pas acquérir le verrou de lecteur tant que tous les lecteurs actuels ont libéré leurs verrous, et un thread a acquis et libéré le verrou de writer.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>This is true even if the other thread that requested the writer lock requested it after the current thread called the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> method.</source>
          <target state="translated">Cela est vrai même si l’autre thread qui a demandé le verrou de writer a demandé une fois que le thread actuel a appelé le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>To restore the lock state, call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</ph> using the <ph id="ph2">&lt;xref:System.Threading.LockCookie&gt;</ph> returned by <ph id="ph3">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">Pour restaurer l’état du verrou, appelez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;</ph> à l’aide de la <ph id="ph2">&lt;xref:System.Threading.LockCookie&gt;</ph> retourné par <ph id="ph3">`UpgradeToWriterLock`</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>Do not use this <ph id="ph1">`LockCookie`</ph> with <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</ph>.</source>
          <target state="translated">N’utilisez pas cette <ph id="ph1">`LockCookie`</ph> avec <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>When a thread has no reader lock, do not use <ph id="ph1">`UpgradeToWriterLock`</ph>.</source>
          <target state="translated">Lorsqu’un thread n’a aucun verrou de lecteur, n’utilisez pas <ph id="ph1">`UpgradeToWriterLock`</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph> instead.</source>
          <target state="translated">Utilisez plutôt <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source>For valid time-out values, see <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Pour les valeurs de délai d’attente valides, consultez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> expires before the lock request is granted.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> expire avant que la demande de verrou soit accordée.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> specifies a negative value other than -1 milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> spécifie une valeur négative autre que -1 milliseconde.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>Gets the current sequence number.</source>
          <target state="translated">Obtient le numéro de séquence actuel.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>The current sequence number.</source>
          <target state="translated">Numéro de séquence actuel.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>The sequence number increases whenever a thread acquires the writer lock.</source>
          <target state="translated">Le numéro de séquence augmente chaque fois qu’un thread acquiert le verrou de writer.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>You can save the sequence number and pass it to <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</ph> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</source>
          <target state="translated">Vous pouvez enregistrer le numéro de séquence et le passer à <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</ph> ultérieurement, si vous souhaitez déterminer si d’autres threads ont acquis le verrou de writer dans l’intervalle.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>You can use <ph id="ph1">`WriterSeqNum`</ph> to improve application performance.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">`WriterSeqNum`</ph> pour améliorer les performances de l’application.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>For example, a thread might cache the information it obtains while holding a reader lock.</source>
          <target state="translated">Par exemple, un thread peut mettre en cache les informations obtenues pendant la détention d’un verrou de lecteur.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling <ph id="ph1">`AnyWritersSince`</ph>; if not, the cached information can be used.</source>
          <target state="translated">Après avoir libéré puis acquis à nouveau le verrou, le thread peut déterminer si les autres threads ont écrit dans la ressource en appelant <ph id="ph1">`AnyWritersSince`</ph>; si non, les informations mises en cache peuvent être utilisées.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</source>
          <target state="translated">Cette technique est utile lors de la lecture des informations protégées par le verrou est coûteuse. par exemple, exécuter une requête de base de données.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</source>
          <target state="translated">L’appelant doit contenir un verrou de lecteur ou un verrou de writer dans l’ordre pour le numéro de séquence être utile.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>The following code example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</ph> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt;</ph> propriété et la <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt;</ph> méthode pour déterminer si un autre thread a acquis le verrou de writer sur la ressource protégée depuis que le thread actuel a détenu le verrou de writer.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLock.WriterSeqNum">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> classe.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>