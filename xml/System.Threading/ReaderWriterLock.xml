<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eceaf936001c4e98e1bf97071c933f2a511a4a69" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37754691" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class&#xA;    inherit CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="3e803-101">Définit un verrou qui prend en charge les writers uniques et les lecteurs multiples.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3e803-101">Defines a lock that supports single writers and multiple readers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e803-102">Le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] a deux verrous de lecteur-writer, à savoir <xref:System.Threading.ReaderWriterLockSlim> et <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-102">The [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] has two reader-writer locks, <xref:System.Threading.ReaderWriterLockSlim> and <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="3e803-103"><xref:System.Threading.ReaderWriterLockSlim> est recommandé pour tout nouveau développement.</span><span class="sxs-lookup"><span data-stu-id="3e803-103"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span> <span data-ttu-id="3e803-104"><xref:System.Threading.ReaderWriterLockSlim> est similaire à <xref:System.Threading.ReaderWriterLock>, mais a des règles simplifiées pour la récursivité ainsi que la mise à niveau et la rétrogradation de l’état de verrou.</span><span class="sxs-lookup"><span data-stu-id="3e803-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="3e803-105"><xref:System.Threading.ReaderWriterLockSlim> évite de nombreux cas d’interblocage potentiel.</span><span class="sxs-lookup"><span data-stu-id="3e803-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="3e803-106">En outre, les performances de <xref:System.Threading.ReaderWriterLockSlim> sont considérablement meilleures que celles de <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 <span data-ttu-id="3e803-107"><xref:System.Threading.ReaderWriterLock> est utilisé pour synchroniser l’accès à une ressource.</span><span class="sxs-lookup"><span data-stu-id="3e803-107"><xref:System.Threading.ReaderWriterLock> is used to synchronize access to a resource.</span></span> <span data-ttu-id="3e803-108">À un moment donné, il permet un accès en lecture simultané de plusieurs threads, ou un accès en écriture pour un seul thread.</span><span class="sxs-lookup"><span data-stu-id="3e803-108">At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</span></span> <span data-ttu-id="3e803-109">Dans une situation où une ressource est rarement modifiée, un `ReaderWriterLock` fournit une productivité supérieure à un verrou d’un-à-à la fois simple, tel que <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="3e803-109">In a situation where a resource is changed infrequently, a `ReaderWriterLock` provides better throughput than a simple one-at-a-time lock, such as <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="3e803-110">`ReaderWriterLock` fonctionne mieux lorsque la plupart des accès sont des lectures, en écriture sont rares et de courte durée.</span><span class="sxs-lookup"><span data-stu-id="3e803-110">`ReaderWriterLock` works best where most accesses are reads, while writes are infrequent and of short duration.</span></span> <span data-ttu-id="3e803-111">Les lecteurs multiples alternent avec les writers uniques, afin que ni les lectures ni enregistreurs sont bloquées pendant de longues périodes.</span><span class="sxs-lookup"><span data-stu-id="3e803-111">Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e803-112">Détention de verrous de lecteur ou de writer pendant de longues périodes retarde l’exécution d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="3e803-112">Holding reader locks or writer locks for long periods will starve other threads.</span></span> <span data-ttu-id="3e803-113">Pour de meilleures performances, envisager de restructurer votre application afin de réduire la durée des écritures.</span><span class="sxs-lookup"><span data-stu-id="3e803-113">For best performance, consider restructuring your application to minimize the duration of writes.</span></span>  
  
 <span data-ttu-id="3e803-114">Un thread ne peut contenir un lecteur de verrou ou un verrou en écriture, mais pas les deux en même temps.</span><span class="sxs-lookup"><span data-stu-id="3e803-114">A thread can hold a reader lock or a writer lock, but not both at the same time.</span></span> <span data-ttu-id="3e803-115">Au lieu de libérer un verrou de lecteur pour acquérir le verrou de writer, vous pouvez utiliser <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> et <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-115">Instead of releasing a reader lock in order to acquire the writer lock, you can use <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> and <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</span></span>  
  
 <span data-ttu-id="3e803-116">Demandes de verrou récursives augmenter le nombre de verrous sur un verrou.</span><span class="sxs-lookup"><span data-stu-id="3e803-116">Recursive lock requests increase the lock count on a lock.</span></span>  
  
 <span data-ttu-id="3e803-117">Lecteurs et writers sont en file d’attente séparément.</span><span class="sxs-lookup"><span data-stu-id="3e803-117">Readers and writers are queued separately.</span></span> <span data-ttu-id="3e803-118">Lorsqu’un thread libère le verrou de writer, tous les threads en attente dans la file d’attente de lecteur à cet instant sont accordées les verrous de lecteur. Lorsque tous ces verrous de lecteur ont été publiées, l’attente de thread suivant dans le writer de file d’attente, si un, est accordé le verrou de writer et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="3e803-118">When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</span></span> <span data-ttu-id="3e803-119">En d’autres termes, `ReaderWriterLock` alterne entre une collection de lecteurs et un seul writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-119">In other words, `ReaderWriterLock` alternates between a collection of readers, and one writer.</span></span>  
  
 <span data-ttu-id="3e803-120">Pendant un thread dans la file d’attente de l’enregistreur est en attente pour les verrous de lecteur actif doit être publié, threads qui demandent de nouveaux verrous de lecteur s’accumulent dans la file d’attente de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-120">While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</span></span> <span data-ttu-id="3e803-121">Leurs demandes ne sont pas accordées, même s’ils peuvent partager un accès simultané avec titulaires de verrou de lecteur ; Cela permet de protéger les rédacteurs pour blocage indéfini par les lecteurs.</span><span class="sxs-lookup"><span data-stu-id="3e803-121">Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</span></span>  
  
 <span data-ttu-id="3e803-122">La plupart des méthodes pour acquérir des verrous sur une `ReaderWriterLock` accepte les valeurs de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="3e803-122">Most methods for acquiring locks on a `ReaderWriterLock` accept time-out values.</span></span> <span data-ttu-id="3e803-123">Utiliser des délais d’expiration pour éviter les blocages dans votre application.</span><span class="sxs-lookup"><span data-stu-id="3e803-123">Use time-outs to avoid deadlocks in your application.</span></span> <span data-ttu-id="3e803-124">Par exemple, un thread peut acquérir le verrou de writer sur une ressource et ensuite demander un verrou de lecteur sur une deuxième ressource ; en attendant, un autre thread peut acquérir le verrou de writer sur la seconde ressource et demande un verrou de lecteur sur le premier.</span><span class="sxs-lookup"><span data-stu-id="3e803-124">For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</span></span> <span data-ttu-id="3e803-125">À moins que les délais d’expiration sont utilisés, le blocage des threads.</span><span class="sxs-lookup"><span data-stu-id="3e803-125">Unless time-outs are used, the threads deadlock.</span></span>  
  
 <span data-ttu-id="3e803-126">Si l’intervalle de délai d’attente expire et que la demande de verrou n’a pas été accordée, la méthode retourne le contrôle au thread appelant en levant une <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="3e803-126">If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <xref:System.ApplicationException>.</span></span> <span data-ttu-id="3e803-127">Un thread peut intercepter cette exception et déterminer l’action à entreprendre.</span><span class="sxs-lookup"><span data-stu-id="3e803-127">A thread can catch this exception and determine what action to take next.</span></span>  
  
 <span data-ttu-id="3e803-128">Délais d’attente sont exprimées en millisecondes.</span><span class="sxs-lookup"><span data-stu-id="3e803-128">Time-outs are expressed in milliseconds.</span></span> <span data-ttu-id="3e803-129">Si vous utilisez un <xref:System.TimeSpan?displayProperty=nameWithType> pour spécifier le délai d’attente, la valeur utilisée est le nombre total de millisecondes entières représenté par le <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="3e803-129">If you use a <xref:System.TimeSpan?displayProperty=nameWithType> to specify the time-out, the value used is the total number of whole milliseconds represented by the <xref:System.TimeSpan>.</span></span> <span data-ttu-id="3e803-130">Le tableau suivant indique les valeurs valides de délai d’attente en millisecondes.</span><span class="sxs-lookup"><span data-stu-id="3e803-130">The following table shows the valid time-out values in milliseconds.</span></span>  
  
|<span data-ttu-id="3e803-131">Value</span><span class="sxs-lookup"><span data-stu-id="3e803-131">Value</span></span>|<span data-ttu-id="3e803-132">Description </span><span class="sxs-lookup"><span data-stu-id="3e803-132">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="3e803-133">-1</span><span class="sxs-lookup"><span data-stu-id="3e803-133">-1</span></span>|<span data-ttu-id="3e803-134">Le thread attend jusqu'à ce que le verrou est acquis, quelle que soit la durée.</span><span class="sxs-lookup"><span data-stu-id="3e803-134">The thread waits until the lock is acquired, regardless of how long it takes.</span></span> <span data-ttu-id="3e803-135">Pour les méthodes qui spécifient les délais d’expiration entiers, la constante <xref:System.Threading.Timeout.Infinite> peut être utilisé.</span><span class="sxs-lookup"><span data-stu-id="3e803-135">For methods that specify integer time-outs, the constant <xref:System.Threading.Timeout.Infinite> can be used.</span></span>|  
|<span data-ttu-id="3e803-136">0</span><span class="sxs-lookup"><span data-stu-id="3e803-136">0</span></span>|<span data-ttu-id="3e803-137">Le thread n’attend pas d’acquisition du verrou.</span><span class="sxs-lookup"><span data-stu-id="3e803-137">The thread does not wait to acquire the lock.</span></span> <span data-ttu-id="3e803-138">Si le verrou ne peut pas être acquis immédiatement, la méthode retourne.</span><span class="sxs-lookup"><span data-stu-id="3e803-138">If the lock cannot be acquired immediately, the method returns.</span></span>|  
|<span data-ttu-id="3e803-139">>0</span><span class="sxs-lookup"><span data-stu-id="3e803-139">>0</span></span>|<span data-ttu-id="3e803-140">Nombre de millisecondes à attendre.</span><span class="sxs-lookup"><span data-stu-id="3e803-140">The number of milliseconds to wait.</span></span>|  
  
 <span data-ttu-id="3e803-141">À l’exception de -1, les valeurs de délai d’attente négatif ne sont pas autorisées.</span><span class="sxs-lookup"><span data-stu-id="3e803-141">With the exception of -1, negative time-out values are not allowed.</span></span> <span data-ttu-id="3e803-142">Si vous spécifiez un entier négatif autre que -1, une valeur égale à zéro est utilisée à la place.</span><span class="sxs-lookup"><span data-stu-id="3e803-142">If you specify a negative integer other than -1, a time-out value of zero is used instead.</span></span> <span data-ttu-id="3e803-143">(Autrement dit, la méthode retourne sans attendre, si le verrou ne peut pas être acquis immédiatement.) Si vous spécifiez un <xref:System.TimeSpan> qui représente un nombre négatif de millisecondes autre que -1, <xref:System.ArgumentOutOfRangeException> est levée.</span><span class="sxs-lookup"><span data-stu-id="3e803-143">(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <xref:System.TimeSpan> that represents a negative number of milliseconds other than -1, <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-144">L’exemple suivant montre comment utiliser un <xref:System.Threading.ReaderWriterLock> pour protéger une ressource partagée, une valeur entière nommée `resource`, qui est lue simultanément et est écrite exclusivement par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="3e803-144">The following example demonstrates how to use a <xref:System.Threading.ReaderWriterLock> to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads.</span></span> <span data-ttu-id="3e803-145">Notez que le <xref:System.Threading.ReaderWriterLock> est déclaré au niveau de la classe afin qu’il soit visible par tous les threads.</span><span class="sxs-lookup"><span data-stu-id="3e803-145">Note that the <xref:System.Threading.ReaderWriterLock> is declared at the class level so that it is visible to all threads.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="3e803-146">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3e803-146">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3e803-147">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-147">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLock" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3e803-148">L'exemple de code suivant illustre la création d'une nouvelle instance de la classe <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-148">The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="3e803-149">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-149">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3e803-150">Acquiert un verrou de lecteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-150">Acquires a reader lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : int -&gt; unit" Usage="readerWriterLock.AcquireReaderLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3e803-151">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-151">The time-out in milliseconds.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-152">Acquiert un verrou de lecteur en utilisant une valeur <see cref="T:System.Int32" /> comme délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-152">Acquires a reader lock, using an <see cref="T:System.Int32" /> value for the time-out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-153"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> bloque si un autre thread détient le verrou de writer ou si au moins un thread attend le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-153"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e803-154">Si le thread actuel a déjà le verrou de writer, aucun verrou de lecteur n’est acquis.</span><span class="sxs-lookup"><span data-stu-id="3e803-154">If the current thread already has the writer lock, no reader lock is acquired.</span></span> <span data-ttu-id="3e803-155">Au lieu de cela, le nombre de verrous sur le verrou de writer est incrémenté.</span><span class="sxs-lookup"><span data-stu-id="3e803-155">Instead, the lock count on the writer lock is incremented.</span></span> <span data-ttu-id="3e803-156">Cela empêche un thread de blocage sur son propre verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-156">This prevents a thread from blocking on its own writer lock.</span></span> <span data-ttu-id="3e803-157">Le résultat est exactement le même que si vous appelez <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>et un appel supplémentaire à <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> est requise lors de la libération du verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-157">The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.</span></span>  
  
 <span data-ttu-id="3e803-158">`AcquireReaderLock` prend en charge les demandes de verrou de lecteur récursives.</span><span class="sxs-lookup"><span data-stu-id="3e803-158">`AcquireReaderLock` supports recursive reader-lock requests.</span></span> <span data-ttu-id="3e803-159">Autrement dit, un thread peut appeler AcquireReaderLock plusieurs fois, ce qui incrémente le nombre de verrous chaque fois.</span><span class="sxs-lookup"><span data-stu-id="3e803-159">That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="3e803-160">Vous devez appeler <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> une fois pour chaque fois que vous appelez `AcquireReaderLock`.</span><span class="sxs-lookup"><span data-stu-id="3e803-160">You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`.</span></span> <span data-ttu-id="3e803-161">Vous pouvez également appeler <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> afin de réduire le nombre de verrous immédiatement à zéro.</span><span class="sxs-lookup"><span data-stu-id="3e803-161">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="3e803-162">Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-162">Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</span></span> <span data-ttu-id="3e803-163">Utilisez les verrous récursifs avec précaution, pour éviter de bloquer les demandes de verrou de writer pendant de longues périodes.</span><span class="sxs-lookup"><span data-stu-id="3e803-163">Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</span></span>  
  
 <span data-ttu-id="3e803-164">Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-164">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-165">L’exemple de code suivant montre comment acquérir et libérer un verrou de lecteur et comment gérer l’exception levée lorsqu’une demande arrive à expiration.</span><span class="sxs-lookup"><span data-stu-id="3e803-165">The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="3e803-166">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-166">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-167">
            <paramref name="millisecondsTimeout" /> expire avant que la demande de verrou soit accordée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-167">
              <paramref name="millisecondsTimeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireReaderLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="3e803-168">
            <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-168">A <see langword="TimeSpan" /> specifying the time-out period.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-169">Acquiert un verrou de lecteur en utilisant une valeur <see cref="T:System.TimeSpan" /> comme délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-169">Acquires a reader lock, using a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-170"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> bloque si un autre thread détient le verrou de writer ou si au moins un thread attend le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-170"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e803-171">Si le thread actuel a déjà le verrou de writer, aucun verrou de lecteur n’est acquis.</span><span class="sxs-lookup"><span data-stu-id="3e803-171">If the current thread already has the writer lock, no reader lock is acquired.</span></span> <span data-ttu-id="3e803-172">Au lieu de cela, le nombre de verrous sur le verrou de writer est incrémenté.</span><span class="sxs-lookup"><span data-stu-id="3e803-172">Instead, the lock count on the writer lock is incremented.</span></span> <span data-ttu-id="3e803-173">Cela empêche un thread de blocage sur son propre verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-173">This prevents a thread from blocking on its own writer lock.</span></span> <span data-ttu-id="3e803-174">Le résultat est exactement le même que si vous appelez <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>et un appel supplémentaire à <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> est requise lors de la libération du verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-174">The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.</span></span>  
  
 <span data-ttu-id="3e803-175">`AcquireReaderLock` prend en charge les demandes de verrou de lecteur récursives.</span><span class="sxs-lookup"><span data-stu-id="3e803-175">`AcquireReaderLock` supports recursive reader-lock requests.</span></span> <span data-ttu-id="3e803-176">Autrement dit, un thread peut appeler AcquireReaderLock plusieurs fois, ce qui incrémente le nombre de verrous chaque fois.</span><span class="sxs-lookup"><span data-stu-id="3e803-176">That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="3e803-177">Vous devez appeler <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> une fois pour chaque fois que vous appelez `AcquireReaderLock`.</span><span class="sxs-lookup"><span data-stu-id="3e803-177">You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`.</span></span> <span data-ttu-id="3e803-178">Vous pouvez également appeler <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> afin de réduire le nombre de verrous immédiatement à zéro.</span><span class="sxs-lookup"><span data-stu-id="3e803-178">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="3e803-179">Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-179">Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</span></span> <span data-ttu-id="3e803-180">Utilisez les verrous récursifs avec précaution, pour éviter de bloquer les demandes de verrou de writer pendant de longues périodes.</span><span class="sxs-lookup"><span data-stu-id="3e803-180">Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</span></span>  
  
 <span data-ttu-id="3e803-181">Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-181">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-182">
            <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-182">
              <paramref name="timeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3e803-183">
            <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-183">
              <paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3e803-184">Acquiert le verrou de writer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-184">Acquires the writer lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : int -&gt; unit" Usage="readerWriterLock.AcquireWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3e803-185">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-185">The time-out in milliseconds.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-186">Acquiert un verrou de writer en utilisant une valeur <see cref="T:System.Int32" /> comme délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-186">Acquires the writer lock, using an <see cref="T:System.Int32" /> value for the time-out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-187">Cette méthode se bloque si un autre thread a un verrou de lecteur ou un verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-187">This method blocks if another thread has a reader lock or writer lock.</span></span> <span data-ttu-id="3e803-188">Pour obtenir une description de la façon dont le verrou de writer alterne avec plusieurs verrous de lecteurs simultanés, consultez la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-188">For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="3e803-189">Un thread qui a déjà un verrou de lecteur peut acquérir le verrou de writer de deux façons : en libérant le verrou de lecteur avant d’appeler <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou en appelant <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-189">A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3e803-190">Si un thread appelle `AcquireWriterLock` pendant qu’il a toujours un verrou de lecteur, il se bloque sur son propre verrou de lecteur ; si un délai d’attente infini est spécifié, le thread se bloquera.</span><span class="sxs-lookup"><span data-stu-id="3e803-190">If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</span></span> <span data-ttu-id="3e803-191">Pour éviter ces blocages, utilisez <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> pour déterminer si le thread actuel a déjà un verrou de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-191">To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.</span></span>  
  
 <span data-ttu-id="3e803-192">`AcquireWriterLock` prend en charge les demandes de verrou de writer récursives.</span><span class="sxs-lookup"><span data-stu-id="3e803-192">`AcquireWriterLock` supports recursive writer-lock requests.</span></span> <span data-ttu-id="3e803-193">Autrement dit, un thread peut appeler `AcquireWriterLock` plusieurs fois, ce qui incrémente le nombre de verrous chaque fois.</span><span class="sxs-lookup"><span data-stu-id="3e803-193">That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="3e803-194">Vous devez appeler <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> une fois pour chaque fois que vous appelez `AcquireWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="3e803-194">You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`.</span></span> <span data-ttu-id="3e803-195">Vous pouvez également appeler <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> afin de réduire le nombre de verrous immédiatement à zéro.</span><span class="sxs-lookup"><span data-stu-id="3e803-195">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="3e803-196">Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente de l’enregistreur.</span><span class="sxs-lookup"><span data-stu-id="3e803-196">Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</span></span>  
  
 <span data-ttu-id="3e803-197">Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-197">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-198">L’exemple de code suivant montre comment acquérir et libérer un verrou de writer et comment gérer l’exception levée lorsqu’une demande arrive à expiration.</span><span class="sxs-lookup"><span data-stu-id="3e803-198">The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="3e803-199">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-199">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-200">
            <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-200">
              <paramref name="timeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="3e803-201">
            <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-201">The <see langword="TimeSpan" /> specifying the time-out period.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-202">Acquiert un verrou de writer en utilisant une valeur <see cref="T:System.TimeSpan" /> comme délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-202">Acquires the writer lock, using a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-203">Cette méthode se bloque si un autre thread a un verrou de lecteur ou un verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-203">This method blocks if another thread has a reader lock or writer lock.</span></span> <span data-ttu-id="3e803-204">Pour obtenir une description de la façon dont le verrou de writer alterne avec plusieurs verrous de lecteurs simultanés, consultez la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-204">For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="3e803-205">Un thread qui a déjà un verrou de lecteur peut acquérir le verrou de writer de deux façons : en libérant le verrou de lecteur avant d’appeler <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou en appelant <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-205">A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3e803-206">Si un thread appelle `AcquireWriterLock` pendant qu’il a toujours un verrou de lecteur, il se bloque sur son propre verrou de lecteur ; si un délai d’attente infini est spécifié, le thread se bloquera.</span><span class="sxs-lookup"><span data-stu-id="3e803-206">If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</span></span> <span data-ttu-id="3e803-207">Pour éviter ces blocages, utilisez <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> pour déterminer si le thread actuel a déjà un verrou de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-207">To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.</span></span>  
  
 <span data-ttu-id="3e803-208">`AcquireWriterLock` prend en charge les demandes de verrou de writer récursives.</span><span class="sxs-lookup"><span data-stu-id="3e803-208">`AcquireWriterLock` supports recursive writer-lock requests.</span></span> <span data-ttu-id="3e803-209">Autrement dit, un thread peut appeler `AcquireWriterLock` plusieurs fois, ce qui incrémente le nombre de verrous chaque fois.</span><span class="sxs-lookup"><span data-stu-id="3e803-209">That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="3e803-210">Vous devez appeler <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> une fois pour chaque fois que vous appelez `AcquireWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="3e803-210">You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`.</span></span> <span data-ttu-id="3e803-211">Vous pouvez également appeler <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> afin de réduire le nombre de verrous immédiatement à zéro.</span><span class="sxs-lookup"><span data-stu-id="3e803-211">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="3e803-212">Demandes de verrou récursives sont toujours accordées immédiatement sans placer le thread de demande dans la file d’attente de l’enregistreur.</span><span class="sxs-lookup"><span data-stu-id="3e803-212">Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</span></span>  
  
 <span data-ttu-id="3e803-213">Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-213">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-214">
            <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-214">
              <paramref name="timeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3e803-215">
            <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-215">
              <paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberSignature Language="F#" Value="member this.AnyWritersSince : int -&gt; bool" Usage="readerWriterLock.AnyWritersSince seqNum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">
          <span data-ttu-id="3e803-216">Numéro de séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-216">The sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-217">Indique si le verrou de writer a été accordé à un thread depuis l'obtention du numéro de séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-217">Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3e803-218">
            <see langword="true" /> si le verrou de writer a été accordé à un thread depuis l'obtention du numéro de séquence ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-218">
              <see langword="true" /> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-219">Vous pouvez utiliser <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> et `AnyWritersSince` pour améliorer les performances de l’application.</span><span class="sxs-lookup"><span data-stu-id="3e803-219">You can use <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> and `AnyWritersSince` to improve application performance.</span></span> <span data-ttu-id="3e803-220">Par exemple, un thread peut mettre en cache les informations obtenues pendant qu’il maintient un verrou de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-220">For example, a thread might cache the information it obtains while holding a reader lock.</span></span> <span data-ttu-id="3e803-221">Après avoir libéré puis acquis à nouveau le verrou, le thread peut utiliser `AnyWritersSince` pour déterminer si d’autres threads ont écrit à la ressource en attendant ; le cas contraire, les informations mises en cache peuvent être utilisées.</span><span class="sxs-lookup"><span data-stu-id="3e803-221">After releasing and later reacquiring the lock, the thread can use `AnyWritersSince` to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</span></span> <span data-ttu-id="3e803-222">Cette technique est utile où la lecture des informations protégées par le verrou est coûteuse ; par exemple, exécuter une requête de base de données.</span><span class="sxs-lookup"><span data-stu-id="3e803-222">This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</span></span>  
  
 <span data-ttu-id="3e803-223">L’appelant doit être détient un verrou de lecteur ou un verrou de writer dans afin que le numéro de séquence être utile.</span><span class="sxs-lookup"><span data-stu-id="3e803-223">The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-224">L’exemple de code suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> (méthode) et le <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propriété afin de déterminer si un autre thread a acquis le verrou de writer sur la ressource protégée depuis le thread actuel a détenu le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-224">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</span></span>  
  
 <span data-ttu-id="3e803-225">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-225">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.DowngradeFromWriterLock :  -&gt; unit" Usage="readerWriterLock.DowngradeFromWriterLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">
          <span data-ttu-id="3e803-226">
            <see cref="T:System.Threading.LockCookie" /> retourné par <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-226">A <see cref="T:System.Threading.LockCookie" /> returned by <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-227">Restaure le verrou du thread à l'état qu'il avait avant l'appel à <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-227">Restores the lock status of the thread to what it was before <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> was called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-228"><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Libère le verrou de writer, quel que soit le nombre de verrous récursifs et restaure le verrou de lecteur détenu par le thread avant la mise à niveau vers le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-228"><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</span></span> <span data-ttu-id="3e803-229">Le nombre de verrous sur le verrou de lecteur est restauré.</span><span class="sxs-lookup"><span data-stu-id="3e803-229">The lock count on the reader lock is restored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e803-230">`DowngradeFromWriterLock` accepte un <xref:System.Threading.LockCookie> obtenu en appelant <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-230">`DowngradeFromWriterLock` accepts a <xref:System.Threading.LockCookie> obtained by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span> <span data-ttu-id="3e803-231">N’utilisez pas un `LockCookie` retourné par <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-231">Do not use a `LockCookie` returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span></span>  
  
 <span data-ttu-id="3e803-232">Un thread ne bloque pas lorsque vous rétrogradez à partir du verrou de writer, même si d’autres threads en attente pour le verrou de writer, étant donné que toutes les demandes de verrou de lecteur sont accordées lorsque le verrou de writer est libéré.</span><span class="sxs-lookup"><span data-stu-id="3e803-232">A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-233">L’exemple de code suivant montre comment demander un verrou de lecteur, mettre à niveau le verrou de lecteur vers un verrou de writer et passer à un verrou de lecteur à nouveau.</span><span class="sxs-lookup"><span data-stu-id="3e803-233">The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</span></span>  
  
 <span data-ttu-id="3e803-234">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-234">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-235">Le thread n'a pas de verrou de writer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-235">The thread does not have the writer lock.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="3e803-236">L’adresse de <paramref name="lockCookie" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-236">The address of <paramref name="lockCookie" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="readerWriterLock.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3e803-237">Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'objet <see cref="T:System.Threading.ReaderWriterLock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-237">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.ReaderWriterLock" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-238">Le garbage collector appelle <xref:System.Threading.ReaderWriterLock.Finalize%2A> lorsque actuel <xref:System.Threading.ReaderWriterLock> objet est prêt à être finalisé.</span><span class="sxs-lookup"><span data-stu-id="3e803-238">The garbage collector calls <xref:System.Threading.ReaderWriterLock.Finalize%2A> when the current <xref:System.Threading.ReaderWriterLock> object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReaderLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3e803-239">Obtient une valeur indiquant si le thread actif détient un verrou de lecteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-239">Gets a value indicating whether the current thread holds a reader lock.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3e803-240">
            <see langword="true" /> si le thread actif détient un verrou de lecteur ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-240">
              <see langword="true" /> if the current thread holds a reader lock; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3e803-241">L’exemple de code suivant montre comment utiliser `IsReaderLockHeld` pour éviter les blocages.</span><span class="sxs-lookup"><span data-stu-id="3e803-241">The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriterLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3e803-242">Obtient une valeur indiquant si le thread actif détient le verrou de writer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-242">Gets a value indicating whether the current thread holds the writer lock.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3e803-243">
            <see langword="true" /> si le thread actif détient le verrou de writer ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-243">
              <see langword="true" /> if the current thread holds the writer lock; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3e803-244">L’exemple de code suivant montre que lorsqu’une tentative est faite pour acquérir un verrou de lecteur sur un thread qui dispose un verrou de writer, `ReaderWriterLock` n’accorde pas le verrou de lecteur et incrémente le nombre de verrous sur le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-244">The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseLock : unit -&gt; System.Threading.LockCookie" Usage="readerWriterLock.ReleaseLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3e803-245">Libère le verrou quel que soit le nombre de fois où il a été acquis par le thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-245">Releases the lock, regardless of the number of times the thread acquired the lock.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3e803-246">Valeur <see cref="T:System.Threading.LockCookie" /> représentant le verrou libéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-246">A <see cref="T:System.Threading.LockCookie" /> value representing the released lock.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-247"><xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Libère le verrou de lecteur ou un verrou de writer, quel que soit le nombre de verrous récursifs.</span><span class="sxs-lookup"><span data-stu-id="3e803-247"><xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> releases the reader lock or writer lock, regardless of the recursive lock count.</span></span> <span data-ttu-id="3e803-248">Pour restaurer l’état du verrou, y compris le nombre de verrous, passez le <xref:System.Threading.LockCookie> à <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-248">To restore the state of the lock, including the lock count, pass the <xref:System.Threading.LockCookie> to <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-249">L’exemple de code suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> méthode pour libérer le verrou, quel que soit le nombre de fois où elle a été acquis par le thread et comment restaurer l’état du verrou plus tard.</span><span class="sxs-lookup"><span data-stu-id="3e803-249">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</span></span>  
  
 <span data-ttu-id="3e803-250">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-250">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseReaderLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseReaderLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3e803-251">Décrémente le nombre de verrous.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-251">Decrements the lock count.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-252"><xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Décrémente le nombre de verrous.</span><span class="sxs-lookup"><span data-stu-id="3e803-252"><xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> decrements the lock count.</span></span> <span data-ttu-id="3e803-253">Lorsque le décompte atteint zéro, le verrou est libéré.</span><span class="sxs-lookup"><span data-stu-id="3e803-253">When the count reaches zero, the lock is released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e803-254">Si un thread possède le verrou de writer, l’appel `ReleaseReaderLock` a le même effet que si vous appelez <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-254">If a thread has the writer lock, calling `ReleaseReaderLock` has the same effect as calling <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span></span> <span data-ttu-id="3e803-255">Si un thread n’a aucun verrou, l’appel `ReleaseReaderLock` lève une <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="3e803-255">If a thread has no locks, calling `ReleaseReaderLock` throws an <xref:System.ApplicationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-256">L’exemple de code suivant montre comment acquérir et libérer un verrou de lecteur et comment gérer l’exception levée lorsqu’une demande arrive à expiration.</span><span class="sxs-lookup"><span data-stu-id="3e803-256">The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="3e803-257">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-257">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-258">Le thread n'a pas de verrous de writer ou de lecteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-258">The thread does not have any reader or writer locks.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseWriterLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseWriterLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3e803-259">Décrémente le nombre de verrous sur le verrou de writer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-259">Decrements the lock count on the writer lock.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-260"><xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Décrémente le verrou de writer nombre.</span><span class="sxs-lookup"><span data-stu-id="3e803-260"><xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> decrements the writer lock count.</span></span> <span data-ttu-id="3e803-261">Lorsque le décompte atteint zéro, le verrou de writer est libéré.</span><span class="sxs-lookup"><span data-stu-id="3e803-261">When the count reaches zero, the writer lock is released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e803-262">Si un thread possède un verrou de lecteur ou aucun verrou, l’appel `ReleaseWriterLock` lève une <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="3e803-262">If a thread has a reader lock, or no locks, calling `ReleaseWriterLock` throws an <xref:System.ApplicationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-263">L’exemple de code suivant montre comment acquérir et libérer un verrou de writer et comment gérer l’exception levée lorsqu’une demande arrive à expiration.</span><span class="sxs-lookup"><span data-stu-id="3e803-263">The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="3e803-264">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-264">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-265">Le thread n'a pas de verrou de writer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-265">The thread does not have the writer lock.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.RestoreLock :  -&gt; unit" Usage="readerWriterLock.RestoreLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">
          <span data-ttu-id="3e803-266">
            <see cref="T:System.Threading.LockCookie" /> retourné par <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-266">A <see cref="T:System.Threading.LockCookie" /> returned by <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-267">Restaure l'état de verrou du thread au moment précédant l'appel à <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-267">Restores the lock status of the thread to what it was before calling <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-268">L’état restauré par `RestoreLock` inclut le nombre de verrous récursifs.</span><span class="sxs-lookup"><span data-stu-id="3e803-268">The state restored by `RestoreLock` includes the recursive lock count.</span></span>  
  
 <span data-ttu-id="3e803-269">Un thread se bloque si elle tente de restaurer un verrou de lecteur après qu’un autre thread a acquis le verrou de writer ou si elle tente de restaurer le verrou de writer après qu’un autre thread a acquis un verrou de lecteur ou un verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-269">A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</span></span> <span data-ttu-id="3e803-270">Étant donné que `RestoreLock` n’accepte pas un délai d’attente, vous devez prendre soin d’éviter les blocages possibles.</span><span class="sxs-lookup"><span data-stu-id="3e803-270">Because `RestoreLock` does not accept a time-out, you should take care to avoid possible deadlocks.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3e803-271">Avant d’appeler `RestoreLock`, assurez-vous que vous avez libéré tous les verrous acquis depuis l’appel à <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-271">Before calling `RestoreLock`, make sure you have released all locks acquired since the call to <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span></span> <span data-ttu-id="3e803-272">Par exemple, un thread se bloque s’il acquiert un verrou de lecteur, puis tente de restaurer un verrou de writer précédent.</span><span class="sxs-lookup"><span data-stu-id="3e803-272">For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</span></span> <span data-ttu-id="3e803-273">Utilisez <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> et <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> pour détecter ces verrous supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="3e803-273">Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> and <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> to detect such additional locks.</span></span>  
  
 <span data-ttu-id="3e803-274">N’utilisez pas un <xref:System.Threading.LockCookie> retourné à partir de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-274">Do not use a <xref:System.Threading.LockCookie> returned from <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-275">L’exemple de code suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> méthode pour libérer le verrou, quel que soit le nombre de fois où elle a été acquis par le thread et comment restaurer l’état du verrou plus tard.</span><span class="sxs-lookup"><span data-stu-id="3e803-275">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</span></span>  
  
 <span data-ttu-id="3e803-276">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-276">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="3e803-277">L’adresse de <paramref name="lockCookie" /> est un pointeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-277">The address of <paramref name="lockCookie" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3e803-278">Met à niveau un verrou de lecteur vers le verrou de writer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-278">Upgrades a reader lock to the writer lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : int -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3e803-279">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-279">The time-out in milliseconds.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-280">Met à niveau un verrou de lecteur vers le verrou de writer en utilisant une valeur <see langword="Int32" /> pour définir le délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-280">Upgrades a reader lock to the writer lock, using an <see langword="Int32" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3e803-281">Valeur <see cref="T:System.Threading.LockCookie" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-281">A <see cref="T:System.Threading.LockCookie" /> value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-282">Lorsqu’un thread appelle `UpgradeToWriterLock` le verrou de lecteur est libéré, quel que soit le nombre de verrous, et le thread se place à la fin de la file d’attente pour le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-282">When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</span></span> <span data-ttu-id="3e803-283">Par conséquent, les autres threads peuvent écrire dans la ressource avant que le thread qui a demandé que la mise à niveau est accordé le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-283">Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e803-284">L’exception de délai d’attente n’est pas levée jusqu'à ce que le thread qui a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> méthode peut acquérir le verrou de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-284">The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock.</span></span> <span data-ttu-id="3e803-285">S’il n’existe aucun autre thread n’attend le verrou de writer, cela se produit immédiatement.</span><span class="sxs-lookup"><span data-stu-id="3e803-285">If there are no other threads waiting for the writer lock, this happens immediately.</span></span> <span data-ttu-id="3e803-286">Toutefois, si un autre thread est en attente pour le verrou de writer, le thread qui a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> méthode ne peut pas acquérir le verrou de lecteur tant que tous les lecteurs en cours ont libéré leurs verrous, et un thread a acquis et libéré le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-286">However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</span></span> <span data-ttu-id="3e803-287">Cela est vrai même si l’autre thread qui a demandé le verrou de writer a demandé une fois que le thread actuel a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3e803-287">This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.</span></span>  
  
 <span data-ttu-id="3e803-288">Pour restaurer l’état du verrou, appelez <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> à l’aide de la <xref:System.Threading.LockCookie> retourné par `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="3e803-288">To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`.</span></span> <span data-ttu-id="3e803-289">N’utilisez pas cette `LockCookie` avec <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-289">Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
 <span data-ttu-id="3e803-290">Quand un thread n’a aucun verrou de lecteur, n’utilisez pas `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="3e803-290">When a thread has no reader lock, do not use `UpgradeToWriterLock`.</span></span> <span data-ttu-id="3e803-291">Utilisez plutôt <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-291">Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.</span></span>  
  
 <span data-ttu-id="3e803-292">Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-292">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-293">L’exemple de code suivant montre comment demander un verrou de lecteur, mettre à niveau le verrou de lecteur vers un verrou de writer et passer à un verrou de lecteur à nouveau.</span><span class="sxs-lookup"><span data-stu-id="3e803-293">The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</span></span>  
  
 <span data-ttu-id="3e803-294">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-294">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-295">
            <paramref name="millisecondsTimeout" /> expire avant que la demande de verrou soit accordée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-295">
              <paramref name="millisecondsTimeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : TimeSpan -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="3e803-296">
            <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-296">The <see langword="TimeSpan" /> specifying the time-out period.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3e803-297">Met à niveau un verrou de lecteur vers le verrou de writer en utilisant une valeur <see langword="TimeSpan" /> pour définir le délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-297">Upgrades a reader lock to the writer lock, using a <see langword="TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3e803-298">Valeur <see cref="T:System.Threading.LockCookie" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-298">A <see cref="T:System.Threading.LockCookie" /> value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-299">Lorsqu’un thread appelle `UpgradeToWriterLock` le verrou de lecteur est libéré, quel que soit le nombre de verrous, et le thread se place à la fin de la file d’attente pour le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-299">When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</span></span> <span data-ttu-id="3e803-300">Par conséquent, les autres threads peuvent écrire dans la ressource avant que le thread qui a demandé que la mise à niveau est accordé le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-300">Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e803-301">L’exception de délai d’attente n’est pas levée jusqu'à ce que le thread qui a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> méthode peut acquérir le verrou de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-301">The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock.</span></span> <span data-ttu-id="3e803-302">S’il n’existe aucun autre thread n’attend le verrou de writer, cela se produit immédiatement.</span><span class="sxs-lookup"><span data-stu-id="3e803-302">If there are no other threads waiting for the writer lock, this happens immediately.</span></span> <span data-ttu-id="3e803-303">Toutefois, si un autre thread est en attente pour le verrou de writer, le thread qui a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> méthode ne peut pas acquérir le verrou de lecteur tant que tous les lecteurs en cours ont libéré leurs verrous, et un thread a acquis et libéré le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-303">However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</span></span> <span data-ttu-id="3e803-304">Cela est vrai même si l’autre thread qui a demandé le verrou de writer a demandé une fois que le thread actuel a appelé le <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3e803-304">This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.</span></span>  
  
 <span data-ttu-id="3e803-305">Pour restaurer l’état du verrou, appelez <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> à l’aide de la <xref:System.Threading.LockCookie> retourné par `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="3e803-305">To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`.</span></span> <span data-ttu-id="3e803-306">N’utilisez pas cette `LockCookie` avec <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-306">Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
 <span data-ttu-id="3e803-307">Quand un thread n’a aucun verrou de lecteur, n’utilisez pas `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="3e803-307">When a thread has no reader lock, do not use `UpgradeToWriterLock`.</span></span> <span data-ttu-id="3e803-308">Utilisez plutôt <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e803-308">Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.</span></span>  
  
 <span data-ttu-id="3e803-309">Pour les valeurs de délai d’attente valides, consultez <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="3e803-309">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3e803-310">
            <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-310">
              <paramref name="timeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3e803-311">
            <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-311">
              <paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WriterSeqNum : int" Usage="System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3e803-312">Obtient le numéro de séquence actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-312">Gets the current sequence number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3e803-313">Numéro de séquence actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3e803-313">The current sequence number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e803-314">Le numéro de séquence augmente chaque fois qu’un thread acquiert le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-314">The sequence number increases whenever a thread acquires the writer lock.</span></span> <span data-ttu-id="3e803-315">Vous pouvez enregistrer le numéro de séquence et transmettez-le à <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> ultérieurement, si vous souhaitez déterminer si d’autres threads ont acquis le verrou de writer dans l’intervalle.</span><span class="sxs-lookup"><span data-stu-id="3e803-315">You can save the sequence number and pass it to <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</span></span>  
  
 <span data-ttu-id="3e803-316">Vous pouvez utiliser `WriterSeqNum` pour améliorer les performances de l’application.</span><span class="sxs-lookup"><span data-stu-id="3e803-316">You can use `WriterSeqNum` to improve application performance.</span></span> <span data-ttu-id="3e803-317">Par exemple, un thread peut mettre en cache les informations obtenues pendant qu’il maintient un verrou de lecteur.</span><span class="sxs-lookup"><span data-stu-id="3e803-317">For example, a thread might cache the information it obtains while holding a reader lock.</span></span> <span data-ttu-id="3e803-318">Après avoir libéré puis acquis à nouveau le verrou, le thread peut déterminer si d’autres threads ont écrit à la ressource en appelant `AnyWritersSince`; si non, les informations mises en cache peuvent être utilisées.</span><span class="sxs-lookup"><span data-stu-id="3e803-318">After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling `AnyWritersSince`; if not, the cached information can be used.</span></span> <span data-ttu-id="3e803-319">Cette technique est utile lors de la lecture des informations protégées par le verrou est coûteuse ; par exemple, exécuter une requête de base de données.</span><span class="sxs-lookup"><span data-stu-id="3e803-319">This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</span></span>  
  
 <span data-ttu-id="3e803-320">L’appelant doit être détient un verrou de lecteur ou un verrou de writer dans afin que le numéro de séquence être utile.</span><span class="sxs-lookup"><span data-stu-id="3e803-320">The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e803-321">L’exemple de code suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propriété et la <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> méthode pour déterminer si un autre thread a acquis le verrou de writer sur la ressource protégée depuis le thread actuel a détenu le verrou de writer.</span><span class="sxs-lookup"><span data-stu-id="3e803-321">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</span></span>  
  
 <span data-ttu-id="3e803-322">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLock> classe.</span><span class="sxs-lookup"><span data-stu-id="3e803-322">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>