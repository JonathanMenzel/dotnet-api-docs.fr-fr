<Type Name="SpinLock" FullName="System.Threading.SpinLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="10f26e6ab91a3ed621e096451edb0d7cae5bcc16" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48595429" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct SpinLock" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SpinLock extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SpinLock" />
  <TypeSignature Language="VB.NET" Value="Public Structure SpinLock" />
  <TypeSignature Language="C++ CLI" Value="public value class SpinLock" />
  <TypeSignature Language="F#" Value="type SpinLock = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsHeld = {IsHeld}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.SpinLock/SystemThreading_SpinLockDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une primitive de verrou d'exclusion mutuelle où un thread, qui tente d'acquérir le verrou, attend dans une boucle en effectuant des vérifications de manière répétée jusqu'à ce que le verrou devienne disponible.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir un exemple montrant comment utiliser un verrou de rotation, consultez [Comment : utiliser le verrouillage SpinLock pour une synchronisation de bas niveau](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md).  
  
 Verrous de rotation peuvent servir pour les verrous de niveau feuille où l’allocation d’objet implicite à l’aide un <xref:System.Threading.Monitor>, taille, ou en raison de la pression du garbage collection, est trop coûteuse. Un verrou de rotation peut être utile pour éviter les blocages ; Toutefois, si vous prévoyez une quantité importante de blocage, vous devez probablement pas utiliser les verrous de rotation en raison de la rotation excessive. Rotation peut s’avérer utile lorsque les verrous sont et affinés nombre (par exemple, un verrou par nœud dans une liste liée) et également lorsque les durées de blocage du verrou sont toujours très courtes. En règle générale, tout en maintenant un verrou de rotation, un doit éviter une de ces actions :  
  
-   blocage,  
  
-   appel de tout élément pouvant lui-même se bloquer,  
  
-   contenant à la fois de plus d’un verrou de rotation  
  
-   passer dynamiquement des appels (interface et virtuels), distribués  
  
-   passer de manière statique des appels dans du code non possédé, distribués ou  
  
-   allocation de mémoire.  
  
 <xref:System.Threading.SpinLock> doit être utilisé uniquement une fois que vous avez déterminé que cela améliorera les performances d’une application. Il est également important de noter que <xref:System.Threading.SpinLock> est un type valeur, pour des raisons de performances. Pour cette raison, vous devez être très attention à ne pas copier par erreur une <xref:System.Threading.SpinLock> de l’instance, comme les deux instances (d’origine et la copie) serait alors indépendamment les uns des autres, ce qui pourrait engendrer un comportement incorrect de l’application. Si un <xref:System.Threading.SpinLock> instance doit être passée, il doit être passé par référence plutôt que par valeur.  
  
 Ne stockez pas <xref:System.Threading.SpinLock> instances dans les champs en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Threading.SpinLock>:  
  
 [!code-csharp[System.Threading.SpinLock#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.spinlock/cs/spinlock.cs#01)]
 [!code-vb[System.Threading.SpinLock#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.spinlock/vb/spinlock.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres de <see cref="T:System.Threading.SpinLock" /> sont thread-safe et peuvent être utilisés à partir de plusieurs threads simultanément.</threadsafe>
    <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
    <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser SpinWait et verrouillage SpinLock</related>
    <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SpinLock (bool enableThreadOwnerTracking);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool enableThreadOwnerTracking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (enableThreadOwnerTracking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SpinLock(bool enableThreadOwnerTracking);" />
      <MemberSignature Language="F#" Value="new System.Threading.SpinLock : bool -&gt; System.Threading.SpinLock" Usage="new System.Threading.SpinLock enableThreadOwnerTracking" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="enableThreadOwnerTracking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enableThreadOwnerTracking">Indique s'il faut capturer et utiliser des ID de thread à des fins de débogage.</param>
        <summary>Initialise une nouvelle instance de la structure de <see cref="T:System.Threading.SpinLock" /> avec l'option permettant de suivre les ID de thread afin d'améliorer le débogage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur par défaut <xref:System.Threading.SpinLock> suit la propriété de thread.  
  
   
  
## Examples  
 L’exemple suivant montre comment un SpinLock peut être utilisé.  
  
```csharp  
// C#  
public class MyType  
{  
    private SpinLock _spinLock = new SpinLock();  
  
    public void DoWork()  
    {  
        bool lockTaken = false;   
        try  
        {  
           _spinLock.Enter(ref lockTaken);  
           // do work here protected by the lock  
        }  
        finally  
        {  
            if (lockTaken) _spinLock.Exit();  
        }  
    }  
}  
```  
  
```vb  
' Visual Basic  
  
Class MyType  
   Private _spinLock As New SpinLock()  
  
   Public Sub DoWork()  
      Dim lockTaken As Boolean = False  
      Try  
         _spinLock.Enter(lockTaken)  
         ' do work here protected by the lock  
      Finally  
         If lockTaken Then _spinLock.Exit()  
      End Try  
   End Sub  
End Class  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public void Enter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Enter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enter(bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.Enter :  -&gt; unit" Usage="spinLock.Enter lockTaken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken">True si le verrou est acquis ; sinon, false. <c>lockTaken</c> doit être initialisé avec la valeur false avant l’appel à cette méthode.</param>
        <summary>Acquiert le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.SpinLock> est un verrou non réentrant, ce qui signifie que si un thread détient le verrou, il n’est pas autorisé à entrer de nouveau le verrou. Si le suivi de la propriété du thread est activée (s’il est activé est disponible via <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), une exception est levée lorsqu’un thread essaie d’entrer à nouveau un verrou qu’il détient déjà. Toutefois, si le suivi de la propriété du thread est désactivée, toute tentative d’entrer un verrou déjà détenu entraîne un blocage.  
  
 Si vous appelez <xref:System.Threading.SpinLock.Exit%2A> sans avoir au préalable appelé <xref:System.Threading.SpinLock.Enter%2A> l’état interne de la <xref:System.Threading.SpinLock> peut être endommagé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler ENTRÉE.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère le verrou.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit();" />
      <MemberSignature Language="F#" Value="member this.Exit : unit -&gt; unit" Usage="spinLock.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère le verrou.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La surcharge par défaut de <xref:System.Threading.SpinLock.Exit%2A> présente le même comportement que si l’appel <xref:System.Threading.SpinLock.Exit%2A> à l’aide de la valeur true comme argument.  
  
 Si vous appelez <xref:System.Threading.SpinLock.Exit%2A> sans avoir au préalable appelé <xref:System.Threading.SpinLock.Enter%2A> l’état interne de la <xref:System.Threading.SpinLock> peut être endommagé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Le suivi de la propriété du thread est autorisé, et le thread actuel n'est pas le propriétaire de ce verrou.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit (bool useMemoryBarrier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit(bool useMemoryBarrier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit (useMemoryBarrier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit(bool useMemoryBarrier);" />
      <MemberSignature Language="F#" Value="member this.Exit : bool -&gt; unit" Usage="spinLock.Exit useMemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useMemoryBarrier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useMemoryBarrier">Valeur booléenne qui indique si une barrière mémoire doit être émise pour publier immédiatement l'opération de sortie sur d'autres threads.</param>
        <summary>Libère le verrou.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Threading.SpinLock.Exit%2A> avec la `useMemoryBarrier` argument défini sur true améliorera l’équité du verrou au détriment des performances. La valeur par défaut <xref:System.Threading.SpinLock.Exit%2A> surcharge se comporte comme si la valeur true pour `useMemoryBarrier`.  
  
 Si vous appelez <xref:System.Threading.SpinLock.Exit%2A> sans avoir au préalable appelé <xref:System.Threading.SpinLock.Enter%2A> l’état interne de la <xref:System.Threading.SpinLock> peut être endommagé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Le suivi de la propriété du thread est autorisé, et le thread actuel n'est pas le propriétaire de ce verrou.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="IsHeld">
      <MemberSignature Language="C#" Value="public bool IsHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHeld : bool" Usage="System.Threading.SpinLock.IsHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le verrou est actuellement détenu par un thread.</summary>
        <value>True si le verrou est actuellement détenu par un thread ; sinon, false.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="IsHeldByCurrentThread">
      <MemberSignature Language="C#" Value="public bool IsHeldByCurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeldByCurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeldByCurrentThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeldByCurrentThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHeldByCurrentThread : bool" Usage="System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le verrou est détenu par le thread actuel.</summary>
        <value>True si le verrou est détenu par le thread actuel ; sinon, false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le verrou a été initialisé pour effectuer le suivi des threads de propriétaire, cela renverra si le verrou est acquis par le thread actuel. Il n’est pas valide pour utiliser cette propriété lorsque le verrou a été initialisé pour ne pas effectuer le suivi de la propriété du thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le suivi de la propriété du thread est désactivé.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadOwnerTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool IsThreadOwnerTrackingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadOwnerTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadOwnerTrackingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadOwnerTrackingEnabled : bool" Usage="System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le suivi de la propriété des threads est activé pour cette instance.</summary>
        <value>True si le suivi de la propriété du thread est autorisé pour cette instance ; sinon, false.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter :  -&gt; unit" Usage="spinLock.TryEnter lockTaken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken">True si le verrou est acquis ; sinon, false. <c>lockTaken</c> doit être initialisé avec la valeur false avant l’appel à cette méthode.</param>
        <summary>Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à <xref:System.Threading.SpinLock.Enter%2A>, TryEnter ne bloquera pas attendre le verrou soit disponible. Si le verrou n’est pas disponible lors de la méthode TryEnter est appelée, elle retournera immédiatement sans aucune autre rotation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : int *  -&gt; unit" Usage="spinLock.TryEnter (millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="lockTaken">True si le verrou est acquis ; sinon, false. <c>lockTaken</c> doit être initialisé avec la valeur false avant l’appel à cette méthode.</param>
        <summary>Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à <xref:System.Threading.SpinLock.Enter%2A>, TryEnter ne bloquera pas indéfiniment attend le verrou soit disponible. Il se bloque jusqu'à ce que le verrou soit disponible ou jusqu'à ce que le `millisecondsTimeout` a expiré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : TimeSpan *  -&gt; unit" Usage="spinLock.TryEnter (timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <param name="lockTaken">True si le verrou est acquis ; sinon, false. <c>lockTaken</c> doit être initialisé avec la valeur false avant l’appel à cette méthode.</param>
        <summary>Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à <xref:System.Threading.SpinLock.Enter%2A>, TryEnter ne bloquera pas indéfiniment attend le verrou soit disponible. Il se bloque jusqu'à ce que le verrou soit disponible ou jusqu'à ce que le `timeout` a expiré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" /> millisecondes.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Comment : utiliser le verrouillage spinlock pour une synchronisation de bas niveau</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Comment : activer le mode de suivi des threads dans le verrouillage Spinlock</related>
      </Docs>
    </Member>
  </Members>
</Type>