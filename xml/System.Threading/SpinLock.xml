<Type Name="SpinLock" FullName="System.Threading.SpinLock">
  <TypeSignature Language="C#" Value="public struct SpinLock" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SpinLock extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SpinLock" />
  <TypeSignature Language="VB.NET" Value="Public Structure SpinLock" />
  <TypeSignature Language="C++ CLI" Value="public value class SpinLock" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsHeld = {IsHeld}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.SpinLock/SystemThreading_SpinLockDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="67862-101">Fournit une primitive de verrou d'exclusion mutuelle où un thread, qui tente d'acquérir le verrou, attend dans une boucle en effectuant des vérifications de manière répétée jusqu'à ce que le verrou devienne disponible.</span><span class="sxs-lookup"><span data-stu-id="67862-101">Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-102">Pour obtenir un exemple d’utilisation d’un verrou de rotation, consultez [Comment : utiliser le verrouillage SpinLock pour une synchronisation de bas niveau](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md).</span><span class="sxs-lookup"><span data-stu-id="67862-102">For an example of how to use a Spin Lock, see [How to: Use SpinLock for Low-Level Synchronization](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md).</span></span>  
  
 <span data-ttu-id="67862-103">Verrous de rotation peuvent servir pour les verrous de niveau feuille où l’allocation d’objet implicite à l’aide un <xref:System.Threading.Monitor>, taille, ou en raison d’une pression du garbage collection, est trop coûteuse.</span><span class="sxs-lookup"><span data-stu-id="67862-103">Spin locks can be used for leaf-level locks where the object allocation implied by using a <xref:System.Threading.Monitor>, in size or due to garbage collection pressure, is overly expensive.</span></span> <span data-ttu-id="67862-104">Un verrou de rotation peut être utile pour éviter les blocages ; Toutefois, si vous prévoyez une quantité importante de blocage, vous devez utiliser probablement pas les verrous de rotation en raison d’une rotation excessive.</span><span class="sxs-lookup"><span data-stu-id="67862-104">A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning.</span></span> <span data-ttu-id="67862-105">Bouclage peut être bénéfique lorsque les verrous sont et affinés nombre (par exemple, un verrou par nœud dans une liste liée) et également lorsque les durées de blocage du verrou sont toujours très courtes.</span><span class="sxs-lookup"><span data-stu-id="67862-105">Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short.</span></span> <span data-ttu-id="67862-106">En règle générale, tout en maintenant un verrou de rotation, un doit éviter une de ces actions :</span><span class="sxs-lookup"><span data-stu-id="67862-106">In general, while holding a spin lock, one should avoid any of these actions:</span></span>  
  
-   <span data-ttu-id="67862-107">blocage,</span><span class="sxs-lookup"><span data-stu-id="67862-107">blocking,</span></span>  
  
-   <span data-ttu-id="67862-108">appel de tout élément pouvant lui-même se bloquer,</span><span class="sxs-lookup"><span data-stu-id="67862-108">calling anything that itself may block,</span></span>  
  
-   <span data-ttu-id="67862-109">contenant plus d’un verrou de rotation à la fois,</span><span class="sxs-lookup"><span data-stu-id="67862-109">holding more than one spin lock at once,</span></span>  
  
-   <span data-ttu-id="67862-110">passer dynamiquement des appels (interface et virtuels), distribués</span><span class="sxs-lookup"><span data-stu-id="67862-110">making dynamically dispatched calls (interface and virtuals),</span></span>  
  
-   <span data-ttu-id="67862-111">passer de manière statique des appels dans du code non possédé, distribués ou</span><span class="sxs-lookup"><span data-stu-id="67862-111">making statically dispatched calls into any code one doesn't own, or</span></span>  
  
-   <span data-ttu-id="67862-112">allocation de mémoire.</span><span class="sxs-lookup"><span data-stu-id="67862-112">allocating memory.</span></span>  
  
 <span data-ttu-id="67862-113"><xref:System.Threading.SpinLock> doit être utilisé uniquement une fois que vous avez déterminé que cela améliorera les performances d’une application.</span><span class="sxs-lookup"><span data-stu-id="67862-113"><xref:System.Threading.SpinLock> should only be used after you have been determined that doing so will improve an application's performance.</span></span> <span data-ttu-id="67862-114">Il est également important de noter que <xref:System.Threading.SpinLock> est un type valeur, pour des raisons de performances.</span><span class="sxs-lookup"><span data-stu-id="67862-114">It is also important to note that <xref:System.Threading.SpinLock> is a value type, for performance reasons.</span></span> <span data-ttu-id="67862-115">Pour cette raison, vous devez être très attention à ne pas copier par erreur un <xref:System.Threading.SpinLock> de l’instance, comme les deux instances (d’origine et la copie) seraient alors complètement indépendants, ce qui pourrait engendrer un comportement incorrect de l’application.</span><span class="sxs-lookup"><span data-stu-id="67862-115">For this reason, you must be very careful not to accidentally copy a <xref:System.Threading.SpinLock> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application.</span></span> <span data-ttu-id="67862-116">Si un <xref:System.Threading.SpinLock> instance doit être passée, il doit être passé par référence plutôt que par valeur.</span><span class="sxs-lookup"><span data-stu-id="67862-116">If a <xref:System.Threading.SpinLock> instance must be passed around, it should be passed by reference rather than by value.</span></span>  
  
 <span data-ttu-id="67862-117">Ne stockez pas <xref:System.Threading.SpinLock> instances dans les champs en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="67862-117">Do not store <xref:System.Threading.SpinLock> instances in readonly fields.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67862-118">L’exemple suivant montre comment utiliser un <xref:System.Threading.SpinLock>:</span><span class="sxs-lookup"><span data-stu-id="67862-118">The following example shows how to use a <xref:System.Threading.SpinLock>:</span></span>  
  
 [!code-csharp[System.Threading.SpinLock#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.spinlock/cs/spinlock.cs#01)]
 [!code-vb[System.Threading.SpinLock#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.spinlock/vb/spinlock.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="67862-119">Tous les membres de <see cref="T:System.Threading.SpinLock" /> sont thread-safe et peuvent être utilisés à partir de plusieurs threads simultanément.</span><span class="sxs-lookup"><span data-stu-id="67862-119">All members of <see cref="T:System.Threading.SpinLock" /> are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SpinLock (bool enableThreadOwnerTracking);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool enableThreadOwnerTracking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (enableThreadOwnerTracking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SpinLock(bool enableThreadOwnerTracking);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="enableThreadOwnerTracking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enableThreadOwnerTracking"><span data-ttu-id="67862-120">Indique s'il faut capturer et utiliser des ID de thread à des fins de débogage.</span><span class="sxs-lookup"><span data-stu-id="67862-120">Whether to capture and use thread IDs for debugging purposes.</span></span></param>
        <summary><span data-ttu-id="67862-121">Initialise une nouvelle instance de la structure de <see cref="T:System.Threading.SpinLock" /> avec l'option permettant de suivre les ID de thread afin d'améliorer le débogage.</span><span class="sxs-lookup"><span data-stu-id="67862-121">Initializes a new instance of the <see cref="T:System.Threading.SpinLock" /> structure with the option to track thread IDs to improve debugging.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-122">Le constructeur par défaut <xref:System.Threading.SpinLock> suit la propriété de thread.</span><span class="sxs-lookup"><span data-stu-id="67862-122">The default constructor for <xref:System.Threading.SpinLock> tracks thread ownership.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67862-123">L’exemple suivant montre comment un SpinLock peut être utilisé.</span><span class="sxs-lookup"><span data-stu-id="67862-123">The following example demonstrates how a SpinLock may be used.</span></span>  
  
```csharp  
// C#  
public class MyType  
{  
    private SpinLock _spinLock = new SpinLock();  
  
    public void DoWork()  
    {  
        bool lockTaken = false;   
        try  
        {  
           _spinLock.Enter(ref lockTaken);  
           // do work here protected by the lock  
        }  
        finally  
        {  
            if (lockTaken) _spinLock.Exit();  
        }  
    }  
}  
```  
  
```vb  
' Visual Basic  
  
Class MyType  
   Private _spinLock As New SpinLock()  
  
   Public Sub DoWork()  
      Dim lockTaken As Boolean = False  
      Try  
         _spinLock.Enter(lockTaken)  
         ' do work here protected by the lock  
      Finally  
         If lockTaken Then _spinLock.Exit()  
      End Try  
   End Sub  
End Class  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public void Enter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Enter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enter(bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken"><span data-ttu-id="67862-124">True si le verrou est acquis ; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="67862-124">True if the lock is acquired; otherwise, false.</span></span> <span data-ttu-id="67862-125"><c>lockTaken</c> doit être initialisé avec la valeur false avant l’appel à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="67862-125"><c>lockTaken</c> must be initialized to false prior to calling this method.</span></span></param>
        <summary><span data-ttu-id="67862-126">Acquiert le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</span><span class="sxs-lookup"><span data-stu-id="67862-126">Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the lock was acquired.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-127"><xref:System.Threading.SpinLock> est un verrou non réentrant, ce qui signifie que si un thread détient le verrou, il n’est pas autorisé à entrer de nouveau le verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-127"><xref:System.Threading.SpinLock> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again.</span></span> <span data-ttu-id="67862-128">Si la propriété de thread de suivi est activée (s’il est activé est disponible via <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), une exception est levée lorsqu’un thread essaie d’entrer à nouveau un verrou qu’il détient déjà.</span><span class="sxs-lookup"><span data-stu-id="67862-128">If thread ownership tracking is enabled (whether it's enabled is available through <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), an exception will be thrown when a thread tries to re-enter a lock it already holds.</span></span> <span data-ttu-id="67862-129">Toutefois, si la propriété de thread de suivi est désactivée, tente de saisir un verrou déjà détenu entraîne un blocage.</span><span class="sxs-lookup"><span data-stu-id="67862-129">However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.</span></span>  
  
 <span data-ttu-id="67862-130">Si vous appelez <xref:System.Threading.SpinLock.Exit%2A> sans avoir au préalable appelé <xref:System.Threading.SpinLock.Enter%2A> l’état interne de la <xref:System.Threading.SpinLock> peut être endommagé.</span><span class="sxs-lookup"><span data-stu-id="67862-130">If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="67862-131">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler ENTRÉE.</span><span class="sxs-lookup"><span data-stu-id="67862-131">The <paramref name="lockTaken" /> argument must be initialized to false prior to calling Enter.</span></span></exception>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="67862-132">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-132">Thread ownership tracking is enabled, and the current thread has already acquired this lock.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="67862-133">Libère le verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-133">Releases the lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="67862-134">Libère le verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-134">Releases the lock.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-135">La surcharge par défaut de <xref:System.Threading.SpinLock.Exit%2A> fournit le même comportement que si l’appel <xref:System.Threading.SpinLock.Exit%2A> à l’aide de la valeur true comme argument.</span><span class="sxs-lookup"><span data-stu-id="67862-135">The default overload of <xref:System.Threading.SpinLock.Exit%2A> provides the same behavior as if calling <xref:System.Threading.SpinLock.Exit%2A> using true as the argument.</span></span>  
  
 <span data-ttu-id="67862-136">Si vous appelez <xref:System.Threading.SpinLock.Exit%2A> sans avoir au préalable appelé <xref:System.Threading.SpinLock.Enter%2A> l’état interne de la <xref:System.Threading.SpinLock> peut être endommagé.</span><span class="sxs-lookup"><span data-stu-id="67862-136">If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="67862-137">Le suivi de la propriété du thread est autorisé, et le thread actuel n'est pas le propriétaire de ce verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-137">Thread ownership tracking is enabled, and the current thread is not the owner of this lock.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit (bool useMemoryBarrier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit(bool useMemoryBarrier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit (useMemoryBarrier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit(bool useMemoryBarrier);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useMemoryBarrier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useMemoryBarrier"><span data-ttu-id="67862-138">Valeur booléenne qui indique si une barrière mémoire doit être émise pour publier immédiatement l'opération de sortie sur d'autres threads.</span><span class="sxs-lookup"><span data-stu-id="67862-138">A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.</span></span></param>
        <summary><span data-ttu-id="67862-139">Libère le verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-139">Releases the lock.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-140">Appel de <xref:System.Threading.SpinLock.Exit%2A> avec la `useMemoryBarrier` argument défini sur true améliore l’équité du verrou au détriment des performances.</span><span class="sxs-lookup"><span data-stu-id="67862-140">Calling <xref:System.Threading.SpinLock.Exit%2A> with the `useMemoryBarrier` argument set to true will improve the fairness of the lock at the expense of some performance.</span></span> <span data-ttu-id="67862-141">La valeur par défaut <xref:System.Threading.SpinLock.Exit%2A> surcharge se comporte comme si la valeur true pour `useMemoryBarrier`.</span><span class="sxs-lookup"><span data-stu-id="67862-141">The default <xref:System.Threading.SpinLock.Exit%2A> overload behaves as if specifying true for `useMemoryBarrier`.</span></span>  
  
 <span data-ttu-id="67862-142">Si vous appelez <xref:System.Threading.SpinLock.Exit%2A> sans avoir au préalable appelé <xref:System.Threading.SpinLock.Enter%2A> l’état interne de la <xref:System.Threading.SpinLock> peut être endommagé.</span><span class="sxs-lookup"><span data-stu-id="67862-142">If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="67862-143">Le suivi de la propriété du thread est autorisé, et le thread actuel n'est pas le propriétaire de ce verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-143">Thread ownership tracking is enabled, and the current thread is not the owner of this lock.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsHeld">
      <MemberSignature Language="C#" Value="public bool IsHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67862-144">Obtient une valeur qui indique si le verrou est actuellement détenu par un thread.</span><span class="sxs-lookup"><span data-stu-id="67862-144">Gets whether the lock is currently held by any thread.</span></span></summary>
        <value><span data-ttu-id="67862-145">True si le verrou est actuellement détenu par un thread ; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="67862-145">true if the lock is currently held by any thread; otherwise false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHeldByCurrentThread">
      <MemberSignature Language="C#" Value="public bool IsHeldByCurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeldByCurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeldByCurrentThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeldByCurrentThread { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67862-146">Obtient une valeur qui indique si le verrou est détenu par le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="67862-146">Gets whether the lock is held by the current thread.</span></span></summary>
        <value><span data-ttu-id="67862-147">True si le verrou est détenu par le thread actuel ; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="67862-147">true if the lock is held by the current thread; otherwise false.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-148">Si le verrou a été initialisé pour effectuer le suivi des threads propriétaires, sera retourné si le verrou est acquis par le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="67862-148">If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread.</span></span> <span data-ttu-id="67862-149">Il n’est pas valide pour utiliser cette propriété lorsque le verrou a été initialisé pour ne pas effectuer le suivi de la propriété de thread.</span><span class="sxs-lookup"><span data-stu-id="67862-149">It is invalid to use this property when the lock was initialized to not track thread ownership.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="67862-150">Le suivi de la propriété du thread est désactivé.</span><span class="sxs-lookup"><span data-stu-id="67862-150">Thread ownership tracking is disabled.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadOwnerTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool IsThreadOwnerTrackingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadOwnerTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadOwnerTrackingEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67862-151">Obtient une valeur qui indique si le suivi de la propriété des threads est activé pour cette instance.</span><span class="sxs-lookup"><span data-stu-id="67862-151">Gets whether thread ownership tracking is enabled for this instance.</span></span></summary>
        <value><span data-ttu-id="67862-152">True si le suivi de la propriété du thread est autorisé pour cette instance ; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="67862-152">true if thread ownership tracking is enabled for this instance; otherwise false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="67862-153">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</span><span class="sxs-lookup"><span data-stu-id="67862-153">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the lock was acquired.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken"><span data-ttu-id="67862-154">True si le verrou est acquis ; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="67862-154">True if the lock is acquired; otherwise, false.</span></span> <span data-ttu-id="67862-155"><c>lockTaken</c> doit être initialisé avec la valeur false avant l’appel à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="67862-155"><c>lockTaken</c> must be initialized to false prior to calling this method.</span></span></param>
        <summary><span data-ttu-id="67862-156">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</span><span class="sxs-lookup"><span data-stu-id="67862-156">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the lock was acquired.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-157">Contrairement aux <xref:System.Threading.SpinLock.Enter%2A>, TryEnter ne bloquera pas attendre le verrou soit disponible.</span><span class="sxs-lookup"><span data-stu-id="67862-157">Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block waiting for the lock to be available.</span></span> <span data-ttu-id="67862-158">Si le verrou n’est pas disponible lorsque TryEnter est appelée, elle retournera immédiatement sans aucune autre rotation.</span><span class="sxs-lookup"><span data-stu-id="67862-158">If the lock is not available when TryEnter is called, it will return immediately without any further spinning.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="67862-159">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</span><span class="sxs-lookup"><span data-stu-id="67862-159">The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.</span></span></exception>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="67862-160">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-160">Thread ownership tracking is enabled, and the current thread has already acquired this lock.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(int millisecondsTimeout, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="67862-161">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="67862-161">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="67862-162">True si le verrou est acquis ; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="67862-162">True if the lock is acquired; otherwise, false.</span></span> <span data-ttu-id="67862-163"><c>lockTaken</c> doit être initialisé avec la valeur false avant l’appel à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="67862-163"><c>lockTaken</c> must be initialized to false prior to calling this method.</span></span></param>
        <summary><span data-ttu-id="67862-164">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</span><span class="sxs-lookup"><span data-stu-id="67862-164">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the lock was acquired.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-165">Contrairement aux <xref:System.Threading.SpinLock.Enter%2A>, TryEnter ne bloquera pas attendre indéfiniment que le verrou soit disponible.</span><span class="sxs-lookup"><span data-stu-id="67862-165">Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available.</span></span> <span data-ttu-id="67862-166">Il se bloque jusqu'à ce que le verrou soit disponible ou jusqu'à ce que le `millisecondsTimeout` a expiré.</span><span class="sxs-lookup"><span data-stu-id="67862-166">It will block until either the lock is available or until the `millisecondsTimeout` has expired.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="67862-167"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="67862-167"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="67862-168">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</span><span class="sxs-lookup"><span data-stu-id="67862-168">The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.</span></span></exception>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="67862-169">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-169">Thread ownership tracking is enabled, and the current thread has already acquired this lock.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(TimeSpan timeout, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="67862-170">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="67862-170">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="67862-171">True si le verrou est acquis ; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="67862-171">True if the lock is acquired; otherwise, false.</span></span> <span data-ttu-id="67862-172"><c>lockTaken</c> doit être initialisé avec la valeur false avant l’appel à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="67862-172"><c>lockTaken</c> must be initialized to false prior to calling this method.</span></span></param>
        <summary><span data-ttu-id="67862-173">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</span><span class="sxs-lookup"><span data-stu-id="67862-173">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the lock was acquired.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67862-174">Contrairement aux <xref:System.Threading.SpinLock.Enter%2A>, TryEnter ne bloquera pas attendre indéfiniment que le verrou soit disponible.</span><span class="sxs-lookup"><span data-stu-id="67862-174">Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available.</span></span> <span data-ttu-id="67862-175">Il se bloque jusqu'à ce que le verrou soit disponible ou jusqu'à ce que le `timeout` a expiré.</span><span class="sxs-lookup"><span data-stu-id="67862-175">It will block until either the lock is available or until the `timeout` has expired.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="67862-176"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" /> millisecondes.</span><span class="sxs-lookup"><span data-stu-id="67862-176"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="67862-177">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</span><span class="sxs-lookup"><span data-stu-id="67862-177">The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.</span></span></exception>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="67862-178">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</span><span class="sxs-lookup"><span data-stu-id="67862-178">Thread ownership tracking is enabled, and the current thread has already acquired this lock.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>