<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="SpinLock.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52e23183129f62f63c4589bc805d4ebc7b8b87041.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2e23183129f62f63c4589bc805d4ebc7b8b87041</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.SpinLock">
          <source>Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.</source>
          <target state="translated">Fournit une primitive de verrou d'exclusion mutuelle où un thread, qui tente d'acquérir le verrou, attend dans une boucle en effectuant des vérifications de manière répétée jusqu'à ce que le verrou devienne disponible.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>For an example of how to use a Spin Lock, see <bpt id="p1">[</bpt>How to: Use SpinLock for Low-Level Synchronization<ept id="p1">](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)</ept>.</source>
          <target state="translated">Pour obtenir un exemple d’utilisation d’un verrou de rotation, consultez <bpt id="p1">[</bpt>Comment : utiliser le verrouillage SpinLock pour une synchronisation de bas niveau<ept id="p1">](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)</ept>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>Spin locks can be used for leaf-level locks where the object allocation implied by using a <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph>, in size or due to garbage collection pressure, is overly expensive.</source>
          <target state="translated">Verrous de rotation peuvent servir pour les verrous de niveau feuille où l’allocation d’objet implicite à l’aide un <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph>, taille, ou en raison d’une pression du garbage collection, est trop coûteuse.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning.</source>
          <target state="translated">Un verrou de rotation peut être utile pour éviter les blocages ; Toutefois, si vous prévoyez une quantité importante de blocage, vous devez utiliser probablement pas les verrous de rotation en raison d’une rotation excessive.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short.</source>
          <target state="translated">Bouclage peut être bénéfique lorsque les verrous sont et affinés nombre (par exemple, un verrou par nœud dans une liste liée) et également lorsque les durées de blocage du verrou sont toujours très courtes.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>In general, while holding a spin lock, one should avoid any of these actions:</source>
          <target state="translated">En règle générale, tout en maintenant un verrou de rotation, un doit éviter une de ces actions :</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>blocking,</source>
          <target state="translated">blocage,</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>calling anything that itself may block,</source>
          <target state="translated">appel de tout élément pouvant lui-même se bloquer,</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>holding more than one spin lock at once,</source>
          <target state="translated">contenant plus d’un verrou de rotation à la fois,</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>making dynamically dispatched calls (interface and virtuals),</source>
          <target state="translated">passer dynamiquement des appels (interface et virtuels), distribués</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>making statically dispatched calls into any code one doesn't own, or</source>
          <target state="translated">passer de manière statique des appels dans du code non possédé, distribués ou</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>allocating memory.</source>
          <target state="translated">allocation de mémoire.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source><ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> should only be used after you have been determined that doing so will improve an application's performance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> doit être utilisé uniquement une fois que vous avez déterminé que cela améliorera les performances d’une application.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>It is also important to note that <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> is a value type, for performance reasons.</source>
          <target state="translated">Il est également important de noter que <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> est un type valeur, pour des raisons de performances.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>For this reason, you must be very careful not to accidentally copy a <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application.</source>
          <target state="translated">Pour cette raison, vous devez être très attention à ne pas copier par erreur un <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> de l’instance, comme les deux instances (d’origine et la copie) seraient alors complètement indépendants, ce qui pourrait engendrer un comportement incorrect de l’application.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> instance must be passed around, it should be passed by reference rather than by value.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> instance doit être passée, il doit être passé par référence plutôt que par valeur.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>Do not store <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> instances in readonly fields.</source>
          <target state="translated">Ne stockez pas <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> instances dans les champs en lecture seule.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>The following example shows how to use a <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>:</source>
          <target state="translated">L’exemple suivant montre comment utiliser un <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>All members of <ph id="ph1">&lt;see cref="T:System.Threading.SpinLock" /&gt;</ph> are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">Tous les membres de <ph id="ph1">&lt;see cref="T:System.Threading.SpinLock" /&gt;</ph> sont thread-safe et peuvent être utilisés à partir de plusieurs threads simultanément.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.#ctor(System.Boolean)">
          <source>Whether to capture and use thread IDs for debugging purposes.</source>
          <target state="translated">Indique s'il faut capturer et utiliser des ID de thread à des fins de débogage.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.SpinLock" /&gt;</ph> structure with the option to track thread IDs to improve debugging.</source>
          <target state="translated">Initialise une nouvelle instance de la structure de <ph id="ph1">&lt;see cref="T:System.Threading.SpinLock" /&gt;</ph> avec l'option permettant de suivre les ID de thread afin d'améliorer le débogage.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.#ctor(System.Boolean)">
          <source>The default constructor for <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> tracks thread ownership.</source>
          <target state="translated">Le constructeur par défaut <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> suit la propriété de thread.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.#ctor(System.Boolean)">
          <source>The following example demonstrates how a SpinLock may be used.</source>
          <target state="translated">L’exemple suivant montre comment un SpinLock peut être utilisé.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>True if the lock is acquired; otherwise, false.</source>
          <target state="translated">True si le verrou est acquis ; sinon, false.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> must be initialized to false prior to calling this method.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> doit être initialisé avec la valeur false avant l’appel à cette méthode.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">Acquiert le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source><ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> est un verrou non réentrant, ce qui signifie que si un thread détient le verrou, il n’est pas autorisé à entrer de nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>If thread ownership tracking is enabled (whether it's enabled is available through <ph id="ph1">&lt;xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A&gt;</ph>), an exception will be thrown when a thread tries to re-enter a lock it already holds.</source>
          <target state="translated">Si la propriété de thread de suivi est activée (s’il est activé est disponible via <ph id="ph1">&lt;xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A&gt;</ph>), une exception est levée lorsqu’un thread essaie d’entrer à nouveau un verrou qu’il détient déjà.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.</source>
          <target state="translated">Toutefois, si la propriété de thread de suivi est désactivée, tente de saisir un verrou déjà détenu entraîne un blocage.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>If you call <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.</source>
          <target state="translated">Si vous appelez <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> sans avoir au préalable appelé <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> l’état interne de la <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> peut être endommagé.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> argument must be initialized to false prior to calling Enter.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> doit être initialisé sur false avant d'appeler ENTRÉE.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</source>
          <target state="translated">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.Threading.SpinLock">
          <source>Releases the lock.</source>
          <target state="translated">Libère le verrou.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit">
          <source>Releases the lock.</source>
          <target state="translated">Libère le verrou.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit">
          <source>The default overload of <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> provides the same behavior as if calling <ph id="ph2">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> using true as the argument.</source>
          <target state="translated">La surcharge par défaut de <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> fournit le même comportement que si l’appel <ph id="ph2">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> à l’aide de la valeur true comme argument.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit">
          <source>If you call <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.</source>
          <target state="translated">Si vous appelez <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> sans avoir au préalable appelé <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> l’état interne de la <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> peut être endommagé.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit">
          <source>Thread ownership tracking is enabled, and the current thread is not the owner of this lock.</source>
          <target state="translated">Le suivi de la propriété du thread est autorisé, et le thread actuel n'est pas le propriétaire de ce verrou.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.</source>
          <target state="translated">Valeur booléenne qui indique si une barrière mémoire doit être émise pour publier immédiatement l'opération de sortie sur d'autres threads.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>Releases the lock.</source>
          <target state="translated">Libère le verrou.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> with the <ph id="ph2">`useMemoryBarrier`</ph> argument set to true will improve the fairness of the lock at the expense of some performance.</source>
          <target state="translated">Appel de <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> avec la <ph id="ph2">`useMemoryBarrier`</ph> argument défini sur true améliore l’équité du verrou au détriment des performances.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>The default <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> overload behaves as if specifying true for <ph id="ph2">`useMemoryBarrier`</ph>.</source>
          <target state="translated">La valeur par défaut <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> surcharge se comporte comme si la valeur true pour <ph id="ph2">`useMemoryBarrier`</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>If you call <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.</source>
          <target state="translated">Si vous appelez <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> sans avoir au préalable appelé <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> l’état interne de la <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> peut être endommagé.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>Thread ownership tracking is enabled, and the current thread is not the owner of this lock.</source>
          <target state="translated">Le suivi de la propriété du thread est autorisé, et le thread actuel n'est pas le propriétaire de ce verrou.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="P:System.Threading.SpinLock.IsHeld">
          <source>Gets whether the lock is currently held by any thread.</source>
          <target state="translated">Obtient une valeur qui indique si le verrou est actuellement détenu par un thread.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsHeld">
          <source>true if the lock is currently held by any thread; otherwise false.</source>
          <target state="translated">True si le verrou est actuellement détenu par un thread ; sinon, false.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>Gets whether the lock is held by the current thread.</source>
          <target state="translated">Obtient une valeur qui indique si le verrou est détenu par le thread actuel.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>true if the lock is held by the current thread; otherwise false.</source>
          <target state="translated">True si le verrou est détenu par le thread actuel ; sinon, false.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread.</source>
          <target state="translated">Si le verrou a été initialisé pour effectuer le suivi des threads propriétaires, sera retourné si le verrou est acquis par le thread actuel.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>It is invalid to use this property when the lock was initialized to not track thread ownership.</source>
          <target state="translated">Il n’est pas valide pour utiliser cette propriété lorsque le verrou a été initialisé pour ne pas effectuer le suivi de la propriété de thread.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>Thread ownership tracking is disabled.</source>
          <target state="translated">Le suivi de la propriété du thread est désactivé.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
          <source>Gets whether thread ownership tracking is enabled for this instance.</source>
          <target state="translated">Obtient une valeur qui indique si le suivi de la propriété des threads est activé pour cette instance.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
          <source>true if thread ownership tracking is enabled for this instance; otherwise false.</source>
          <target state="translated">True si le suivi de la propriété du thread est autorisé pour cette instance ; sinon, false.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="T:System.Threading.SpinLock">
          <source>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>True if the lock is acquired; otherwise, false.</source>
          <target state="translated">True si le verrou est acquis ; sinon, false.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> must be initialized to false prior to calling this method.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> doit être initialisé avec la valeur false avant l’appel à cette méthode.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block waiting for the lock to be available.</source>
          <target state="translated">Contrairement aux <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter ne bloquera pas attendre le verrou soit disponible.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>If the lock is not available when TryEnter is called, it will return immediately without any further spinning.</source>
          <target state="translated">Si le verrou n’est pas disponible lorsque TryEnter est appelée, elle retournera immédiatement sans aucune autre rotation.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> argument must be initialized to false prior to calling TryEnter.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> doit être initialisé sur false avant d'appeler TryEnter.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</source>
          <target state="translated">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>True if the lock is acquired; otherwise, false.</source>
          <target state="translated">True si le verrou est acquis ; sinon, false.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> must be initialized to false prior to calling this method.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> doit être initialisé avec la valeur false avant l’appel à cette méthode.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block indefinitely waiting for the lock to be available.</source>
          <target state="translated">Contrairement aux <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter ne bloquera pas attendre indéfiniment que le verrou soit disponible.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>It will block until either the lock is available or until the <ph id="ph1">`millisecondsTimeout`</ph> has expired.</source>
          <target state="translated">Il se bloque jusqu'à ce que le verrou soit disponible ou jusqu'à ce que le <ph id="ph1">`millisecondsTimeout`</ph> a expiré.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> argument must be initialized to false prior to calling TryEnter.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> doit être initialisé sur false avant d'appeler TryEnter.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</source>
          <target state="translated">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millièmes de secondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 millième de seconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>True if the lock is acquired; otherwise, false.</source>
          <target state="translated">True si le verrou est acquis ; sinon, false.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> must be initialized to false prior to calling this method.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> doit être initialisé avec la valeur false avant l’appel à cette méthode.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block indefinitely waiting for the lock to be available.</source>
          <target state="translated">Contrairement aux <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter ne bloquera pas attendre indéfiniment que le verrou soit disponible.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>It will block until either the lock is available or until the <ph id="ph1">`timeout`</ph> has expired.</source>
          <target state="translated">Il se bloque jusqu'à ce que le verrou soit disponible ou jusqu'à ce que le <ph id="ph1">`timeout`</ph> a expiré.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini - ou - le délai d'attente est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> millisecondes.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> argument must be initialized to false prior to calling TryEnter.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> doit être initialisé sur false avant d'appeler TryEnter.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</source>
          <target state="translated">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>