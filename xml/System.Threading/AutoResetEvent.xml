<Type Name="AutoResetEvent" FullName="System.Threading.AutoResetEvent">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a70cc7b3c6903a5500072e799554598f083322e5" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52732899" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AutoResetEvent : System.Threading.EventWaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AutoResetEvent extends System.Threading.EventWaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.AutoResetEvent" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AutoResetEvent&#xA;Inherits EventWaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class AutoResetEvent sealed : System::Threading::EventWaitHandle" />
  <TypeSignature Language="F#" Value="type AutoResetEvent = class&#xA;    inherit EventWaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.EventWaitHandle</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f64e9-101">Avertit un thread en attente qu'un événement s'est produit.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f64e9-101">Notifies a waiting thread that an event has occurred.</span>
      </span>
      <span data-ttu-id="f64e9-102">Cette classe ne peut pas être héritée.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f64e9-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f64e9-103">`AutoResetEvent` permet aux threads de communiquer entre eux par la signalisation.</span><span class="sxs-lookup"><span data-stu-id="f64e9-103">`AutoResetEvent` allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="f64e9-104">En règle générale, vous utilisez cette classe lorsque les threads ont besoin d’un accès exclusif à une ressource.</span><span class="sxs-lookup"><span data-stu-id="f64e9-104">Typically, you use this class when threads need exclusive access to a resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f64e9-105">Ce type implémente le <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="f64e9-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f64e9-106">Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement.</span><span class="sxs-lookup"><span data-stu-id="f64e9-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f64e9-107">Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc.</span><span class="sxs-lookup"><span data-stu-id="f64e9-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f64e9-108">Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="f64e9-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f64e9-109">Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.</span><span class="sxs-lookup"><span data-stu-id="f64e9-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f64e9-110">Un thread attend un signal en appelant <xref:System.Threading.WaitHandle.WaitOne%2A> sur le `AutoResetEvent`.</span><span class="sxs-lookup"><span data-stu-id="f64e9-110">A thread waits for a signal by calling <xref:System.Threading.WaitHandle.WaitOne%2A> on the `AutoResetEvent`.</span></span> <span data-ttu-id="f64e9-111">Si le `AutoResetEvent` est dans l’état non signalé, le thread se bloque et attend que le thread de contrôle qui est actuellement la ressource pour signaler que la ressource est disponible en appelant <xref:System.Threading.EventWaitHandle.Set%2A>.</span><span class="sxs-lookup"><span data-stu-id="f64e9-111">If the `AutoResetEvent` is in the non-signaled state, the thread blocks, waiting for the thread that currently controls the resource to signal that the resource is available by calling <xref:System.Threading.EventWaitHandle.Set%2A>.</span></span>  
  
 <span data-ttu-id="f64e9-112">Appel `Set` signaux `AutoResetEvent` pour libérer un thread en attente.</span><span class="sxs-lookup"><span data-stu-id="f64e9-112">Calling `Set` signals `AutoResetEvent` to release a waiting thread.</span></span> <span data-ttu-id="f64e9-113">`AutoResetEvent` reste signalé jusqu'à ce qu’un seul thread en attente est libéré et retourne automatiquement à l’état non signalé.</span><span class="sxs-lookup"><span data-stu-id="f64e9-113">`AutoResetEvent` remains signaled until a single waiting thread is released, and then automatically returns to the non-signaled state.</span></span> <span data-ttu-id="f64e9-114">Si aucun thread n’attend, l’état reste signalé indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="f64e9-114">If no threads are waiting, the state remains signaled indefinitely.</span></span>  
  
 <span data-ttu-id="f64e9-115">Si un thread appelle <xref:System.Threading.WaitHandle.WaitOne%2A> tandis que le <xref:System.Threading.AutoResetEvent> est dans l’état signalé, le thread ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="f64e9-115">If a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A> while the <xref:System.Threading.AutoResetEvent> is in the signaled state, the thread does not block.</span></span> <span data-ttu-id="f64e9-116">Le <xref:System.Threading.AutoResetEvent> libère immédiatement le thread et retourne à l’état non signalé.</span><span class="sxs-lookup"><span data-stu-id="f64e9-116">The <xref:System.Threading.AutoResetEvent> releases the thread immediately and returns to the non-signaled state.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f64e9-117">Il n’existe aucune garantie que chaque appel à la <xref:System.Threading.EventWaitHandle.Set%2A> libère un thread.</span><span class="sxs-lookup"><span data-stu-id="f64e9-117">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread.</span></span> <span data-ttu-id="f64e9-118">Si deux appels sont trop proches, afin que le deuxième appel se produit avant la libération d’un thread, un seul thread est libéré.</span><span class="sxs-lookup"><span data-stu-id="f64e9-118">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="f64e9-119">Il s’agit comme si le deuxième appel n’a pas eu lieu.</span><span class="sxs-lookup"><span data-stu-id="f64e9-119">It is as if the second call did not happen.</span></span> <span data-ttu-id="f64e9-120">En outre, si <xref:System.Threading.EventWaitHandle.Set%2A> est appelée lorsqu’il n’y a aucun thread n’attend que <xref:System.Threading.AutoResetEvent> est déjà signalé, l’appel n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="f64e9-120">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.AutoResetEvent> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="f64e9-121">Vous pouvez contrôler l’état initial d’un `AutoResetEvent` en transmettant une valeur booléenne au constructeur : `true` si l’état initial est signalé et `false` dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="f64e9-121">You can control the initial state of an `AutoResetEvent` by passing a Boolean value to the constructor: `true` if the initial state is signaled and `false` otherwise.</span></span>  
  
 <span data-ttu-id="f64e9-122">`AutoResetEvent` peut également être utilisé avec le `static` <xref:System.Threading.WaitHandle.WaitAll%2A> et <xref:System.Threading.WaitHandle.WaitAny%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="f64e9-122">`AutoResetEvent` can also be used with the `static`<xref:System.Threading.WaitHandle.WaitAll%2A> and <xref:System.Threading.WaitHandle.WaitAny%2A> methods.</span></span>  
  
 <span data-ttu-id="f64e9-123">Pour plus d’informations sur les mécanismes de synchronisation de threads, consultez [AutoResetEvent](~/docs/standard/threading/autoresetevent.md) dans la documentation conceptuelle.</span><span class="sxs-lookup"><span data-stu-id="f64e9-123">For more information about thread synchronization mechanisms, see [AutoResetEvent](~/docs/standard/threading/autoresetevent.md) in the conceptual documentation.</span></span>  
  
 <span data-ttu-id="f64e9-124">À partir de .NET Framework version 2.0, <xref:System.Threading.AutoResetEvent> dérive la nouvelle <xref:System.Threading.EventWaitHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="f64e9-124">Beginning with the .NET Framework version 2.0, <xref:System.Threading.AutoResetEvent> derives from the new <xref:System.Threading.EventWaitHandle> class.</span></span> <span data-ttu-id="f64e9-125">Un <xref:System.Threading.AutoResetEvent> est fonctionnellement équivalent à un <xref:System.Threading.EventWaitHandle> créé avec <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f64e9-125">An <xref:System.Threading.AutoResetEvent> is functionally equivalent to an <xref:System.Threading.EventWaitHandle> created with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f64e9-126">Contrairement à la <xref:System.Threading.AutoResetEvent> (classe), la <xref:System.Threading.EventWaitHandle> classe fournit l’accès aux événements de synchronisation système nommé.</span><span class="sxs-lookup"><span data-stu-id="f64e9-126">Unlike the <xref:System.Threading.AutoResetEvent> class, the <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f64e9-127">L’exemple suivant montre comment utiliser <xref:System.Threading.AutoResetEvent> pour libérer un thread à la fois, en appelant le <xref:System.Threading.EventWaitHandle.Set%2A> (méthode) (sur la classe de base) chaque fois que l’utilisateur appuie sur le **entrée** clé.</span><span class="sxs-lookup"><span data-stu-id="f64e9-127">The following example shows how to use <xref:System.Threading.AutoResetEvent> to release one thread at a time, by calling the <xref:System.Threading.EventWaitHandle.Set%2A> method (on the base class) each time the user presses the **Enter** key.</span></span> <span data-ttu-id="f64e9-128">L’exemple démarre trois threads qui attendent un <xref:System.Threading.AutoResetEvent> qui a été créé dans l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="f64e9-128">The example starts three threads, which wait on an <xref:System.Threading.AutoResetEvent> that was created in the signaled state.</span></span> <span data-ttu-id="f64e9-129">Le premier thread est libéré immédiatement, car le <xref:System.Threading.AutoResetEvent> est déjà dans l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="f64e9-129">The first thread is released immediately, because the <xref:System.Threading.AutoResetEvent> is already in the signaled state.</span></span> <span data-ttu-id="f64e9-130">Cette opération réinitialise la <xref:System.Threading.AutoResetEvent> à l’état non signalé, pouvoir bloquer les threads suivants.</span><span class="sxs-lookup"><span data-stu-id="f64e9-130">This resets the <xref:System.Threading.AutoResetEvent> to the non-signaled state, so that subsequent threads block.</span></span> <span data-ttu-id="f64e9-131">Les threads bloqués ne sont pas libérées jusqu'à ce que l’utilisateur relâche les une à la fois en appuyant sur la **entrée** clé.</span><span class="sxs-lookup"><span data-stu-id="f64e9-131">The blocked threads are not released until the user releases them one at a time by pressing the **Enter** key.</span></span>  
  
 <span data-ttu-id="f64e9-132">Une fois que les threads sont libérés à partir de la première <xref:System.Threading.AutoResetEvent>, ils sont en attente sur un autre <xref:System.Threading.AutoResetEvent> qui a été créé dans un état non signalé.</span><span class="sxs-lookup"><span data-stu-id="f64e9-132">After the threads are released from the first <xref:System.Threading.AutoResetEvent>, they wait on another <xref:System.Threading.AutoResetEvent> that was created in the non-signaled state.</span></span> <span data-ttu-id="f64e9-133">Tous les trois blocs de threads, donc la <xref:System.Threading.EventWaitHandle.Set%2A> méthode doit être appelée trois fois pour libérer toutes les.</span><span class="sxs-lookup"><span data-stu-id="f64e9-133">All three threads block, so the <xref:System.Threading.EventWaitHandle.Set%2A> method must be called three times to release them all.</span></span>  
  
 [!code-cpp[System.Threading.AutoResetEvent#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CPP/simplerisbetter.cpp#3)]
 [!code-csharp[System.Threading.AutoResetEvent#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CS/simplerisbetter.cs#3)]
 [!code-vb[System.Threading.AutoResetEvent#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/VB/simplerisbetter.vb#3)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="f64e9-134">Cette classe est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f64e9-134">This class is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="f64e9-135">Threading managé</span>
      <span class="sxs-lookup">
        <span data-stu-id="f64e9-135">Managed Threading</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AutoResetEvent (bool initialState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AutoResetEvent(bool initialState);" />
      <MemberSignature Language="F#" Value="new System.Threading.AutoResetEvent : bool -&gt; System.Threading.AutoResetEvent" Usage="new System.Threading.AutoResetEvent initialState" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="f64e9-136">
            <see langword="true" /> Pour définir l’état initial comme étant signalé ; <see langword="false" /> pour définir l’état initial non signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f64e9-136">
              <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set the initial state to non-signaled.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f64e9-137">Initialise une nouvelle instance de la <see cref="T:System.Threading.AutoResetEvent" /> classe avec une valeur booléenne indiquant si l’état initial "signalé".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f64e9-137">Initializes a new instance of the <see cref="T:System.Threading.AutoResetEvent" /> class with a Boolean value indicating whether to set the initial state to signaled.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f64e9-138">L’exemple suivant utilise un <xref:System.Threading.AutoResetEvent> pour synchroniser les activités de deux threads.</span><span class="sxs-lookup"><span data-stu-id="f64e9-138">The following example uses an <xref:System.Threading.AutoResetEvent> to synchronize the activities of two threads.</span></span> <span data-ttu-id="f64e9-139">Le premier thread, qui est le thread d’application, exécute `Main`.</span><span class="sxs-lookup"><span data-stu-id="f64e9-139">The first thread, which is the application thread, executes `Main`.</span></span> <span data-ttu-id="f64e9-140">Il écrit des valeurs à la ressource protégée, qui est un `static` (`Shared` en Visual Basic) champ nommé `number`.</span><span class="sxs-lookup"><span data-stu-id="f64e9-140">It writes values to the protected resource, which is a `static` (`Shared` in Visual Basic) field named `number`.</span></span> <span data-ttu-id="f64e9-141">Le deuxième thread exécute la méthode statique `ThreadProc` (méthode), qui lit les valeurs écrites par `Main`.</span><span class="sxs-lookup"><span data-stu-id="f64e9-141">The second thread executes the static `ThreadProc` method, which reads the values written by `Main`.</span></span>  
  
 <span data-ttu-id="f64e9-142">Le `ThreadProc` méthode attend le <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="f64e9-142">The `ThreadProc` method waits for the <xref:System.Threading.AutoResetEvent>.</span></span> <span data-ttu-id="f64e9-143">Lorsque `Main` appelle le <xref:System.Threading.EventWaitHandle.Set%2A> méthode sur le <xref:System.Threading.AutoResetEvent>, le `ThreadProc` méthode lit une valeur.</span><span class="sxs-lookup"><span data-stu-id="f64e9-143">When `Main` calls the <xref:System.Threading.EventWaitHandle.Set%2A> method on the <xref:System.Threading.AutoResetEvent>, the `ThreadProc` method reads one value.</span></span> <span data-ttu-id="f64e9-144">Le <xref:System.Threading.AutoResetEvent> immédiatement réinitialisé, donc la `ThreadProc` méthode à attendre.</span><span class="sxs-lookup"><span data-stu-id="f64e9-144">The <xref:System.Threading.AutoResetEvent> immediately resets, so the `ThreadProc` method waits again.</span></span>  
  
 <span data-ttu-id="f64e9-145">La logique de programme garantit que le `ThreadProc` méthode lira jamais la même valeur deux fois.</span><span class="sxs-lookup"><span data-stu-id="f64e9-145">The program logic guarantees that the `ThreadProc` method will never read the same value two times.</span></span> <span data-ttu-id="f64e9-146">Il ne garantit pas que le `ThreadProc` méthode lira chaque valeur écrite par `Main`.</span><span class="sxs-lookup"><span data-stu-id="f64e9-146">It does not guarantee that the `ThreadProc` method will read every value written by `Main`.</span></span> <span data-ttu-id="f64e9-147">Cette garantie nécessiterait un deuxième <xref:System.Threading.AutoResetEvent> verrou.</span><span class="sxs-lookup"><span data-stu-id="f64e9-147">That guarantee would require a second <xref:System.Threading.AutoResetEvent> lock.</span></span>  
  
 <span data-ttu-id="f64e9-148">Après chaque opération d’écriture, `Main` génère en appelant le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> (méthode), pour donner au deuxième thread une chance de s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="f64e9-148">After each write operation, `Main` yields by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, to give the second thread a chance to execute.</span></span> <span data-ttu-id="f64e9-149">Sinon, sur un ordinateur monoprocesseur `Main` écrirait de nombreuses valeurs entre les deux opérations de lecture.</span><span class="sxs-lookup"><span data-stu-id="f64e9-149">Otherwise, on a single-processor computer `Main` would write many values between any two read operations.</span></span>  
  
 [!code-cpp[System.Threading.AutoResetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.AutoResetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CS/class1.cs#1)]
 [!code-vb[System.Threading.AutoResetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f64e9-150">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f64e9-150">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AutoResetEvent.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="autoResetEvent.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f64e9-151">Définit l'état de l'événement à "non signalé", ce qui entraîne le blocage des threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f64e9-151">Sets the state of the event to nonsignaled, which causes threads to block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f64e9-152">
            <see langword="true" /> si l’opération aboutit ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f64e9-152">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AutoResetEvent.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="autoResetEvent.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f64e9-153">Définit l'état de l'événement à "signalé", ce qui permet à un seul thread en attente de continuer à s'exécuter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f64e9-153">Sets the state of the event to signaled, which allows at most one waiting thread to proceed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f64e9-154">
            <see langword="true" /> si l’opération aboutit ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f64e9-154">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="f64e9-155">La méthode Set libère un thread unique.</span><span class="sxs-lookup"><span data-stu-id="f64e9-155">The Set method releases a single thread.</span></span> <span data-ttu-id="f64e9-156">S’il n’y a pas de threads en attente, le handle d’attente reste signalé jusqu'à ce qu’un thread tente d’attendre, ou jusqu'à ce que sa méthode de réinitialisation est appelée.</span><span class="sxs-lookup"><span data-stu-id="f64e9-156">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its Reset method is called.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f64e9-157">Il n’existe aucune garantie que chaque appel à la méthode Set libère un thread.</span><span class="sxs-lookup"><span data-stu-id="f64e9-157">There is no guarantee that every call to the Set method will release a thread.</span></span> <span data-ttu-id="f64e9-158">Si deux appels sont trop proches, afin que le deuxième appel se produit avant la libération d’un thread, un seul thread est libéré, comme si le deuxième appel n’a pas eu lieu.</span><span class="sxs-lookup"><span data-stu-id="f64e9-158">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released — as if the second call did not happen.</span></span> <span data-ttu-id="f64e9-159">En outre, si la méthode Set est appelée lorsqu’il n’y a aucun thread n’attend que <xref:System.Threading.AutoResetEvent> est déjà signalé, l’appel n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="f64e9-159">Also, if the Set method is called when there are no threads waiting and the <xref:System.Threading.AutoResetEvent> is already signaled, the call has no effect.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>