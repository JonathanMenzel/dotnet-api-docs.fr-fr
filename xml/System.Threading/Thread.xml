<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Thread.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac570043b3fb7b7bab63012cb47f77848879069524a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">70043b3fb7b7bab63012cb47f77848879069524a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">Crée et contrôle un thread, définit sa priorité et obtient son état.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">Lorsqu’un processus démarre, le common language runtime crée automatiquement un thread de premier plan pour exécuter le code de l’application.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">En même temps que ce thread de premier plan principal, un processus peut créer un ou plusieurs threads pour exécuter une partie du code de programme associé au processus.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">Ces threads peuvent s’exécuter en premier plan ou en arrière-plan.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">En outre, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> classe pour exécuter du code sur les threads de travail qui sont gérés par le common language runtime.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In this section</source>
          <target state="translated">Dans cette section</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Démarrage d’un thread<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Retrieving Thread objects<ept id="p1">](#Retrieving)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>La récupération d’objets de Thread<ept id="p1">](#Retrieving)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Threads de premier plan et d’arrière-plan<ept id="p1">](#Foreground)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Culture and threads<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Culture et des threads<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Getting information about and controlling threads<ept id="p1">](#Properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Obtenir des informations sur et contrôler les threads<ept id="p1">](#Properties)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Starting a thread</source>
          <target state="translated">Démarrage d’un thread</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">Vous démarrez un thread en fournissant un délégué qui représente la méthode que le thread doit s’exécuter dans son constructeur de classe.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You then call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method to begin execution.</source>
          <target state="translated">Vous appelez ensuite la <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> méthode commence l’exécution.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructeurs peuvent prendre une des types délégués de deux, et selon que vous pouvez passer un argument à la méthode à exécuter :</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>If the method has no arguments, you pass a <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> delegate to  the constructor.</source>
          <target state="translated">Si la méthode a aucun argument, vous passez un <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> déléguer au constructeur.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It has the signature:</source>
          <target state="translated">Il a la signature :</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example creates and starts a thread that executes the <ph id="ph1">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">L’exemple suivant crée et démarre un thread qui exécute le <ph id="ph1">`ExecuteInForeground`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">La méthode affiche des informations sur certaines propriétés de thread, puis exécute une boucle dans laquelle elle s’interrompt pendant une demi-seconde et affiche le nombre de secondes écoulé.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">Lorsque le thread a exécuté pour au moins cinq secondes, la fin de la boucle et le thread termine l’exécution.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>If the method has an argument, you pass a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate to the constructor.</source>
          <target state="translated">Si la méthode possède un argument, vous passez un <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> déléguer au constructeur.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It has the signature:</source>
          <target state="translated">Il a la signature :</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">La méthode exécutée par le délégué peut ensuite effectuer un cast (en c#) ou convertir (en Visual Basic) le paramètre vers le type approprié.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example is identical to the previous one, except that it calls the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor.</source>
          <target state="translated">L’exemple suivant est identique au précédent, à ceci près qu’elle appelle la <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">Cette version de la <ph id="ph1">`ExecuteInForeground`</ph> méthode possède un paramètre unique qui représente le nombre approximatif de millisecondes de la boucle doit s’exécuter.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It is not necessary to retain a reference to a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> object once you have started the thread.</source>
          <target state="translated">Il n’est pas nécessaire de conserver une référence à un <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> une fois que vous avez démarré le thread de l’objet.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">Le thread continue à s’exécuter jusqu'à la fin de la procédure de thread.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Retrieving Thread objects</source>
          <target state="translated">La récupération d’objets de Thread</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated">Vous pouvez utiliser la méthode statique (<ph id="ph1">`Shared`</ph> en Visual Basic) <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> propriété à récupérer une référence au thread en cours d’exécution à partir du code que le thread s’exécute.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> propriété pour afficher des informations sur le thread d’application principal, un autre thread de premier plan, un thread d’arrière-plan et un thread de pool de threads.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Foreground and background threads</source>
          <target state="translated">Threads de premier plan et d’arrière-plan</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Instances of the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class represent either foreground threads or background threads.</source>
          <target state="translated">Instances de la <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> classe représentent les threads de premier plan ou les threads d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">Threads d’arrière-plan sont identiques aux threads de premier plan à une exception près : un thread d’arrière-plan ne conserve pas un processus exécuté si tous les threads de premier plan sont terminés.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">Une fois que tous les threads de premier plan ont été arrêtés, l’exécution s’arrête tous les threads d’arrière-plan et s’arrête.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>By default, the following threads execute in the foreground:</source>
          <target state="translated">Par défaut, les threads suivants s’exécutent au premier plan :</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The main application thread.</source>
          <target state="translated">Le thread d’application principal.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>All threads created by calling a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class constructor.</source>
          <target state="translated">Tous les threads créés en appelant un <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructeur de classe.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following threads execute in the background by default:</source>
          <target state="translated">Les threads suivants s’exécutent en arrière-plan par défaut :</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Thread de pool de threads, qui sont un pool de threads de travail géré par le runtime.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class.</source>
          <target state="translated">Vous pouvez configurer le travail de planification et de pool de thread sur les threads du pool à l’aide de la <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">Opérations asynchrones basées sur les tâches s’exécutent automatiquement sur les threads du pool.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Task-based asynchronous operations use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>.</source>
          <target state="translated">Utilisent des opérations asynchrones basées sur une tâche le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> classes pour implémenter le <bpt id="p1">[</bpt>modèle asynchrone basé sur des tâches<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">Tous les threads qui entrent dans l’environnement d’exécution managé à partir de code non managé.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can change a thread to execute in the background by setting the <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property at any time.</source>
          <target state="translated">Vous pouvez modifier un thread d’exécuter en arrière-plan en définissant le <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> propriété à tout moment.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">Threads d’arrière-plan sont utiles pour toute opération qui doit continuer tant qu’une application est en cours d’exécution mais ne doit pas empêcher l’application à partir de la fin d’exécution, comme la surveillance des modifications de système de fichiers ou des connexions de socket entrante.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">L’exemple suivant illustre la différence entre les threads de premier plan et d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">C’est comme le premier exemple de la <bpt id="p1">[</bpt>à partir d’un thread<ept id="p1">](#Starting)</ept> section, sauf qu’il définit le thread d’exécution en arrière-plan avant de le démarrer.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">Comme le montre la sortie, la boucle est interrompue avant d’exécuter pendant cinq secondes.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Culture and threads</source>
          <target state="translated">Culture et des threads</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Each thread has a culture, represented by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property, and a UI culture, represented by the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;</ph> property.</source>
          <target state="translated">Chaque thread possède une culture, représentée par le <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> propriété et une culture d’interface utilisateur, représentée par le <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">La culture actuelle prend en charge ces opérations dépendantes de la culture en tant que l’analyse et de mise en forme, comparaison de chaînes et le tri et contrôle également le système d’écriture et le calendrier utilisé par un thread.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">Fournit de la culture d’interface utilisateur actuelle pour la récupération de ressources dans les fichiers de ressources dépendantes de la culture.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">Lorsqu’un nouveau thread est instancié, sa culture et la culture d’interface utilisateur sont définis par la culture système en cours et la culture d’interface utilisateur et non par la culture et la culture d’interface utilisateur du thread à partir duquel le nouveau thread est créé.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">Cela signifie, par exemple, que si la culture système actuelle est anglais (États-Unis) et la culture actuelle du thread principal de l’application est le Français (France), la culture d’un nouveau thread créé en appelant le <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructeur à partir du thread principal est l’anglais (États-Unis) et pas Français (France).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the "Culture and threads" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Pour plus d’informations, consultez la section « Culture et threads » de la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">Cela n’est pas vrai pour les threads qui exécutent des opérations asynchrones pour les applications qui ciblent le <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> et versions ultérieures, dans ce cas, la culture et la culture d’interface utilisateur fait partie d’une commande asynchrone contexte des opérations ; le thread sur lequel une opération asynchrone s’exécute par défaut hérite de la culture et la culture d’interface utilisateur du thread sur lequel l’opération asynchrone a été lancée.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Pour plus d'informations, consultez la section « Culture et opérations asynchrones basées sur les tâches » de la rubrique relative à la classe <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</source>
          <target state="translated">Vous pouvez effectuer l’une des opérations suivantes pour vous assurer que tous les threads l’exécution dans une application partagent la même culture et la culture d’interface utilisateur :</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to the <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate or the <ph id="ph3">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez passer un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet qui représente cette culture pour le <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> déléguer ou <ph id="ph3">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Pour les applications en cours d’exécution le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> et versions ultérieures, vous pouvez définir la culture et la culture d’interface utilisateur qui doit être attribué à tous les threads créés dans un domaine d’application en définissant la valeur de la <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> propriétés.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">Notez qu’il s’agit d’un paramètre par domaine d’application.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information and examples, see the "Culture and threads" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Pour plus d’informations et d’exemples, consultez la section « Culture et threads » de la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Getting information about and controlling threads</source>
          <target state="translated">Obtenir des informations sur et contrôler les threads</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated">Vous pouvez récupérer un nombre de valeurs de propriété qui fournissent des informations sur un thread.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">Dans certains cas, vous pouvez également définir ces valeurs de propriété pour contrôler le fonctionnement du thread.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>These thread properties include:</source>
          <target state="translated">Ces propriétés de thread sont les suivantes :</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A name.</source>
          <target state="translated">Nom.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> is a write-once property that you can use to identify a thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> est une opération d’écriture-propriété une fois que vous pouvez utiliser pour identifier un thread.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Sa valeur par défaut est <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A hash code, which you can retrieve by calling the <ph id="ph1">&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;</ph> method.</source>
          <target state="translated">Un code de hachage, que vous pouvez extraire en appelant le <ph id="ph1">&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">Le code de hachage peut être utilisé pour identifier de façon unique un thread ; pour la durée de vie de votre thread, son code de hachage ne sera pas entrer en conflit avec la valeur d’un autre thread, quel que soit le domaine d’application à partir de laquelle vous obtenez la valeur.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A thread ID.</source>
          <target state="translated">Un ID de thread.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The value of the read-only <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">La valeur de la lecture seule <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> propriété est attribuée par le runtime et identifie de façon unique un thread au sein de son processus.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">Un <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> de système d’exploitation n’est pas lié de manière fixe à un thread managé, car un hôte non managé peut contrôler la relation entre les threads managés et les threads non managés.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">Plus précisément, un hôte élaboré peut utiliser le <bpt id="p1">[</bpt>API d’hébergement CLR<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> pour planifier de nombreux threads managés sur le même thread de système d’exploitation, ou pour déplacer un thread managé entre les threads du système d’exploitation différent.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The thread's current state.</source>
          <target state="translated">L’état du thread actuel.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the <ph id="ph1">&lt;xref:System.Threading.ThreadState&gt;</ph> property.</source>
          <target state="translated">Pendant la durée de son existence, un thread se trouve toujours dans une ou plusieurs des états définis par le <ph id="ph1">&lt;xref:System.Threading.ThreadState&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A scheduling priority level, which is defined by the <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> property.</source>
          <target state="translated">Un niveau de priorité de planification est défini par le <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">Bien que vous pouvez définir cette valeur pour demander une priorité de thread, il n’est pas garanti qu’il sera respecté par le système d’exploitation.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The read-only <ph id="ph1">&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</ph> property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">En lecture seule <ph id="ph1">&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</ph> propriété qui indique si un thread est un thread de pool de threads.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">Pour plus d’informations, consultez la <bpt id="p1">[</bpt>les threads de premier plan et arrière-plan<ept id="p1">](#Foreground)</ept> section.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example demonstrates simple threading functionality.</source>
          <target state="translated">L’exemple suivant illustre les fonctionnalités de threading simple.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This code produces output similar to the following:</source>
          <target state="translated">Ce code génère la sortie est similaire à ce qui suit :</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Délégué qui représente les méthodes à appeler au début de l'exécution de ce thread.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>, en spécifiant un délégué qui permet à un objet d'être passé au thread quand le thread est démarré.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Un thread d’exécution ne commence pas lors de sa création.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>To schedule the thread for execution, call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method.</source>
          <target state="translated">Pour planifier l’exécution du thread, appelez le <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>To pass a data object to the thread, use the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;</ph> method overload.</source>
          <target state="translated">Pour passer un objet de données au thread, utilisez la <ph id="ph1">&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Visual Basic users can omit the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor when creating a thread.</source>
          <target state="translated">Les utilisateurs de Visual Basic peuvent omettre la <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructeur lors de la création d’un thread.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">`AddressOf`</ph> opérateur lors du passage de votre méthode, par exemple <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Visual Basic automatically calls the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</source>
          <target state="translated">Visual Basic appelle automatiquement la <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>The following example shows the syntax for creating and using a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate with a static method and an instance method.</source>
          <target state="translated">L’exemple suivant montre la syntaxe pour créer et utiliser un <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> délégué avec une méthode statique et une méthode d’instance.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> qui représente les méthodes à appeler au début de l'exécution de ce thread.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Un thread d’exécution ne commence pas lors de sa création.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>To schedule the thread for execution, call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method.</source>
          <target state="translated">Pour planifier l’exécution du thread, appelez le <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Visual Basic users can omit the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor when creating a thread.</source>
          <target state="translated">Les utilisateurs de Visual Basic peuvent omettre la <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructeur lors de la création d’un thread.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">`AddressOf`</ph> opérateur lors du passage de votre méthode par exemple <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Visual Basic automatically calls the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</source>
          <target state="translated">Visual Basic appelle automatiquement la <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The following code example shows how to create a thread that executes a static method.</source>
          <target state="translated">L’exemple de code suivant montre comment créer un thread qui exécute une méthode statique.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The following code example shows how to create a thread that executes an instance method.</source>
          <target state="translated">L’exemple de code suivant montre comment créer un thread qui exécute une méthode d’instance.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The <ph id="ph1">&lt;paramref name="start" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="start" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph> qui représente les méthodes à appeler au début de l'exécution de ce thread.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Taille de pile maximale, en octets, à utiliser par le thread, ou 0 pour utiliser la taille de pile maximale par défaut spécifiée dans l'en-tête pour le fichier exécutable.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Important   For partially trusted code, <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Important   Pour le code partiellement fiable, <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> est ignoré s’il est supérieur à la taille de la pile par défaut.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>, en spécifiant un délégué qui permet à un objet d'être passé au thread quand le thread est démarré et en spécifiant la taille de pile maximale pour le thread.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Évitez d’utiliser cette surcharge de constructeur.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>The default stack size used by the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor overload is the recommended stack size for threads.</source>
          <target state="translated">La taille de pile par défaut utilisée par le <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> surcharge de constructeur est la taille de pile recommandée pour les threads.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Si un thread a des problèmes de mémoire, la cause la plus probable est une erreur de programmation, par exemple une récurrence infinie.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph2">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, seul le code peut définir de confiance suffisant <ph id="ph2">`maxStackSize`</ph> à une valeur qui est supérieure à la taille de pile par défaut (1 mégaoctet).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Si une valeur supérieure est spécifiée pour <ph id="ph1">`maxStackSize`</ph> lorsque le code s’exécute avec une confiance partielle, <ph id="ph2">`maxStackSize`</ph> est ignoré et la taille de pile par défaut est utilisée.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Code à tout niveau de confiance peut affecter <ph id="ph1">`maxStackSize`</ph> à une valeur inférieure à la taille de pile par défaut.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">Si vous développez une bibliothèque de niveau de confiance totale qui sera utilisée par du code partiellement fiable, et vous devez démarrer un thread qui requiert une grande pile, vous devez déclarer une confiance totale avant de créer le thread ou la taille de pile par défaut sera utilisée.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Ne le faites pas, sauf si vous contrôlez totalement le code qui s’exécute sur le thread.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Si <ph id="ph1">`maxStackSize`</ph> est inférieure à la taille minimale de pile, la taille de pile minimale est utilisée.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Si <ph id="ph1">`maxStackSize`</ph> n’est pas un multiple de la taille de page, il est arrondi au prochain multiple de la taille de page.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Par exemple, si vous utilisez le .NET Framework version 2.0 sur Windows Vista, 256 Ko (262 144 octets) est la taille de pile minimale et la taille de page est de 64 Ko (65 536 octets).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">Sur les versions de Microsoft Windows antérieurs à Windows XP et Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> est ignoré, et la taille de pile spécifiée dans l’en-tête de l’exécutable est utilisée.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Si vous spécifiez une très petite taille de pile, vous devrez désactiver la détection de débordement de pile.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Lorsque la pile est strictement limitée, la détection peut elle-même provoquer un débordement de pile.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Pour désactiver la détection de dépassement de capacité de pile, ajoutez le code suivant à votre fichier de configuration d’application.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> qui représente les méthodes à appeler au début de l'exécution de ce thread.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Taille de pile maximale, en octets, à utiliser par le thread, ou 0 pour utiliser la taille de pile maximale par défaut spécifiée dans l'en-tête pour le fichier exécutable.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Important   For partially trusted code, <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Important   Pour le code partiellement fiable, <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> est ignoré s’il est supérieur à la taille de la pile par défaut.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>, en spécifiant la taille de pile maximale pour le thread.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Évitez d’utiliser cette surcharge de constructeur.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>The default stack size used by the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</ph> constructor overload is the recommended stack size for threads.</source>
          <target state="translated">La taille de pile par défaut utilisée par le <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</ph> surcharge de constructeur est la taille de pile recommandée pour les threads.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Si un thread a des problèmes de mémoire, la cause la plus probable est une erreur de programmation, par exemple une récurrence infinie.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph2">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, seul le code peut définir de confiance suffisant <ph id="ph2">`maxStackSize`</ph> à une valeur qui est supérieure à la taille de pile par défaut (1 mégaoctet).</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Si une valeur supérieure est spécifiée pour <ph id="ph1">`maxStackSize`</ph> lorsque le code s’exécute avec une confiance partielle, <ph id="ph2">`maxStackSize`</ph> est ignoré et la taille de pile par défaut est utilisée.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">Code à tout niveau de confiance peut affecter <ph id="ph1">`maxStackSize`</ph> à une valeur inférieure à la taille de pile par défaut.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">Si vous développez une bibliothèque de niveau de confiance totale qui sera utilisée par du code partiellement fiable, et vous devez démarrer un thread qui requiert une grande pile, vous devez déclarer une confiance totale avant de créer le thread ou la taille de pile par défaut sera utilisée.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">Ne le faites pas, sauf si vous contrôlez totalement le code qui s’exécute sur le thread.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Si <ph id="ph1">`maxStackSize`</ph> est inférieure à la taille minimale de pile, la taille de pile minimale est utilisée.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Si <ph id="ph1">`maxStackSize`</ph> n’est pas un multiple de la taille de page, il est arrondi au prochain multiple de la taille de page.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Par exemple, si vous utilisez le .NET Framework version 2.0 sur Windows Vista, 256 Ko (262 144 octets) est la taille de pile minimale et la taille de page est de 64 Ko (65 536 octets).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">Sur les versions de Microsoft Windows antérieurs à Windows XP et Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> est ignoré, et la taille de pile spécifiée dans l’en-tête de l’exécutable est utilisée.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Si vous spécifiez une très petite taille de pile, vous devrez désactiver la détection de débordement de pile.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Lorsque la pile est strictement limitée, la détection peut elle-même provoquer un débordement de pile.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Pour désactiver la détection de dépassement de capacité de pile, ajoutez le code suivant à votre fichier de configuration d’application.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Déclenche <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">L'appel de cette méthode arrête généralement le thread.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Déclenche <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">L'appel de cette méthode arrête généralement le thread.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>When this method is invoked on a thread, the system throws a <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread to abort it.</source>
          <target state="translated">Lorsque cette méthode est appelée sur un thread, le système lève un <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> dans le thread pour l’abandonner.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> est une exception spéciale qui peut être interceptée par le code d’application, mais qui est levée de nouveau à la fin de la <ph id="ph2">`catch`</ph> bloquer sauf si <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> Annule la demande d’abandon et empêche le <ph id="ph2">`ThreadAbortException`</ph> à partir de l’arrêt du thread.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Non <ph id="ph1">`finally`</ph> blocs sont exécutés avant l’abandon du thread.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>When a thread calls <ph id="ph1">`Abort`</ph> on itself, the effect is similar to throwing an exception; the <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> happens immediately, and the result is predictable.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`Abort`</ph> sur lui-même, l’effet est similaire à la levée d’une exception ; le <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> se produit immédiatement et le résultat est prévisible.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Toutefois, si un thread appelle <ph id="ph1">`Abort`</ph> sur un autre thread, l’abandon interrompt le code qui est en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">Il est également possible qu’un constructeur statique soit abandonné.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">Dans de rares cas, ceci peut empêcher les instances de cette classe d’être créées dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">Dans les versions 1.0 et 1.1 du .NET Framework, il existe un risque que le thread abandonné pendant un <ph id="ph1">`finally`</ph> bloc est en cours d’exécution, auquel cas la <ph id="ph2">`finally`</ph> bloc est abandonné.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">Le thread n’est pas garanti pour abandonner immédiatement, ou tout.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Cette situation peut se produire si un thread effectue un nombre illimité de calculs dans le <ph id="ph1">`finally`</ph> blocs qui sont appelées dans le cadre de la procédure d’abandon, ce qui retarde indéfiniment l’abandon.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>To wait until a thread has aborted, you can call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method on the thread after calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, but there is no guarantee the wait will end.</source>
          <target state="translated">Pour attendre qu’un thread a abandonné, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> méthode sur le thread après avoir appelé la <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> (méthode), mais il n’existe aucune garantie que l’attente se termine.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>The thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">Le thread qui appelle <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> peut se bloquer si le thread abandonné est dans une région protégée de code, comme un <ph id="ph2">`catch`</ph> bloc, <ph id="ph3">`finally`</ph> bloc ou région d’exécution limitée.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If the thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Si le thread qui appelle <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> détient un verrou que le thread interrompu requiert, un interblocage peut se produire.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> is called.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> est appelée sur un thread qui n’a pas été démarré, le thread sera abandonnée lorsque <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> est appelée sur un thread qui est bloqué ou en état de veille, le thread est interrompu et puis abandonné.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> is thrown in the thread that called <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> is added to the <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property of the thread being aborted.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> est appelée sur un thread qui a été suspendu, un <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> est levée dans le thread qui a appelé <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> est ajouté à la <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> propriété du thread en cours d’abandon.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is not thrown in the suspended thread until <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> is called.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> n’est pas levée dans le thread suspendu jusqu'à ce que <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> est appelée sur un thread managé pendant l’exécution de code non managé, un <ph id="ph2">`ThreadAbortException`</ph> n’est pas levée tant que le thread retourne au code managé.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Si deux appels à <ph id="ph1">`Abort`</ph> sont fournis en même temps, il est possible qu’un seul appel définir les informations d’état et l’appel s’exécute le <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Toutefois, une application ne peut pas détecter cette situation.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</source>
          <target state="translated">Après avoir <ph id="ph1">`Abort`</ph> est appelé sur un thread, l’état du thread inclut <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</source>
          <target state="translated">Une fois que le thread s’est arrêté suite à un appel réussi à <ph id="ph1">`Abort`</ph>, l’état du thread est modifié pour <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Avec des autorisations suffisantes, un thread qui est la cible d’une <ph id="ph1">`Abort`</ph> peut annuler l’abandon à l’aide de la <ph id="ph2">`ResetAbort`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Pour obtenir un exemple qui montre comment appeler le <ph id="ph1">`ResetAbort`</ph> méthode, consultez la <ph id="ph2">`ThreadAbortException`</ph> classe.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">.NET Core uniquement : ce membre n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">Le thread en cours d’abandon est actuellement suspendu.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>for advanced operations on threads.</source>
          <target state="translated">pour des opérations avancées sur les threads.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">Objet contenant des informations spécifiques à l'application, telles que l'état, qui peuvent être utilisées par le thread en cours d'abandon.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">Déclenche une <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread, tout en fournissant des informations sur les exceptions relatives à l'arrêt du thread.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">L'appel de cette méthode arrête généralement le thread.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>When this method is invoked on a thread, the system throws a <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread to abort it.</source>
          <target state="translated">Lorsque cette méthode est appelée sur un thread, le système lève un <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> dans le thread pour l’abandonner.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> est une exception spéciale qui peut être interceptée par le code d’application, mais qui est levée de nouveau à la fin de la <ph id="ph2">`catch`</ph> bloquer sauf si <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> Annule la demande d’abandon et empêche le <ph id="ph2">`ThreadAbortException`</ph> à partir de l’arrêt du thread.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Non <ph id="ph1">`finally`</ph> blocs sont exécutés avant l’abandon du thread.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>When a thread calls <ph id="ph1">`Abort`</ph> on itself, the effect is similar to throwing an exception; the <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> happens immediately, and the result is predictable.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`Abort`</ph> sur lui-même, l’effet est similaire à la levée d’une exception ; le <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> se produit immédiatement et le résultat est prévisible.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Toutefois, si un thread appelle <ph id="ph1">`Abort`</ph> sur un autre thread, l’abandon interrompt le code qui est en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">Il est probable qu’un constructeur statique soit abandonné.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">Dans de rares cas, ceci peut empêcher les instances de cette classe d’être créées dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">Dans les versions 1.0 et 1.1 du .NET Framework, il existe un risque que le thread abandonné pendant un <ph id="ph1">`finally`</ph> bloc est en cours d’exécution, auquel cas la <ph id="ph2">`finally`</ph> bloc est abandonné.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">Le thread n’est pas garanti pour abandonner immédiatement, ou tout.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Cette situation peut se produire si un thread effectue un nombre illimité de calculs dans le <ph id="ph1">`finally`</ph> blocs qui sont appelées dans le cadre de la procédure d’abandon, ce qui retarde indéfiniment l’abandon.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>To wait until a thread has aborted, you can call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method on the thread after calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, but there is no guarantee that the wait will end.</source>
          <target state="translated">Pour attendre qu’un thread a abandonné, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> méthode sur le thread après avoir appelé la <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> (méthode), mais il n’existe aucune garantie que l’attente se termine.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">Le thread qui appelle <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> peut se bloquer si le thread abandonné est dans une région protégée de code, comme un <ph id="ph2">`catch`</ph> bloc, <ph id="ph3">`finally`</ph> bloc ou région d’exécution limitée.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If the thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Si le thread qui appelle <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> détient un verrou que le thread interrompu requiert, un interblocage peut se produire.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> is called.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> est appelée sur un thread qui n’a pas été démarré, le thread sera abandonnée lorsque <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> est appelée sur un thread qui est bloqué ou en état de veille, le thread est interrompu et puis abandonné.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> is thrown in the thread that called <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> is added to the <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property of the thread being aborted.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> est appelée sur un thread qui a été suspendu, un <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> est levée dans le thread qui a appelé <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> est ajouté à la <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> propriété du thread en cours d’abandon.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is not thrown in the suspended thread until <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> is called.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> n’est pas levée dans le thread suspendu jusqu'à ce que <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> est appelée sur un thread managé pendant l’exécution de code non managé, un <ph id="ph2">`ThreadAbortException`</ph> n’est pas levée tant que le thread retourne au code managé.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Si deux appels à <ph id="ph1">`Abort`</ph> sont fournis en même temps, il est possible qu’un seul appel définir les informations d’état et l’appel s’exécute le <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Toutefois, une application ne peut pas détecter cette situation.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</source>
          <target state="translated">Après avoir <ph id="ph1">`Abort`</ph> est appelé sur un thread, l’état du thread inclut <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</source>
          <target state="translated">Une fois que le thread s’est arrêté suite à un appel réussi à <ph id="ph1">`Abort`</ph>, l’état du thread est modifié pour <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Avec des autorisations suffisantes, un thread qui est la cible d’une <ph id="ph1">`Abort`</ph> peut annuler l’abandon à l’aide de la <ph id="ph2">`ResetAbort`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Pour obtenir un exemple qui montre comment appeler le <ph id="ph1">`ResetAbort`</ph> méthode, consultez la <ph id="ph2">`ThreadAbortException`</ph> classe.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The following code example shows how to pass information to a thread that is being aborted.</source>
          <target state="translated">L’exemple de code suivant montre comment passer des informations à un thread en cours d’abandon.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">.NET Core uniquement : ce membre n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">Le thread en cours d’abandon est actuellement suspendu.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>for advanced operations on threads.</source>
          <target state="translated">pour des opérations avancées sur les threads.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">Alloue sur tous les threads un emplacement de données sans nom.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Emplacement de données nommé alloué sur tous les threads.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut) et emplacements de données.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de TLS, consultez <bpt id="p1">[</bpt>stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">L’emplacement est alloué sur tous les threads.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Le thread peut allouer un emplacement de données dans le magasin de données, stocker et récupérer des données de valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Emplacements de données sont uniques pour chaque thread.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Aucun autre thread (pas même un thread enfant) ne peut obtenir ces données.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>This section contains two code examples.</source>
          <target state="translated">Cette section contient deux exemples de code.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Le premier exemple montre comment utiliser un champ qui est marqué avec la <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Le deuxième exemple montre comment utiliser un emplacement de données pour effectuer la même opération.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Premier exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un champ qui est marqué avec <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Deuxième exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The following code example demonstrates how to use a data slot to store thread-specific information.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">Nom de l'emplacement de données à allouer.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">Alloue sur tous les threads un emplacement de données nommé.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Emplacement de données nommé alloué sur tous les threads.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut) et emplacements de données.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de TLS, consultez <bpt id="p1">[</bpt>stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Le thread peut allouer un emplacement de données dans le magasin de données, stocker et récupérer des données de valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Emplacements de données sont uniques pour chaque thread.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Aucun autre thread (pas même un thread enfant) ne peut obtenir ces données.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>It is not necessary to use the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method to allocate a named data slot, because the <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method allocates the slot if it has not already been allocated.</source>
          <target state="translated">Il n’est pas nécessaire d’utiliser le <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> méthode pour allouer un emplacement de données, car le <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> méthode alloue l’emplacement s’il n’a pas déjà été attribué.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> méthode est utilisée, elle doit être appelée dans le thread principal au démarrage du programme, car il lève une exception si un emplacement portant le nom spécifié a déjà été alloué.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">Il n’existe aucun moyen de tester si un emplacement a déjà été alloué.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Slots allocated with this method must be freed with <ph id="ph1">&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</ph>.</source>
          <target state="translated">Emplacements alloués avec cette méthode doivent être libérées avec <ph id="ph1">&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Cette section contient deux exemples de code.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Le premier exemple montre comment utiliser un champ qui est marqué avec la <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Le deuxième exemple montre comment utiliser un emplacement de données pour effectuer la même opération.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Premier exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un champ qui est marqué avec <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Deuxième exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The example code does not use the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method, because the <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method allocates the slot if it has not already been allocated.</source>
          <target state="translated">L’exemple de code n’utilise pas le <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> (méthode), car le <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> méthode alloue l’emplacement s’il n’a pas déjà été attribué.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method is used, it should be called in the main thread at program startup.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> méthode est utilisée, elle doit être appelée dans le thread principal au démarrage du programme.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">Un emplacement de données portant le nom spécifié existe déjà.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ApartmentState">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">Obtient ou définit l'état de cloisonnement de ce thread.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The initial value is <ph id="ph1">&lt;see langword="Unknown" /&gt;</ph>.</source>
          <target state="translated">La valeur initiale est <ph id="ph1">&lt;see langword="Unknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source><bpt id="p1">**</bpt>The <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Le <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propriété est obsolète.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The non-obsolete alternatives are the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method to retrieve the apartment state and the   <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method to set the apartment state.</source>
          <target state="translated">Les alternatives non obsolète sont la <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> méthode pour récupérer l’état de cloisonnement et <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> pour définir l’état de cloisonnement.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">Dans les versions du .NET Framework 1.0 et 1.1, la <ph id="ph1">`ApartmentState`</ph> propriété marque un thread pour indiquer qu’il s’exécutera dans un cloisonnement monothread ou multithread.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">Cette propriété peut être définie lorsque le thread est dans le <ph id="ph1">`Unstarted`</ph> ou <ph id="ph2">`Running`</ph> état ; Toutefois, elle peut être définie qu’une seule fois pour un thread.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">Si la propriété n’a pas été définie, elle retourne <ph id="ph1">`Unknown`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>An attempt to use the <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">Essayez d’utiliser le <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propriété à définir l’état de cloisonnement d’un thread dont l’état de cloisonnement a déjà été défini est ignorée.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>However, the <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> in this case.</source>
          <target state="translated">Toutefois, le <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> méthode lève une exception un <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> dans ce cas.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework version 2.0, new threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">Dans le .NET Framework version 2.0, les nouveaux threads sont initialisés en tant que <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> si leur état de cloisonnement n’a pas été défini avant leur démarrage.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">Le thread d’application principal est initialisé à <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> par défaut.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>You can no longer set the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> by setting the <ph id="ph2">&lt;xref:System.Threading.ApartmentState?displayProperty=nameWithType&gt;</ph> property on the first line of code.</source>
          <target state="translated">Vous ne pouvez plus définir le thread d’application principal <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> en définissant le <ph id="ph2">&lt;xref:System.Threading.ApartmentState?displayProperty=nameWithType&gt;</ph> propriété sur la première ligne de code.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>Use the <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph> instead.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)</ept> linker option.</source>
          <target state="translated">Dans le .NET Framework version 2.0, vous pouvez spécifier le modèle pour une application C++ à l’aide de thread COM le <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)</ept> option de l’éditeur de liens.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The following code example demonstrates how to set the apartment state of a thread.</source>
          <target state="translated">L’exemple de code suivant montre comment définir l’état de cloisonnement d’un thread.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ApartmentState">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<ph id="ph1">&lt;see langword="STA" /&gt;</ph>) or multithreaded apartment (<ph id="ph2">&lt;see langword="MTA" /&gt;</ph>)).</source>
          <target state="translated">Une tentative est effectuée pour définir cette propriété sur un état qui n’est pas un état de cloisonnement valide (un état autre que celui de thread unique cloisonné (<ph id="ph1">&lt;see langword="STA" /&gt;</ph>) ou de multithread cloisonné (<ph id="ph2">&lt;see langword="MTA" /&gt;</ph>)).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">Avertit un hôte que l'exécution est sur le point d'entrer dans une zone de code dans laquelle les effets d'un abandon de thread ou d'une exception non gérée peuvent compromettre d'autres tâches dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Les hôtes du common language runtime (CLR), telles que Microsoft SQL Server 2005, peuvent établir des stratégies différentes pour les erreurs dans les régions de code critiques et non critiques.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Une zone critique est une dans laquelle les effets d’un abandon de thread ou une exception non gérée ne se limitent pas à la tâche actuelle.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">En revanche, un abandon ou une défaillance dans une région de code non critique affecte uniquement la tâche dans laquelle l’erreur se produit.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Par exemple, considérez une tâche qui tente d’allouer de la mémoire tout en maintenant un verrou.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Si l’allocation de mémoire échoue, l’abandon de la tâche en cours n’est pas suffisante pour assurer la stabilité de le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, car il peut exister d’autres tâches dans le domaine qui attendent le même verrou.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Si la tâche en cours est arrêtée, les autres tâches peuvent être bloquées.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Lorsqu’une défaillance se produit dans une région critique, l’hôte peut décider de décharger l’intégralité de <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> plutôt que de prendre le risque de continuer l’exécution dans un état potentiellement instable.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>To inform the host that your code is entering a critical region, call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</source>
          <target state="translated">Pour informer l’hôte que votre code entre dans une région critique, appelez <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> when execution returns to a non-critical region of code.</source>
          <target state="translated">Appelez <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> lorsque l’exécution retourne dans une région non critique de code.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Dans le code qui s’exécute sous SQL Server 2005 à l’aide de cette méthode requiert le code à exécuter sur le niveau de protection de l’hôte le plus élevé.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> methods to divide a block of code into critical and non-critical regions.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> méthodes pour diviser un bloc de code en régions critiques et non critiques.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Avertit un hôte que le code managé est sur le point d'exécuter des instructions qui dépendent de l'identité du thread du système d'exploitation physique actuel.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Certains hôtes du common language runtime, tels que Microsoft SQL Server 2005, fournissent leur propre gestion de threads.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Un hôte qui fournit sa propre gestion de threads peut déplacer une tâche en cours d’exécution d’un thread de système d’exploitation physique à un autre à tout moment.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">La plupart des tâches ne sont pas affectées par ce basculement.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Toutefois, certaines tâches ont une affinité de thread : autrement dit, ils dépendent de l’identité d’un thread de système d’exploitation physique.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Ces tâches doivent informer l’hôte lorsqu’elles exécutent du code qui ne doit pas être basculé.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> before acquiring the lock, and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> after releasing the lock.</source>
          <target state="translated">Par exemple, si votre application appelle une API système pour acquérir un système d’exploitation de verrouillage qui possède l’affinité de thread, tel que Win32 CRITICAL_SECTION, vous devez appeler <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> avant d’acquérir le verrou, et <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> après l’avoir libéré le verrou.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Dans le code qui s’exécute sous SQL Server 2005 à l’aide de cette méthode requiert le code à exécuter sur le niveau de protection de l’hôte le plus élevé.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> méthodes pour avertir un hôte qu’un bloc de code dépend de l’identité d’un thread de système d’exploitation physique.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentContext">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">Obtient le contexte actuel dans lequel le thread s'exécute.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Contexts.Context" /&gt;</ph> representing the current thread context.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Contexts.Context" /&gt;</ph> représentant le contexte actuel du thread.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentContext">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">Obtient ou définit la culture du thread actuel.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">Objet qui représente la culture du thread actuel.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet qui est retourné par cette propriété, ainsi que ses objets associés, déterminer le format par défaut pour les dates, heures, des nombres, les valeurs de devise, l’ordre de tri du texte, conventions de casse et les comparaisons de chaînes.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Consultez la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> classe pour en savoir plus sur les noms de la culture et les identificateurs, les différences entre les cultures invariantes, neutres et spécifiques, et les informations de culture de façon affectent les domaines d’application et les threads.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> propriété pour en savoir plus de la manière dont la culture de valeur par défaut d’un thread est déterminée, et comment les utilisateurs définir les informations de culture pour leurs ordinateurs.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, you can set the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property to a neutral culture.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, vous pouvez définir le <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> propriété à une culture neutre.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>This is because the behavior of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class has changed: When it represents a neutral culture, its property values (in particular, the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;</ph> properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">C’est parce que le comportement de la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> classe a été modifiée : lorsqu’il représente une culture neutre, ses valeurs de propriété (en particulier, la <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;</ph>, et <ph id="ph6">&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;</ph> propriétés) maintenant refléter la culture spécifique associée à la culture neutre.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>In earlier versions of the .NET Framework, the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property threw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception when a neutral culture was assigned.</source>
          <target state="translated">Dans les versions antérieures du .NET Framework, le <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> propriété a levé une <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception lorsqu’une culture neutre a été attribuée.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</source>
          <target state="translated">L’exemple de code suivant montre l’instruction de thread qui permet à l’interface utilisateur de Windows Forms à afficher dans la culture est définie dans le panneau de configuration.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Additional code is needed.</source>
          <target state="translated">Code supplémentaire est nécessaire.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The property is set to <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété est définie sur <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>for setting the property.</source>
          <target state="translated">Pour définir la propriété.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">Obtient ou définit le principal actuel du thread (pour une sécurité basée sur les rôles).</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.Principal.IPrincipal" /&gt;</ph> value representing the security context.</source>
          <target state="translated">Valeur <ph id="ph1">&lt;see cref="T:System.Security.Principal.IPrincipal" /&gt;</ph> représentant le contexte de sécurité.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>The following code example shows how to set and retrieve the principal of a thread.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et récupérer l’entité de sécurité d’un thread.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">L’appelant n’a pas l’autorisation nécessaire pour définir le principal.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>to manipulate the principal object.</source>
          <target state="translated">pour manipuler l’objet principal.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentThread">
          <source>Gets the currently running thread.</source>
          <target state="translated">Obtient le thread en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> that is the representation of the currently running thread.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> constituant la représentation du thread en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The following example creates a task that in turn creates 20 child tasks.</source>
          <target state="translated">L’exemple suivant crée une tâche qui crée à son tour de 20 tâches enfants.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The application itself, as well as each task, calls the <ph id="ph1">`ShowThreadInformation`</ph> method, which uses the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property  to display information about the thread on which it is running.</source>
          <target state="translated">L’application elle-même, en tant que bien que chaque tâche, appelle le <ph id="ph1">`ShowThreadInformation`</ph> méthode, qui utilise le <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> propriété pour afficher des informations sur le thread sur lequel il est en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</source>
          <target state="translated">Chaque tâche enfant 1 million de nombres aléatoires compris entre 1 et 1 million de génère et retourne leur moyenne.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The parent task calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</source>
          <target state="translated">Les appels de la tâche parent la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> pour s’assurer que les tâches enfants terminées avant d’afficher la moyenne retournée par chaque tâche et en calculant la moyenne des moyens.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</source>
          <target state="translated">Notez que pendant que l’application s’exécute sur un thread de premier plan, chaque tâche s’exécute sur un thread de pool de threads.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">Obtient ou définit la culture actuelle utilisée par le Gestionnaire de ressources pour rechercher des ressources spécifiques à la culture au moment de l'exécution.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>An object that represents the current culture.</source>
          <target state="translated">Objet qui représente la culture actuelle.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</source>
          <target state="translated">La culture d’interface utilisateur spécifie les ressources d’une application doit prendre en charge l’entrée d’utilisateur et de sortie et par défaut est identique à la culture du système d’exploitation.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Consultez la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> classe pour en savoir plus sur les noms de la culture et les identificateurs, les différences entre les cultures invariantes, neutres et spécifiques, et les informations de culture de façon affectent les domaines d’application et les threads.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> property to learn how a thread's default UI culture is determined.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> propriété pour savoir comment la culture d’interface utilisateur d’un thread par défaut est déterminée.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> returned by this property can be a neutral culture.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> retourné par cette propriété peut être une culture neutre.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Neutral cultures should not be used with formatting methods such as <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Cultures neutres ne doivent pas être utilisés avec mise en forme telles que les méthodes <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> method to get a specific culture, or use the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> (méthode) à une culture spécifique, ou utilisez le <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> method throws <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> méthode lève une exception <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> pour les cultures neutres « zh-Hant » (« zh-CHT ») et « zh-Hans » (« zh-CHS »).</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The following example determines whether the language of the current thread's UI culture is French.</source>
          <target state="translated">L’exemple suivant détermine si la langue de la culture d’interface utilisateur du thread actuel est le Français.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>If it is not, it sets the UI culture of the current thread to English (United States).</source>
          <target state="translated">Si elle n’est pas le cas, il définit la culture d’interface utilisateur du thread actuel vers l’anglais (États-Unis).</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</source>
          <target state="translated">L’exemple de code suivant montre l’instruction de thread qui permet à l’interface utilisateur de Windows Forms à afficher dans la culture est définie dans le panneau de configuration.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Additional code is needed.</source>
          <target state="translated">Code supplémentaire est nécessaire.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The property is set to <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété est définie sur <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">La propriété a la valeur d’un nom de culture qui ne peut pas être utilisé pour localiser un fichier de ressources.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">Les noms de fichiers des ressources doivent inclure uniquement des lettres, des chiffres, des traits d’union ou des traits de soulignement.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">Désactive le nettoyage automatique des wrappers RCW (Runtime Callable Wrapper) pour le thread actuel.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">Par défaut, le common language runtime (CLR) nettoie automatiquement les wrappers RCW.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</source>
          <target state="translated">Les CLR pompe des messages pendant le nettoyage, ce qui peut entraîner des problèmes de réentrance pour quelques applications qui répondent aux critères inhabituels suivants :</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The application does its own message pumping.</source>
          <target state="translated">L’application effectue son propre pompage de messages.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">L’application doit contrôler précisément lorsque le pompage de messages se produit.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Such applications can use the <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A&gt;</ph> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">Ces applications peuvent utiliser le <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A&gt;</ph> pour empêcher le CLR d’effectuer une récupération automatique du runtime callable wrappers.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">Lorsque cette méthode a été appelée sur un thread, le nettoyage automatique ne peut pas être réactivé pour ce thread.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>When your application is ready to clean up runtime callable wrappers, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType&gt;</ph> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">Lorsque votre application est prête à nettoyer des wrappers RCW, utilisez la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType&gt;</ph> méthode pour demander au runtime de nettoyer tous les wrappers RCW dans le contexte actuel.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">Pompage de messages se produit pendant l’exécution de la méthode.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">Avertit un hôte que l’exécution est sur le point d’entrer dans une zone de code dans laquelle les effets d’un abandon de thread ou d’une exception non gérée sont limités à la tâche actuelle.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Les hôtes du common language runtime (CLR), telles que Microsoft SQL Server 2005, peuvent établir des stratégies différentes pour les erreurs dans les régions de code critiques et non critiques.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Une zone critique est une dans laquelle les effets d’un abandon de thread ou une exception non gérée ne se limitent pas à la tâche actuelle.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">En revanche, un abandon ou une défaillance dans une région de code non critique affecte uniquement la tâche dans laquelle l’erreur se produit.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Par exemple, considérez une tâche qui tente d’allouer de la mémoire tout en maintenant un verrou.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Si l’allocation de mémoire échoue, l’abandon de la tâche en cours n’est pas suffisante pour assurer la stabilité de le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, car il peut exister d’autres tâches dans le domaine qui attendent le même verrou.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Si la tâche en cours est arrêtée, les autres tâches peuvent être bloquées.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Lorsqu’une défaillance se produit dans une région critique, l’hôte peut décider de décharger l’intégralité de <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> plutôt que de prendre le risque de continuer l’exécution dans un état potentiellement instable.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>To inform the host that your code is entering a critical region, call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</source>
          <target state="translated">Pour informer l’hôte que votre code entre dans une région critique, appelez <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> when execution returns to a non-critical region of code.</source>
          <target state="translated">Appelez <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> lorsque l’exécution retourne dans une région non critique de code.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Dans le code qui s’exécute sous SQL Server 2005 à l’aide de cette méthode requiert le code à exécuter sur le niveau de protection de l’hôte le plus élevé.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> methods to divide a block of code into critical and non-critical regions.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> méthodes pour diviser un bloc de code en régions critiques et non critiques.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Avertit un hôte que le code managé a terminé l'exécution des instructions qui dépendent de l'identité du thread du système d'exploitation physique actuel.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Certains hôtes du common language runtime, tels que Microsoft SQL Server 2005, fournissent leur propre gestion de threads.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Un hôte qui fournit sa propre gestion de threads peut déplacer une tâche en cours d’exécution d’un thread de système d’exploitation physique à un autre à tout moment.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">La plupart des tâches ne sont pas affectées par ce basculement.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Toutefois, certaines tâches ont une affinité de thread : autrement dit, ils dépendent de l’identité d’un thread de système d’exploitation physique.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Ces tâches doivent informer l’hôte lorsqu’elles exécutent du code qui ne doit pas être basculé.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> before acquiring the lock, and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> after releasing the lock.</source>
          <target state="translated">Par exemple, si votre application appelle une API système pour acquérir un système d’exploitation de verrouillage qui possède l’affinité de thread, tel que Win32 CRITICAL_SECTION, vous devez appeler <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> avant d’acquérir le verrou, et <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> après l’avoir libéré le verrou.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Dans le code qui s’exécute sous SQL Server 2005 à l’aide de cette méthode requiert le code à exécuter sur le niveau de protection de l’hôte le plus élevé.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> méthodes pour avertir un hôte qu’un bloc de code dépend de l’identité d’un thread de système d’exploitation physique.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ExecutionContext">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> object that contains information about the various contexts of the current thread.</source>
          <target state="translated">Obtient un objet <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> qui contient des informations relatives aux divers contextes du thread actuel.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>An <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> object that consolidates context information for the current thread.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> qui consolide des informations de contexte pour le thread actuel.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ExecutionContext&gt;</ph> class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.ExecutionContext&gt;</ph> classe fournit un conteneur unique pour toutes les informations relatives à un thread logique d’exécution.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">Cela inclut le contexte de sécurité, contexte d’appel, le contexte de synchronisation, le contexte de localisation et contexte de transaction.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> object.</source>
          <target state="translated">Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'objet <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Finalize">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Threading.Thread.Finalize%2A&gt;</ph> when the current object is ready to be finalized.</source>
          <target state="translated">Le garbage collector appelle <ph id="ph1">&lt;xref:System.Threading.Thread.Finalize%2A&gt;</ph> lorsque l’objet actuel est prêt à être finalisé.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">Nom de l'emplacement de données à libérer.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">Élimine l'association entre un nom et un emplacement pour tous les threads du processus.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut) et emplacements de données.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de TLS, consultez <bpt id="p1">[</bpt>stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">Une fois un thread appelle <ph id="ph1">`FreeNamedDataSlot`</ph>, aucun autre thread qui appelle <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> portant le même nom allouera un nouvel emplacement associé au nom.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">Les appels suivants à <ph id="ph1">`GetNamedDataSlot`</ph> par n’importe quel thread retourneront le nouvel emplacement.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>However, any thread that still has a <ph id="ph1">&lt;xref:System.LocalDataStoreSlot?displayProperty=nameWithType&gt;</ph> returned by an earlier call to <ph id="ph2">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">Toutefois, n’importe quel thread qui a toujours un <ph id="ph1">&lt;xref:System.LocalDataStoreSlot?displayProperty=nameWithType&gt;</ph> retourné par un appel précédent à <ph id="ph2">`GetNamedDataSlot`</ph> peuvent continuer à utiliser l’ancien emplacement.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">Un emplacement qui a été associé à un nom est libéré uniquement lorsque chaque <ph id="ph1">`LocalDataStoreSlot`</ph> qui a été obtenu avant l’appel à <ph id="ph2">`FreeNamedDataSlot`</ph> a été publié et le garbage collector.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Le thread peut allouer un emplacement de données dans le magasin de données, stocker et récupérer des données de valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Emplacements de données sont uniques pour chaque thread.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Aucun autre thread (pas même un thread enfant) ne peut obtenir ces données.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Cette section contient deux exemples de code.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Le premier exemple montre comment utiliser un champ qui est marqué avec la <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Le deuxième exemple montre comment utiliser un emplacement de données pour effectuer la même opération.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Premier exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un champ qui est marqué avec <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Deuxième exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> value indicating the apartment state.</source>
          <target state="translated">Retourne une valeur <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> qui indique l'état de cloisonnement.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> values indicating the apartment state of the managed thread.</source>
          <target state="translated">Une des valeurs <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> qui indique l'état de cloisonnement du thread managé.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The default is <ph id="ph1">&lt;see cref="F:System.Threading.ApartmentState.Unknown" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see cref="F:System.Threading.ApartmentState.Unknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>This method, along with the <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph3">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">Cette méthode, ainsi que la <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> (méthode) et le <ph id="ph2">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> (méthode), remplace le <ph id="ph3">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The code example creates a thread.</source>
          <target state="translated">L’exemple de code crée un thread.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Avant que le thread est démarré, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> affiche la première <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> état et <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> modifie l’état à <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthode retourne ensuite <ph id="ph2">`false`</ph> lorsque vous tentez de modifier l’état à <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> car l’état de cloisonnement est déjà définie.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Si la même opération avait été tentée avec <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> aurait été levée.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Une fois que le thread est démarré, le <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthode est utilisée à nouveau.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Cette fois, elle lève une exception <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> , car le thread a déjà été démarré.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">Retourne un objet <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> qui peut être utilisé pour capturer la pile pour le thread actuel.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>None.</source>
          <target state="translated">Aucun.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>This method is no longer supported.</source>
          <target state="translated">Cette méthode n’est plus pris en charge.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>In all cases.</source>
          <target state="translated">Dans tous les cas.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> from which to get the value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> à partir duquel obtenir la valeur.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">Récupère la valeur de l'emplacement spécifié sur le thread actif, dans le domaine actuel du thread actif.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The retrieved value.</source>
          <target state="translated">Valeur récupérée.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut) et emplacements de données.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de TLS, consultez <bpt id="p1">[</bpt>stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Le thread peut allouer un emplacement de données dans le magasin de données, stocker et récupérer des données de valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Emplacements de données sont uniques pour chaque thread.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Aucun autre thread (pas même un thread enfant) ne peut obtenir ces données.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.GetData%2A&gt;</ph> is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.GetData%2A&gt;</ph> est un <ph id="ph2">`Shared`</ph> méthode s’applique toujours au thread en cours d’exécution, même si vous appelez à l’aide d’une variable qui fait référence à un autre thread.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">Pour éviter toute confusion, utilisez le nom de classe lorsque vous appelez <ph id="ph1">`Shared`</ph> méthodes : <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>This section contains two code examples.</source>
          <target state="translated">Cette section contient deux exemples de code.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Le premier exemple montre comment utiliser un champ qui est marqué avec la <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Le deuxième exemple montre comment utiliser un emplacement de données pour effectuer la même opération.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Premier exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un champ qui est marqué avec <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Deuxième exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The following example demonstrates how to use a data slot to store thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomain">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">Retourne le domaine actuel dans lequel le thread actif est en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomain">
          <source>An <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> representing the current application domain of the running thread.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> représentant le domaine d'application actuel du thread en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetDomain">
          <source>The following code example shows how to retrieve the name and ID of the <ph id="ph1">`AppDomain`</ph> in which the thread is running.</source>
          <target state="translated">L’exemple de code suivant montre comment récupérer le nom et l’ID de la <ph id="ph1">`AppDomain`</ph> dans lequel le thread s’exécute.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomainID">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">Retourne un identificateur unique de domaine d'application.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomainID">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">Entier signé 32 bits identifiant de manière unique le domaine d'application.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetDomainID">
          <source>The following code example shows how to retrieve the name and ID of the <ph id="ph1">`AppDomain`</ph> in which the thread is running.</source>
          <target state="translated">L’exemple de code suivant montre comment récupérer le nom et l’ID de la <ph id="ph1">`AppDomain`</ph> dans lequel le thread s’exécute.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetHashCode">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">Retourne un code de hachage pour le thread actuel.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetHashCode">
          <source>An integer hash code value.</source>
          <target state="translated">Valeur de code de hachage entier.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetHashCode">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">Le code de hachage n’est pas garanti pour être unique.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetHashCode">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property if you need a unique identifier for a managed thread.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> propriété si vous avez besoin d’un identificateur unique pour un thread managé.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The name of the local data slot.</source>
          <target state="translated">Nom de l'emplacement de données local.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Looks up a named data slot.</source>
          <target state="translated">Recherche un emplacement de données nommé.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> allocated for this thread.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> alloué pour ce thread.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut) et emplacements de données.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de TLS, consultez <bpt id="p1">[</bpt>stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">Le thread peut allouer un emplacement de données dans le magasin de données, stocker et récupérer des données de valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Emplacements de données sont uniques pour chaque thread.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Aucun autre thread (pas même un thread enfant) ne peut obtenir ces données.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">Si l’emplacement nommé n’existe pas, un nouvel emplacement est alloué.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">Emplacements de données nommés sont publics et peuvent être manipulées par tout le monde.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Cette section contient deux exemples de code.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Le premier exemple montre comment utiliser un champ qui est marqué avec la <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Le deuxième exemple montre comment utiliser un emplacement de données pour effectuer la même opération.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Premier exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un champ qui est marqué avec <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Deuxième exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Interrupt">
          <source>Interrupts a thread that is in the <ph id="ph1">&lt;see langword="WaitSleepJoin" /&gt;</ph> thread state.</source>
          <target state="translated">Interrompt un thread dont l'état est <ph id="ph1">&lt;see langword="WaitSleepJoin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">Si ce thread n’est pas actuellement bloqué en attente, de veille ou d’état de jointure, il sera interrompu lorsqu’elle commence ensuite à bloquer.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source><ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> est levée dans le thread interrompu, mais pas jusqu'à ce que le thread se bloque.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">Si le thread n’est jamais bloqué, l’exception n’est jamais levée, et par conséquent, le thread peut se terminer sans jamais être interrompu.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</source>
          <target state="translated">L’exemple de code suivant illustre le comportement d’un thread en cours d’exécution lorsqu’il est interrompu, puis bloqué.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Interrupt">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">L'appelant n'a pas de <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph> appropriée.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>for advanced operations on threads.</source>
          <target state="translated">pour des opérations avancées sur les threads.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsAlive">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">Obtient une valeur indiquant l'état de l'exécution du thread actuel.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsAlive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread has been started and has not terminated normally or aborted; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si ce thread a été démarré mais ne s'est pas arrêté normalement ou s'il a été abandonné ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsBackground">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">Obtient ou définit une valeur indiquant si le thread est un thread d'arrière-plan ou non.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread is or is to become a background thread; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si ce thread est ou doit devenir un thread d'arrière-plan ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">Un thread est un thread d’arrière-plan ou un thread de premier plan.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">Threads d’arrière-plan sont identiques aux threads de premier plan, à ceci près que les threads d’arrière-plan n’empêchent pas d’un processus à partir de la fin d’exécution.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">Une fois que tous les threads de premier plan appartenant à un processus sont terminés, le common language runtime termine le processus.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">Les threads d’arrière-plan restants sont arrêtés et ne se terminent pas.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>By default, the following threads execute in the foreground (that is, their <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>):</source>
          <target state="translated">Par défaut, les threads suivants s’exécutent au premier plan (autrement dit, leurs <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> propriété renvoie <ph id="ph2">`false`</ph>) :</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The primary thread (or main application thread).</source>
          <target state="translated">Le thread principal (ou le thread d’application principal).</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>All threads created by calling a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class constructor.</source>
          <target state="translated">Tous les threads créés en appelant un <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructeur de classe.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>By default, the following threads execute in the background  (that is, their <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>):</source>
          <target state="translated">Par défaut, les threads suivants s’exécutent en arrière-plan (autrement dit, leurs <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> propriété renvoie <ph id="ph2">`true`</ph>) :</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">Thread de pool de threads, qui sont un pool de threads de travail géré par le runtime.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class.</source>
          <target state="translated">Vous pouvez configurer le travail de planification et de pool de thread sur les threads du pool à l’aide de la <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">Opérations asynchrones basées sur les tâches s’exécutent automatiquement sur les threads du pool.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">Tous les threads qui entrent dans l’environnement d’exécution managé à partir de code non managé.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The following example contrasts the behavior of foreground and background threads.</source>
          <target state="translated">L’exemple suivant compare le comportement des threads de premier plan et d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>It creates a foreground thread and a background thread.</source>
          <target state="translated">Il crée un thread de premier plan et d’un thread d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The foreground thread keeps the process running until completes its <ph id="ph1">`for`</ph> loop and terminates.</source>
          <target state="translated">Le thread de premier plan maintient le processus en cours d’exécution jusqu'à ce que se termine son <ph id="ph1">`for`</ph> boucle et s’arrête.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</source>
          <target state="translated">Toutefois, comme le montre la sortie de l’exemple, étant donné que le thread de premier plan a terminé son exécution, le processus est arrêté avant que le thread d’arrière-plan a terminé son exécution.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsBackground">
          <source>The thread is dead.</source>
          <target state="translated">Le thread est inactif.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">Obtient une valeur indiquant si un thread appartient au pool de threads managés ou non.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread belongs to the managed thread pool; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si ce thread appartient au pool de threads managés ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/docs/standard/threading/the-managed-thread-pool.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>le Pool de threads géré<ept id="p1">](~/docs/standard/threading/the-managed-thread-pool.md)</ept>.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>The following code example shows how to determine whether a thread is from the thread pool.</source>
          <target state="translated">L’exemple de code suivant montre comment déterminer si un thread est dans le pool de threads.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Blocks the calling thread until the thread represented by this instance terminates.</source>
          <target state="translated">Bloque le thread appelant jusqu’à l’arrêt du thread représenté par cette instance.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <ph id="ph1">&lt;see langword="SendMessage" /&gt;</ph> pumping.</source>
          <target state="translated">Bloque le thread appelant jusqu’à ce que le thread représenté par cette instance s’arrête, tout en continuant d’exécuter le pompage COM et <ph id="ph1">&lt;see langword="SendMessage" /&gt;</ph> standard.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que le thread dont <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> méthode est appelée est terminée.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">Utilisez cette méthode pour vous assurer qu’un thread a été arrêté.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">L’appelant sera indéfiniment bloqué si le thread n’arrête pas.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block until <ph id="ph5">`Thread2`</ph> has completed.</source>
          <target state="translated">Dans l’exemple suivant, la <ph id="ph1">`Thread1`</ph> thread appelle le <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> méthode de <ph id="ph3">`Thread2`</ph>, ce qui entraîne la <ph id="ph4">`Thread1`</ph> pour bloquer jusqu'à ce que <ph id="ph5">`Thread2`</ph> est terminée.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Si le thread est déjà arrêté lorsque <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> est appelée, la méthode retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>You should never call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object that represents the current thread from the current thread.</source>
          <target state="translated">Vous ne devez jamais appeler le <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> objet qui représente le thread actuel du thread actuel.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,</source>
          <target state="translated">Ainsi, votre application se bloque, car le thread en cours attend indéfiniment, à elle-même</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>This method changes the state of the calling thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Cette méthode modifie l’état du thread appelant pour inclure <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">Vous ne pouvez pas appeler <ph id="ph1">`Join`</ph> sur un thread qui se trouve dans le <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>The caller attempted to join a thread that is in the <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph> state.</source>
          <target state="translated">L’appelant a tenté de joindre un thread dont l’état est <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">Le thread est interrompu lors de l’attente.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">Nombre de millisecondes à attendre l'arrêt du thread.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Bloque le thread appelant jusqu'à ce que le thread représenté par cette instance s'arrête ou que la durée spécifiée soit écoulée, tout en continuant d'exécuter le pompage COM et SendMessage standard.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the thread has terminated; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the thread has not terminated after the amount of time specified by the <ph id="ph3">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le thread s'est arrêté ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> s'il ne s'est pas arrêté après l'expiration du délai spécifié par le paramètre <ph id="ph3">&lt;paramref name="millisecondsTimeout" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.Int32%29&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.Int32%29&gt;</ph> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que soit le thread dont <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> méthode est appelée est terminée ou l’intervalle de délai d’attente est écoulé.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block either until <ph id="ph5">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">Dans l’exemple suivant, la <ph id="ph1">`Thread1`</ph> thread appelle le <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> méthode de <ph id="ph3">`Thread2`</ph>, ce qui entraîne la <ph id="ph4">`Thread1`</ph> pour bloquer jusqu'à <ph id="ph5">`Thread2`</ph> terminée ou 2 secondes.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method behaves identically to the <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> method overload, except for the return value.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> est spécifié pour le <ph id="ph2">`millisecondsTimeout`</ph> paramètre, cette méthode se comporte comme la <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> la surcharge de méthode, à l’exception de la valeur de retour.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Si le thread est déjà arrêté lorsque <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> est appelée, la méthode retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>This method changes the state of the calling thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Cette méthode modifie l’état du thread appelant pour inclure <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">Vous ne pouvez pas appeler <ph id="ph1">`Join`</ph> sur un thread qui se trouve dans le <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est négative et n’est pas égale à <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> en millisecondes.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The thread has not been started.</source>
          <target state="translated">Le thread n’a pas été démarré.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> ayant pour valeur la durée à attendre l'arrêt du thread.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Bloque le thread appelant jusqu'à ce que le thread représenté par cette instance s'arrête ou que la durée spécifiée soit écoulée, tout en continuant d'exécuter le pompage COM et SendMessage standard.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the thread terminated; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the thread has not terminated after the amount of time specified by the <ph id="ph3">&lt;paramref name="timeout" /&gt;</ph> parameter has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le thread s'est arrêté ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> s'il ne s'est pas arrêté après l'expiration du délai spécifié par le paramètre <ph id="ph3">&lt;paramref name="timeout" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.TimeSpan%29&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.TimeSpan%29&gt;</ph> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que soit le thread dont <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> méthode est appelée est terminée ou l’intervalle de délai d’attente est écoulé.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block either until <ph id="ph5">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">Dans l’exemple suivant, la <ph id="ph1">`Thread1`</ph> thread appelle le <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> méthode de <ph id="ph3">`Thread2`</ph>, ce qui entraîne la <ph id="ph4">`Thread1`</ph> pour bloquer jusqu'à <ph id="ph5">`Thread2`</ph> terminée ou 2 secondes.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> is specified for <ph id="ph2">`timeout`</ph>, this method behaves identically to the <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> method overload, except for the return value.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> est spécifiée pour <ph id="ph2">`timeout`</ph>, cette méthode se comporte comme la <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> la surcharge de méthode, à l’exception de la valeur de retour.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Si le thread est déjà arrêté lorsque <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> est appelée, la méthode retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>This method changes the state of the current thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Cette méthode modifie l’état du thread actuel pour inclure <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">Vous ne pouvez pas appeler <ph id="ph1">`Join`</ph> sur un thread qui se trouve dans le <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The following code example demonstrates how to use a <ph id="ph1">`TimeSpan`</ph> value with the <ph id="ph2">`Join`</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser un <ph id="ph1">`TimeSpan`</ph> valeur avec le <ph id="ph2">`Join`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds, or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est négative et n’est pas égale à <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> en millisecondes, ou est supérieure à <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> millisecondes.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The caller attempted to join a thread that is in the <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph> state.</source>
          <target state="translated">L’appelant a tenté de joindre un thread dont l’état est <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">Obtient un identificateur unique pour le thread managé actuel.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">Entier représentant un identificateur unique pour ce thread managé.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>A thread's <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">D’un thread <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> fait Office de valeur de propriété pour identifier de façon unique ce thread dans son processus.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>The value of the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">La valeur de la <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> propriété ne varie pas au fil du temps, même si le code non managé qui héberge le common language runtime implémente le thread comme une fibre.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.MemoryBarrier">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <ph id="ph1">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph> execute after memory accesses that follow the call to <ph id="ph2">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph>.</source>
          <target state="translated">Synchronise l'accès à la mémoire comme suit : le processeur qui exécute le thread actuel ne peut pas réorganiser les instructions de sorte que les accès à la mémoire antérieurs à l'appel de <ph id="ph1">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph> s'exécutent après les accès à la mémoire postérieurs à l'appel de <ph id="ph2">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.MemoryBarrier">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.MemoryBarrier%2A&gt;</ph> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.MemoryBarrier%2A&gt;</ph> est requis uniquement sur les systèmes multiprocesseurs avec une faible mémoire tri (par exemple, un système employant plusieurs processeurs Intel Itanium).</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.MemoryBarrier">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier ways to synchronize data.</source>
          <target state="translated">La plupart des cas, le langage c# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction, ou la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe fournir plus simples pour synchroniser les données.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Name">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">Obtient ou définit le nom du thread.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>A string containing the name of the thread, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no name was set.</source>
          <target state="translated">Chaîne contenant le nom du thread ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si aucun nom n'a été défini.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>This property is write-once.</source>
          <target state="translated">Cette propriété est en écriture-une fois.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>Because the default value of a thread's <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> property is <ph id="ph2">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Étant donné que la valeur par défaut d’un thread <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> propriété <ph id="ph2">`null`</ph>, vous pouvez déterminer si un nom a déjà été explicitement affecté au thread en le comparant avec <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>The string assigned to the <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> property can include any Unicode character.</source>
          <target state="translated">La chaîne assignée à la <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> propriété peut inclure n’importe quel caractère Unicode.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>The following example shows how to name a thread.</source>
          <target state="translated">L’exemple suivant montre comment nommer un thread.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Name">
          <source>A set operation was requested, but the <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property has already been set.</source>
          <target state="translated">Une opération ensembliste a été demandée, mais la propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> a déjà été définie.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">Obtient ou définit une valeur indiquant la priorité de planification d'un thread.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Threading.ThreadPriority.Normal" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see cref="F:System.Threading.ThreadPriority.Normal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>A thread can be assigned any one of the following priority <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> values:</source>
          <target state="translated">Un thread peut être affecté à l’un de l’ordre de priorité suivant <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> valeurs :</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">Systèmes d’exploitation ne doivent pas respecter la priorité d’un thread.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>The following example shows the result of changing the priority of a thread.</source>
          <target state="translated">L’exemple suivant montre le résultat de la modification de la priorité d’un thread.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Three threads are created, the priority of one thread is set to <ph id="ph1">&lt;xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType&gt;</ph>, and the priority of a second is set to <ph id="ph2">&lt;xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Trois threads sont créés, la priorité d’un thread est définie sur <ph id="ph1">&lt;xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType&gt;</ph>, et la priorité de seconde est définie sur <ph id="ph2">&lt;xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Each thread increments a variable in a <ph id="ph1">`while`</ph> loop and runs for a set time.</source>
          <target state="translated">Chaque thread incrémente une variable dans un <ph id="ph1">`while`</ph> boucle et s’exécute pendant une période définie.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>The thread has reached a final state, such as <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Aborted" /&gt;</ph>.</source>
          <target state="translated">Le thread a atteint un état final, tel que <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Aborted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>The value specified for a set operation is not a valid <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph> value.</source>
          <target state="translated">La valeur spécifiée pour une opération ensembliste n'est pas une valeur <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>Cancels an <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Abort(System.Object)" /&gt;</ph> requested for the current thread.</source>
          <target state="translated">Annule un <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Abort(System.Object)" /&gt;</ph> demandé pour le thread actuel.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">Cette méthode peut être appelée uniquement par du code avec les autorisations appropriées.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>.</source>
          <target state="translated">Lorsqu’un appel est effectué à <ph id="ph1">`Abort`</ph> pour terminer un thread, le système lève un <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> est une exception spéciale qui peut être interceptée par le code d’application, mais qui est levée de nouveau à la fin du bloc catch, sauf si <ph id="ph2">`ResetAbort`</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> Annule la demande d’abandon et empêche le <ph id="ph2">`ThreadAbortException`</ph> à partir de l’arrêt du thread.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>See <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> for an example that demonstrates calling the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> pour obtenir un exemple qui montre comment appeler le <ph id="ph2">`ResetAbort`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">.NET Core uniquement : ce membre n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">&lt;see langword="Abort" /&gt;</ph> was not invoked on the current thread.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Abort" /&gt;</ph> n'a pas été appelé sur le thread en cours.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">L’appelant n’a pas l’autorisation de sécurité requise pour le thread actuel.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>for advanced operations on threads.</source>
          <target state="translated">pour des opérations avancées sur les threads.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">Reprend un thread qui a été suspendu.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Do not use the <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> methods to synchronize the activities of threads.</source>
          <target state="translated">N’utilisez pas le <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> méthodes pour synchroniser les activités de threads.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">Vous ne disposez d’aucun moyen de savoir quel code un thread s’exécute lorsque vous l’interrompez.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> might be blocked.</source>
          <target state="translated">Si vous suspendez un thread pendant qu’il détient des verrous pendant une évaluation des autorisations de sécurité, d’autres threads dans le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> risque d’être bloqué.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that attempt to use that class are blocked.</source>
          <target state="translated">Si vous suspendez un thread pendant qu’il s’exécute un constructeur de classe, d’autres threads dans le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> qui tentent d’utiliser cette classe sera bloqué.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Blocages peuvent se produire très facilement.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">.NET Core uniquement : ce membre n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">Le thread n’a pas été démarré, est inactif ou n’est pas dans l’état interrompu.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">L'appelant n'a pas de <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph> appropriée.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>for advanced operations on threads.</source>
          <target state="translated">pour des opérations avancées sur les threads.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The new apartment state.</source>
          <target state="translated">Nouvel état de cloisonnement.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Définit l'état de cloisonnement d'un thread avant qu'il ne soit démarré.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>New threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">Les nouveaux threads sont initialisés en tant que <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> si leur état de cloisonnement n’a pas été défini avant leur démarrage.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">État de cloisonnement doit être défini avant de démarre un thread.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">Le thread d’application principal est initialisé à <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> par défaut.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The only way to set the apartment state of the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> is to apply the <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> attribute to the entry point method.</source>
          <target state="translated">La seule façon de définir l’état de cloisonnement du thread d’application principal à <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> consiste à appliquer le <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> d’attribut à la méthode de point d’entrée.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method, along with the <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> (méthode), avec la <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> (méthode) et le <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> (méthode), remplace le <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The code example creates a thread.</source>
          <target state="translated">L’exemple de code crée un thread.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Avant que le thread est démarré, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> affiche la première <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> état et <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> modifie l’état à <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthode retourne ensuite <ph id="ph2">`false`</ph> lorsque vous tentez de modifier l’état à <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> car l’état de cloisonnement est déjà définie.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Si la même opération avait été tentée avec <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> aurait été levée.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Une fois que le thread est démarré, le <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthode est utilisée à nouveau.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Cette fois, elle lève une exception <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> , car le thread a déjà été démarré.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>.NET Core only: This member is not supported on the macOS and Linux platforms.</source>
          <target state="translated">.NET Core uniquement : ce membre n’est pas pris en charge sur les plateformes macOS et Linux.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;paramref name="state" /&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="state" /&gt;</ph> n'est pas un état de cloisonnement valide.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The thread has already been started.</source>
          <target state="translated">Le thread a déjà été démarré.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">L’état de cloisonnement a déjà été initialisé.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> object to be applied to the current thread.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> à appliquer au thread actuel.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>Applies a captured <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> to the current thread.</source>
          <target state="translated">Applique une <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> capturée au thread actuel.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>This method is no longer supported.</source>
          <target state="translated">Cette méthode n’est plus pris en charge.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>In all cases.</source>
          <target state="translated">Dans tous les cas.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> in which to set the value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> dans lequel définir la valeur.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The value to be set.</source>
          <target state="translated">Valeur à définir.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">Définit les données dans l'emplacement spécifié sur le thread en cours d'exécution, pour le domaine actuel de ce thread.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>For better performance, use fields marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut) et emplacements de données.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de TLS, consultez <bpt id="p1">[</bpt>stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> object has been reclaimed by garbage collection.</source>
          <target state="translated">Le thread peut allouer un emplacement de données dans le magasin de données, stocker et récupérer des données de valeur dans l’emplacement et libérer de l’emplacement pour réutilisation après la fin de la procédure de thread et le <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> objet a été récupéré par le garbage collection.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Emplacements de données sont uniques pour chaque thread.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Aucun autre thread (pas même un thread enfant) ne peut obtenir ces données.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SetData%2A&gt;</ph> is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SetData%2A&gt;</ph> est un <ph id="ph2">`Shared`</ph> méthode s’applique toujours au thread en cours d’exécution, même si vous appelez à l’aide d’une variable qui fait référence à un autre thread.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">Pour éviter toute confusion, utilisez le nom de classe lorsque vous appelez <ph id="ph1">`Shared`</ph> méthodes : <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>This section contains two code examples.</source>
          <target state="translated">Cette section contient deux exemples de code.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">Le premier exemple montre comment utiliser un champ qui est marqué avec la <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribut pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">Le deuxième exemple montre comment utiliser un emplacement de données pour effectuer la même opération.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Premier exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un champ qui est marqué avec <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> pour contenir des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Deuxième exemple<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Suspend le thread actuel pendant la durée spécifiée.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">Nombre de millisecondes pendant lesquelles le thread est suspendu.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If the value of the <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Si la valeur de l’argument <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> est égale à zéro, le thread abandonne le reste de sa tranche de temps à n’importe quel thread de priorité égale prêt à être exécuté.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">S'il n'existe pas d'autres threads de priorité égale prêts à être exécutés, l'exécution du thread actuel n'est pas suspendue.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">Suspend le thread actuel pendant le nombre spécifié de millisecondes.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">Le thread n’est plus planifié pour l’exécution par le système d’exploitation pendant la durée spécifiée.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method changes the state of the thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Cette méthode modifie l’état du thread pour inclure <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>You can specify <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Vous pouvez spécifier <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> pour la <ph id="ph2">`millisecondsTimeout`</ph> paramètre d’interruption du thread indéfiniment.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>However, we recommend that you use other <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> classes such as <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> instead to sychronize threads or manage resources.</source>
          <target state="translated">Toutefois, nous vous recommandons d’utiliser des autres <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> classes telles que <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> à la place pour synchroniser des threads ou gérer les ressources.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">Les battements d’horloge système à un rythme spécifique appelé la résolution de l’horloge.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">Le délai d’attente réel ne soient pas exactement dans le délai spécifié, car le délai d’attente spécifié est ajustée pour coïncider avec battements d’horloge.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">Pour plus d’informations sur la résolution de l’horloge et le temps d’attente, consultez la <bpt id="p1">[</bpt>fonction de mise en veille<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">Cette méthode appelle la <bpt id="p1">[</bpt>mise en veille de la fonction<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> à partir de l’API du système de Windows.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Cette méthode n’effectue pas de standard pompage COM et SendMessage.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If you need to sleep on a thread that has <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method that specifies a timeout interval.</source>
          <target state="translated">Si vous devez mettre en veille sur un thread qui a <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, mais que vous souhaitez effectuer standard pompage COM et SendMessage, envisagez d’utiliser une des surcharges de la <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> méthode qui spécifie un intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method to block the application's main thread.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> méthode pour bloquer le thread principal de l’application.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The time-out value is negative and is not equal to <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">La valeur du délai d’attente est négative et n’est pas égale à <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">Durée pendant laquelle le thread est suspendu.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If the value of the <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> argument is <ph id="ph1">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Si la valeur de l’argument <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> est <ph id="ph1">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph>, le thread abandonne le reste de sa tranche de temps à n’importe quel thread de priorité égale prêt à être exécuté.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">S'il n'existe pas d'autres threads de priorité égale prêts à être exécutés, l'exécution du thread actuel n'est pas suspendue.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Suspend le thread actuel pendant la durée spécifiée.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">Le thread n’est plus planifié pour l’exécution par le système d’exploitation pendant la durée spécifiée.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This method changes the state of the thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Cette méthode modifie l’état du thread pour inclure <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>You can specify <ph id="ph1">&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Vous pouvez spécifier <ph id="ph1">&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType&gt;</ph> pour la <ph id="ph2">`timeout`</ph> paramètre d’interruption du thread indéfiniment.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>However, we recommend that you use other <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> classes such as <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> instead to sychronize threads or manage resources.</source>
          <target state="translated">Toutefois, nous vous recommandons d’utiliser des autres <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> classes telles que <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> à la place pour synchroniser des threads ou gérer les ressources.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This overload of <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> uses the total number of whole milliseconds in <ph id="ph2">`timeout`</ph>.</source>
          <target state="translated">Cette surcharge de <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> utilise le nombre total de millisecondes entières dans <ph id="ph2">`timeout`</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">Millisecondes fractionnaires sont ignorés.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Cette méthode n’effectue pas de standard pompage COM et SendMessage.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If you need to sleep on a thread that has <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method that specifies a timeout interval.</source>
          <target state="translated">Si vous devez mettre en veille sur un thread qui a <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, mais que vous souhaitez effectuer standard pompage COM et SendMessage, envisagez d’utiliser une des surcharges de la <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> méthode qui spécifie un intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%28System.TimeSpan%29&gt;</ph> method overload to block the application's main thread five times, for two seconds each time.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%28System.TimeSpan%29&gt;</ph> surcharge de méthode pour bloquer des cinq fois thread principal de l’application de deux secondes.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds, or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est négative et n’est pas égale à <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> en millisecondes, ou est supérieure à <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> millisecondes.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">Entier signé 32 bits qui définit le temps pendant lequel un thread doit attendre.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Causes a thread to wait the number of times defined by the <ph id="ph1">&lt;paramref name="iterations" /&gt;</ph> parameter.</source>
          <target state="translated">Provoque l'attente d'un thread pendant le nombre de fois défini par le paramètre <ph id="ph1">&lt;paramref name="iterations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> method is useful for implementing locks.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> méthode est utile pour implémenter les verrouillages.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Classes in the .NET Framework, such as <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, use this method internally.</source>
          <target state="translated">Classes dans le .NET Framework, telles que <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, utilisez cette méthode en interne.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph2">`iterations`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> place essentiellement le processeur dans une boucle très serrée, avec le nombre de boucles spécifié par le <ph id="ph2">`iterations`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">Par conséquent, la durée de l’attente dépend de la vitesse du processeur.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Contrast this with the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method.</source>
          <target state="translated">Ceci contraste avec le <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>A thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">Un thread qui appelle <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> génère le reste de sa tranche de temps processeur, même si l’intervalle spécifié est égal à zéro.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Specifying a non-zero interval for <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">Spécification d’un intervalle de zéro pour <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> supprime le thread d’examen par le Planificateur de threads jusqu'à ce que l’intervalle de temps écoulé.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> is not generally useful for ordinary applications.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> est généralement pas utile aux applications ordinaires.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> or a statement that wraps <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">`lock`</ph> in C# or <ph id="ph4">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">Dans la plupart des cas, vous devez utiliser les classes de synchronisation fournies par le .NET Framework ; par exemple, appeler <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> ou une instruction qui encapsule <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">`lock`</ph> en c# ou <ph id="ph4">`SyncLock`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> method in your loop.</source>
          <target state="translated">Dans les rares cas où il est avantageux d’éviter un changement de contexte, par exemple lorsque vous savez qu’un changement d’état est imminent, effectuez un appel à la <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> méthode dans la boucle.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The code <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">Le code <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> s’exécute est conçu pour éviter les problèmes qui peuvent se produire sur les ordinateurs avec plusieurs processeurs.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> prevents processor starvation in certain situations.</source>
          <target state="translated">Par exemple, sur les ordinateurs avec plusieurs processeurs Intel utilisant la technologie Hyper-Threading, <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> empêche la privation de processeur dans certaines situations.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Causes a thread to be scheduled for execution.</source>
          <target state="translated">Entraîne la planification de l'exécution d'un thread.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>Causes the operating system to change the state of the current instance to <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>.</source>
          <target state="translated">Provoque le changement, par le système d'exploitation, de l'état de l'instance actuelle en <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Once a thread is in the <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> state, the operating system can schedule it for execution.</source>
          <target state="translated">Une fois qu’un thread se trouve dans le <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> d’état, le système d’exploitation peut planifier son exécution.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>The thread begins executing at the first line of the method represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate supplied to the thread constructor.</source>
          <target state="translated">Le thread commence à s’exécuter à la première ligne de la méthode représentée par le <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> délégué fourni au constructeur de thread.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Note that the call to <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> does not block the calling thread.</source>
          <target state="translated">Notez que l’appel à <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> ne bloque pas le thread appelant.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>If this overload is used with a thread created using a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">Si cette surcharge est utilisée avec un thread créé à l’aide un <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> déléguer, <ph id="ph2">`null`</ph> est passé à la méthode exécutée par le thread.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Une fois que le thread s’arrête, il ne peut pas être redémarré par un autre appel à <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>The following example creates and starts a thread.</source>
          <target state="translated">L’exemple suivant crée et démarre un thread.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>The thread has already been started.</source>
          <target state="translated">Le thread a déjà été démarré.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">La mémoire disponible est insuffisante pour démarrer ce thread.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">Objet contenant les données que la méthode exécutée par le thread doit utiliser.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Causes the operating system to change the state of the current instance to <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">Provoque le changement, par le système d'exploitation, de l'état de l'instance actuelle en <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>, et fournit éventuellement un objet contenant les données que la méthode exécutée par le thread doit utiliser.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Once a thread is in the <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> state, the operating system can schedule it for execution.</source>
          <target state="translated">Une fois qu’un thread se trouve dans le <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> d’état, le système d’exploitation peut planifier son exécution.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The thread begins executing at the first line of the method represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate supplied to the thread constructor.</source>
          <target state="translated">Le thread commence à s’exécuter à la première ligne de la méthode représentée par le <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> délégué fourni au constructeur de thread.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Note that the call to <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> does not block the calling thread.</source>
          <target state="translated">Notez que l’appel à <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> ne bloque pas le thread appelant.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Une fois que le thread s’arrête, il ne peut pas être redémarré par un autre appel à <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>This overload and the <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">Cette surcharge et la <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> délégué facilitent l’utilisation passer des données à une procédure de thread, mais la technique n’est pas de type sécurisé car n’importe quel objet peut être passé à cette surcharge.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">Une façon plus fiable pour transmettre des données à une procédure de thread est de placer la procédure de thread et les champs de données dans un objet de travail.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>création de Threads et passage de données au moment de démarrer<ept id="p1">](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)</ept>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate with a static method and an instance method.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> délégué avec une méthode statique et une méthode d’instance.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The thread has already been started.</source>
          <target state="translated">Le thread a déjà été démarré.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">La mémoire disponible est insuffisante pour démarrer ce thread.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>This thread was created using a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate instead of a <ph id="ph2">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph> delegate.</source>
          <target state="translated">Ce thread a été créé à l’aide d’un délégué <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> au lieu d’un délégué <ph id="ph2">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">Suspend le thread ou, s'il est déjà suspendu, n'a aucun effet.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">Si le thread est déjà suspendu, cette méthode n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Do not use the <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> methods to synchronize the activities of threads.</source>
          <target state="translated">N’utilisez pas le <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> méthodes pour synchroniser les activités de threads.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">Vous ne disposez d’aucun moyen de savoir quel code un thread s’exécute lorsque vous l’interrompez.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> might be blocked.</source>
          <target state="translated">Si vous suspendez un thread pendant qu’il détient des verrous pendant une évaluation des autorisations de sécurité, d’autres threads dans le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> risque d’être bloqué.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that attempt to use that class are blocked.</source>
          <target state="translated">Si vous suspendez un thread pendant qu’il s’exécute un constructeur de classe, d’autres threads dans le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> qui tentent d’utiliser cette classe sera bloqué.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Blocages peuvent se produire très facilement.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">.NET Core uniquement : ce membre n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">Le thread n’a pas été démarré ou est inactif.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">L'appelant n'a pas de <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph> appropriée.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>for advanced operations on threads.</source>
          <target state="translated">pour des opérations avancées sur les threads.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Réservé à un usage ultérieur.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Doit être IID_NULL.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Tableau passé des noms à mapper.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Compte des noms à mapper.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexte des paramètres régionaux dans lequel interpréter les noms.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L’accès à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Informations de type à retourner.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificateur des paramètres régionaux pour les informations de type.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Reçoit un pointeur vers l'objet d'informations de type demandé.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L’accès à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L’accès à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifie le membre.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Réservé à un usage ultérieur.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Doit être IID_NULL.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexte des paramètres régionaux dans lequel interpréter les arguments.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Indicateurs décrivant le contexte de l'appel.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Pointeur vers l'emplacement où le résultat doit être stocké.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Pointeur vers une structure qui contient les informations sur les exceptions.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Index du premier argument comportant une erreur.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::Invoke`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L’accès à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ThreadState">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">Obtient une valeur contenant les états du thread actuel.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ThreadState" /&gt;</ph> values indicating the state of the current thread.</source>
          <target state="translated">Une des valeurs <ph id="ph1">&lt;see cref="T:System.Threading.ThreadState" /&gt;</ph> indiquant l'état du thread actuel.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The initial value is <ph id="ph1">&lt;see langword="Unstarted" /&gt;</ph>.</source>
          <target state="translated">La valeur initiale est <ph id="ph1">&lt;see langword="Unstarted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property provides more specific information than the <ph id="ph2">&lt;xref:System.Threading.Thread.IsAlive%2A&gt;</ph> property.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> propriété fournit des informations plus spécifiques que le <ph id="ph2">&lt;xref:System.Threading.Thread.IsAlive%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">État du thread n’est utile dans les scénarios de débogage.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">Votre code ne doit jamais utiliser l’état des threads pour synchroniser les activités des threads.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The following code example demonstrates accessing the <ph id="ph1">`ThreadState`</ph> of a thread.</source>
          <target state="translated">L’exemple de code suivant illustre l’accès à la <ph id="ph1">`ThreadState`</ph> d’un thread.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The new apartment state.</source>
          <target state="translated">Nouvel état de cloisonnement.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Définit l'état de cloisonnement d'un thread avant qu'il ne soit démarré.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the apartment state is set; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'état de cloisonnement est défini ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>New threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">Les nouveaux threads sont initialisés en tant que <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> si leur état de cloisonnement n’a pas été défini avant leur démarrage.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">État de cloisonnement doit être défini avant de démarre un thread.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">Le thread d’application principal est initialisé à <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> par défaut.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The only way to set the apartment state of the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> is to apply the <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> attribute to the entry point method.</source>
          <target state="translated">La seule façon de définir l’état de cloisonnement du thread d’application principal à <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> consiste à appliquer le <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> d’attribut à la méthode de point d’entrée.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, along with the <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> (méthode), avec la <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> (méthode) et le <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> (méthode), remplace le <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The code example creates a thread.</source>
          <target state="translated">L’exemple de code crée un thread.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Avant que le thread est démarré, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> affiche la première <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> état et <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> modifie l’état à <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthode retourne ensuite <ph id="ph2">`false`</ph> lorsque vous tentez de modifier l’état à <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> car l’état de cloisonnement est déjà définie.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Si la même opération avait été tentée avec <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> aurait été levée.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Une fois que le thread est démarré, le <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> méthode est utilisée à nouveau.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Cette fois, elle lève une exception <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> , car le thread a déjà été démarré.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;paramref name="state" /&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="state" /&gt;</ph> n'est pas un état de cloisonnement valide.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The thread has already been started.</source>
          <target state="translated">Le thread a déjà été démarré.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The field to be read.</source>
          <target state="translated">Champ à lire.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lit la valeur d'un champ.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Dernière valeur écrite dans le champ par un processeur.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Champ dans lequel la valeur doit être écrite.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>The value to be written.</source>
          <target state="translated">Valeur à écrire.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> sont des cas spéciaux de la synchronisation.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">Dans des circonstances normales, C# <ph id="ph1">`lock`</ph> instruction, Visual Basic <ph id="ph2">`SyncLock`</ph> instruction et la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe de fournir des alternatives plus simples.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">Sur un système multiprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Vous devrez peut-être vider les caches de processeur.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Même sur un système monoprocesseur, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> vous assurer qu’une valeur lues ou écrite dans la mémoire et pas mis en cache (par exemple, dans un Registre de processeur).</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ qui peut être modifié par un autre thread, ou par le matériel.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Appel de cette méthode affecte uniquement l’accès de la mémoire.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En c#, à l’aide de la <ph id="ph1">`volatile`</ph> modificateur sur un champ garantit que tous les accès à ce champ utilisent <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">Oblige le thread appelant à céder l'exécution à un autre thread prêt à s'exécuter sur le processeur actuel.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">Le système d'exploitation sélectionne le thread auquel l'exécution doit être cédée.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system switched execution to another thread; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le système d'exploitation a basculé l'exécution vers un autre thread ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">Si cette méthode réussit, le reste de la tranche de temps actuelle du thread est trouvée.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">Le système d’exploitation planifie le thread appelant pour une autre tranche de temps, en fonction de sa priorité et l’état des autres threads qui sont disponibles pour l’exécuter.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">Génération de résultats est limitée au processeur qui exécute le thread appelant.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">Le système d’exploitation ne bascule pas de l’exécution à un autre processeur, même si ce processeur est inactif ou exécute un thread de priorité inférieure.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si aucun autre thread qui sont prêts à exécuter sur le processeur actuel, le système d’exploitation ne suspend pas l’exécution, et cette méthode retourne <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">Cette méthode est équivalente à l’appel à l’aide de la plateforme pour appeler des Win32 natif <ph id="ph1">`SwitchToThread`</ph> (fonction).</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>You should call the <ph id="ph1">&lt;xref:System.Threading.Thread.Yield%2A&gt;</ph> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">Vous devez appeler la <ph id="ph1">&lt;xref:System.Threading.Thread.Yield%2A&gt;</ph> appeler de méthode au lieu d’utiliser la plateforme, car l’appel de plateforme ignore tout comportement de thread personnalisé l’hôte a demandé.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>