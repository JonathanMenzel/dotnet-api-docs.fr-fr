<Type Name="ManualResetEvent" FullName="System.Threading.ManualResetEvent">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6bd57be7d0b7a3e06e014afa452e4dadda84883c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30527803" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ManualResetEvent : System.Threading.EventWaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ManualResetEvent extends System.Threading.EventWaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ManualResetEvent" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ManualResetEvent&#xA;Inherits EventWaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class ManualResetEvent sealed : System::Threading::EventWaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.EventWaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Avertit un ou plusieurs threads en attente qu'un événement s'est produit. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le .NET Framework version 2.0, <xref:System.Threading.ManualResetEvent> dérive de la nouvelle <xref:System.Threading.EventWaitHandle> classe. A <xref:System.Threading.ManualResetEvent> est fonctionnellement équivalent à un <xref:System.Threading.EventWaitHandle> créé avec <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Contrairement à la <xref:System.Threading.ManualResetEvent> (classe), la <xref:System.Threading.EventWaitHandle> classe fournit l’accès aux événements de synchronisation système nommé.  
  
 <xref:System.Threading.ManualResetEvent> permet aux threads de communiquer entre eux par la signalisation. En règle générale, cette communication concerne une tâche qu’un thread doit terminer avant de procéder des autres threads.  
  
 Lorsqu’un thread commence une activité qui doit s’achever avant les autres threads puissent s’exécuter, il appelle <xref:System.Threading.EventWaitHandle.Reset%2A> à placer `ManualResetEvent` dans l’état non signalé. Ce thread peut être considéré comme contrôle de le `ManualResetEvent`. Threads qui appellent <xref:System.Threading.WaitHandle.WaitOne%2A> sur la `ManualResetEvent` se bloque, en attendant le signal. Lorsque le thread de contrôle termine l’activité, il appelle <xref:System.Threading.EventWaitHandle.Set%2A> pour signaler que les threads en attente peuvent continuer. Tous les threads en attente sont libérés.  
  
 Une fois qu’il a été signalé, `ManualResetEvent` conserve cet état jusqu'à sa réinitialisation manuelle. Autrement dit, les appels à `WaitOne` retourner immédiatement.  
  
 Vous pouvez contrôler l’état initial d’un `ManualResetEvent` en passant une valeur booléenne au constructeur, `true` si l’état initial est signalé et `false` dans le cas contraire.  
  
 `ManualResetEvent` peut également être utilisé avec le `static` <xref:System.Threading.WaitHandle.WaitAll%2A> et <xref:System.Threading.WaitHandle.WaitAny%2A> méthodes.  
  
 Pour plus d’informations sur les mécanismes de synchronisation de threads, consultez [ManualResetEvent et ManualResetEventSlim](~/docs/standard/threading/manualresetevent-and-manualreseteventslim.md) dans la documentation conceptuelle.  
  
   
  
## Examples  
 L’exemple suivant montre comment <xref:System.Threading.ManualResetEvent> fonctionne. L’exemple commence par un <xref:System.Threading.ManualResetEvent> dans l’état non signalé (autrement dit, `false` est passé au constructeur). L’exemple crée trois threads, chacun se bloquant sur le <xref:System.Threading.ManualResetEvent> en appelant son <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Lorsque l’utilisateur appuie sur le **entrée** de clé, l’exemple appelle la <xref:System.Threading.EventWaitHandle.Set%2A> méthode, ce qui libère les trois threads. Ceci contraste avec le comportement de la <xref:System.Threading.AutoResetEvent> classe, ce qui libère les threads un à la fois, la réinitialisation automatiquement après chaque mise en production.  
  
 En appuyant sur la **entrée** clé montre à nouveau que les <xref:System.Threading.ManualResetEvent> reste dans l’état signalé jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée : l’exemple démarre deux threads supplémentaires. Ces threads ne bloquent pas lorsqu’ils appellent le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode), mais leur exécution jusqu'à son achèvement.  
  
 En appuyant sur la **entrée** clé provoque à nouveau l’exemple appelle la <xref:System.Threading.EventWaitHandle.Reset%2A> (méthode) et pour démarrer un thread de plus, ce qui se bloque lorsqu’il appelle <xref:System.Threading.WaitHandle.WaitOne%2A>. En appuyant sur la **entrée** clé une dernière fois pour appeler <xref:System.Threading.EventWaitHandle.Set%2A> pour libérer le dernier thread et le programme se termine.  
  
 [!code-cpp[System.Threading.ManualResetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ManualResetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/CS/source.cs#1)]
 [!code-vb[System.Threading.ManualResetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Cette classe est thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ManualResetEvent (bool initialState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ManualResetEvent(bool initialState);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> pour définir un état initial signalé ; <see langword="false" /> pour définir un état initial non signalé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ManualResetEvent" /> avec une valeur booléenne indiquant si l'état initial doit être défini comme signalé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’état initial d’un <xref:System.Threading.ManualResetEvent> est signalé (autrement dit, si elle est créée en passant `true` pour `initialState`), les threads qui attendent que le <xref:System.Threading.ManualResetEvent> ne bloquent pas. Si l’état initial est "non signalé", threads se bloquent jusqu'à ce que le <xref:System.Threading.EventWaitHandle.Set%2A> méthode est appelée.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
  </Members>
</Type>