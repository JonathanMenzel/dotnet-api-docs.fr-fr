<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a13a27594fa1d97d7387994076cdc3b3a30d735d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609272" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ca1be-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ca1be-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-102">Le <xref:System.Threading.WaitHandle> classe encapsule des handles de synchronisation Win32 et permet de représenter tous les objets de synchronisation dans le runtime qui permettent plusieurs opérations d’attente.</span><span class="sxs-lookup"><span data-stu-id="ca1be-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="ca1be-103">Pour obtenir une comparaison de handles d’attente avec d’autres objets de synchronisation, consultez [vue d’ensemble des Primitives de synchronisation](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="ca1be-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="ca1be-104">Le <xref:System.Threading.WaitHandle> classe elle-même est abstraite.</span><span class="sxs-lookup"><span data-stu-id="ca1be-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="ca1be-105">Les classes dérivées de <xref:System.Threading.WaitHandle> définissent un mécanisme de signalisation pour indiquer la capture ou la libération d’un accès à une ressource partagée, mais ils utilisent le hérité <xref:System.Threading.WaitHandle> méthodes pour bloquer lors de l’attente pour l’accès à des ressources partagées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="ca1be-106">Les classes dérivées de <xref:System.Threading.WaitHandle> incluent :</span><span class="sxs-lookup"><span data-stu-id="ca1be-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="ca1be-107">La classe <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="ca1be-108">Consultez [mutex](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="ca1be-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="ca1be-109">Le <xref:System.Threading.EventWaitHandle> classe et ses classes dérivées, <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="ca1be-110">Voir [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="ca1be-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="ca1be-111">La classe <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="ca1be-112">Consultez [Semaphore et SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="ca1be-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="ca1be-113">Threads peuvent bloquer un handle d’attente individuels en appelant la méthode d’instance <xref:System.Threading.WaitHandle.WaitOne%2A>, qui est hérité par les classes dérivées de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="ca1be-114">Les classes dérivées de <xref:System.Threading.WaitHandle> diffèrent dans leur affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="ca1be-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="ca1be-115">Handles d’attente d’événement (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, et <xref:System.Threading.ManualResetEvent>) et les sémaphores n’ont pas d’affinité de thread ; n’importe quel thread peut signaler un handle d’attente d’événement ou un sémaphore.</span><span class="sxs-lookup"><span data-stu-id="ca1be-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="ca1be-116">Les mutex, quant à eux, ont une affinité de thread ; le thread qui détient un mutex doit le libérer et une exception est levée si un thread appelle la <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode sur un mutex qu’il ne possède pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="ca1be-117">Étant donné que le <xref:System.Threading.WaitHandle> dérive de la classe <xref:System.MarshalByRefObject>, ces classes peuvent être utilisées pour synchroniser les activités de threads au-delà des limites du domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="ca1be-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="ca1be-118">En plus de ses classes dérivées, la <xref:System.Threading.WaitHandle> classe a un nombre de méthodes statiques qui bloque un thread jusqu'à ce qu’une ou plusieurs objets de synchronisation reçoivent un signal...</span><span class="sxs-lookup"><span data-stu-id="ca1be-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="ca1be-119">Elles incluent notamment :</span><span class="sxs-lookup"><span data-stu-id="ca1be-119">These include:</span></span>  
  
-   <span data-ttu-id="ca1be-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, qui permet à un thread à un handle d’attente de signal et attendre immédiatement un autre.</span><span class="sxs-lookup"><span data-stu-id="ca1be-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="ca1be-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, ce qui permet à un thread d’attendre jusqu'à ce que tous les handles d’attente dans un tableau reçoivent un signal.</span><span class="sxs-lookup"><span data-stu-id="ca1be-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="ca1be-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, ce qui permet à un thread d’attendre jusqu'à ce que l’un d’un jeu spécifié de handles d’attente a été signalé.</span><span class="sxs-lookup"><span data-stu-id="ca1be-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="ca1be-123">Les surcharges de ces méthodes fournissent des intervalles de délai d’attente pour abandonner l’attente et la possibilité de quitter un contexte de synchronisation avant de commencer l’attente, autoriser d’autres threads à utiliser le contexte de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ca1be-124">Ce type implémente le <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="ca1be-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="ca1be-125">Lorsque vous avez fini d’utiliser le type ou un type dérivé de celle-ci, vous devez supprimer il directement ou indirectement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="ca1be-126">Pour supprimer le type directement, appelez sa <xref:System.Threading.WaitHandle.Close%2A> méthode dans un `try` / `catch` bloc.</span><span class="sxs-lookup"><span data-stu-id="ca1be-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="ca1be-127">Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ca1be-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="ca1be-128">Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.</span><span class="sxs-lookup"><span data-stu-id="ca1be-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="ca1be-129"><xref:System.Threading.WaitHandle> implémente la <xref:System.IDisposable.Dispose%2A> modèle.</span><span class="sxs-lookup"><span data-stu-id="ca1be-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="ca1be-130">Consultez [Dispose, modèle](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="ca1be-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="ca1be-131">Lorsque vous dérivez de <xref:System.Threading.WaitHandle>, utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété pour stocker votre handle de système d’exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="ca1be-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="ca1be-132">Vous n’avez pas besoin de remplacer l’élément protégé <xref:System.Threading.WaitHandle.Dispose%2A> (méthode), sauf si vous utilisez des ressources non managées supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="ca1be-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-133">Le code suivant montre l’exemple comment deux threads peuvent effectuent les tâches en arrière-plan lors de la Main thread attend l’achèvement des tâches à l’aide de la méthode statique <xref:System.Threading.WaitHandle.WaitAny%2A> et <xref:System.Threading.WaitHandle.WaitAll%2A> méthodes de la <xref:System.Threading.WaitHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="ca1be-134">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ca1be-134">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-137">Cette méthode est l’implémentation publique de la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> méthode pour la <xref:System.Threading.WaitHandle> classe et ses classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="ca1be-138">Il fournit une implémentation standard qui appelle le `Dispose(Boolean)` surcharge avec un `true` argument, puis appelle le <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ca1be-139">Appelez cette méthode pour libérer toutes les ressources détenues par une instance de `WaitHandle` ou une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="ca1be-140">Une fois que cette méthode est appelée, les références à l’instance actuelle provoquent un comportement non défini.</span><span class="sxs-lookup"><span data-stu-id="ca1be-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-141">Appelez toujours <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> avant de libérer votre dernière référence à la <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ca1be-142">Sinon, les ressources qu’il utilise ne seront pas libérées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="ca1be-143">
            <para>Vous devez substituer la <see langword="Dispose(Boolean)" /> méthode pour libérer les ressources allouées dans les classes dérivées.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-143">
              <para>You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-146">Cette méthode est équivalente à la <xref:System.Threading.WaitHandle.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-147">Appelez toujours <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> avant de libérer votre dernière référence à la <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ca1be-148">Sinon, les ressources qu’il utilise ne seront pas libérées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="ca1be-149">
            <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-149">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-151">Cette méthode est appelée par le <xref:System.Threading.WaitHandle.Close%2A> et <xref:System.Threading.WaitHandle.Dispose> méthodes avec la `explicitDisposing` paramètre défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="ca1be-152">Lorsque le `explicitDisposing` paramètre est `true`, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Threading.WaitHandle> références d’objet.</span><span class="sxs-lookup"><span data-stu-id="ca1be-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="ca1be-153">
            <para>Vous devez substituer la <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> méthode pour libérer les ressources allouées dans les classes dérivées.  Le <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> méthode peut être appelée plusieurs fois par d’autres objets. Lorsque vous substituez cette méthode, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un précédent appel à <see langword="Dispose" /> ou <see langword="Close" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-153">
              <para>You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.  The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects. When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-154">Gets or sets the native operating system handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-154">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ca1be-155">
            <see langword="IntPtr" /> représentant le handle du système d'exploitation natif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-155">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="ca1be-156">La valeur par défaut est celle du champ <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-156">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-157">Affectation d’une nouvelle valeur à la <xref:System.Threading.WaitHandle.Handle%2A> propriété ne ferme pas le handle précédent.</span><span class="sxs-lookup"><span data-stu-id="ca1be-157">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="ca1be-158">Cela peut entraîner une fuite du handle.</span><span class="sxs-lookup"><span data-stu-id="ca1be-158">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="ca1be-159">N’utilisez pas cette propriété dans le .NET Framework version 2.0 ou ultérieure ; utiliser le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété à la place.</span><span class="sxs-lookup"><span data-stu-id="ca1be-159">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="ca1be-160">Définition de cette propriété pour un handle valide définit également la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété, mais en lui affectant <xref:System.Threading.WaitHandle.InvalidHandle> peut entraîner une fuite du handle.</span><span class="sxs-lookup"><span data-stu-id="ca1be-160">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="ca1be-161">Requiert une confiance totale pour l’appelant immédiat définir la valeur de propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-161">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="ca1be-162">Ce membre ne peut pas être défini par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-162">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="ca1be-163">Types dérivés doivent avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> pour définir la valeur de propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-163">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-164">Represents an invalid native operating system handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-164">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="ca1be-165">This field is read-only.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-165">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-166">Utilisé en interne pour initialiser le <xref:System.Threading.WaitHandle.Handle%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="ca1be-166">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="ca1be-167">
            <para>Vous pouvez utiliser cette valeur pour déterminer si le <see cref="P:System.Threading.WaitHandle.Handle" /> propriété contient un handle valide de système d’exploitation natif.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-167">
              <para>You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-168">Gets or sets the native operating system handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-168">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ca1be-169">
            <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> représentant le handle du système d'exploitation natif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-169">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-170">Lorsque vous assignez une nouvelle valeur à la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété, le handle précédent est fermé lorsque le précédent <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objet est collecté.</span><span class="sxs-lookup"><span data-stu-id="ca1be-170">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="ca1be-171">Ne fermez pas manuellement le handle, car il en résulte un <xref:System.ObjectDisposedException> lorsque le <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> essaie de fermer le handle.</span><span class="sxs-lookup"><span data-stu-id="ca1be-171">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="ca1be-172"><xref:System.Threading.WaitHandle> implémente la <xref:System.IDisposable.Dispose%2A> modèle.</span><span class="sxs-lookup"><span data-stu-id="ca1be-172"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="ca1be-173">Consultez [Dispose, modèle](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="ca1be-173">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="ca1be-174">Lorsque vous dérivez de <xref:System.Threading.WaitHandle>, utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété pour stocker votre handle de système d’exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="ca1be-174">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="ca1be-175">Vous n’avez pas besoin de remplacer l’élément protégé <xref:System.Threading.WaitHandle.Dispose%2A> (méthode), sauf si vous utilisez des ressources non managées supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="ca1be-175">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="ca1be-176">Requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-176">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="ca1be-177">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-177">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="ca1be-178">Types dérivés doivent avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> pour appeler ce membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-179">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-179">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="ca1be-180">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-180">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="ca1be-181">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-181">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-182">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-182">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-183">
            <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-183">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-184">Cette opération n’est pas garantie pour être atomiques.</span><span class="sxs-lookup"><span data-stu-id="ca1be-184">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="ca1be-185">Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.</span><span class="sxs-lookup"><span data-stu-id="ca1be-185">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-186">Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</span><span class="sxs-lookup"><span data-stu-id="ca1be-186">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="ca1be-187">L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE.</span><span class="sxs-lookup"><span data-stu-id="ca1be-187">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="ca1be-188">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="ca1be-188">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-189">
            <paramref name="toSignal" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-189">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-190">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-190">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-191">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-191">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="ca1be-192">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-192">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-193">
            <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-193">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-194">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-194">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-195">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-195">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="ca1be-196">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-196">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="ca1be-197">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-197">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ca1be-198">An integer that represents the interval to wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-198">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="ca1be-199">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-199">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ca1be-200">
            <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-200">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-201">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-201">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-202">
            <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-202">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-203">Cette opération n’est pas garantie pour être atomiques.</span><span class="sxs-lookup"><span data-stu-id="ca1be-203">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="ca1be-204">Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.</span><span class="sxs-lookup"><span data-stu-id="ca1be-204">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="ca1be-205">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-205">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-206">Il vérifie l’état de la `toWaitOn` et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-206">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ca1be-207">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="ca1be-207">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ca1be-208">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-208">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ca1be-209">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-209">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ca1be-210">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="ca1be-210">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ca1be-211">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-211">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="ca1be-212">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-212">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="ca1be-213">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-213">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ca1be-214">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-214">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ca1be-215">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="ca1be-215">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ca1be-216">Lorsque le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-216">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-217">
            <paramref name="toSignal" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-217">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-218">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-218">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-219">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-219">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="ca1be-220">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-220">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-221">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-221">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-222">
            <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-222">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-223">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-223">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-224">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-224">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="ca1be-225">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-225">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="ca1be-226">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-226">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ca1be-227">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-227">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="ca1be-228">If the value is -1, the wait is infinite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-228">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ca1be-229">
            <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-229">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-230">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-230">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-231">
            <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-231">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-232">Cette opération n’est pas garantie pour être atomiques.</span><span class="sxs-lookup"><span data-stu-id="ca1be-232">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="ca1be-233">Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.</span><span class="sxs-lookup"><span data-stu-id="ca1be-233">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="ca1be-234">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-234">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ca1be-235">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-235">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-236">Il vérifie l’état de la `toWaitOn` et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-236">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ca1be-237">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="ca1be-237">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ca1be-238">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-238">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ca1be-239">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-239">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ca1be-240">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="ca1be-240">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ca1be-241">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-241">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="ca1be-242">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-242">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="ca1be-243">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-243">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ca1be-244">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-244">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ca1be-245">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="ca1be-245">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ca1be-246">Lorsque le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-246">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-247">
            <paramref name="toSignal" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-247">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-248">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-248">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-249">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-249">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="ca1be-250">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-250">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-251">
            <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-251">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-252">
            <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-252">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="ca1be-253">-or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-253">-or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-254">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-254">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-255">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-255">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-256">Waits for all the elements in the specified array to receive a signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-256">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-257">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-257">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ca1be-258">This array cannot contain multiple references to the same object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-258">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-259">Waits for all the elements in the specified array to receive a signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-259">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-260">
            <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-260">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-261"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-261"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-262">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-262">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-263">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-263">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-264">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-264">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-265">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-265">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-266">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lorsque tous les handles sont signalés.</span><span class="sxs-lookup"><span data-stu-id="ca1be-266">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="ca1be-267">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-267">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ca1be-268">Si le tableau contient des doublons, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-268">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-269">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-269">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="ca1be-270">Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) pour `millisecondsTimeout` et `true` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-270">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-271">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</span><span class="sxs-lookup"><span data-stu-id="ca1be-271">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="ca1be-272">Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-272">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="ca1be-273">Le thread principal attend que tous les éléments signaler et se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-273">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-274">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-274">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-275">-or-  One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-275">-or-  One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-276">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-276">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="ca1be-277">
            <block subset="none" type="note">
              <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
            </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-277">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
              </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-278">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-278">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ca1be-279">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-279">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ca1be-280">
            <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-280">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-281">The wait terminated because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-281">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-282">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-282">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-283">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-283">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-284">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-284">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ca1be-285">This array cannot contain multiple references to the same object (duplicates).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-285">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ca1be-286">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-286">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-287">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-287">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-288">
            <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-288">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-289">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-289">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-290">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-290">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-291">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="ca1be-292">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-292">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ca1be-293">S’il existe des doublons dans le tableau, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-293">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-294">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-294">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="ca1be-295">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-295">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-297">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-297">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-298">-or-  <paramref name="waitHandles" /> is an array with no elements.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-298">-or-  <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="ca1be-299">
            <block subset="none" type="note">
              <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
            </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-299">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
              </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-300">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-300">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ca1be-301">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-301">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-302">
            <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-302">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-303">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-303">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-304">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-304">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-305">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-305">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-306">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-306">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ca1be-307">This array cannot contain multiple references to the same object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-307">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ca1be-308">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-308">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-309">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-309">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-310">
            <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-310">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-311">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-311">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-312">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-312">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-313">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-313">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="ca1be-314">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-314">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ca1be-315">Si le tableau contient des doublons, l’appel échoue.</span><span class="sxs-lookup"><span data-stu-id="ca1be-315">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-316">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-316">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="ca1be-317">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-317">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ca1be-318">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-318">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-319">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-319">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-320">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-320">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-321">-or-  <paramref name="waitHandles" /> is an array with no elements.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-321">-or-  <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="ca1be-322">
            <block subset="none" type="note">
              <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
            </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-322">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
              </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-323">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-323">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ca1be-324">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-324">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-325">
            <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-325">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-326">The wait terminated because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-326">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-327">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-327">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-328">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-328">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-329">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-329">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ca1be-330">This array cannot contain multiple references to the same object (duplicates).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-330">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ca1be-331">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-331">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ca1be-332">
            <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-332">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-333">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-333">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-334">
            <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-334">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-335">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-335">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-336">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-336">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-337"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-337"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-338">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-338">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-339">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-339">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-340">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-340">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-341">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-341">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-342">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-342">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="ca1be-343">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-343">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ca1be-344">S’il existe des doublons dans le tableau, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-344">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-345">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-345">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ca1be-346">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="ca1be-346">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ca1be-347">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-347">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ca1be-348">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-348">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ca1be-349">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="ca1be-349">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ca1be-350">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-350">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="ca1be-351">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-351">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="ca1be-352">Cela peut être utile lorsque la classe liée au contexte comporte la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-352">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="ca1be-353">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-353">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ca1be-354">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="ca1be-354">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ca1be-355">Lorsque le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-355">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-356">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</span><span class="sxs-lookup"><span data-stu-id="ca1be-356">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="ca1be-357">Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-357">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="ca1be-358">Le thread principal attend que tous les éléments signaler et se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-358">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-359">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-359">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-360">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-360">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-361">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-361">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="ca1be-362">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-362">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-363">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-363">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ca1be-364">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-364">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ca1be-365">
            <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-365">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-366">
            <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-366">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-367">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-367">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-368">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-368">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-369">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-369">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-370">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-370">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ca1be-371">This array cannot contain multiple references to the same object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-371">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ca1be-372">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-372">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ca1be-373">
            <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-373">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-374">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-374">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-375">
            <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-375">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-376">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-376">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-377">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-377">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-378"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-378"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-379">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-379">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-380">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-380">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-381">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-381">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-382">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-382">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-383">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-383">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="ca1be-384">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-384">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ca1be-385">Si le tableau contient des doublons, l’appel échoue.</span><span class="sxs-lookup"><span data-stu-id="ca1be-385">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-386">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-386">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="ca1be-387">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-387">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ca1be-388">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="ca1be-388">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ca1be-389">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-389">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ca1be-390">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-390">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ca1be-391">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="ca1be-391">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ca1be-392">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-392">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="ca1be-393">Il retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-393">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="ca1be-394">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-394">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ca1be-395">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-395">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ca1be-396">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="ca1be-396">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ca1be-397">Lorsque le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-397">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-398">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</span><span class="sxs-lookup"><span data-stu-id="ca1be-398">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="ca1be-399">Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-399">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="ca1be-400">Le thread principal attend que tous les éléments signaler et se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-400">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-401">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-401">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-402">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-402">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-403">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-403">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="ca1be-404">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-404">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-405">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-405">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ca1be-406">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-406">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ca1be-407">
            <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-407">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-408">
            <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-408">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-409">The wait terminated because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-409">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-410">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-410">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-411">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-411">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-412">Waits for any of the elements in the specified array to receive a signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-412">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-413">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-413">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-414">Waits for any of the elements in the specified array to receive a signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-414">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-415">The array index of the object that satisfied the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-415">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-416"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-416"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-417">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-417">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-418">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-418">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-419">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-419">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-420">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-420">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-421">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-421">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ca1be-422">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-422">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-423">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-423">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="ca1be-424">Cette méthode est retournée lorsqu’un handle est signalé.</span><span class="sxs-lookup"><span data-stu-id="ca1be-424">This method returns when any handle is signaled.</span></span> <span data-ttu-id="ca1be-425">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="ca1be-425">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ca1be-426">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-426">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="ca1be-427">Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) pour `millisecondsTimeout` et `true` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-427">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-428">L’exemple de code suivant montre l’appel la <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-428">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-429">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-429">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-430">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-430">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-431">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-431">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ca1be-432">
            <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-432">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-433">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-433">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-434">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-434">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ca1be-435">
            <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-435">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-436">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-436">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-437">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-437">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ca1be-438">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-438">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-439">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-439">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-440">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-440">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-441">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-441">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-442">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-442">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-443">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-443">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ca1be-444">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-444">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="ca1be-445">Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’expiration se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-445">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="ca1be-446">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="ca1be-446">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ca1be-447">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-447">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="ca1be-448">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-448">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-449">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-449">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-450">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-450">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-451">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-451">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-452">
            <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-452">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-453">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-453">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ca1be-455">
            <paramref name="waitHandles" /> is an array with no elements.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-455">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-456">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-456">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ca1be-458">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-458">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-459">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-459">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-460">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-460">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-461">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-461">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-462">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-462">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-463">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-463">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ca1be-464">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-464">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="ca1be-465">Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-465">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="ca1be-466">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="ca1be-466">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ca1be-467">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-467">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="ca1be-468">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-468">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ca1be-469">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-469">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-470">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-470">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-471">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-471">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-472">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-472">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-473">
            <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-473">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-474">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-474">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-475">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-475">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ca1be-476">
            <paramref name="waitHandles" /> is an array with no elements.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-476">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-477">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-477">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-478">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-478">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ca1be-479">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-479">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ca1be-480">
            <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-480">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-481">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-481">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-482">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-482">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-483">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-483">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-484">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-484">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-485"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-485"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-486">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-486">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-487">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-487">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-488">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-488">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-489">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-489">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-490">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-490">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ca1be-491">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-491">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-492">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-492">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="ca1be-493">Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’expiration se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-493">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="ca1be-494">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="ca1be-494">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ca1be-495">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-495">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ca1be-496">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="ca1be-496">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ca1be-497">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-497">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ca1be-498">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-498">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ca1be-499">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="ca1be-499">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ca1be-500">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-500">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="ca1be-501">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-501">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="ca1be-502">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-502">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ca1be-503">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-503">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ca1be-504">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="ca1be-504">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ca1be-505">Lorsque le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-505">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-506">L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément.</span><span class="sxs-lookup"><span data-stu-id="ca1be-506">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="ca1be-507">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</span><span class="sxs-lookup"><span data-stu-id="ca1be-507">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-508">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-508">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-509">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-509">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-510">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-510">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ca1be-511">
            <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-511">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-512">
            <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-512">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-513">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-513">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-514">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-514">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ca1be-515">
            <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-515">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-516">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-516">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ca1be-517">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-517">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ca1be-518">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-518">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ca1be-519">
            <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-519">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-520">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-520">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-521">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-521">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-522">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-522">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-523">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-523">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-524"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-524"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-525">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-525">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-526">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-526">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-527">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-527">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-528">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-528">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-529">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-529">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ca1be-530">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-530">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1be-531">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-531">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="ca1be-532">Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-532">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="ca1be-533">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="ca1be-533">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ca1be-534">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="ca1be-534">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="ca1be-535">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-535">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ca1be-536">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="ca1be-536">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ca1be-537">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-537">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ca1be-538">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-538">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ca1be-539">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="ca1be-539">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ca1be-540">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-540">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="ca1be-541">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-541">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="ca1be-542">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-542">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ca1be-543">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-543">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ca1be-544">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="ca1be-544">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ca1be-545">Lorsque le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-545">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-546">L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément.</span><span class="sxs-lookup"><span data-stu-id="ca1be-546">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="ca1be-547">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</span><span class="sxs-lookup"><span data-stu-id="ca1be-547">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ca1be-548">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-548">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ca1be-549">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-549">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ca1be-550">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-550">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ca1be-551">
            <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-551">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-552">
            <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-552">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-553">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-553">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-554">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-554">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ca1be-555">
            <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-555">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-556">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-556">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-557">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-557">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-558">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-558">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-559">
            <see langword="true" /> if the current instance receives a signal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-559">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="ca1be-560">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-560">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-561"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-561"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-562">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-562">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-563">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-563">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-564">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-564">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-565">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-565">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-566">L’appelant de cette méthode se bloque indéfiniment jusqu'à ce que l’instance actuelle reçoive un signal.</span><span class="sxs-lookup"><span data-stu-id="ca1be-566">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="ca1be-567">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-567">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ca1be-568">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="ca1be-568">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ca1be-569">Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pour le premier paramètre et `false` pour le deuxième paramètre.</span><span class="sxs-lookup"><span data-stu-id="ca1be-569">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="ca1be-570">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-570">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-571">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="ca1be-571">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ca1be-572">The current instance has already been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-572">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-573">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-573">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-574">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-574">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-575">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-575">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ca1be-576">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-576">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-577">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-577">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-578">
            <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-578">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-579">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-579">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-580">Il teste l’état du handle d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-580">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-581">L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-581">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="ca1be-582">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-582">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ca1be-583">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="ca1be-583">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ca1be-584">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-584">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="ca1be-585">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-585">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-586">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="ca1be-586">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ca1be-587">The current instance has already been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-587">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-588">
            <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-588">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-589">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-589">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-590">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-590">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-591">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-591">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="ca1be-592">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-592">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-593">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-593">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-594">
            <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-594">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-595">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-595">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-596">Il teste l’état du handle d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-596">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-597">L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-597">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="ca1be-598">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-598">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ca1be-599">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="ca1be-599">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ca1be-600">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-600">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="ca1be-601">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-601">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ca1be-602">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-602">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ca1be-603">The current instance has already been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-603">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-604">
            <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-604">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-605">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-605">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-606">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-606">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-607">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-607">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ca1be-608">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-608">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ca1be-609">
            <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-609">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-611">
            <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-611">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-612">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-612">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-613">Il teste l’état du handle d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-613">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-614"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-615">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-616">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-617">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-618">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-619">L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-619">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="ca1be-620">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ca1be-621">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="ca1be-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ca1be-622">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-622">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ca1be-623">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="ca1be-623">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ca1be-624">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-624">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ca1be-625">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-625">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ca1be-626">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="ca1be-626">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ca1be-627">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-627">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="ca1be-628">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-628">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="ca1be-629">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-629">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ca1be-630">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-630">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ca1be-631">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="ca1be-631">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ca1be-632">Lorsque le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-632">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-633">L’exemple suivant montre comment la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge de méthode se comporte lorsqu’elle est appelée dans un domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-633">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="ca1be-634">Tout d’abord, un thread attend avec `exitContext` défini sur `false` et bloque jusqu'à ce que le délai d’attente expire.</span><span class="sxs-lookup"><span data-stu-id="ca1be-634">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="ca1be-635">Un deuxième thread s’exécute après que le premier thread s’arrête et attend avec `exitContext` défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-635">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="ca1be-636">L’appel pour signaler le handle d’attente de ce deuxième thread n’est pas bloqué, et le thread se termine avant le délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="ca1be-636">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ca1be-637">The current instance has already been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-637">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-638">
            <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-638">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-639">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-639">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-640">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-640">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-641">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-641">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="ca1be-642">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-642">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ca1be-643">
            <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-643">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca1be-644">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-644">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca1be-645">
            <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-645">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-646">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="ca1be-646">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ca1be-647">Il teste l’état du handle d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ca1be-647">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="ca1be-648"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="ca1be-648"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ca1be-649">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="ca1be-649">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ca1be-650">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-650">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ca1be-651">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="ca1be-651">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ca1be-652">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="ca1be-652">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ca1be-653">L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="ca1be-653">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="ca1be-654">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-654">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ca1be-655">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="ca1be-655">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ca1be-656">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="ca1be-656">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="ca1be-657">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-657">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ca1be-658">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="ca1be-658">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ca1be-659">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="ca1be-659">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ca1be-660">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-660">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ca1be-661">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="ca1be-661">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ca1be-662">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca1be-662">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="ca1be-663">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="ca1be-663">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="ca1be-664">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ca1be-664">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ca1be-665">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="ca1be-665">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ca1be-666">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="ca1be-666">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ca1be-667">Lorsque le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="ca1be-667">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-668">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="ca1be-668">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ca1be-669">The current instance has already been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-669">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ca1be-670">
            <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-670">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ca1be-671">The wait completed because a thread exited without releasing a mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-671">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ca1be-672">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-672">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ca1be-673">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-673">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="ca1be-674">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-674">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="ca1be-675">This field is constant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca1be-675">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1be-676">Ce champ est une des valeurs de retour possibles de `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="ca1be-676">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1be-677">L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément.</span><span class="sxs-lookup"><span data-stu-id="ca1be-677">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="ca1be-678">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</span><span class="sxs-lookup"><span data-stu-id="ca1be-678">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>