<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="WaitHandle.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59c30c9bf2d271da2afe9d173213a99d04fceefda.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9c30c9bf2d271da2afe9d173213a99d04fceefda</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.WaitHandle">
          <source>Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</source>
          <target state="translated">Encapsule les objets spécifiques au système d'exploitation qui attendent un accès exclusif aux ressources partagées.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> classe encapsule les descripteurs de synchronisation Win32 et est utilisé pour représenter tous les objets de synchronisation dans le runtime qui permettent plusieurs opérations d’attente.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>For a comparison of wait handles with other synchronization objects, see <bpt id="p1">[</bpt>Overview of Synchronization Primitives<ept id="p1">](~/docs/standard/threading/overview-of-synchronization-primitives.md)</ept>.</source>
          <target state="translated">Pour une comparaison des handles d’attente avec d’autres objets de synchronisation, consultez <bpt id="p1">[</bpt>vue d’ensemble des Primitives de synchronisation<ept id="p1">](~/docs/standard/threading/overview-of-synchronization-primitives.md)</ept>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> class itself is abstract.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> classe elle-même est abstraite.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>Classes derived from <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> methods to block while waiting for access to shared resources.</source>
          <target state="translated">Les classes dérivées de <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> définissent un mécanisme de signalisation pour indiquer la capture ou la libération d’un accès à une ressource partagée, mais elles hérité <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> méthodes bloquer lors de l’attente pour l’accès à des ressources partagées.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The classes derived from <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> include:</source>
          <target state="translated">Les classes dérivées de <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> incluent :</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class.</source>
          <target state="translated">La classe <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>See <bpt id="p1">[</bpt>Mutexes<ept id="p1">](~/docs/standard/threading/mutexes.md)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>mutex<ept id="p1">](~/docs/standard/threading/mutexes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class and its derived classes, <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> classe et ses classes dérivées, <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> et <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>See <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</source>
          <target state="translated">Voir <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class.</source>
          <target state="translated">La classe <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>See <bpt id="p1">[</bpt>Semaphore and SemaphoreSlim<ept id="p1">](~/docs/standard/threading/semaphore-and-semaphoreslim.md)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Semaphore et SemaphoreSlim<ept id="p1">](~/docs/standard/threading/semaphore-and-semaphoreslim.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>Threads can block on an individual wait handle by calling the instance method <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, which is inherited by classes derived from <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>.</source>
          <target state="translated">Les threads peuvent bloquer un handle d’attente individuel en appelant la méthode d’instance <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, qui est hérité par les classes dérivées de <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The derived classes of <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> differ in their thread affinity.</source>
          <target state="translated">Les classes dérivées de <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> diffèrent dans leur affinité de thread.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>Event wait handles (<ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</source>
          <target state="translated">Handles d’attente d’événement (<ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>, et <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>) et les sémaphores n’ont pas d’affinité de thread ; n’importe quel thread peut signaler un handle d’attente d’événement ou d’un sémaphore.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method on a mutex that it does not own.</source>
          <target state="translated">En revanche, les mutex, ont une affinité de thread ; le thread qui détient un mutex doit libérer et une exception est levée si un thread appelle la <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> méthode sur un mutex qu’il ne possède pas.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> class derives from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, these classes can be used to synchronize the activities of threads across application domain boundaries.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> dérive de la classe <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, ces classes peuvent être utilisées pour synchroniser les activités des threads au-delà des limites de domaine application.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>In addition to its derived classes, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</source>
          <target state="translated">En plus de ses classes dérivées, la <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> classe a un nombre de méthodes statiques qui bloque un thread jusqu'à ce qu’une ou plusieurs objets de synchronisation reçoivent un signal...</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>These include:</source>
          <target state="translated">Elles incluent notamment :</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph>, which allows a thread to signal one wait handle and immediately wait on another.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph>, qui permet à un thread de signaler un handle d’attente et d’attendre immédiatement un autre.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>, which allows a thread to wait until all the wait handles in an array receive a signal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>, qui permet à un thread d’attendre que tous les handles d’attente dans un tableau reçoivent un signal.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, qui permet à un thread d’attendre que l’un d’un jeu spécifié de handles d’attente a été signalé.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</source>
          <target state="translated">Les surcharges de ces méthodes fournissent des intervalles de délai d’attente pour abandonner l’attente et la possibilité de quitter un contexte de synchronisation avant de commencer l’attente, ce qui permet d’utiliser le contexte de synchronisation des autres threads.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Ce type implémente le <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Lorsque vous avez fini d’utiliser le type ou un type dérivé, vous devez la supprimer directement ou indirectement.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Pour supprimer le type directement, vous devez appeler sa <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> méthode dans un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Pour la supprimer indirectement, utiliser une construction de langage telles que <ph id="ph1">`using`</ph> (en c#) ou <ph id="ph2">`Using`</ph> (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> rubrique de l’interface.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> implements the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> pattern.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> implémente la <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> modèle.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>See <bpt id="p1">[</bpt>Dispose Pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>modèle de suppression<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>When you derive from <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property to store your native handle operating system handle.</source>
          <target state="translated">Lorsque vous dérivez de <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> propriété pour stocker votre handle de système d’exploitation natif.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>You do not need to override the protected <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Dispose%2A&gt;</ph> method unless you use additional unmanaged resources.</source>
          <target state="translated">Vous n’avez pas besoin de substituer la méthode protégée <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Dispose%2A&gt;</ph> (méthode), sauf si vous utilisez les ressources non managées supplémentaires.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Threading.WaitHandle&gt;</ph> class.</source>
          <target state="translated">Le code suivant montre d’exemple comment deux threads peuvent effectuent les tâches en arrière-plan lors de la Main thread attend que les tâches se terminent à l’aide de la méthode statique <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthodes de la <ph id="ph3">&lt;xref:System.Threading.WaitHandle&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.WaitHandle">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.Close">
          <source>Releases all resources held by the current <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>.</source>
          <target state="translated">Libère toutes les ressources détenues par le <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Close">
          <source>This method is the public implementation of the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method for the <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> class and its derived classes.</source>
          <target state="translated">Cette méthode est l’implémentation publique de la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> méthode pour la <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> classe et ses classes dérivées.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Close">
          <source>It provides a standard implementation that calls the <ph id="ph1">`Dispose(Boolean)`</ph> overload with a <ph id="ph2">`true`</ph> argument and then calls the <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Il fournit une implémentation standard qui appelle le <ph id="ph1">`Dispose(Boolean)`</ph> surcharge avec un <ph id="ph2">`true`</ph> argument, puis appelle la <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Close">
          <source>Call this method to release all resources held by an instance of <ph id="ph1">`WaitHandle`</ph> or a derived class.</source>
          <target state="translated">Appelez cette méthode pour libérer toutes les ressources détenues par une instance de <ph id="ph1">`WaitHandle`</ph> ou une classe dérivée.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Close">
          <source>Once this method is called, references to the current instance cause undefined behavior.</source>
          <target state="translated">Une fois que cette méthode est appelée, les références à l’instance actuelle provoquent un comportement non défini.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Close">
          <source>Always call <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> before you release your last reference to the <ph id="ph3">&lt;xref:System.Threading.WaitHandle&gt;</ph>.</source>
          <target state="translated">Appelez toujours <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> avant de libérer votre dernière référence à le <ph id="ph3">&lt;xref:System.Threading.WaitHandle&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Close">
          <source>Otherwise, the resources it is using will not be freed.</source>
          <target state="translated">Sinon, les ressources qu’il utilise ne seront pas libérées.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Close">
          <source>You should override the <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph> method to release resources allocated in derived classes.</source>
          <target state="translated">Vous devez substituer la <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph> méthode pour libérer les ressources allouées dans les classes dérivées.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="T:System.Threading.WaitHandle">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> class</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> class.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Dispose">
          <source>This method is equivalent to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode est équivalente à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Dispose">
          <source>Always call <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> before you release your last reference to the <ph id="ph3">&lt;xref:System.Threading.WaitHandle&gt;</ph>.</source>
          <target state="translated">Appelez toujours <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> avant de libérer votre dernière référence à le <ph id="ph3">&lt;xref:System.Threading.WaitHandle&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Dispose">
          <source>Otherwise, the resources it is using will not be freed.</source>
          <target state="translated">Sinon, les ressources qu’il utilise ne seront pas libérées.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour libérer les ressources managées et non managées ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour ne libérer que les ressources non managées.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.Dispose(System.Boolean)">
          <source>When overridden in a derived class, releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>, and optionally releases the managed resources.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> et libère éventuellement les ressources managées.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Dispose(System.Boolean)">
          <source>This method is called by the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> and the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> methods with the <ph id="ph3">`explicitDisposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Cette méthode est appelée par le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> méthodes avec les <ph id="ph3">`explicitDisposing`</ph> paramètre la valeur <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`explicitDisposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Threading.WaitHandle&gt;</ph> object references.</source>
          <target state="translated">Lorsque le <ph id="ph1">`explicitDisposing`</ph> paramètre est <ph id="ph2">`true`</ph>, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <ph id="ph3">&lt;xref:System.Threading.WaitHandle&gt;</ph> références d’objet.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Dispose(System.Boolean)">
          <source>You should override the <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /&gt;</ph> method to release resources allocated in derived classes.</source>
          <target state="translated">Vous devez substituer la <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /&gt;</ph> méthode pour libérer les ressources allouées dans les classes dérivées.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> or <ph id="ph2">&lt;see cref="M:System.Threading.WaitHandle.Dispose" /&gt;</ph> method can be called multiple times by other objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> ou <ph id="ph2">&lt;see cref="M:System.Threading.WaitHandle.Dispose" /&gt;</ph> méthode peut être appelée plusieurs fois par d’autres objets.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.Dispose(System.Boolean)">
          <source>When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> or <ph id="ph2">&lt;see langword="Close" /&gt;</ph>.</source>
          <target state="translated">Lorsque vous substituez cette méthode, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un appel antérieur à <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> ou <ph id="ph2">&lt;see langword="Close" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="P:System.Threading.WaitHandle.Handle">
          <source>Gets or sets the native operating system handle.</source>
          <target state="translated">Obtient ou définit le handle du système d'exploitation natif.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>An <ph id="ph1">&lt;see langword="IntPtr" /&gt;</ph> representing the native operating system handle.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="IntPtr" /&gt;</ph> représentant le handle du système d'exploitation natif.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>The default is the value of the <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.InvalidHandle" /&gt;</ph> field.</source>
          <target state="translated">La valeur par défaut est celle du champ <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.InvalidHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>Assigning a new value to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Handle%2A&gt;</ph> property does not close the previous handle.</source>
          <target state="translated">Affectation d’une nouvelle valeur à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Handle%2A&gt;</ph> propriété ne ferme pas le handle précédent.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>This can result in a leaked handle.</source>
          <target state="translated">Cela peut entraîner une fuite du handle.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>Do not use this property in the .NET Framework version 2.0 or later; use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property instead.</source>
          <target state="translated">N’utilisez pas cette propriété dans le .NET Framework version 2.0 ou version ultérieure ; Utilisez le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> propriété à la place.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>Setting this property to a valid handle also sets the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property, but setting it to <ph id="ph2">&lt;xref:System.Threading.WaitHandle.InvalidHandle&gt;</ph> can result in a leaked handle.</source>
          <target state="translated">Définition de cette propriété pour un handle valide définit également la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> propriété, mais la valeur <ph id="ph2">&lt;xref:System.Threading.WaitHandle.InvalidHandle&gt;</ph> peut entraîner une fuite du handle.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>Requires full trust for the immediate caller to set the property value.</source>
          <target state="translated">Requiert une confiance totale pour l’appelant immédiat définir la valeur de propriété.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>This member cannot be set by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être défini par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.Handle">
          <source>Derived types must have <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> to set the property value.</source>
          <target state="translated">Types dérivés doivent avoir <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> pour définir la valeur de propriété.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="F:System.Threading.WaitHandle.InvalidHandle">
          <source>Represents an invalid native operating system handle.</source>
          <target state="translated">Représente un handle du système d'exploitation natif non valide.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="F:System.Threading.WaitHandle.InvalidHandle">
          <source>This field is read-only.</source>
          <target state="translated">Ce champ est en lecture seule.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Threading.WaitHandle.InvalidHandle">
          <source>Used internally to initialize the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Handle%2A&gt;</ph> property.</source>
          <target state="translated">Utilisé en interne pour initialiser le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Handle%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Threading.WaitHandle.InvalidHandle">
          <source>You can use this value to determine whether the <ph id="ph1">&lt;see cref="P:System.Threading.WaitHandle.Handle" /&gt;</ph> property contains a valid native operating system handle.</source>
          <target state="translated">Vous pouvez utiliser cette valeur pour déterminer si le <ph id="ph1">&lt;see cref="P:System.Threading.WaitHandle.Handle" /&gt;</ph> propriété contient un handle valide de système d’exploitation natif.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>Gets or sets the native operating system handle.</source>
          <target state="translated">Obtient ou définit le handle du système d'exploitation natif.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>A <ph id="ph1">&lt;see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /&gt;</ph> representing the native operating system handle.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /&gt;</ph> représentant le handle du système d'exploitation natif.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>When you assign a new value to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property, the previous handle will be closed when the previous <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> object is collected.</source>
          <target state="translated">Lorsque vous attribuez une nouvelle valeur à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> propriété, le handle précédent est fermé lorsque le précédent <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> objet est collecté.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>Do not manually close the handle, because this results in an <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> when the <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> attempts to close the handle.</source>
          <target state="translated">Ne fermez pas manuellement le handle, car cela entraîne une <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> lorsque le <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> essaie de fermer le handle.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> implements the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> pattern.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> implémente la <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> modèle.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>See <bpt id="p1">[</bpt>Dispose Pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>modèle de suppression<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>When you derive from <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property to store your native handle operating system handle.</source>
          <target state="translated">Lorsque vous dérivez de <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> propriété pour stocker votre handle de système d’exploitation natif.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>You do not need to override the protected <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Dispose%2A&gt;</ph> method unless you use additional unmanaged resources.</source>
          <target state="translated">Vous n’avez pas besoin de substituer la méthode protégée <ph id="ph1">&lt;xref:System.Threading.WaitHandle.Dispose%2A&gt;</ph> (méthode), sauf si vous utilisez les ressources non managées supplémentaires.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.WaitHandle.SafeWaitHandle">
          <source>Derived types must have <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> to call this member.</source>
          <target state="translated">Types dérivés doivent avoir <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> pour appeler ce membre.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="T:System.Threading.WaitHandle">
          <source>Signals one <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> and waits on another.</source>
          <target state="translated">Signale un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> et attend un autre.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to signal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> à signaler.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to wait on.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> à attendre.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>Signals one <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> and waits on another.</source>
          <target state="translated">Signale un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> et attend un autre.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le signal et l'attente se terminent avec succès ; si l'attente ne se termine pas, la méthode ne retourne pas.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>This operation is not guaranteed to be atomic.</source>
          <target state="translated">Cette opération n’est pas garantie atomique.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>After the current thread signals <ph id="ph1">`toSignal`</ph> but before it waits on <ph id="ph2">`toWaitOn`</ph>, a thread that is running on another processor might signal <ph id="ph3">`toWaitOn`</ph> or wait on it.</source>
          <target state="translated">Après les signaux de thread en cours <ph id="ph1">`toSignal`</ph> mais avant qu’il attende <ph id="ph2">`toWaitOn`</ph>, un thread qui s’exécute sur un autre processeur peut signaler <ph id="ph3">`toWaitOn`</ph> ou attendre.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">Le code suivant exemple utilise le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>The example starts five threads, allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, and then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">L’exemple démarre cinq threads et leur permet de bloquer sur un <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant une <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> créé avec le <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source><ph id="ph1">&lt;paramref name="toWaitOn" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toWaitOn" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>The method was called on a thread that has <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph>.</source>
          <target state="translated">La méthode a été appelée sur un thread qui comporte l'attribut <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>This method is not supported on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> is a semaphore, and it already has a full count.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> est un sémaphore, et possède déjà un nombre complet.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to signal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> à signaler.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to wait on.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> à attendre.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>An integer that represents the interval to wait.</source>
          <target state="translated">Entier qui représente l'intervalle à attendre.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>If the value is <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>, that is, -1, the wait is infinite.</source>
          <target state="translated">Si la valeur est <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>, c'est-à-dire -1, l'attente est infinie.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>Signals one <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</source>
          <target state="translated">Signale un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> et en attend un autre, en spécifiant un délai sous la forme d'un entier signé 32 bits et en spécifiant s'il faut quitter le domaine de synchronisation du contexte avant de commencer l'attente.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if both the signal and the wait completed successfully, or <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the signal completed but the wait timed out.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le signal et l'attente se sont terminés avec succès ou <ph id="ph2">&lt;see langword="false" /&gt;</ph> si le signal s'est terminé mais que l'attente a expiré.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>This operation is not guaranteed to be atomic.</source>
          <target state="translated">Cette opération n’est pas garantie atomique.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>After the current thread signals <ph id="ph1">`toSignal`</ph> but before it waits on <ph id="ph2">`toWaitOn`</ph>, a thread that is running on another processor might signal <ph id="ph3">`toWaitOn`</ph> or wait on it.</source>
          <target state="translated">Après les signaux de thread en cours <ph id="ph1">`toSignal`</ph> mais avant qu’il attende <ph id="ph2">`toWaitOn`</ph>, un thread qui s’exécute sur un autre processeur peut signaler <ph id="ph3">`toWaitOn`</ph> ou attendre.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>It tests the state of the <ph id="ph1">`toWaitOn`</ph> and returns immediately.</source>
          <target state="translated">Elle teste l’état de la <ph id="ph1">`toWaitOn`</ph> et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le <ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>Even if you are currently executing a method on a class that does not derive from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>The thread returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method completes.</source>
          <target state="translated">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>This can be useful when the context-bound class has <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="toWaitOn" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toWaitOn" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>The method is called on a thread that has <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph>.</source>
          <target state="translated">La méthode est appelée sur un thread qui comporte l'attribut <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>This method is not supported on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> cannot be signaled because it would exceed its maximum count.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> ne peut pas être signalé, car il dépasse sa valeur maximale.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to signal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> à signaler.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to wait on.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> à attendre.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the interval to wait.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente l'intervalle à attendre.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>If the value is -1, the wait is infinite.</source>
          <target state="translated">Si la valeur est -1, l'attente est infinie.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>Signals one <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> and waits on another, specifying the time-out interval as a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> and specifying whether to exit the synchronization domain for the context before entering the wait.</source>
          <target state="translated">Signale un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> et en attend un autre, en spécifiant le délai sous la forme d'une valeur <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> et en spécifiant s'il faut quitter le domaine de synchronisation du contexte avant de commencer l'attente.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if both the signal and the wait completed successfully, or <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the signal completed but the wait timed out.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le signal et l'attente se sont terminés avec succès ou <ph id="ph2">&lt;see langword="false" /&gt;</ph> si le signal s'est terminé mais que l'attente a expiré.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>This operation is not guaranteed to be atomic.</source>
          <target state="translated">Cette opération n’est pas garantie atomique.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>After the current thread signals <ph id="ph1">`toSignal`</ph> but before it waits on <ph id="ph2">`toWaitOn`</ph>, a thread that is running on another processor might signal <ph id="ph3">`toWaitOn`</ph> or wait on it.</source>
          <target state="translated">Après les signaux de thread en cours <ph id="ph1">`toSignal`</ph> mais avant qu’il attende <ph id="ph2">`toWaitOn`</ph>, un thread qui s’exécute sur un autre processeur peut signaler <ph id="ph3">`toWaitOn`</ph> ou attendre.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>The maximum value for <ph id="ph1">`timeout`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La valeur maximale de <ph id="ph1">`timeout`</ph> est <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>If <ph id="ph1">`timeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>It tests the state of the <ph id="ph1">`toWaitOn`</ph> and returns immediately.</source>
          <target state="translated">Elle teste l’état de la <ph id="ph1">`toWaitOn`</ph> et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le <ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>Even if you are currently executing a method on a class that does not derive from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>The thread returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method completes.</source>
          <target state="translated">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>This can be useful when the context-bound class has <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="toWaitOn" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toWaitOn" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>The method was called on a thread that has <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph>.</source>
          <target state="translated">La méthode a été appelée sur un thread qui comporte l'attribut <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>This method is not supported on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> is a semaphore, and it already has a full count.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toSignal" /&gt;</ph> est un sémaphore, et possède déjà un nombre complet.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> evaluates to a negative number of milliseconds other than -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> prend comme valeur un nombre négatif de millièmes de secondes autre que -1.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="T:System.Threading.WaitHandle">
          <source>Waits for all the elements in the specified array to receive a signal.</source>
          <target state="translated">Attend que tous les éléments du tableau spécifié reçoivent un signal.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>This array cannot contain multiple references to the same object.</source>
          <target state="translated">Ce tableau ne peut pas contenir plusieurs références au même objet.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>Waits for all the elements in the specified array to receive a signal.</source>
          <target state="translated">Attend que tous les éléments du tableau spécifié reçoivent un signal.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> when every element in <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> has received a signal; otherwise the method never returns.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> quand tous les éléments de <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> ont reçu un signal ; sinon, la méthode ne retourne jamais.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode renvoie <ph id="ph2">`true`</ph> quand un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when all the handles are signaled.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode est retournée lorsque tous les handles sont signalés.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>On some implementations, if more than 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>If the array contains duplicates, the call fails with a <ph id="ph1">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.</source>
          <target state="translated">Si le tableau contient des doublons, l’appel échoue avec une <ph id="ph1">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode n’est pas prise en charge sur les threads qui ont <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> method overload and specifying -1 (or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>) for <ph id="ph3">`millisecondsTimeout`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`exitContext`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> surcharge de méthode et en spécifiant -1 (ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>) pour <ph id="ph3">`millisecondsTimeout`</ph> et <ph id="ph4">`true`</ph> pour <ph id="ph5">`exitContext`</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>Each write operation is queued as a work item and signals when it is finished.</source>
          <target state="translated">Chaque opération d’écriture est en attente comme un élément de travail et des signaux lorsqu’elle est terminée.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The main thread waits for all the items to signal and then exits.</source>
          <target state="translated">Le thread principal attend que tous les éléments signaler et se termine.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements and the .NET Framework version is 2.0 or later.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.ArgumentException" /&gt;</ph>, instead.</source>
          <target state="translated">Dans <bpt id="p1">[</bpt>.NET pour les applications du Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou la <bpt id="p2">[</bpt>Bibliothèque de classes portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, interceptez l’exception de la classe de base, <ph id="ph1">&lt;see cref="T:System.ArgumentException" /&gt;</ph>, à la place.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains elements that are duplicates.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient des éléments qui sont des doublons.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> attribute is applied to the thread procedure for the current thread, and <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contains more than one element.</source>
          <target state="translated">L’attribut <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> est appliqué à la procédure de thread pour le thread actuel, et <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contient plusieurs éléments.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The wait terminated because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>This array cannot contain multiple references to the same object (duplicates).</source>
          <target state="translated">Ce tableau ne peut pas contenir plusieurs références au même objet (doublons).</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>Waits for all the elements in the specified array to receive a signal, using an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value to specify the time interval.</source>
          <target state="translated">Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> pour spécifier l'intervalle de temps.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> when every element in <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> has received a signal; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> quand tous les éléments de <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> ont reçu un signal ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>It tests the state of the wait handles and returns immediately.</source>
          <target state="translated">Il teste l’état des handles d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode est retournée lorsque l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>On some implementations, if more than 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>If there are duplicates in the array, the call fails with a <ph id="ph1">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.</source>
          <target state="translated">Si le tableau contient des doublons, l’appel échoue avec une <ph id="ph1">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode n’est pas prise en charge sur les threads qui ont <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`exitContext`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode est le même que d’appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> surcharge et en spécifiant <ph id="ph2">`false`</ph> pour <ph id="ph3">`exitContext`</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.ArgumentException" /&gt;</ph>, instead.</source>
          <target state="translated">Dans <bpt id="p1">[</bpt>.NET pour les applications du Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou la <bpt id="p2">[</bpt>Bibliothèque de classes portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, interceptez l’exception de la classe de base, <ph id="ph1">&lt;see cref="T:System.ArgumentException" /&gt;</ph>, à la place.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains elements that are duplicates.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient des éléments qui sont des doublons.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> attribute is applied to the thread procedure for the current thread, and <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contains more than one element.</source>
          <target state="translated">L’attribut <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> est appliqué à la procédure de thread pour le thread actuel, et <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contient plusieurs éléments.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>This array cannot contain multiple references to the same object.</source>
          <target state="translated">Ce tableau ne peut pas contenir plusieurs références au même objet.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds, to wait indefinitely.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millisecondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 milliseconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>Waits for all the elements in the specified array to receive a signal, using a <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> value to specify the time interval.</source>
          <target state="translated">Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> pour spécifier l'intervalle de temps.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> when every element in <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> has received a signal; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> quand tous les éléments de <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> ont reçu un signal ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>It tests the state of the wait handles and returns immediately.</source>
          <target state="translated">Il teste l’état des handles d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode est retournée lorsque l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>On some implementations, if more than 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>If the array contains duplicates, the call will fail.</source>
          <target state="translated">Si le tableau contient des doublons, l’appel échoue.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode n’est pas prise en charge sur les threads qui ont <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The maximum value for <ph id="ph1">`timeout`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La valeur maximale de <ph id="ph1">`timeout`</ph> est <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`exitContext`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode est le même que d’appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt;</ph> surcharge et en spécifiant <ph id="ph2">`false`</ph> pour <ph id="ph3">`exitContext`</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.ArgumentException" /&gt;</ph>, instead.</source>
          <target state="translated">Dans <bpt id="p1">[</bpt>.NET pour les applications du Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou la <bpt id="p2">[</bpt>Bibliothèque de classes portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, interceptez l’exception de la classe de base, <ph id="ph1">&lt;see cref="T:System.ArgumentException" /&gt;</ph>, à la place.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains elements that are duplicates.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient des éléments qui sont des doublons.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> attribute is applied to the thread procedure for the current thread, and <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contains more than one element.</source>
          <target state="translated">L’attribut <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> est appliqué à la procédure de thread pour le thread actuel, et <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contient plusieurs éléments.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The wait terminated because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>This array cannot contain multiple references to the same object (duplicates).</source>
          <target state="translated">Ce tableau ne peut pas contenir plusieurs références au même objet (doublons).</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>Waits for all the elements in the specified array to receive a signal, using an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</source>
          <target state="translated">Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> when every element in <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> has received a signal; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> quand tous les éléments de <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> ont reçu un signal ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>It tests the state of the wait handles and returns immediately.</source>
          <target state="translated">Il teste l’état des handles d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode renvoie <ph id="ph2">`true`</ph> quand un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode est retournée lorsque l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>On some implementations, if more than 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>If there are duplicates in the array, the call fails with a <ph id="ph1">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.</source>
          <target state="translated">Si le tableau contient des doublons, l’appel échoue avec une <ph id="ph1">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode n’est pas prise en charge sur les threads qui ont <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le <ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>Even if you are currently executing a method on a class that is not derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The thread returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method completes.</source>
          <target state="translated">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>This can be useful when the context-bound class has the <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte la <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribut.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>Each write operation is queued as a work item and signals when it is finished.</source>
          <target state="translated">Chaque opération d’écriture est en attente comme un élément de travail et des signaux lorsqu’elle est terminée.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The main thread waits for all the items to signal and then exits.</source>
          <target state="translated">Le thread principal attend que tous les éléments signaler et se termine.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements and the .NET Framework version is 2.0 or later.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains elements that are duplicates.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient des éléments qui sont des doublons.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> attribute is applied to the thread procedure for the current thread, and <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contains more than one element.</source>
          <target state="translated">L’attribut <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> est appliqué à la procédure de thread pour le thread actuel, et <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contient plusieurs éléments.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>This array cannot contain multiple references to the same object.</source>
          <target state="translated">Ce tableau ne peut pas contenir plusieurs références au même objet.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds, to wait indefinitely.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millisecondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 milliseconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>Waits for all the elements in the specified array to receive a signal, using a <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</source>
          <target state="translated">Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> when every element in <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> has received a signal; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> lorsque tous les éléments de <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> ont reçu un signal ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>If <ph id="ph1">`timeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>It tests the state of the wait handles and returns immediately.</source>
          <target state="translated">Il teste l’état des handles d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode renvoie <ph id="ph2">`true`</ph> quand un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode est retournée lorsque l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>On some implementations, if more than 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>If the array contains duplicates, the call will fail.</source>
          <target state="translated">Si le tableau contient des doublons, l’appel échoue.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode n’est pas prise en charge sur les threads qui ont <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The maximum value for <ph id="ph1">`timeout`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La valeur maximale de <ph id="ph1">`timeout`</ph> est <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le <ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>Even if you are currently executing a method on a class that is not derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>It returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method completes.</source>
          <target state="translated">Il retourne au contexte par défaut d’origine après l’appel à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>This can be useful when the context-bound class has <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>Each write operation is queued as a work item and signals when it is finished.</source>
          <target state="translated">Chaque opération d’écriture est en attente comme un élément de travail et des signaux lorsqu’elle est terminée.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The main thread waits for all the items to signal and then exits.</source>
          <target state="translated">Le thread principal attend que tous les éléments signaler et se termine.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements and the .NET Framework version is 2.0 or later.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains elements that are duplicates.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient des éléments qui sont des doublons.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> attribute is applied to the thread procedure for the current thread, and <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contains more than one element.</source>
          <target state="translated">L’attribut <ph id="ph1">&lt;see cref="T:System.STAThreadAttribute" /&gt;</ph> est appliqué à la procédure de thread pour le thread actuel, et <ph id="ph2">&lt;paramref name="waitHandles" /&gt;</ph> contient plusieurs éléments.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The wait terminated because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="T:System.Threading.WaitHandle">
          <source>Waits for any of the elements in the specified array to receive a signal.</source>
          <target state="translated">Attend que l'un des éléments du tableau spécifié reçoive un signal.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>Waits for any of the elements in the specified array to receive a signal.</source>
          <target state="translated">Attend que l'un des éléments du tableau spécifié reçoive un signal.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>The array index of the object that satisfied the wait.</source>
          <target state="translated">Index du tableau de l'objet ayant respecté l'attente.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> if the wait completes because a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> retourne de la méthode <ph id="ph2">`true`</ph> si l’attente se termine parce qu’un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> uniquement lorsque l’attente se termine en raison d’un mutex abandonné.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>If <ph id="ph1">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.</source>
          <target state="translated">Si <ph id="ph1">`waitHandles`</ph> contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode se termine normalement et l’exception n’est levée.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>, and that <ph id="ph2">`Mutex`</ph> is at index 0 (zero) in a <ph id="ph3">`WaitAny`</ph> array on another thread, the index returned by <ph id="ph4">`WaitAny`</ph> is 128 instead of 0.</source>
          <target state="translated">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>et qui <ph id="ph2">`Mutex`</ph> est à l’index 0 (zéro) dans un <ph id="ph3">`WaitAny`</ph> tableau sur un autre thread, l’index retourné par <ph id="ph4">`WaitAny`</ph> est 128 au lieu de 0.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>This method returns when any handle is signaled.</source>
          <target state="translated">Cette méthode retourne quand un handle est signalé.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</source>
          <target state="translated">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>On some implementations, if more that 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> method overload and specifying -1 (or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>) for <ph id="ph3">`millisecondsTimeout`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`exitContext`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> surcharge de méthode et en spécifiant -1 (ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>) pour <ph id="ph3">`millisecondsTimeout`</ph> et <ph id="ph4">`true`</ph> pour <ph id="ph5">`exitContext`</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>The following code example demonstrates calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre l’appel du <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements, and the .NET Framework version is 2.0 or later.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</source>
          <target state="translated">Attend que l'un des éléments du tableau spécifié reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>The array index of the object that satisfied the wait, or <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.WaitTimeout" /&gt;</ph> if no object satisfied the wait and a time interval equivalent to <ph id="ph2">&lt;paramref name="millisecondsTimeout" /&gt;</ph> has passed.</source>
          <target state="translated">Index de tableau de l'objet ayant respecté l'attente ou <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.WaitTimeout" /&gt;</ph> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <ph id="ph2">&lt;paramref name="millisecondsTimeout" /&gt;</ph> s'est écoulé.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>It tests the state of the wait handles and returns immediately.</source>
          <target state="translated">Il teste l’état des handles d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> uniquement lorsque l’attente se termine en raison d’un mutex abandonné.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>If <ph id="ph1">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.</source>
          <target state="translated">Si <ph id="ph1">`waitHandles`</ph> contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode se termine normalement et l’exception n’est levée.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</source>
          <target state="translated">Cette méthode retourne lorsque l’attente se termine lorsqu’une des poignées sont signalée soit lorsqu’un dépassement de délai se produit.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</source>
          <target state="translated">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>On some implementations, if more that 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`exitContext`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode est le même que d’appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> surcharge et en spécifiant <ph id="ph2">`false`</ph> pour <ph id="ph3">`exitContext`</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millièmes de secondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 millième de seconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>Waits for any of the elements in the specified array to receive a signal, using a <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> to specify the time interval.</source>
          <target state="translated">Attend que l'un des éléments du tableau spécifié reçoive un signal, en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> pour spécifier l'intervalle de temps.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The array index of the object that satisfied the wait, or <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.WaitTimeout" /&gt;</ph> if no object satisfied the wait and a time interval equivalent to <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> has passed.</source>
          <target state="translated">Index de tableau de l'objet ayant respecté l'attente ou <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.WaitTimeout" /&gt;</ph> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> s'est écoulé.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>It tests the state of the wait handles and returns immediately.</source>
          <target state="translated">Il teste l’état des handles d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> uniquement lorsque l’attente se termine en raison d’un mutex abandonné.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>If <ph id="ph1">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.</source>
          <target state="translated">Si <ph id="ph1">`waitHandles`</ph> contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode se termine normalement et l’exception n’est levée.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</source>
          <target state="translated">Cette méthode retourne lorsque l’attente se termine lorsqu’une des poignées sont signalée soit lorsqu’un dépassement de délai se produit.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</source>
          <target state="translated">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>On some implementations, if more that 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The maximum value for <ph id="ph1">`timeout`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La valeur maximale de <ph id="ph1">`timeout`</ph> est <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`exitContext`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode est le même que d’appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt;</ph> surcharge et en spécifiant <ph id="ph2">`false`</ph> pour <ph id="ph3">`exitContext`</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau sans éléments.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</source>
          <target state="translated">Attend que l’un des éléments du tableau spécifié reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The array index of the object that satisfied the wait, or <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.WaitTimeout" /&gt;</ph> if no object satisfied the wait and a time interval equivalent to <ph id="ph2">&lt;paramref name="millisecondsTimeout" /&gt;</ph> has passed.</source>
          <target state="translated">Index de tableau de l'objet ayant respecté l'attente ou <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.WaitTimeout" /&gt;</ph> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <ph id="ph2">&lt;paramref name="millisecondsTimeout" /&gt;</ph> s'est écoulé.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>It tests the state of the wait handles and returns immediately.</source>
          <target state="translated">Il teste l’état des handles d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> if the wait completes because a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> retourne de la méthode <ph id="ph2">`true`</ph> si l’attente se termine parce qu’un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> uniquement lorsque l’attente se termine en raison d’un mutex abandonné.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.</source>
          <target state="translated">Si <ph id="ph1">`waitHandles`</ph> contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode se termine normalement et l’exception n’est levée.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>, and that <ph id="ph2">`Mutex`</ph> is at index 0 (zero) in a <ph id="ph3">`WaitAny`</ph> array on another thread, the index returned by <ph id="ph4">`WaitAny`</ph> is 128 instead of 0.</source>
          <target state="translated">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>et qui <ph id="ph2">`Mutex`</ph> est à l’index 0 (zéro) dans un <ph id="ph3">`WaitAny`</ph> tableau sur un autre thread, l’index retourné par <ph id="ph4">`WaitAny`</ph> est 128 au lieu de 0.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</source>
          <target state="translated">Cette méthode retourne lorsque l’attente se termine lorsqu’une des poignées sont signalée soit lorsqu’un dépassement de délai se produit.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</source>
          <target state="translated">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>On some implementations, if more that 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le <ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>Even if you are currently executing a method on a class that does not derive from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The thread returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes.</source>
          <target state="translated">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>This can be useful when the context-bound class has <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le pool de threads pour la recherche simultanée d’un fichier sur plusieurs disques.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>For space considerations, only the root directory of each disk is searched.</source>
          <target state="translated">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements, and the .NET Framework version is 2.0 or later.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> array containing the objects for which the current instance will wait.</source>
          <target state="translated">Tableau <ph id="ph1">&lt;see langword="WaitHandle" /&gt;</ph> qui contient les objets que l'instance actuelle attendra.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millièmes de secondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 millième de seconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>Waits for any of the elements in the specified array to receive a signal, using a <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</source>
          <target state="translated">Attend que l'un des éléments du tableau spécifié reçoive un signal ; en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The array index of the object that satisfied the wait, or <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.WaitTimeout" /&gt;</ph> if no object satisfied the wait and a time interval equivalent to <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> has passed.</source>
          <target state="translated">Index de tableau de l'objet ayant respecté l'attente ou <ph id="ph1">&lt;see cref="F:System.Threading.WaitHandle.WaitTimeout" /&gt;</ph> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> s'est écoulé.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>If <ph id="ph1">`timeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>It tests the state of the wait handles and returns immediately.</source>
          <target state="translated">Il teste l’état des handles d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> if the wait completes because a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> retourne de la méthode <ph id="ph2">`true`</ph> si l’attente se termine parce qu’un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> uniquement lorsque l’attente se termine en raison d’un mutex abandonné.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>If <ph id="ph1">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.</source>
          <target state="translated">Si <ph id="ph1">`waitHandles`</ph> contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode se termine normalement et l’exception n’est levée.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>, and that <ph id="ph2">`Mutex`</ph> is at index 0 (zero) in a <ph id="ph3">`WaitAny`</ph> array on another thread, the index returned by <ph id="ph4">`WaitAny`</ph> is 128 instead of 0.</source>
          <target state="translated">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>et qui <ph id="ph2">`Mutex`</ph> est à l’index 0 (zéro) dans un <ph id="ph3">`WaitAny`</ph> tableau sur un autre thread, l’index retourné par <ph id="ph4">`WaitAny`</ph> est 128 au lieu de 0.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</source>
          <target state="translated">Cette méthode retourne lorsque l’attente se termine lorsqu’une des poignées sont signalée soit lorsqu’un dépassement de délai se produit.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</source>
          <target state="translated">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>On some implementations, if more that 64 handles are passed, a <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">Dans certaines implémentations, si plus de 64 handles sont passés, un <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The maximum value for <ph id="ph1">`timeout`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La valeur maximale de <ph id="ph1">`timeout`</ph> est <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le <ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>Even if you are currently executing a method on a class that does not derive from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The thread returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes.</source>
          <target state="translated">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>This can be useful when the context-bound class has <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le pool de threads pour la recherche simultanée d’un fichier sur plusieurs disques.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>For space considerations, only the root directory of each disk is searched.</source>
          <target state="translated">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>One or more of the objects in the <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un ou plusieurs des objets dans le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> sont <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The number of objects in <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is greater than the system permits.</source>
          <target state="translated">Le nombre d’objets dans <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est supérieur à ce que le système autorise.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> is an array with no elements, and the .NET Framework version is 2.0 or later.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> array contains a transparent proxy for a <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="waitHandles" /&gt;</ph> contient un proxy transparent pour un <ph id="ph2">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="T:System.Threading.WaitHandle">
          <source>Blocks the current thread until the current <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> receives a signal.</source>
          <target state="translated">Bloque le thread actuel jusqu'à ce que le <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> actuel reçoive un signal.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>Blocks the current thread until the current <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> receives a signal.</source>
          <target state="translated">Bloque le thread actuel jusqu'à ce que le <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> actuel reçoive un signal.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current instance receives a signal.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'instance actuelle reçoit un signal.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>If the current instance is never signaled, <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /&gt;</ph> never returns.</source>
          <target state="translated">Si l'instance actuelle ne reçoit jamais de signal, <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /&gt;</ph> ne retourne jamais.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode renvoie <ph id="ph2">`true`</ph> quand un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>The caller of this method blocks indefinitely until the current instance receives a signal.</source>
          <target state="translated">L’appelant de cette méthode bloque indéfiniment jusqu'à ce que l’instance actuelle reçoive un signal.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>Use this method to block until a <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.</source>
          <target state="translated">Utilisez cette méthode pour bloquer jusqu'à un <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29&gt;</ph> method overload and specifying -1 or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> for the first parameter and <ph id="ph3">`false`</ph> for the second parameter.</source>
          <target state="translated">Appel de cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29&gt;</ph> surcharge de méthode et en spécifiant -1 ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> pour le premier paramètre et <ph id="ph3">`false`</ph> pour le deuxième paramètre.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>Override this method to customize the behavior of derived classes.</source>
          <target state="translated">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus de s’arrêter alors qu’il attend la fin de l’exécution d’un thread d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>The current instance has already been disposed.</source>
          <target state="translated">L’instance actuelle a déjà été supprimée.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne">
          <source>The current instance is a transparent proxy for a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">L'instance actuelle est un proxy transparent pour un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d'application.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>Blocks the current thread until the current <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</source>
          <target state="translated">Bloque le thread actuel jusqu'à ce que le <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> actuel reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current instance receives a signal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'instance actuelle reçoit un signal ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>It tests the state of the wait handle and returns immediately.</source>
          <target state="translated">Il teste l’état du handle d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>The caller of this method blocks until the current instance receives a signal or a time-out occurs.</source>
          <target state="translated">L’appelant de cette méthode bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>Use this method to block until a <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.</source>
          <target state="translated">Utilisez cette méthode pour bloquer jusqu'à un <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>Override this method to customize the behavior of derived classes.</source>
          <target state="translated">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`exitContext`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode est le même que d’appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29&gt;</ph> surcharge et en spécifiant <ph id="ph2">`false`</ph> pour <ph id="ph3">`exitContext`</ph>.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus de s’arrêter alors qu’il attend la fin de l’exécution d’un thread d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>The current instance has already been disposed.</source>
          <target state="translated">L’instance actuelle a déjà été supprimée.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32)">
          <source>The current instance is a transparent proxy for a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">L'instance actuelle est un proxy transparent pour un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d'application.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millièmes de secondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 millième de seconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>Blocks the current thread until the current instance receives a signal, using a <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> to specify the time interval.</source>
          <target state="translated">Bloque le thread actuel jusqu'à ce que l'instance actuelle reçoive un signal, en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> pour spécifier l'intervalle de temps.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current instance receives a signal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'instance actuelle reçoit un signal ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>It tests the state of the wait handle and returns immediately.</source>
          <target state="translated">Il teste l’état du handle d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>The caller of this method blocks until the current instance receives a signal or a time-out occurs.</source>
          <target state="translated">L’appelant de cette méthode bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>Use this method to block until a <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.</source>
          <target state="translated">Utilisez cette méthode pour bloquer jusqu'à un <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>Override this method to customize the behavior of derived classes.</source>
          <target state="translated">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>The maximum value for <ph id="ph1">`timeout`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La valeur maximale de <ph id="ph1">`timeout`</ph> est <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`exitContext`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode est le même que d’appeler le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29&gt;</ph> surcharge et en spécifiant <ph id="ph2">`false`</ph> pour <ph id="ph3">`exitContext`</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>The current instance has already been disposed.</source>
          <target state="translated">L’instance actuelle a déjà été supprimée.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)">
          <source>The current instance is a transparent proxy for a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">L'instance actuelle est un proxy transparent pour un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d'application.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>Blocks the current thread until the current <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</source>
          <target state="translated">Bloque le thread actuel jusqu'à ce que le <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> actuel reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current instance receives a signal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'instance actuelle reçoit un signal ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>It tests the state of the wait handle and returns immediately.</source>
          <target state="translated">Il teste l’état du handle d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode renvoie <ph id="ph2">`true`</ph> quand un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The caller of this method blocks until the current instance receives a signal or a time-out occurs.</source>
          <target state="translated">L’appelant de cette méthode bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>Use this method to block until a <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.</source>
          <target state="translated">Utilisez cette méthode pour bloquer jusqu'à un <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>Override this method to customize the behavior of derived classes.</source>
          <target state="translated">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le <ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>Even if you are currently executing a method on a class that does not derive from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The thread returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method completes.</source>
          <target state="translated">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>This can be useful when the context-bound class has <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The following example shows how the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29&gt;</ph> method overload behaves when it is called within a synchronization domain.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29&gt;</ph> surcharge de méthode se comporte lorsqu’elle est appelée au sein d’un domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>First, a thread waits with <ph id="ph1">`exitContext`</ph> set to <ph id="ph2">`false`</ph> and blocks until the wait timeout expires.</source>
          <target state="translated">Tout d’abord, un thread attend avec <ph id="ph1">`exitContext`</ph> la valeur <ph id="ph2">`false`</ph> et se bloque jusqu'à ce que le délai d’attente expire.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>A second thread executes after the first thread terminates and waits with <ph id="ph1">`exitContext`</ph> set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Un deuxième thread s’exécute après que le premier thread s’arrête et attend avec <ph id="ph1">`exitContext`</ph> la valeur <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</source>
          <target state="translated">L’appel pour signaler le handle d’attente de ce deuxième thread n’est pas bloqué, et le thread se termine avant le délai d’attente.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The current instance has already been disposed.</source>
          <target state="translated">L’instance actuelle a déjà été supprimée.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)">
          <source>The current instance is a transparent proxy for a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">L'instance actuelle est un proxy transparent pour un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d'application.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millièmes de secondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 millième de seconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>Blocks the current thread until the current instance receives a signal, using a <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</source>
          <target state="translated">Bloque le thread actuel jusqu'à ce que l'instance actuelle reçoive un signal, en utilisant une valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current instance receives a signal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'instance actuelle reçoit un signal ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>If <ph id="ph1">`timeout`</ph> is zero, the method does not block.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est égal à zéro, la méthode ne bloque pas.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>It tests the state of the wait handle and returns immediately.</source>
          <target state="translated">Il teste l’état du handle d’attente et retourne immédiatement.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> est une nouveauté de .NET Framework version 2.0.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>In previous versions, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when a mutex is abandoned.</source>
          <target state="translated">Dans les versions précédentes, le <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode renvoie <ph id="ph2">`true`</ph> quand un mutex est abandonné.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>An abandoned mutex often indicates a serious coding error.</source>
          <target state="translated">Un mutex abandonné indique souvent une grave erreur de codage.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows).</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The exception contains information useful for debugging.</source>
          <target state="translated">L’exception contient des informations utiles pour le débogage.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The caller of this method blocks until the current instance receives a signal or a time-out occurs.</source>
          <target state="translated">L’appelant de cette méthode bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>Use this method to block until a <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.</source>
          <target state="translated">Utilisez cette méthode pour bloquer jusqu'à un <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>Override this method to customize the behavior of derived classes.</source>
          <target state="translated">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The maximum value for <ph id="ph1">`timeout`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La valeur maximale de <ph id="ph1">`timeout`</ph> est <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le <ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>Even if you are currently executing a method on a class that does not derive from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The thread returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method completes.</source>
          <target state="translated">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>This can be useful when the context-bound class has <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus de s’arrêter alors qu’il attend la fin de l’exécution d’un thread d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The current instance has already been disposed.</source>
          <target state="translated">L’instance actuelle a déjà été supprimée.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The wait completed because a thread exited without releasing a mutex.</source>
          <target state="translated">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>This exception is not thrown on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)">
          <source>The current instance is a transparent proxy for a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> in another application domain.</source>
          <target state="translated">L'instance actuelle est un proxy transparent pour un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> dans un autre domaine d'application.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="F:System.Threading.WaitHandle.WaitTimeout">
          <source>Indicates that a <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /&gt;</ph> operation timed out before any of the wait handles were signaled.</source>
          <target state="translated">Indique que le délai fixé pour une opération <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /&gt;</ph> a été dépassé sans qu'aucun des handles d'attente n'ait été signalé.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="F:System.Threading.WaitHandle.WaitTimeout">
          <source>This field is constant.</source>
          <target state="translated">Ce champ est constant.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Threading.WaitHandle.WaitTimeout">
          <source>This field is one of the possible return values of <ph id="ph1">`WaitAny`</ph>.</source>
          <target state="translated">Ce champ est une des valeurs de retour possibles de <ph id="ph1">`WaitAny`</ph>.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Threading.WaitHandle.WaitTimeout">
          <source>The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le pool de threads pour la recherche simultanée d’un fichier sur plusieurs disques.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Threading.WaitHandle.WaitTimeout">
          <source>For space considerations, only the root directory of each disk is searched.</source>
          <target state="translated">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>