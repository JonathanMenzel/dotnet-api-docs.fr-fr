<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5bc57b6d09c8f3f7aebbf5cc7bfbbcb207a197ba" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51937859" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsule les objets spécifiques au système d'exploitation qui attendent un accès exclusif aux ressources partagées.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.WaitHandle> classe encapsule un descripteur de synchronisation du système d’exploitation natif et est utilisé pour représenter tous les objets de synchronisation dans le runtime qui permettent plusieurs opérations d’attente. Pour obtenir une comparaison de handles d’attente avec d’autres objets de synchronisation, consultez [vue d’ensemble des Primitives de synchronisation](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 Le <xref:System.Threading.WaitHandle> classe elle-même est abstraite. Les classes dérivées de <xref:System.Threading.WaitHandle> définissent un mécanisme de signalisation pour indiquer la capture ou la libération d’un accès à une ressource partagée, mais ils utilisent le hérité <xref:System.Threading.WaitHandle> méthodes pour bloquer lors de l’attente pour l’accès à des ressources partagées. Les classes dérivées de <xref:System.Threading.WaitHandle> incluent :  
  
-   La classe <xref:System.Threading.Mutex>. Consultez [mutex](~/docs/standard/threading/mutexes.md).  
  
-   Le <xref:System.Threading.EventWaitHandle> classe et ses classes dérivées, <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent>. Voir [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   La classe <xref:System.Threading.Semaphore>. Consultez [Semaphore et SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Threads peuvent bloquer un handle d’attente individuels en appelant la méthode d’instance <xref:System.Threading.WaitHandle.WaitOne%2A>, qui est hérité par les classes dérivées de <xref:System.Threading.WaitHandle>.  
  
 Les classes dérivées de <xref:System.Threading.WaitHandle> diffèrent dans leur affinité de thread. Handles d’attente d’événement (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, et <xref:System.Threading.ManualResetEvent>) et les sémaphores n’ont pas d’affinité de thread ; n’importe quel thread peut signaler un handle d’attente d’événement ou un sémaphore. Les mutex, quant à eux, ont une affinité de thread ; le thread qui détient un mutex doit le libérer et une exception est levée si un thread appelle la <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode sur un mutex qu’il ne possède pas.  
  
 Étant donné que le <xref:System.Threading.WaitHandle> dérive de la classe <xref:System.MarshalByRefObject>, ces classes peuvent être utilisées pour synchroniser les activités de threads au-delà des limites du domaine d’application.  
  
 En plus de ses classes dérivées, la <xref:System.Threading.WaitHandle> classe a un nombre de méthodes statiques qui bloque un thread jusqu'à ce qu’une ou plusieurs objets de synchronisation reçoivent un signal. Elles incluent notamment :  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, qui permet à un thread à un handle d’attente de signal et attendre immédiatement un autre.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, ce qui permet à un thread d’attendre jusqu'à ce que tous les handles d’attente dans un tableau reçoivent un signal.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, ce qui permet à un thread d’attendre jusqu'à ce que l’un d’un jeu spécifié de handles d’attente a été signalé.  
  
 Les surcharges de ces méthodes fournissent des intervalles de délai d’attente pour abandonner l’attente et la possibilité de quitter un contexte de synchronisation avant de commencer l’attente, autoriser d’autres threads à utiliser le contexte de synchronisation.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type ou un type dérivé de celle-ci, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.Threading.WaitHandle.Close%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 <xref:System.Threading.WaitHandle> implémente la <xref:System.IDisposable.Dispose%2A> modèle. Consultez [Dispose, modèle](~/docs/standard/design-guidelines/dispose-pattern.md). Lorsque vous dérivez de <xref:System.Threading.WaitHandle>, utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété pour stocker votre handle de système d’exploitation natif. Vous n’avez pas besoin de remplacer l’élément protégé <xref:System.Threading.WaitHandle.Dispose%2A> (méthode), sauf si vous utilisez des ressources non managées supplémentaires.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment deux threads peuvent effectuent les tâches en arrière-plan lors de la Main thread attend l’achèvement des tâches à l’aide de la méthode statique <xref:System.Threading.WaitHandle.WaitAny%2A> et <xref:System.Threading.WaitHandle.WaitAll%2A> méthodes de la <xref:System.Threading.WaitHandle> classe.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Thread</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Fonctionnalités et objets de threading</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent et ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sémaphores</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources détenues par le <see cref="T:System.Threading.WaitHandle" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est l’implémentation publique de la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> méthode pour la <xref:System.Threading.WaitHandle> classe et ses classes dérivées. Il fournit une implémentation standard qui appelle le `Dispose(Boolean)` surcharge avec un `true` argument, puis appelle le <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode). Appelez cette méthode pour libérer toutes les ressources détenues par une instance de `WaitHandle` ou une classe dérivée.  
  
 Une fois que cette méthode est appelée, les références à l’instance actuelle provoquent un comportement non défini.  
  
> [!NOTE]
>  Appelez toujours <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> avant de libérer votre dernière référence à la <xref:System.Threading.WaitHandle>. Sinon, les ressources qu’il utilise ne seront pas libérées.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous devez substituer la <see langword="Dispose(Boolean)" /> méthode pour libérer les ressources allouées dans les classes dérivées.</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implémentation d'une méthode Dispose</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l’instance actuelle de la classe <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à la <xref:System.Threading.WaitHandle.Close%2A> (méthode).  
  
> [!NOTE]
>  Appelez toujours <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> avant de libérer votre dernière référence à la <xref:System.Threading.WaitHandle>. Sinon, les ressources qu’il utilise ne seront pas libérées.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Nettoyage de ressources non managées</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par <see cref="T:System.Threading.WaitHandle" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le <xref:System.Threading.WaitHandle.Close%2A> et <xref:System.Threading.WaitHandle.Dispose> méthodes avec la `explicitDisposing` paramètre défini sur `true`.  Lorsque le `explicitDisposing` paramètre est `true`, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Threading.WaitHandle> références d’objet.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous devez substituer la <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> méthode pour libérer les ressources allouées dans les classes dérivées.  
  
Le <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> méthode peut être appelée plusieurs fois par d’autres objets. Lorsque vous substituez cette méthode, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un précédent appel à <see langword="Dispose" /> ou <see langword="Close" />.</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implémentation d'une méthode Dispose</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le handle du système d'exploitation natif.</summary>
        <value>
          <see langword="IntPtr" /> représentant le handle du système d'exploitation natif. La valeur par défaut est celle du champ <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Affectation d’une nouvelle valeur à la <xref:System.Threading.WaitHandle.Handle%2A> propriété ne ferme pas le handle précédent. Cela peut entraîner une fuite du handle.  
  
 N’utilisez pas cette propriété dans le .NET Framework version 2.0 ou ultérieure ; utiliser le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété à la place. Définition de cette propriété pour un handle valide définit également la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété, mais en lui affectant <xref:System.Threading.WaitHandle.InvalidHandle> peut entraîner une fuite du handle.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat définir la valeur de propriété. Ce membre ne peut pas être défini par le code de confiance partielle ou transparent.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Types dérivés doivent avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> pour définir la valeur de propriété.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente un handle du système d'exploitation natif non valide. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisé en interne pour initialiser le <xref:System.Threading.WaitHandle.Handle%2A> propriété.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez utiliser cette valeur pour déterminer si le <see cref="P:System.Threading.WaitHandle.Handle" /> propriété contient un handle valide de système d’exploitation natif.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le handle du système d'exploitation natif.</summary>
        <value>
          <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> représentant le handle du système d'exploitation natif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous assignez une nouvelle valeur à la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété, le handle précédent est fermé lorsque le précédent <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objet est collecté. Ne fermez pas manuellement le handle, car il en résulte un <xref:System.ObjectDisposedException> lorsque le <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> essaie de fermer le handle.  
  
 <xref:System.Threading.WaitHandle> implémente la <xref:System.IDisposable.Dispose%2A> modèle. Consultez [Dispose, modèle](~/docs/standard/design-guidelines/dispose-pattern.md). Lorsque vous dérivez de <xref:System.Threading.WaitHandle>, utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété pour stocker votre handle de système d’exploitation natif. Vous n’avez pas besoin de remplacer l’élément protégé <xref:System.Threading.WaitHandle.Dispose%2A> (méthode), sauf si vous utilisez des ressources non managées supplémentaires.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Types dérivés doivent avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> pour appeler ce membre.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale un <see cref="T:System.Threading.WaitHandle" /> et attend un autre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> à signaler.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> à attendre.</param>
        <summary>Signale un <see cref="T:System.Threading.WaitHandle" /> et attend un autre.</summary>
        <returns>
          <see langword="true" /> si le signal et l'attente se terminent avec succès ; si l'attente ne se termine pas, la méthode ne retourne pas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération n’est pas garantie pour être atomiques. Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.  
  
 L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE. L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="toWaitOn" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode a été appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> est un sémaphore, et possède déjà un nombre complet.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> à signaler.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> à attendre.</param>
        <param name="millisecondsTimeout">Entier qui représente l'intervalle à attendre. Si la valeur est <see cref="F:System.Threading.Timeout.Infinite" />, c'est-à-dire -1, l'attente est infinie.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Signale un <see cref="T:System.Threading.WaitHandle" /> et en attend un autre, en spécifiant un délai sous la forme d’un entier signé 32 bits et en spécifiant s’il faut quitter le domaine de synchronisation du contexte avant de commencer l’attente.</summary>
        <returns>
          <see langword="true" /> si le signal et l'attente se sont terminés avec succès ou <see langword="false" /> si le signal s'est terminé mais que l'attente a expiré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération n’est pas garantie pour être atomiques. Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.  
  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il vérifie l’état de la `toWaitOn` et retourne immédiatement.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="toWaitOn" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode est appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.WaitHandle" /> ne peut pas être signalé, car il dépasse sa valeur maximale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> à signaler.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> à attendre.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente l'intervalle à attendre. Si la valeur est -1, l'attente est infinie.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Signale un <see cref="T:System.Threading.WaitHandle" /> et en attend un autre, en spécifiant le délai sous la forme d’une valeur <see cref="T:System.TimeSpan" /> et en spécifiant s’il faut quitter le domaine de synchronisation du contexte avant de commencer l’attente.</summary>
        <returns>
          <see langword="true" /> si le signal et l'attente se sont terminés avec succès ou <see langword="false" /> si le signal s'est terminé mais que l'attente a expiré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération n’est pas garantie pour être atomiques. Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.  
  
 La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il vérifie l’état de la `toWaitOn` et retourne immédiatement.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="toWaitOn" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode a été appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> est un sémaphore, et possède déjà un nombre complet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> prend comme valeur un nombre négatif de millièmes de secondes autre que -1.  
  
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal.</summary>
        <returns>
          <see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, la méthode ne retourne jamais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lorsque tous les handles sont signalés. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. Si le tableau contient des doublons, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
 Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) pour `millisecondsTimeout` et `true` pour `exitContext`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers. Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée. Le thread principal attend que tous les éléments signaler et se termine.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />. - ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.  
  
</para>
          </block>  
  
 Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
- ou - 
L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet (doublons).</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.Int32" /> pour spécifier l'intervalle de temps.</summary>
        <returns>
          <see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état de handles d’attente et retourne immédiatement.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. S’il existe des doublons dans le tableau, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
 Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> est un tableau sans éléments.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.  
  
</para>
          </block>  
  
 Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
- ou - 
L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 milliseconde, pour attendre indéfiniment.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</summary>
        <returns>
          <see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état de handles d’attente et retourne immédiatement.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. Si le tableau contient des doublons, l’appel échoue.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
 La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> est un tableau sans éléments.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.  
  
</para>
          </block>  
  
 Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
- ou - 
L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini. 
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet (doublons).</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.Int32" /> pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</summary>
        <returns>
          <see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état de handles d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. S’il existe des doublons dans le tableau, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribut. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers. Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée. Le thread principal attend que tous les éléments signaler et se termine.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
- ou - 
L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 milliseconde, pour attendre indéfiniment.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</summary>
        <returns>
          <see langword="true" /> lorsque tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état de handles d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. Si le tableau contient des doublons, l’appel échoue.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
 La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode). Il retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers. Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée. Le thread principal attend que tous les éléments signaler et se termine.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
- ou - 
L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini. 
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal.</summary>
        <returns>Index du tableau de l'objet ayant respecté l'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.  
  
> [!NOTE]
>  Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.  
  
 Cette méthode est retournée lorsqu’un handle est signalé. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé". Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
 Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) pour `millisecondsTimeout` et `true` pour `exitContext`.  
  
   
  
## Examples  
 L’exemple de code suivant montre l’appel la <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode).  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</summary>
        <returns>Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="millisecondsTimeout" /> s'est écoulé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état de handles d’attente et retourne immédiatement.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.  
  
 Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’expiration se produit. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé". Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
 Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau sans éléments.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</summary>
        <returns>Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="timeout" /> s'est écoulé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état de handles d’attente et retourne immédiatement.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.  
  
 Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’attente se produit. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé". Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
 La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini. 
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau sans éléments.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Attend que l’un des éléments du tableau spécifié reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</summary>
        <returns>Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="millisecondsTimeout" /> s'est écoulé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état de handles d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.  
  
> [!NOTE]
>  Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.  
  
 Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’expiration se produit. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé". Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément. Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Attend que l’un des éléments du tableau spécifié reçoive un signal ; en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</summary>
        <returns>Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="timeout" /> s'est écoulé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état de handles d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.  
  
> [!NOTE]
>  Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.  
  
 Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’attente se produit. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé". Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
 La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément. Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
- ou - 
Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini. 
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal. Si l'instance actuelle ne reçoit jamais de signal, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> ne retourne jamais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 L’appelant de cette méthode se bloque indéfiniment jusqu'à ce que l’instance actuelle reçoive un signal. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pour le premier paramètre et `false` pour le deuxième paramètre.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état du handle d’attente et retourne immédiatement.  
  
 L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
 Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Bloque le thread actuel jusqu'à ce que l'instance actuelle reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état du handle d’attente et retourne immédiatement.  
  
 L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
 La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini. 
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Bloque le thread actuel jusqu’à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état du handle d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge de méthode se comporte lorsqu’elle est appelée dans un domaine de synchronisation. Tout d’abord, un thread attend avec `exitContext` défini sur `false` et bloque jusqu'à ce que le délai d’attente expire. Un deuxième thread s’exécute après que le premier thread s’arrête et attend avec `exitContext` défini sur `true`. L’appel pour signaler le handle d’attente de ce deuxième thread n’est pas bloqué, et le thread se termine avant le délai d’attente.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Bloque le thread actuel jusqu’à ce que l’instance actuelle reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état du handle d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows). L’exception contient des informations utiles pour le débogage.  
  
 L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
 La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini. 
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indique que le délai fixé pour une opération <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> a été dépassé sans qu'aucun des handles d'attente n'ait été signalé. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ est une des valeurs de retour possibles de `WaitAny`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément. Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>