<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="270c2a502b040636f65807d18c2bf250df51525c" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58722361" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="5f946-101">Encapsule des objets spécifiques au système d'exploitation, qui attendent un accès exclusif aux ressources partagées.</span><span class="sxs-lookup"><span data-stu-id="5f946-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-102">Le <xref:System.Threading.WaitHandle> classe encapsule un descripteur de synchronisation du système d’exploitation natif et est utilisé pour représenter tous les objets de synchronisation dans le runtime qui permettent plusieurs opérations d’attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="5f946-103">Pour obtenir une comparaison de handles d’attente avec d’autres objets de synchronisation, consultez [vue d’ensemble des Primitives de synchronisation](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="5f946-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="5f946-104">Le <xref:System.Threading.WaitHandle> classe elle-même est abstraite.</span><span class="sxs-lookup"><span data-stu-id="5f946-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="5f946-105">Les classes dérivées de <xref:System.Threading.WaitHandle> définissent un mécanisme de signalisation pour indiquer la capture ou la libération d’un accès à une ressource partagée, mais ils utilisent le hérité <xref:System.Threading.WaitHandle> méthodes pour bloquer lors de l’attente pour l’accès à des ressources partagées.</span><span class="sxs-lookup"><span data-stu-id="5f946-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="5f946-106">Les classes dérivées de <xref:System.Threading.WaitHandle> incluent :</span><span class="sxs-lookup"><span data-stu-id="5f946-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="5f946-107">La classe <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="5f946-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="5f946-108">Consultez [mutex](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="5f946-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="5f946-109">Le <xref:System.Threading.EventWaitHandle> classe et ses classes dérivées, <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="5f946-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="5f946-110">La classe <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="5f946-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="5f946-111">Consultez [Semaphore et SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="5f946-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="5f946-112">Threads peuvent bloquer un handle d’attente individuels en appelant la méthode d’instance <xref:System.Threading.WaitHandle.WaitOne%2A>, qui est hérité par les classes dérivées de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5f946-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="5f946-113">Les classes dérivées de <xref:System.Threading.WaitHandle> diffèrent dans leur affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="5f946-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="5f946-114">Handles d’attente d’événement (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, et <xref:System.Threading.ManualResetEvent>) et les sémaphores n’ont pas d’affinité de thread ; n’importe quel thread peut signaler un handle d’attente d’événement ou un sémaphore.</span><span class="sxs-lookup"><span data-stu-id="5f946-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="5f946-115">Les mutex, quant à eux, ont une affinité de thread ; le thread qui détient un mutex doit le libérer et une exception est levée si un thread appelle la <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode sur un mutex qu’il ne possède pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="5f946-116">Étant donné que le <xref:System.Threading.WaitHandle> dérive de la classe <xref:System.MarshalByRefObject>, ces classes peuvent être utilisées pour synchroniser les activités de threads au-delà des limites du domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="5f946-117">En plus de ses classes dérivées, la <xref:System.Threading.WaitHandle> classe a un nombre de méthodes statiques qui bloque un thread jusqu'à ce qu’une ou plusieurs objets de synchronisation reçoivent un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="5f946-118">Elles incluent notamment :</span><span class="sxs-lookup"><span data-stu-id="5f946-118">These include:</span></span>  
  
-   <span data-ttu-id="5f946-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, qui permet à un thread à un handle d’attente de signal et attendre immédiatement un autre.</span><span class="sxs-lookup"><span data-stu-id="5f946-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="5f946-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, ce qui permet à un thread d’attendre jusqu'à ce que tous les handles d’attente dans un tableau reçoivent un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="5f946-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, ce qui permet à un thread d’attendre jusqu'à ce que l’un d’un jeu spécifié de handles d’attente a été signalé.</span><span class="sxs-lookup"><span data-stu-id="5f946-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="5f946-122">Les surcharges de ces méthodes fournissent des intervalles de délai d’attente pour abandonner l’attente et la possibilité de quitter un contexte de synchronisation avant de commencer l’attente, autoriser d’autres threads à utiliser le contexte de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5f946-123">Ce type implémente le <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="5f946-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="5f946-124">Lorsque vous avez fini d’utiliser le type ou un type dérivé de celle-ci, vous devez supprimer il directement ou indirectement.</span><span class="sxs-lookup"><span data-stu-id="5f946-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="5f946-125">Pour supprimer le type directement, appelez sa <xref:System.Threading.WaitHandle.Close%2A> méthode dans un `try` / `catch` bloc.</span><span class="sxs-lookup"><span data-stu-id="5f946-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="5f946-126">Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en C#) ou `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5f946-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="5f946-127">Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.</span><span class="sxs-lookup"><span data-stu-id="5f946-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="5f946-128"><xref:System.Threading.WaitHandle> implémente la <xref:System.IDisposable.Dispose%2A> modèle.</span><span class="sxs-lookup"><span data-stu-id="5f946-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="5f946-129">Consultez [mise en œuvre d’une méthode Dispose (méthode)](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="5f946-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="5f946-130">Lorsque vous dérivez de <xref:System.Threading.WaitHandle>, utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété pour stocker votre handle de système d’exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="5f946-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="5f946-131">Vous n’avez pas besoin de remplacer l’élément protégé <xref:System.Threading.WaitHandle.Dispose%2A> (méthode), sauf si vous utilisez des ressources non managées supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="5f946-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-132">Le code suivant montre l’exemple comment deux threads peuvent effectuent les tâches en arrière-plan lors de la Main thread attend l’achèvement des tâches à l’aide de la méthode statique <xref:System.Threading.WaitHandle.WaitAny%2A> et <xref:System.Threading.WaitHandle.WaitAll%2A> méthodes de la <xref:System.Threading.WaitHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="5f946-133">Ce type est thread-safe.</span><span class="sxs-lookup"><span data-stu-id="5f946-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="5f946-134">Thread</span><span class="sxs-lookup"><span data-stu-id="5f946-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="5f946-135">Fonctionnalités et objets de threading</span><span class="sxs-lookup"><span data-stu-id="5f946-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="5f946-136">Mutex</span><span class="sxs-lookup"><span data-stu-id="5f946-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="5f946-137">EventWaitHandle, AutoResetEvent et ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="5f946-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="5f946-138">Sémaphores</span><span class="sxs-lookup"><span data-stu-id="5f946-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f946-139">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f946-140">Libère toutes les ressources détenues par le <see cref="T:System.Threading.WaitHandle" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-141">Cette méthode est l’implémentation publique de la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> méthode pour la <xref:System.Threading.WaitHandle> classe et ses classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5f946-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="5f946-142">Il fournit une implémentation standard qui appelle le `Dispose(Boolean)` surcharge avec un `true` argument, puis appelle le <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f946-143">Appelez cette méthode pour libérer toutes les ressources détenues par une instance de `WaitHandle` ou une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="5f946-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="5f946-144">Une fois que cette méthode est appelée, les références à l’instance actuelle provoquent un comportement non défini.</span><span class="sxs-lookup"><span data-stu-id="5f946-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-145">Appelez toujours <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> avant de libérer votre dernière référence à la <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5f946-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="5f946-146">Sinon, les ressources qu’il utilise ne seront pas libérées.</span><span class="sxs-lookup"><span data-stu-id="5f946-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="5f946-147">Vous devez substituer la <see langword="Dispose(Boolean)" /> méthode pour libérer les ressources allouées dans les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5f946-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="5f946-148">Implémentation d'une méthode Dispose</span><span class="sxs-lookup"><span data-stu-id="5f946-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f946-149">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f946-150">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-151">Cette méthode est équivalente à la <xref:System.Threading.WaitHandle.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-152">Appelez toujours <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> avant de libérer votre dernière référence à la <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5f946-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="5f946-153">Sinon, les ressources qu’il utilise ne seront pas libérées.</span><span class="sxs-lookup"><span data-stu-id="5f946-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="5f946-154">Nettoyage de ressources non managées</span><span class="sxs-lookup"><span data-stu-id="5f946-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="5f946-155"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="5f946-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="5f946-156">En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par <see cref="T:System.Threading.WaitHandle" /> et libère éventuellement les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="5f946-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-157">Cette méthode est appelée par le <xref:System.Threading.WaitHandle.Close%2A> et <xref:System.Threading.WaitHandle.Dispose> méthodes avec la `explicitDisposing` paramètre défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="5f946-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="5f946-158">Lorsque le `explicitDisposing` paramètre est `true`, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Threading.WaitHandle> références d’objet.</span><span class="sxs-lookup"><span data-stu-id="5f946-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="5f946-159">Vous devez substituer la <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> méthode pour libérer les ressources allouées dans les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5f946-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="5f946-160">Le <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> méthode peut être appelée plusieurs fois par d’autres objets.</span><span class="sxs-lookup"><span data-stu-id="5f946-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="5f946-161">Lorsque vous substituez cette méthode, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un précédent appel à <see langword="Dispose" /> ou <see langword="Close" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="5f946-162">Implémentation d'une méthode Dispose</span><span class="sxs-lookup"><span data-stu-id="5f946-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f946-163">Libère les ressources détenues par l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="5f946-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="5f946-164">Ce membre a été supprimé à partir de .NET Framework version 2.0 et versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="5f946-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="5f946-165">Cette rubrique s’applique uniquement aux versions répertoriées dans « Informations de Version » plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="5f946-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="5f946-166">Code d’application n’appelle pas cette méthode ; elle est automatiquement appelée lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée.</span><span class="sxs-lookup"><span data-stu-id="5f946-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="5f946-167">Pour plus d’informations, consultez <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> et <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="5f946-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="5f946-168">Cette méthode se substitue à <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="5f946-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5f946-169">Obtient ou définit le handle du système d'exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="5f946-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="5f946-170"><see langword="IntPtr" /> représentant le handle du système d'exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="5f946-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="5f946-171">La valeur par défaut est celle du champ <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-172">Affectation d’une nouvelle valeur à la <xref:System.Threading.WaitHandle.Handle%2A> propriété ne ferme pas le handle précédent.</span><span class="sxs-lookup"><span data-stu-id="5f946-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="5f946-173">Cela peut entraîner une fuite du handle.</span><span class="sxs-lookup"><span data-stu-id="5f946-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="5f946-174">N’utilisez pas cette propriété dans le .NET Framework version 2.0 ou ultérieure ; utiliser le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété à la place.</span><span class="sxs-lookup"><span data-stu-id="5f946-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="5f946-175">Définition de cette propriété pour un handle valide définit également la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété, mais en lui affectant <xref:System.Threading.WaitHandle.InvalidHandle> peut entraîner une fuite du handle.</span><span class="sxs-lookup"><span data-stu-id="5f946-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5f946-176">Requiert une confiance totale pour l’appelant immédiat définir la valeur de propriété.</span><span class="sxs-lookup"><span data-stu-id="5f946-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="5f946-177">Ce membre ne peut pas être défini par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="5f946-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="5f946-178">Types dérivés doivent avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> pour définir la valeur de propriété.</span><span class="sxs-lookup"><span data-stu-id="5f946-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5f946-179">Représente un handle du système d'exploitation natif non valide.</span><span class="sxs-lookup"><span data-stu-id="5f946-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="5f946-180">Ce champ est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="5f946-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-181">Utilisé en interne pour initialiser le <xref:System.Threading.WaitHandle.Handle%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="5f946-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="5f946-182">Vous pouvez utiliser cette valeur pour déterminer si le <see cref="P:System.Threading.WaitHandle.Handle" /> propriété contient un handle valide de système d’exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="5f946-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5f946-183">Obtient ou définit le handle du système d'exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="5f946-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="5f946-184"><see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> représentant le handle du système d'exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="5f946-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-185">Lorsque vous assignez une nouvelle valeur à la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété, le handle précédent est fermé lorsque le précédent <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objet est collecté.</span><span class="sxs-lookup"><span data-stu-id="5f946-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="5f946-186">Ne fermez pas manuellement le handle, car il en résulte un <xref:System.ObjectDisposedException> lorsque le <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> essaie de fermer le handle.</span><span class="sxs-lookup"><span data-stu-id="5f946-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="5f946-187"><xref:System.Threading.WaitHandle> implémente la <xref:System.IDisposable.Dispose%2A> modèle.</span><span class="sxs-lookup"><span data-stu-id="5f946-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="5f946-188">Consultez [mise en œuvre d’une méthode Dispose (méthode)](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="5f946-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="5f946-189">Lorsque vous dérivez de <xref:System.Threading.WaitHandle>, utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété pour stocker votre handle de système d’exploitation natif.</span><span class="sxs-lookup"><span data-stu-id="5f946-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="5f946-190">Vous n’avez pas besoin de remplacer l’élément protégé <xref:System.Threading.WaitHandle.Dispose%2A> (méthode), sauf si vous utilisez des ressources non managées supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="5f946-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5f946-191">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="5f946-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f946-192">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="5f946-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="5f946-193">Types dérivés doivent avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> pour appeler ce membre.</span><span class="sxs-lookup"><span data-stu-id="5f946-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f946-194">Signale un <see cref="T:System.Threading.WaitHandle" /> et attend un autre.</span><span class="sxs-lookup"><span data-stu-id="5f946-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="5f946-195"><see cref="T:System.Threading.WaitHandle" /> à signaler.</span><span class="sxs-lookup"><span data-stu-id="5f946-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="5f946-196"><see cref="T:System.Threading.WaitHandle" /> à attendre.</span><span class="sxs-lookup"><span data-stu-id="5f946-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="5f946-197">Signale un <see cref="T:System.Threading.WaitHandle" /> et attend un autre.</span><span class="sxs-lookup"><span data-stu-id="5f946-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="5f946-198"><see langword="true" /> si le signal et l'attente se terminent avec succès ; si l'attente ne se termine pas, la méthode ne retourne pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-199">Cette opération n’est pas garantie pour être atomiques.</span><span class="sxs-lookup"><span data-stu-id="5f946-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="5f946-200">Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.</span><span class="sxs-lookup"><span data-stu-id="5f946-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-201">Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</span><span class="sxs-lookup"><span data-stu-id="5f946-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="5f946-202">L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE.</span><span class="sxs-lookup"><span data-stu-id="5f946-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="5f946-203">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="5f946-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-204"><paramref name="toSignal" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-205">- ou -</span><span class="sxs-lookup"><span data-stu-id="5f946-205">-or-</span></span> 
 <span data-ttu-id="5f946-206"><paramref name="toWaitOn" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-207">La méthode a été appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-207">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="5f946-208">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-208">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-209"><paramref name="toSignal" /> est un sémaphore, et possède déjà un nombre complet.</span><span class="sxs-lookup"><span data-stu-id="5f946-209"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-210">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-210">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-211">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-211">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="5f946-212"><see cref="T:System.Threading.WaitHandle" /> à signaler.</span><span class="sxs-lookup"><span data-stu-id="5f946-212">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="5f946-213"><see cref="T:System.Threading.WaitHandle" /> à attendre.</span><span class="sxs-lookup"><span data-stu-id="5f946-213">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5f946-214">Entier qui représente l'intervalle à attendre.</span><span class="sxs-lookup"><span data-stu-id="5f946-214">An integer that represents the interval to wait.</span></span> <span data-ttu-id="5f946-215">Si la valeur est <see cref="F:System.Threading.Timeout.Infinite" />, c'est-à-dire -1, l'attente est infinie.</span><span class="sxs-lookup"><span data-stu-id="5f946-215">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="5f946-216"><see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-216"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f946-217">Signale un <see cref="T:System.Threading.WaitHandle" /> et en attend un autre, en spécifiant un délai sous la forme d'un entier signé 32 bits et en spécifiant s'il faut quitter le domaine de synchronisation du contexte avant de commencer l'attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-217">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="5f946-218"><see langword="true" /> si le signal et l'attente se sont terminés avec succès ou <see langword="false" /> si le signal s'est terminé mais que l'attente a expiré.</span><span class="sxs-lookup"><span data-stu-id="5f946-218"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-219">Cette opération n’est pas garantie pour être atomiques.</span><span class="sxs-lookup"><span data-stu-id="5f946-219">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="5f946-220">Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.</span><span class="sxs-lookup"><span data-stu-id="5f946-220">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="5f946-221">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-221">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-222">Il vérifie l’état de la `toWaitOn` et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-222">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5f946-223">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="5f946-223">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5f946-224">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="5f946-224">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5f946-225">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5f946-225">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5f946-226">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-226">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5f946-227">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-227">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="5f946-228">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-228">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="5f946-229">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-229">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5f946-230">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-230">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5f946-231">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="5f946-231">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5f946-232">Lorsque le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-232">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-233"><paramref name="toSignal" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-233"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-234">- ou -</span><span class="sxs-lookup"><span data-stu-id="5f946-234">-or-</span></span> 
 <span data-ttu-id="5f946-235"><paramref name="toWaitOn" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-235"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-236">La méthode est appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-236">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="5f946-237">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-237">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-238"><see cref="T:System.Threading.WaitHandle" /> ne peut pas être signalé, car il dépasse sa valeur maximale.</span><span class="sxs-lookup"><span data-stu-id="5f946-238">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-239"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-239"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-240">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-240">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-241">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-241">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="5f946-242"><see cref="T:System.Threading.WaitHandle" /> à signaler.</span><span class="sxs-lookup"><span data-stu-id="5f946-242">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="5f946-243"><see cref="T:System.Threading.WaitHandle" /> à attendre.</span><span class="sxs-lookup"><span data-stu-id="5f946-243">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="5f946-244"><see cref="T:System.TimeSpan" /> qui représente l'intervalle à attendre.</span><span class="sxs-lookup"><span data-stu-id="5f946-244">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="5f946-245">Si la valeur est -1, l'attente est infinie.</span><span class="sxs-lookup"><span data-stu-id="5f946-245">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="5f946-246"><see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-246"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f946-247">Signale un <see cref="T:System.Threading.WaitHandle" /> et en attend un autre, en spécifiant le délai sous la forme d’une valeur <see cref="T:System.TimeSpan" /> et en spécifiant s’il faut quitter le domaine de synchronisation du contexte avant de commencer l’attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-247">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="5f946-248"><see langword="true" /> si le signal et l'attente se sont terminés avec succès ou <see langword="false" /> si le signal s'est terminé mais que l'attente a expiré.</span><span class="sxs-lookup"><span data-stu-id="5f946-248"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-249">Cette opération n’est pas garantie pour être atomiques.</span><span class="sxs-lookup"><span data-stu-id="5f946-249">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="5f946-250">Après les signaux de thread actuelle `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre sur lui.</span><span class="sxs-lookup"><span data-stu-id="5f946-250">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="5f946-251">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5f946-251">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f946-252">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-252">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-253">Il vérifie l’état de la `toWaitOn` et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-253">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5f946-254">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="5f946-254">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5f946-255">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="5f946-255">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5f946-256">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5f946-256">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5f946-257">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-257">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5f946-258">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-258">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="5f946-259">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-259">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="5f946-260">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-260">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5f946-261">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-261">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5f946-262">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="5f946-262">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5f946-263">Lorsque le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-263">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-264"><paramref name="toSignal" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-264"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-265">- ou -</span><span class="sxs-lookup"><span data-stu-id="5f946-265">-or-</span></span> 
 <span data-ttu-id="5f946-266"><paramref name="toWaitOn" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-266"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-267">La méthode a été appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-267">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="5f946-268">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-268">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-269"><paramref name="toSignal" /> est un sémaphore, et possède déjà un nombre complet.</span><span class="sxs-lookup"><span data-stu-id="5f946-269"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-270"><paramref name="timeout" /> prend comme valeur un nombre négatif de millièmes de secondes autre que -1.</span><span class="sxs-lookup"><span data-stu-id="5f946-270"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="5f946-271">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-271">-or-</span></span> 
 <span data-ttu-id="5f946-272"><paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-272"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-273">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-273">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-274">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-274">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f946-275">Libère toutes les ressources utilisées par <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-275">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="5f946-276">Appel `Dispose` autorise les ressources utilisées par le <xref:System.Threading.WaitHandle> d’être réaffectées à d’autres fins.</span><span class="sxs-lookup"><span data-stu-id="5f946-276">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="5f946-277">Pour plus d’informations sur `Dispose`, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="5f946-277">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f946-278">Attend que tous les éléments du tableau spécifié reçoivent un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-279">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-279">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5f946-280">Ce tableau ne peut pas contenir plusieurs références au même objet.</span><span class="sxs-lookup"><span data-stu-id="5f946-280">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="5f946-281">Attend que tous les éléments du tableau spécifié reçoivent un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-281">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="5f946-282"><see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, la méthode ne retourne jamais.</span><span class="sxs-lookup"><span data-stu-id="5f946-282"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-283"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-283"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-284">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-284">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5f946-285">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-285">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-286">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-286">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-287">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-287">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-288">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lorsque tous les handles sont signalés.</span><span class="sxs-lookup"><span data-stu-id="5f946-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="5f946-289">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-289">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5f946-290">Si le tableau contient des doublons, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="5f946-290">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-291">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="5f946-292">Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) pour `millisecondsTimeout` et `true` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5f946-292">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-293">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</span><span class="sxs-lookup"><span data-stu-id="5f946-293">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="5f946-294">Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée.</span><span class="sxs-lookup"><span data-stu-id="5f946-294">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="5f946-295">Le thread principal attend que tous les éléments signaler et se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-295">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-296">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="5f946-297">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-297">-or-</span></span> 
<span data-ttu-id="5f946-298">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-298">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-299">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-299">-or-</span></span> 
 <span data-ttu-id="5f946-300"><paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</span><span class="sxs-lookup"><span data-stu-id="5f946-300"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="5f946-301">Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.</span><span class="sxs-lookup"><span data-stu-id="5f946-301">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="5f946-302">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</span><span class="sxs-lookup"><span data-stu-id="5f946-302">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-303">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-303">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="5f946-304">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-304">-or-</span></span> 
<span data-ttu-id="5f946-305">L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-305">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="5f946-306"><paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="5f946-306"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-307">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-307">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-308">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-308">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-309">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-309">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-310">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-310">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5f946-311">Ce tableau ne peut pas contenir plusieurs références au même objet (doublons).</span><span class="sxs-lookup"><span data-stu-id="5f946-311">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5f946-312">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-312">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5f946-313">Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.Int32" /> pour spécifier l'intervalle de temps.</span><span class="sxs-lookup"><span data-stu-id="5f946-313">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="5f946-314"><see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-314"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-315">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-315">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-316">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-316">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-317">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="5f946-318">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-318">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5f946-319">S’il existe des doublons dans le tableau, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="5f946-319">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-320">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-320">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="5f946-321">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5f946-321">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-322">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-322">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-323">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-323">-or-</span></span> 
<span data-ttu-id="5f946-324">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-324">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-325">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-325">-or-</span></span> 
 <span data-ttu-id="5f946-326"><paramref name="waitHandles" /> est un tableau sans éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-326"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="5f946-327">Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.</span><span class="sxs-lookup"><span data-stu-id="5f946-327">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="5f946-328">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</span><span class="sxs-lookup"><span data-stu-id="5f946-328">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-329">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-329">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="5f946-330">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-330">-or-</span></span> 
<span data-ttu-id="5f946-331">L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-331">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-332"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-332"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-333">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-333">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-334">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-334">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-335">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-335">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-336">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-336">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5f946-337">Ce tableau ne peut pas contenir plusieurs références au même objet.</span><span class="sxs-lookup"><span data-stu-id="5f946-337">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="5f946-338"><see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 milliseconde, pour attendre indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="5f946-338">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5f946-339">Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</span><span class="sxs-lookup"><span data-stu-id="5f946-339">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="5f946-340"><see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-340"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-341">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-341">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-342">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-342">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-343">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="5f946-344">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-344">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5f946-345">Si le tableau contient des doublons, l’appel échoue.</span><span class="sxs-lookup"><span data-stu-id="5f946-345">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-346">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-346">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="5f946-347">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5f946-347">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f946-348">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5f946-348">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-349">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-349">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-350">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-350">-or-</span></span> 
<span data-ttu-id="5f946-351">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-351">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-352">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-352">-or-</span></span> 
 <span data-ttu-id="5f946-353"><paramref name="waitHandles" /> est un tableau sans éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-353"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="5f946-354">Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.</span><span class="sxs-lookup"><span data-stu-id="5f946-354">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="5f946-355">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</span><span class="sxs-lookup"><span data-stu-id="5f946-355">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-356">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-356">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="5f946-357">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-357">-or-</span></span> 
<span data-ttu-id="5f946-358">L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-358">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-359"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-359"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="5f946-360">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-360">-or-</span></span> 
 <span data-ttu-id="5f946-361"><paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-361"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-362">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-362">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-363">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-363">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-364">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-364">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-365">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-365">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5f946-366">Ce tableau ne peut pas contenir plusieurs références au même objet (doublons).</span><span class="sxs-lookup"><span data-stu-id="5f946-366">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5f946-367">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-367">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="5f946-368"><see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-368"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f946-369">Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.Int32" /> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-369">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="5f946-370"><see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-370"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-371">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-371">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-372">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-372">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-373"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-373"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-374">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-374">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5f946-375">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-375">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-376">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-376">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-377">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-377">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-378">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="5f946-379">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-379">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5f946-380">S’il existe des doublons dans le tableau, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="5f946-380">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-381">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-381">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5f946-382">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="5f946-382">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5f946-383">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="5f946-383">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5f946-384">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5f946-384">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5f946-385">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-385">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5f946-386">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-386">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="5f946-387">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-387">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="5f946-388">Cela peut être utile lorsque la classe liée au contexte comporte la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="5f946-388">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="5f946-389">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-389">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5f946-390">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="5f946-390">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5f946-391">Lorsque le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-391">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-392">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</span><span class="sxs-lookup"><span data-stu-id="5f946-392">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="5f946-393">Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée.</span><span class="sxs-lookup"><span data-stu-id="5f946-393">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="5f946-394">Le thread principal attend que tous les éléments signaler et se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-394">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-395">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-395">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-396">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-396">-or-</span></span> 
<span data-ttu-id="5f946-397">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-397">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-398">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-398">-or-</span></span> 
 <span data-ttu-id="5f946-399"><paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</span><span class="sxs-lookup"><span data-stu-id="5f946-399"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="5f946-400">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</span><span class="sxs-lookup"><span data-stu-id="5f946-400">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-401">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-401">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="5f946-402">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-402">-or-</span></span> 
<span data-ttu-id="5f946-403">L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-403">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="5f946-404"><paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="5f946-404"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-405"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-405"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-406">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-406">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-407">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-407">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-408">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-408">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-409">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-409">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="5f946-410">Ce tableau ne peut pas contenir plusieurs références au même objet.</span><span class="sxs-lookup"><span data-stu-id="5f946-410">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="5f946-411"><see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 milliseconde, pour attendre indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="5f946-411">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="5f946-412"><see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-412"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f946-413">Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-413">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="5f946-414"><see langword="true" /> lorsque tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-414"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-415">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-415">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-416">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-416">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-417"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-417"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-418">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-418">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5f946-419">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-419">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-420">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-420">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-421">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-421">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-422">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lors de l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="5f946-423">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-423">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="5f946-424">Si le tableau contient des doublons, l’appel échoue.</span><span class="sxs-lookup"><span data-stu-id="5f946-424">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-425">Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-425">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="5f946-426">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5f946-426">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5f946-427">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="5f946-427">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5f946-428">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="5f946-428">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5f946-429">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5f946-429">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5f946-430">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-430">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5f946-431">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-431">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="5f946-432">Il retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-432">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="5f946-433">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-433">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5f946-434">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-434">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5f946-435">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="5f946-435">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5f946-436">Lorsque le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-436">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-437">L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers.</span><span class="sxs-lookup"><span data-stu-id="5f946-437">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="5f946-438">Chaque opération d’écriture est en file d’attente en tant qu’un élément de travail et des signaux lorsqu’elle est terminée.</span><span class="sxs-lookup"><span data-stu-id="5f946-438">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="5f946-439">Le thread principal attend que tous les éléments signaler et se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-439">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-440">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-440">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-441">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-441">-or-</span></span> 
<span data-ttu-id="5f946-442">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-442">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-443">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-443">-or-</span></span> 
 <span data-ttu-id="5f946-444"><paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</span><span class="sxs-lookup"><span data-stu-id="5f946-444"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="5f946-445">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</span><span class="sxs-lookup"><span data-stu-id="5f946-445">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-446">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-446">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="5f946-447">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-447">-or-</span></span> 
<span data-ttu-id="5f946-448">L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-448">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="5f946-449"><paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="5f946-449"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-450"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-450"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="5f946-451">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-451">-or-</span></span> 
 <span data-ttu-id="5f946-452"><paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-452"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-453">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-453">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-454">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-455">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-455">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f946-456">Attend que l'un des éléments du tableau spécifié reçoive un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-456">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-457">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="5f946-458">Attend que l'un des éléments du tableau spécifié reçoive un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-458">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="5f946-459">Index du tableau de l'objet ayant respecté l'attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-459">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-460"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-460"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-461">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-461">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="5f946-462">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-462">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-463">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-463">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-464">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-464">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-465">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-465">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5f946-466">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-466">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-467">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.</span><span class="sxs-lookup"><span data-stu-id="5f946-467">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="5f946-468">Cette méthode est retournée lorsqu’un handle est signalé.</span><span class="sxs-lookup"><span data-stu-id="5f946-468">This method returns when any handle is signaled.</span></span> <span data-ttu-id="5f946-469">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="5f946-469">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5f946-470">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-470">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="5f946-471">Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) pour `millisecondsTimeout` et `true` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5f946-471">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-472">L’exemple de code suivant montre l’appel la <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-472">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-473">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-473">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-474">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-474">-or-</span></span> 
<span data-ttu-id="5f946-475">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-475">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-476">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-476">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="5f946-477"><paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="5f946-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-478">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-478">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-479">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-479">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f946-480"><paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</span><span class="sxs-lookup"><span data-stu-id="5f946-480"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-481">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-481">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-482">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-482">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5f946-483">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-483">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5f946-484">Attend que l'un des éléments du tableau spécifié reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</span><span class="sxs-lookup"><span data-stu-id="5f946-484">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="5f946-485">Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="millisecondsTimeout" /> s'est écoulé.</span><span class="sxs-lookup"><span data-stu-id="5f946-485">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-486">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-486">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-487">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-487">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-488">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-488">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5f946-489">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-489">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="5f946-490">Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’expiration se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-490">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="5f946-491">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="5f946-491">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5f946-492">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-492">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="5f946-493">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5f946-493">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-494">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-494">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-495">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-495">-or-</span></span> 
<span data-ttu-id="5f946-496">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-496">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-497">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-497">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-498"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-498"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-499">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-499">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-500">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-500">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f946-501"><paramref name="waitHandles" /> est un tableau sans éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-501"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-502">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-502">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-503">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-503">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="5f946-504"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="5f946-504">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5f946-505">Attend que l'un des éléments du tableau spécifié reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</span><span class="sxs-lookup"><span data-stu-id="5f946-505">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="5f946-506">Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="timeout" /> s'est écoulé.</span><span class="sxs-lookup"><span data-stu-id="5f946-506">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-507">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-507">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-508">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-508">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-509">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-509">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5f946-510">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-510">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="5f946-511">Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-511">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="5f946-512">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="5f946-512">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5f946-513">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-513">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="5f946-514">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5f946-514">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f946-515">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5f946-515">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-516">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-516">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-517">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-517">-or-</span></span> 
<span data-ttu-id="5f946-518">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-518">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-519">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-519">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-520"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-520"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="5f946-521">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-521">-or-</span></span> 
 <span data-ttu-id="5f946-522"><paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-522"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-523">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-523">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-524">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-524">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f946-525"><paramref name="waitHandles" /> est un tableau sans éléments.</span><span class="sxs-lookup"><span data-stu-id="5f946-525"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-526">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-526">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-527">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-527">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="5f946-528">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-528">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="5f946-529"><see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-529"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f946-530">Attend que l’un des éléments du tableau spécifié reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-530">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="5f946-531">Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="millisecondsTimeout" /> s'est écoulé.</span><span class="sxs-lookup"><span data-stu-id="5f946-531">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-532">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-532">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-533">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-533">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-534"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-534"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-535">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-535">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="5f946-536">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-536">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-537">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-537">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-538">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-538">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-539">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-539">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5f946-540">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-540">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-541">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.</span><span class="sxs-lookup"><span data-stu-id="5f946-541">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="5f946-542">Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’expiration se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-542">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="5f946-543">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="5f946-543">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5f946-544">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-544">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5f946-545">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="5f946-545">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5f946-546">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="5f946-546">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5f946-547">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5f946-547">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5f946-548">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-548">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5f946-549">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-549">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="5f946-550">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-550">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="5f946-551">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-551">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5f946-552">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-552">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5f946-553">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="5f946-553">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5f946-554">Lorsque le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-554">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-555">L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément.</span><span class="sxs-lookup"><span data-stu-id="5f946-555">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="5f946-556">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</span><span class="sxs-lookup"><span data-stu-id="5f946-556">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-557">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-557">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-558">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-558">-or-</span></span> 
<span data-ttu-id="5f946-559">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-559">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-560">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-560">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="5f946-561"><paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="5f946-561"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-562"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-562"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-563">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-563">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-564">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-564">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f946-565"><paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</span><span class="sxs-lookup"><span data-stu-id="5f946-565"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-566">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-566">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="5f946-567">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</span><span class="sxs-lookup"><span data-stu-id="5f946-567">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="5f946-568"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="5f946-568">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="5f946-569"><see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-569"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f946-570">Attend que l’un des éléments du tableau spécifié reçoive un signal ; en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-570">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="5f946-571">Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="timeout" /> s'est écoulé.</span><span class="sxs-lookup"><span data-stu-id="5f946-571">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-572">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-572">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-573">Il teste l’état de handles d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-573">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-574"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-574"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-575">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine, car un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-575">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="5f946-576">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-576">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-577">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-577">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-578">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-578">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-579">Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève un <xref:System.Threading.AbandonedMutexException> uniquement quand l’attente se termine en raison d’un mutex abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-579">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="5f946-580">Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-580">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f946-581">Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.</span><span class="sxs-lookup"><span data-stu-id="5f946-581">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="5f946-582">Cette méthode est retournée lors de l’attente se termine lorsqu’un des handles sont signalé ou lorsqu’un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-582">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="5f946-583">Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé avec la plus petite valeur d’index de tous les objets "signalé".</span><span class="sxs-lookup"><span data-stu-id="5f946-583">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="5f946-584">Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5f946-584">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="5f946-585">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5f946-585">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5f946-586">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="5f946-586">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5f946-587">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="5f946-587">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5f946-588">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5f946-588">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5f946-589">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-589">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5f946-590">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-590">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="5f946-591">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-591">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="5f946-592">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-592">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5f946-593">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-593">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5f946-594">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="5f946-594">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5f946-595">Lorsque le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-595">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-596">L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément.</span><span class="sxs-lookup"><span data-stu-id="5f946-596">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="5f946-597">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</span><span class="sxs-lookup"><span data-stu-id="5f946-597">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5f946-598">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-598">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5f946-599">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-599">-or-</span></span> 
<span data-ttu-id="5f946-600">Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-600">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5f946-601">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</span><span class="sxs-lookup"><span data-stu-id="5f946-601">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="5f946-602"><paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="5f946-602"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-603"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-603"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="5f946-604">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-604">-or-</span></span> 
 <span data-ttu-id="5f946-605"><paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-605"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-606">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-606">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-607">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-607">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f946-608"><paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</span><span class="sxs-lookup"><span data-stu-id="5f946-608"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-609">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="5f946-609">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f946-610">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f946-611">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-611">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="5f946-612"><see langword="true" /> si l'instance actuelle reçoit un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-612"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="5f946-613">Si l'instance actuelle ne reçoit jamais de signal, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> ne retourne jamais.</span><span class="sxs-lookup"><span data-stu-id="5f946-613">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-614"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-615">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5f946-616">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-617">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-618">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-619">L’appelant de cette méthode se bloque indéfiniment jusqu'à ce que l’instance actuelle reçoive un signal.</span><span class="sxs-lookup"><span data-stu-id="5f946-619">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="5f946-620">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5f946-621">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="5f946-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5f946-622">Appel de cette surcharge de méthode revient à appeler le <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pour le premier paramètre et `false` pour le deuxième paramètre.</span><span class="sxs-lookup"><span data-stu-id="5f946-622">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="5f946-623">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5f946-623">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-624">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5f946-624">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5f946-625">L’instance actuelle a déjà été supprimée.</span><span class="sxs-lookup"><span data-stu-id="5f946-625">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-626">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-627">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-628">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="5f946-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="5f946-629">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-629">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5f946-630">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</span><span class="sxs-lookup"><span data-stu-id="5f946-630">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="5f946-631"><see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-632">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-632">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-633">Il teste l’état du handle d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-634">L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="5f946-635">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5f946-636">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="5f946-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5f946-637">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5f946-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="5f946-638">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5f946-638">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-639">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5f946-639">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5f946-640">L’instance actuelle a déjà été supprimée.</span><span class="sxs-lookup"><span data-stu-id="5f946-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-641"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-641"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-642">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-642">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-643">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-643">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-644">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="5f946-644">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="5f946-645"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="5f946-645">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="5f946-646">Bloque le thread actuel jusqu'à ce que l'instance actuelle reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</span><span class="sxs-lookup"><span data-stu-id="5f946-646">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="5f946-647"><see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-647"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-648">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-648">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-649">Il teste l’état du handle d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-649">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-650">L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-650">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="5f946-651">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-651">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5f946-652">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="5f946-652">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5f946-653">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5f946-653">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="5f946-654">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5f946-654">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f946-655">Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="5f946-655">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5f946-656">L’instance actuelle a déjà été supprimée.</span><span class="sxs-lookup"><span data-stu-id="5f946-656">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-657"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-657"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="5f946-658">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-658">-or-</span></span> 
 <span data-ttu-id="5f946-659"><paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-659"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-660">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-660">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-661">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-661">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-662">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="5f946-662">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="5f946-663">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-663">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="5f946-664"><see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-664"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f946-665">Bloque le thread actuel jusqu’à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-665">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="5f946-666"><see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-666"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-667">Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-667">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-668">Il teste l’état du handle d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-668">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-669"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-669"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-670">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-670">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5f946-671">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-671">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-672">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-672">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-673">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-673">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-674">L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-674">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="5f946-675">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-675">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5f946-676">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="5f946-676">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5f946-677">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5f946-677">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5f946-678">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="5f946-678">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5f946-679">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="5f946-679">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5f946-680">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5f946-680">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5f946-681">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-681">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5f946-682">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-682">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="5f946-683">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-683">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="5f946-684">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-684">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5f946-685">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-685">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5f946-686">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="5f946-686">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5f946-687">Lorsque le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-687">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-688">L’exemple suivant montre comment la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge de méthode se comporte lorsqu’elle est appelée dans un domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-688">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="5f946-689">Tout d’abord, un thread attend avec `exitContext` défini sur `false` et bloque jusqu'à ce que le délai d’attente expire.</span><span class="sxs-lookup"><span data-stu-id="5f946-689">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="5f946-690">Un deuxième thread s’exécute après que le premier thread s’arrête et attend avec `exitContext` défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="5f946-690">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="5f946-691">L’appel pour signaler le handle d’attente de ce deuxième thread n’est pas bloqué, et le thread se termine avant le délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-691">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5f946-692">L’instance actuelle a déjà été supprimée.</span><span class="sxs-lookup"><span data-stu-id="5f946-692">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-693"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-693"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-694">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-694">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-695">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-695">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-696">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="5f946-696">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="5f946-697"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="5f946-697">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="5f946-698"><see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-698"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f946-699">Bloque le thread actuel jusqu'à ce que l'instance actuelle reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</span><span class="sxs-lookup"><span data-stu-id="5f946-699">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="5f946-700"><see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-700"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-701">Si `timeout` est égal à zéro, la méthode ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="5f946-701">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="5f946-702">Il teste l’état du handle d’attente et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="5f946-702">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="5f946-703"><xref:System.Threading.AbandonedMutexException> est une nouveauté dans le .NET Framework version 2.0.</span><span class="sxs-lookup"><span data-stu-id="5f946-703"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5f946-704">Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> retourne de la méthode `true` lorsqu’un mutex est abandonné.</span><span class="sxs-lookup"><span data-stu-id="5f946-704">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="5f946-705">Un mutex abandonné indique souvent une grave erreur de codage.</span><span class="sxs-lookup"><span data-stu-id="5f946-705">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="5f946-706">Dans le cas d’un mutex système, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches Windows).</span><span class="sxs-lookup"><span data-stu-id="5f946-706">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="5f946-707">L’exception contient des informations utiles pour le débogage.</span><span class="sxs-lookup"><span data-stu-id="5f946-707">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="5f946-708">L’appelant de cette méthode se bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit.</span><span class="sxs-lookup"><span data-stu-id="5f946-708">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="5f946-709">Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-709">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="5f946-710">Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="5f946-710">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="5f946-711">Substituez cette méthode pour personnaliser le comportement des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5f946-711">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="5f946-712">La valeur maximale pour `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5f946-712">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="5f946-713">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="5f946-713">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="5f946-714">Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="5f946-714">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="5f946-715">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="5f946-715">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="5f946-716">Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="5f946-716">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="5f946-717">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5f946-717">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="5f946-718">Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="5f946-718">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="5f946-719">Cela peut être utile lorsque la classe liée au contexte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5f946-719">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="5f946-720">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="5f946-720">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="5f946-721">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="5f946-721">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="5f946-722">Lorsque le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5f946-722">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-723">L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus à partir de la fin d’exécution alors qu’il attend un thread d’arrière-plan terminer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5f946-723">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5f946-724">L’instance actuelle a déjà été supprimée.</span><span class="sxs-lookup"><span data-stu-id="5f946-724">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f946-725"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</span><span class="sxs-lookup"><span data-stu-id="5f946-725"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="5f946-726">ou</span><span class="sxs-lookup"><span data-stu-id="5f946-726">-or-</span></span> 
 <span data-ttu-id="5f946-727"><paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5f946-727"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="5f946-728">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex.</span><span class="sxs-lookup"><span data-stu-id="5f946-728">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="5f946-729">Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="5f946-729">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5f946-730">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="5f946-730">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="5f946-731">Indique que le délai fixé pour une opération <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> a été dépassé sans qu'aucun des handles d'attente n'ait été signalé.</span><span class="sxs-lookup"><span data-stu-id="5f946-731">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="5f946-732">Ce champ est constant.</span><span class="sxs-lookup"><span data-stu-id="5f946-732">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f946-733">Ce champ est une des valeurs de retour possibles de `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="5f946-733">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f946-734">L’exemple de code suivant montre comment utiliser le pool de threads pour rechercher un fichier sur plusieurs disques simultanément.</span><span class="sxs-lookup"><span data-stu-id="5f946-734">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="5f946-735">Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.</span><span class="sxs-lookup"><span data-stu-id="5f946-735">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>