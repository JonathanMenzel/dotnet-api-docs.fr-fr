<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9c30c9bf2d271da2afe9d173213a99d04fceefda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531503" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsule les objets spécifiques au système d'exploitation qui attendent un accès exclusif aux ressources partagées.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Threading.WaitHandle> classe encapsule les descripteurs de synchronisation Win32 et est utilisé pour représenter tous les objets de synchronisation dans le runtime qui permettent plusieurs opérations d’attente. Pour une comparaison des handles d’attente avec d’autres objets de synchronisation, consultez [vue d’ensemble des Primitives de synchronisation](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 La <xref:System.Threading.WaitHandle> classe elle-même est abstraite. Les classes dérivées de <xref:System.Threading.WaitHandle> définissent un mécanisme de signalisation pour indiquer la capture ou la libération d’un accès à une ressource partagée, mais elles hérité <xref:System.Threading.WaitHandle> méthodes bloquer lors de l’attente pour l’accès à des ressources partagées. Les classes dérivées de <xref:System.Threading.WaitHandle> incluent :  
  
-   La classe <xref:System.Threading.Mutex>. Consultez [mutex](~/docs/standard/threading/mutexes.md).  
  
-   Le <xref:System.Threading.EventWaitHandle> classe et ses classes dérivées, <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent>. Voir [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   La classe <xref:System.Threading.Semaphore>. Consultez [Semaphore et SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Les threads peuvent bloquer un handle d’attente individuel en appelant la méthode d’instance <xref:System.Threading.WaitHandle.WaitOne%2A>, qui est hérité par les classes dérivées de <xref:System.Threading.WaitHandle>.  
  
 Les classes dérivées de <xref:System.Threading.WaitHandle> diffèrent dans leur affinité de thread. Handles d’attente d’événement (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, et <xref:System.Threading.ManualResetEvent>) et les sémaphores n’ont pas d’affinité de thread ; n’importe quel thread peut signaler un handle d’attente d’événement ou d’un sémaphore. En revanche, les mutex, ont une affinité de thread ; le thread qui détient un mutex doit libérer et une exception est levée si un thread appelle la <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode sur un mutex qu’il ne possède pas.  
  
 Étant donné que la <xref:System.Threading.WaitHandle> dérive de la classe <xref:System.MarshalByRefObject>, ces classes peuvent être utilisées pour synchroniser les activités des threads au-delà des limites de domaine application.  
  
 En plus de ses classes dérivées, la <xref:System.Threading.WaitHandle> classe a un nombre de méthodes statiques qui bloque un thread jusqu'à ce qu’une ou plusieurs objets de synchronisation reçoivent un signal... Elles incluent notamment :  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, qui permet à un thread de signaler un handle d’attente et d’attendre immédiatement un autre.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, qui permet à un thread d’attendre que tous les handles d’attente dans un tableau reçoivent un signal.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, qui permet à un thread d’attendre que l’un d’un jeu spécifié de handles d’attente a été signalé.  
  
 Les surcharges de ces méthodes fournissent des intervalles de délai d’attente pour abandonner l’attente et la possibilité de quitter un contexte de synchronisation avant de commencer l’attente, ce qui permet d’utiliser le contexte de synchronisation des autres threads.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type ou un type dérivé, vous devez la supprimer directement ou indirectement. Pour supprimer le type directement, vous devez appeler sa <xref:System.Threading.WaitHandle.Close%2A> méthode dans un `try` / `catch` bloc. Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.  
  
 <xref:System.Threading.WaitHandle> implémente la <xref:System.IDisposable.Dispose%2A> modèle. Consultez [modèle de suppression](~/docs/standard/design-guidelines/dispose-pattern.md). Lorsque vous dérivez de <xref:System.Threading.WaitHandle>, utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété pour stocker votre handle de système d’exploitation natif. Vous n’avez pas besoin de substituer la méthode protégée <xref:System.Threading.WaitHandle.Dispose%2A> (méthode), sauf si vous utilisez les ressources non managées supplémentaires.  
  
   
  
## Examples  
 Le code suivant montre d’exemple comment deux threads peuvent effectuent les tâches en arrière-plan lors de la Main thread attend que les tâches se terminent à l’aide de la méthode statique <xref:System.Threading.WaitHandle.WaitAny%2A> et <xref:System.Threading.WaitHandle.WaitAll%2A> méthodes de la <xref:System.Threading.WaitHandle> classe.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources détenues par le <see cref="T:System.Threading.WaitHandle" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est l’implémentation publique de la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> méthode pour la <xref:System.Threading.WaitHandle> classe et ses classes dérivées. Il fournit une implémentation standard qui appelle le `Dispose(Boolean)` surcharge avec un `true` argument, puis appelle la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode). Appelez cette méthode pour libérer toutes les ressources détenues par une instance de `WaitHandle` ou une classe dérivée.  
  
 Une fois que cette méthode est appelée, les références à l’instance actuelle provoquent un comportement non défini.  
  
> [!NOTE]
>  Appelez toujours <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> avant de libérer votre dernière référence à le <xref:System.Threading.WaitHandle>. Sinon, les ressources qu’il utilise ne seront pas libérées.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous devez substituer la <see langword="Dispose(Boolean)" /> méthode pour libérer les ressources allouées dans les classes dérivées.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à la <xref:System.Threading.WaitHandle.Close%2A> (méthode).  
  
> [!NOTE]
>  Appelez toujours <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> avant de libérer votre dernière référence à le <xref:System.Threading.WaitHandle>. Sinon, les ressources qu’il utilise ne seront pas libérées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par <see cref="T:System.Threading.WaitHandle" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le <xref:System.Threading.WaitHandle.Close%2A> et <xref:System.Threading.WaitHandle.Dispose> méthodes avec les `explicitDisposing` paramètre la valeur `true`.  Lorsque le `explicitDisposing` paramètre est `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Threading.WaitHandle> références d’objet.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous devez substituer la <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> méthode pour libérer les ressources allouées dans les classes dérivées.  
  
 Le <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> méthode peut être appelée plusieurs fois par d’autres objets. Lorsque vous substituez cette méthode, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un appel antérieur à <see langword="Dispose" /> ou <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le handle du système d'exploitation natif.</summary>
        <value>
          <see langword="IntPtr" /> représentant le handle du système d'exploitation natif. La valeur par défaut est celle du champ <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Affectation d’une nouvelle valeur à la <xref:System.Threading.WaitHandle.Handle%2A> propriété ne ferme pas le handle précédent. Cela peut entraîner une fuite du handle.  
  
 N’utilisez pas cette propriété dans le .NET Framework version 2.0 ou version ultérieure ; Utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété à la place. Définition de cette propriété pour un handle valide définit également la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété, mais la valeur <xref:System.Threading.WaitHandle.InvalidHandle> peut entraîner une fuite du handle.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat définir la valeur de propriété. Ce membre ne peut pas être défini par le code de confiance partielle ou transparent.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Types dérivés doivent avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> pour définir la valeur de propriété.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente un handle du système d'exploitation natif non valide. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisé en interne pour initialiser le <xref:System.Threading.WaitHandle.Handle%2A> propriété.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez utiliser cette valeur pour déterminer si le <see cref="P:System.Threading.WaitHandle.Handle" /> propriété contient un handle valide de système d’exploitation natif.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le handle du système d'exploitation natif.</summary>
        <value>
          <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> représentant le handle du système d'exploitation natif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous attribuez une nouvelle valeur à la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété, le handle précédent est fermé lorsque le précédent <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objet est collecté. Ne fermez pas manuellement le handle, car cela entraîne une <xref:System.ObjectDisposedException> lorsque le <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> essaie de fermer le handle.  
  
 <xref:System.Threading.WaitHandle> implémente la <xref:System.IDisposable.Dispose%2A> modèle. Consultez [modèle de suppression](~/docs/standard/design-guidelines/dispose-pattern.md). Lorsque vous dérivez de <xref:System.Threading.WaitHandle>, utilisez le <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriété pour stocker votre handle de système d’exploitation natif. Vous n’avez pas besoin de substituer la méthode protégée <xref:System.Threading.WaitHandle.Dispose%2A> (méthode), sauf si vous utilisez les ressources non managées supplémentaires.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Types dérivés doivent avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> pour appeler ce membre.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale un <see cref="T:System.Threading.WaitHandle" /> et attend un autre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> à signaler.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> à attendre.</param>
        <summary>Signale un <see cref="T:System.Threading.WaitHandle" /> et attend un autre.</summary>
        <returns>
          <see langword="true" /> si le signal et l'attente se terminent avec succès ; si l'attente ne se termine pas, la méthode ne retourne pas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération n’est pas garantie atomique. Après les signaux de thread en cours `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.  
  
 L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE. L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant une <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="toWaitOn" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode a été appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> est un sémaphore, et possède déjà un nombre complet.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> à signaler.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> à attendre.</param>
        <param name="millisecondsTimeout">Entier qui représente l'intervalle à attendre. Si la valeur est <see cref="F:System.Threading.Timeout.Infinite" />, c'est-à-dire -1, l'attente est infinie.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Signale un <see cref="T:System.Threading.WaitHandle" /> et en attend un autre, en spécifiant un délai sous la forme d'un entier signé 32 bits et en spécifiant s'il faut quitter le domaine de synchronisation du contexte avant de commencer l'attente.</summary>
        <returns>
          <see langword="true" /> si le signal et l'attente se sont terminés avec succès ou <see langword="false" /> si le signal s'est terminé mais que l'attente a expiré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération n’est pas garantie atomique. Après les signaux de thread en cours `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre.  
  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Elle teste l’état de la `toWaitOn` et retourne immédiatement.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle la <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="toWaitOn" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode est appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.WaitHandle" /> ne peut pas être signalé, car il dépasse sa valeur maximale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> à signaler.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> à attendre.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente l'intervalle à attendre. Si la valeur est -1, l'attente est infinie.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Signale un <see cref="T:System.Threading.WaitHandle" /> et en attend un autre, en spécifiant le délai sous la forme d'une valeur <see cref="T:System.TimeSpan" /> et en spécifiant s'il faut quitter le domaine de synchronisation du contexte avant de commencer l'attente.</summary>
        <returns>
          <see langword="true" /> si le signal et l'attente se sont terminés avec succès ou <see langword="false" /> si le signal s'est terminé mais que l'attente a expiré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération n’est pas garantie atomique. Après les signaux de thread en cours `toSignal` mais avant qu’il attende `toWaitOn`, un thread qui s’exécute sur un autre processeur peut signaler `toWaitOn` ou attendre.  
  
 La valeur maximale de `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Elle teste l’état de la `toWaitOn` et retourne immédiatement.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle la <xref:System.Threading.WaitHandle.SignalAndWait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque la <xref:System.Threading.WaitHandle.SignalAndWait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="toWaitOn" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode a été appelée sur un thread qui comporte l'attribut <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Cette méthode n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> est un sémaphore, et possède déjà un nombre complet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> prend comme valeur un nombre négatif de millièmes de secondes autre que -1.  
  
 - ou -  
  
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal.</summary>
        <returns>
          <see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, la méthode ne retourne jamais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode renvoie `true` quand un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lorsque tous les handles sont signalés. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. Si le tableau contient des doublons, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
 Appel de cette surcharge de méthode équivaut à appeler le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) pour `millisecondsTimeout` et `true` pour `exitContext`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers. Chaque opération d’écriture est en attente comme un élément de travail et des signaux lorsqu’elle est terminée. Le thread principal attend que tous les éléments signaler et se termine.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />. - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
 - ou -  
  
 <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.  
  
</para>
          </block>  
  
 Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
 - ou -  
  
 L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet (doublons).</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.Int32" /> pour spécifier l'intervalle de temps.</summary>
        <returns>
          <see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état des handles d’attente et retourne immédiatement.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lorsque l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. Si le tableau contient des doublons, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
 Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
 - ou -  
  
 <paramref name="waitHandles" /> est un tableau sans éléments.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.  
  
</para>
          </block>  
  
 Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
 - ou -  
  
 L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 milliseconde, pour attendre indéfiniment.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</summary>
        <returns>
          <see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état des handles d’attente et retourne immédiatement.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lorsque l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. Si le tableau contient des doublons, l’appel échoue.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
 La valeur maximale de `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
 - ou -  
  
 <paramref name="waitHandles" /> est un tableau sans éléments.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.ArgumentException" />, à la place.  
  
</para>
          </block>  
  
 Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
 - ou -  
  
 L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.  
  
 - ou -  
  
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet (doublons).</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.Int32" /> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</summary>
        <returns>
          <see langword="true" /> quand tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état des handles d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode renvoie `true` quand un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lorsque l’attente se termine, ce qui signifie que lorsque tous les handles sont signalés ou un délai d’attente se produit. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. Si le tableau contient des doublons, l’appel échoue avec une <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribut. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle la <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers. Chaque opération d’écriture est en attente comme un élément de travail et des signaux lorsqu’elle est terminée. Le thread principal attend que tous les éléments signaler et se termine.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
 - ou -  
  
 <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
 - ou -  
  
 L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra. Ce tableau ne peut pas contenir plusieurs références au même objet.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 milliseconde, pour attendre indéfiniment.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Attend que tous les éléments du tableau spécifié reçoivent un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</summary>
        <returns>
          <see langword="true" /> lorsque tous les éléments de <paramref name="waitHandles" /> ont reçu un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état des handles d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode renvoie `true` quand un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée lorsque l’attente se termine, ce qui signifie que tous les handles sont signalés ou un dépassement de délai se produit. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée. Si le tableau contient des doublons, l’appel échoue.  
  
> [!NOTE]
>  Le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode n’est pas prise en charge sur les threads qui ont <xref:System.STAThreadAttribute>.  
  
 La valeur maximale de `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAll%2A> méthode appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode). Il retourne au contexte par défaut d’origine après l’appel à la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle la <xref:System.Threading.WaitHandle.WaitAll%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque la <xref:System.Threading.WaitHandle.WaitAll%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads à créer de façon asynchrone et d’écrire dans un groupe de fichiers. Chaque opération d’écriture est en attente comme un élément de travail et des signaux lorsqu’elle est terminée. Le thread principal attend que tous les éléments signaler et se termine.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.  
  
 - ou -  
  
 <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">Le tableau <paramref name="waitHandles" /> contient des éléments qui sont des doublons.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.  
  
 - ou -  
  
 L’attribut <see cref="T:System.STAThreadAttribute" /> est appliqué à la procédure de thread pour le thread actuel, et <paramref name="waitHandles" /> contient plusieurs éléments.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau sans éléments, et que la version de .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.  
  
 - ou -  
  
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente a été arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal.</summary>
        <returns>Index du tableau de l'objet ayant respecté l'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine parce qu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève une exception une <xref:System.Threading.AbandonedMutexException> uniquement lorsque l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est levée.  
  
> [!NOTE]
>  Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.  
  
 Cette méthode retourne quand un handle est signalé. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
 Appel de cette surcharge de méthode équivaut à appeler le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) pour `millisecondsTimeout` et `true` pour `exitContext`.  
  
   
  
## Examples  
 L’exemple de code suivant montre l’appel du <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode).  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</summary>
        <returns>Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="millisecondsTimeout" /> s'est écoulé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état des handles d’attente et retourne immédiatement.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève une exception une <xref:System.Threading.AbandonedMutexException> uniquement lorsque l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est levée.  
  
 Cette méthode retourne lorsque l’attente se termine lorsqu’une des poignées sont signalée soit lorsqu’un dépassement de délai se produit. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
 Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau sans éléments.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</summary>
        <returns>Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="timeout" /> s'est écoulé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état des handles d’attente et retourne immédiatement.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève une exception une <xref:System.Threading.AbandonedMutexException> uniquement lorsque l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est levée.  
  
 Cette méthode retourne lorsque l’attente se termine lorsqu’une des poignées sont signalée soit lorsqu’un dépassement de délai se produit. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
 La valeur maximale de `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.  
  
 - ou -  
  
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau sans éléments.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Attend que l’un des éléments du tableau spécifié reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l’intervalle de temps et en spécifiant s’il faut quitter le domaine de synchronisation avant l’attente.</summary>
        <returns>Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="millisecondsTimeout" /> s'est écoulé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état des handles d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine parce qu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève une exception une <xref:System.Threading.AbandonedMutexException> uniquement lorsque l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est levée.  
  
> [!NOTE]
>  Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.  
  
 Cette méthode retourne lorsque l’attente se termine lorsqu’une des poignées sont signalée soit lorsqu’un dépassement de délai se produit. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle la <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads pour la recherche simultanée d’un fichier sur plusieurs disques. Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Tableau <see langword="WaitHandle" /> qui contient les objets que l'instance actuelle attendra.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Attend que l'un des éléments du tableau spécifié reçoive un signal ; en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</summary>
        <returns>Index de tableau de l'objet ayant respecté l'attente ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si aucun objet n'a respecté l'attente et qu'un intervalle de temps équivalent à <paramref name="timeout" /> s'est écoulé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état des handles d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitAny%2A> retourne de la méthode `true` si l’attente se termine parce qu’un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 Le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode lève une exception une <xref:System.Threading.AbandonedMutexException> uniquement lorsque l’attente se termine en raison d’un mutex abandonné. Si `waitHandles` contient un mutex libéré avec un numéro d’index inférieur à celui du mutex abandonné, le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine normalement et l’exception n’est levée.  
  
> [!NOTE]
>  Dans les versions du .NET Framework antérieures à la version 2.0, si un thread se termine ou s’interrompt sans libérer explicitement un <xref:System.Threading.Mutex>et qui `Mutex` est à l’index 0 (zéro) dans un `WaitAny` tableau sur un autre thread, l’index retourné par `WaitAny` est 128 au lieu de 0.  
  
 Cette méthode retourne lorsque l’attente se termine lorsqu’une des poignées sont signalée soit lorsqu’un dépassement de délai se produit. Si plusieurs objets sont signalés pendant l’appel, la valeur de retour est l’index de tableau de l’objet signalé ayant la plus petite valeur d’index de tous les objets signalés. Dans certaines implémentations, si plus de 64 handles sont passés, un <xref:System.NotSupportedException> est levée.  
  
 La valeur maximale de `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitAny%2A> méthode appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle la <xref:System.Threading.WaitHandle.WaitAny%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque la <xref:System.Threading.WaitHandle.WaitAny%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads pour la recherche simultanée d’un fichier sur plusieurs disques. Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="waitHandles" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un ou plusieurs des objets dans le tableau <paramref name="waitHandles" /> sont <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le nombre d’objets dans <paramref name="waitHandles" /> est supérieur à ce que le système autorise.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.  
  
 - ou -  
  
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> est un tableau qui ne contient aucun élément et la version du .NET Framework est 2.0 ou ultérieure.</exception>
        <exception cref="T:System.InvalidOperationException">Le tableau <paramref name="waitHandles" /> contient un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d’application.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal. Si l'instance actuelle ne reçoit jamais de signal, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> ne retourne jamais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode renvoie `true` quand un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 L’appelant de cette méthode bloque indéfiniment jusqu'à ce que l’instance actuelle reçoive un signal. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Appel de cette surcharge de méthode équivaut à appeler le <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge de méthode et en spécifiant -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pour le premier paramètre et `false` pour le deuxième paramètre.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus de s’arrêter alors qu’il attend la fin de l’exécution d’un thread d’arrière-plan.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état du handle d’attente et retourne immédiatement.  
  
 L’appelant de cette méthode bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
 Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus de s’arrêter alors qu’il attend la fin de l’exécution d’un thread d’arrière-plan.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Bloque le thread actuel jusqu'à ce que l'instance actuelle reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état du handle d’attente et retourne immédiatement.  
  
 L’appelant de cette méthode bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
 La valeur maximale de `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> surcharge et en spécifiant `false` pour `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.  
  
 - ou -  
  
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.WaitHandle" /> actuel reçoive un signal, en utilisant un entier signé 32 bits pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état du handle d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode renvoie `true` quand un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 L’appelant de cette méthode bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> surcharge de méthode se comporte lorsqu’elle est appelée au sein d’un domaine de synchronisation. Tout d’abord, un thread attend avec `exitContext` la valeur `false` et se bloque jusqu'à ce que le délai d’attente expire. Un deuxième thread s’exécute après que le premier thread s’arrête et attend avec `exitContext` la valeur `true`. L’appel pour signaler le handle d’attente de ce deuxième thread n’est pas bloqué, et le thread se termine avant le délai d’attente.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <param name="exitContext">
          <see langword="true" /> pour quitter le domaine de synchronisation du contexte avant l'attente (dans le cas d'un contexte synchronisé) et l'acquérir à nouveau ensuite ; sinon, <see langword="false" />.</param>
        <summary>Bloque le thread actuel jusqu'à ce que l'instance actuelle reçoive un signal, en utilisant une valeur <see cref="T:System.TimeSpan" /> pour spécifier l'intervalle de temps et en spécifiant s'il faut quitter le domaine de synchronisation avant l'attente.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle reçoit un signal ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` est égal à zéro, la méthode ne bloque pas. Il teste l’état du handle d’attente et retourne immédiatement.  
  
 <xref:System.Threading.AbandonedMutexException> est une nouveauté de .NET Framework version 2.0. Dans les versions précédentes, le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode renvoie `true` quand un mutex est abandonné. Un mutex abandonné indique souvent une grave erreur de codage. Dans le cas d’un mutex à l’échelle du système, il peut indiquer qu’une application a été arrêtée soudainement (par exemple, en utilisant le Gestionnaire des tâches de Windows). L’exception contient des informations utiles pour le débogage.  
  
 L’appelant de cette méthode bloque jusqu'à ce que l’instance actuelle reçoive un signal ou un délai d’attente se produit. Utilisez cette méthode pour bloquer jusqu'à un <xref:System.Threading.WaitHandle> reçoive un signal d’un autre thread, tel qu’est générée lorsqu’une opération asynchrone se termine. Pour plus d’informations, consultez le <xref:System.IAsyncResult> interface.  
  
 Substituez cette méthode pour personnaliser le comportement des classes dérivées.  
  
 La valeur maximale de `timeout` est <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le `exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui ne dérive pas de <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Le thread retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser un handle d’attente pour conserver un processus de s’arrêter alors qu’il attend la fin de l’exécution d’un thread d’arrière-plan.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.  
  
 - ou -  
  
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L’attente s’est arrêtée, car un thread s’est terminé sans libérer de mutex. Cette exception n’est pas levée sur Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'instance actuelle est un proxy transparent pour un <see cref="T:System.Threading.WaitHandle" /> dans un autre domaine d'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indique que le délai fixé pour une opération <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> a été dépassé sans qu'aucun des handles d'attente n'ait été signalé. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ est une des valeurs de retour possibles de `WaitAny`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le pool de threads pour la recherche simultanée d’un fichier sur plusieurs disques. Pour des raisons d’espace, uniquement le répertoire racine de chaque disque est recherché.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>