<Type Name="ExecutionContext" FullName="System.Threading.ExecutionContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adc4bccedfe23f29239724c27f989a2722f76f74" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37548784" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ExecutionContext : IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit ExecutionContext extends System.Object implements class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ExecutionContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ExecutionContext&#xA;Implements IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ExecutionContext sealed : IDisposable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type ExecutionContext = class&#xA;    interface IDisposable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Manages the execution context for the current thread. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.ExecutionContext> classe fournit un conteneur unique pour toutes les informations relatives à un thread logique d’exécution. Cela inclut le contexte de sécurité, contexte d’appel et le contexte de synchronisation.  
  
 Le <xref:System.Threading.ExecutionContext> classe fournit les fonctionnalités pour le code utilisateur capturer et de transférer ce contexte sur des points asynchrones définis par l’utilisateur. Le common language runtime garantit que le <xref:System.Threading.ExecutionContext> est transféré régulièrement entre des points d’asynchrones définis par l’exécution dans le processus managé.  
  
 Un contexte d’exécution est l’équivalent d’un cloisonnement COM géré. Au sein d’un domaine d’application, le contexte d’exécution complet doit être transféré chaque fois qu’un thread est transféré. Cette situation se produit pendant les transferts effectués par le <xref:System.Threading.Thread.Start%2A?displayProperty=nameWithType> (méthode), la plupart des opérations de pool de thread et Windows Forms thread marshaling via la pompe de messages Windows. Il ne se produit pas dans les opérations de pool de threads unsafe (telles que la <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> méthode), qui ne sont pas transférés de la pile compressée. Partout où la pile compressée circule, le principal géré, la synchronisation, paramètres régionaux et contexte de l’utilisateur sont également flux. Le <xref:System.Threading.ExecutionContext> classe fournit le <xref:System.Threading.ExecutionContext.Capture%2A> et <xref:System.Threading.ExecutionContext.CreateCopy%2A> méthodes pour obtenir le contexte d’exécution et le <xref:System.Threading.ExecutionContext.Run%2A> méthode pour définir le contexte d’exécution pour le thread actuel.  
  
 Un <xref:System.Threading.ExecutionContext> qui est associé avec un thread ne peut pas être définie sur un autre thread. Toute tentative entraîne la levée d’une exception. Pour propager les <xref:System.Threading.ExecutionContext> à partir d’un seul thread à un autre, faites une copie de la <xref:System.Threading.ExecutionContext>.  
  
 En interne, le <xref:System.Threading.ExecutionContext> stocke toutes les données qui sont associées le <xref:System.Runtime.Remoting.Messaging.LogicalCallContext>. Cela permet la <xref:System.Runtime.Remoting.Messaging.LogicalCallContext> propagation lorsque des données le <xref:System.Threading.ExecutionContext> est copié et transféré.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static System.Threading.ExecutionContext Capture ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.ExecutionContext Capture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ExecutionContext.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture () As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ExecutionContext ^ Capture();" />
      <MemberSignature Language="F#" Value="static member Capture : unit -&gt; System.Threading.ExecutionContext" Usage="System.Threading.ExecutionContext.Capture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Captures the execution context from the current thread.</summary>
        <returns>An <see cref="T:System.Threading.ExecutionContext" /> object representing the execution context for the current thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contexte d’exécution capturé peut être utilisé en tant que le `executionContext` paramètre pour le <xref:System.Threading.ExecutionContext.Run%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCopy">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext CreateCopy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.ExecutionContext CreateCopy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ExecutionContext.CreateCopy" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCopy () As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ExecutionContext ^ CreateCopy();" />
      <MemberSignature Language="F#" Value="member this.CreateCopy : unit -&gt; System.Threading.ExecutionContext" Usage="executionContext.CreateCopy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a copy of the current execution context.</summary>
        <returns>An <see cref="T:System.Threading.ExecutionContext" /> object representing the current execution context.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utile pour propager un contexte d’exécution d’un thread à un autre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This context cannot be copied because it is used. Only newly captured contexts can be copied.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ExecutionContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="executionContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.ExecutionContext" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode `Dispose` une fois que vous avez terminé d'utiliser <xref:System.Threading.ExecutionContext>. La méthode `Dispose` rend le <xref:System.Threading.ExecutionContext> inutilisable. Après avoir appelé `Dispose`, vous devez libérer toutes les références à la <xref:System.Threading.ExecutionContext> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Threading.ExecutionContext> occupée.  
  
 Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours `Dispose` avant de libérer votre dernière référence à <xref:System.Threading.ExecutionContext>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Threading.ExecutionContext> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="executionContext.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to be populated with serialization information.</param>
        <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure representing the destination context of the serialization.</param>
        <summary>Sets the specified <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the logical context information needed to recreate an instance of the current execution context.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext.GetObjectData%2A> définit un <xref:System.Runtime.Serialization.SerializationInfo> avec l’opérateur logique appeler les informations de contexte. Pendant la désérialisation, l’objet de contexte d’exécution est reconstituée à partir du <xref:System.Runtime.Serialization.SerializationInfo> transmis au flux.  
  
 Pour plus d'informations, consultez <xref:System.Runtime.Serialization.SerializationInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsFlowSuppressed">
      <MemberSignature Language="C#" Value="public static bool IsFlowSuppressed ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFlowSuppressed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ExecutionContext.IsFlowSuppressed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFlowSuppressed () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFlowSuppressed();" />
      <MemberSignature Language="F#" Value="static member IsFlowSuppressed : unit -&gt; bool" Usage="System.Threading.ExecutionContext.IsFlowSuppressed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether the flow of the execution context is currently suppressed.</summary>
        <returns>
          <see langword="true" /> if the flow is suppressed; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.ExecutionContext.IsFlowSuppressed%2A> méthode est utilisée par les composants d’infrastructure pour déterminer s’il faut transférer le <xref:System.Threading.ExecutionContext> pendant des opérations asynchrones.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreFlow">
      <MemberSignature Language="C#" Value="public static void RestoreFlow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RestoreFlow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ExecutionContext.RestoreFlow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RestoreFlow ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RestoreFlow();" />
      <MemberSignature Language="F#" Value="static member RestoreFlow : unit -&gt; unit" Usage="System.Threading.ExecutionContext.RestoreFlow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restores the flow of the execution context across asynchronous threads.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext.RestoreFlow%2A> inverse l’effet d’un avant <xref:System.Threading.ExecutionContext.SuppressFlow%2A> appel de méthode.  
  
 Cette méthode est appelée par le <xref:System.Threading.AsyncFlowControl.Undo%2A> méthode de la <xref:System.Threading.AsyncFlowControl> structure retournée par le <xref:System.Threading.ExecutionContext.SuppressFlow%2A> (méthode).  Vous devez utiliser le <xref:System.Threading.AsyncFlowControl.Undo%2A> méthode pour restaurer le flux du contexte d’exécution, ne pas le <xref:System.Threading.ExecutionContext.RestoreFlow%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The context flow cannot be restored because it is not being suppressed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Threading.ExecutionContext executionContext, class System.Threading.ContextCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Threading::ExecutionContext ^ executionContext, System::Threading::ContextCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member Run : System.Threading.ExecutionContext * System.Threading.ContextCallback * obj -&gt; unit" Usage="System.Threading.ExecutionContext.Run (executionContext, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="executionContext" Type="System.Threading.ExecutionContext" />
        <Parameter Name="callback" Type="System.Threading.ContextCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="executionContext">The <see cref="T:System.Threading.ExecutionContext" /> to set.</param>
        <param name="callback">A <see cref="T:System.Threading.ContextCallback" /> delegate that represents the method to be run in the provided execution context.</param>
        <param name="state">The object to pass to the callback method.</param>
        <summary>Runs a method in a specified execution context on the current thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contexte d’exécution est retourné à son état précédent lorsque la méthode est terminée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="executionContext" /> is <see langword="null" />.  -or-  <paramref name="executionContext" /> was not acquired through a capture operation.  -or-  <paramref name="executionContext" /> has already been used as the argument to a <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" /> call.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="SuppressFlow">
      <MemberSignature Language="C#" Value="public static System.Threading.AsyncFlowControl SuppressFlow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.AsyncFlowControl SuppressFlow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ExecutionContext.SuppressFlow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SuppressFlow () As AsyncFlowControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::AsyncFlowControl SuppressFlow();" />
      <MemberSignature Language="F#" Value="static member SuppressFlow : unit -&gt; System.Threading.AsyncFlowControl" Usage="System.Threading.ExecutionContext.SuppressFlow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.AsyncFlowControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suppresses the flow of the execution context across asynchronous threads.</summary>
        <returns>An <see cref="T:System.Threading.AsyncFlowControl" /> structure for restoring the flow.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour supprimer le flux de la <xref:System.Threading.ExecutionContext> sur le thread actuel.  
  
 Vous devez utiliser le <xref:System.Threading.AsyncFlowControl.Undo%2A> méthode sur retourné <xref:System.Threading.AsyncFlowControl> structure pour restaurer le flux de la <xref:System.Threading.ExecutionContext>.  
  
 Cette méthode est protégée par un <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour <xref:System.Security.Permissions.SecurityPermissionFlag.Infrastructure?displayProperty=nameWithType> autorisation. Un composant de niveau de confiance suffisant peut appeler cette méthode pour supprimer le flux de la <xref:System.Threading.ExecutionContext> pendant les appels asynchrones. Lorsque le flux est supprimé, le <xref:System.Security.SecurityContext.Capture%2A> retourne de la méthode `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The context flow is already suppressed.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Threading.AsyncFlowControl" />
      </Docs>
    </Member>
  </Members>
</Type>