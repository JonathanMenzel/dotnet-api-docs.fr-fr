<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ff41ad40a28c7f90e15d73f0eb8b61f649bdbc39" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52912050" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class HostSecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostSecurityManager" />
  <TypeSignature Language="F#" Value="type HostSecurityManager = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Autorise le contrôle et la personnalisation du comportement de sécurité pour les domaines d'application.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous créez un nouveau <xref:System.AppDomain>, le common language runtime interroge le <xref:System.AppDomainManager> la présence d’un <xref:System.Security.HostSecurityManager>, qui participe aux décisions de sécurité le <xref:System.AppDomain>.  Fournisseurs d’hébergement doivent implémenter un gestionnaire de sécurité hôte qui hérite de la <xref:System.Security.HostSecurityManager> classe.  
  
   
  
## Examples  
 L’exemple suivant montre une implémentation très simple d’un <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par le code de confiance partielle ou transparent.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Cette classe ne peut pas être héritée par du code partiellement fiable.</permission>
    <block subset="none" type="overrides">
      <para>Certains membres d’un <see cref="T:System.Security.HostSecurityManager" /> sont appelés chaque fois qu’un assembly est chargé, implicitement ou explicitement. Le <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> et <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> méthodes ne doivent pas charger d’assemblys, car cela entraînerait dans les membres de la <see cref="T:System.Security.HostSecurityManager" /> qui est appelée de manière récursive. Pour éviter les références circulaires, vous devez créer de nouvelles instances de classes qui peuvent provoquer des assemblys à charger, implicitement ou explicitement, dans le constructeur d’une classe qui dérive de <see cref="T:System.Security.HostSecurityManager" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostSecurityManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.HostSecurityManager" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Ce membre ne peut pas être hérité par du code partiellement fiable.</permission>
        <block subset="none" type="overrides">
          <para>Créer des instances de classes peuvent entraîner des assemblys à charger, explicitement ou implicitement, dans ce constructeur.  L’accesseur get de la <see cref="P:System.Security.HostSecurityManager.DomainPolicy" /> propriété et la <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> et <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> méthodes sont appelées chaque fois qu’un assembly est chargé et le chargement ultérieur d’assemblys entraîne des références circulaires.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineApplicationTrust (applicationEvidence As Evidence, activatorEvidence As Evidence, context As TrustManagerContext) As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::ApplicationTrust ^ DetermineApplicationTrust(System::Security::Policy::Evidence ^ applicationEvidence, System::Security::Policy::Evidence ^ activatorEvidence, System::Security::Policy::TrustManagerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust&#xA;override this.DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust" Usage="hostSecurityManager.DetermineApplicationTrust (applicationEvidence, activatorEvidence, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Preuve pour l'application à activer.</param>
        <param name="activatorEvidence">Éventuellement, preuve pour le domaine d'application d'activation.</param>
        <param name="context">Contexte d'approbation.</param>
        <summary>Détermine si une application doit être exécutée.</summary>
        <returns>Objet qui contient des informations d'approbation sur l'application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée. L’implémentation de base appelle le Gestionnaire de sécurité d’application pour déterminer si l’application doit être exécutée.  
  
 L’implémentation de base n’utilise pas la preuve de l’activateur. Toutefois, une implémentation substituée peut utiliser la preuve de l’activateur pour déterminer la preuve de sécurité du domaine d’application tente d’activer l’application.  
  
   
  
## Examples  
 L’exemple suivant montre comment substituer la <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A> méthode pour un gestionnaire de sécurité hôte personnalisé. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.HostSecurityManager> classe.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationEvidence" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un objet <see cref="T:System.Runtime.Hosting.ActivationArguments" /> est introuvable dans la preuve de l'application.  
  
- ou - 
La propriété <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" /> dans les arguments d'activation est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le jeu d'autorisations <see cref="T:System.Security.Policy.ApplicationTrust" /> ne contient pas le jeu de demandes minimum spécifié par <see cref="T:System.ActivationContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DomainPolicy As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::PolicyLevel ^ DomainPolicy { System::Security::Policy::PolicyLevel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainPolicy : System.Security.Policy.PolicyLevel" Usage="System.Security.HostSecurityManager.DomainPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de remplacement dans une classe dérivée, récupère la stratégie de sécurité du domaine d’application actuel.</summary>
        <value>La stratégie de sécurité du domaine d’application actuel. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut être substituée dans une classe dérivée. L'implémentation de base retourne toujours `null`.  
  
 Cette propriété est appelée à <xref:System.AppDomain> heure de création. Il permet à un hôte de fournir une stratégie pour actuel <xref:System.AppDomain>.  Un niveau de stratégie se compose des éléments suivants :  
  
-   Un ensemble de groupes de codes organisés en une arborescence de racine unique.  
  
-   Un ensemble de jeux d’autorisations nommés qui sont référencés par les groupes de codes pour spécifier les autorisations à accorder au code appartenant au groupe de codes.  
  
-   Liste des assemblys entièrement fiables.  
  
> [!IMPORTANT]
>  Consultez les remarques pour les héritiers pour la <xref:System.Security.HostSecurityManager> classe pour plus d’informations critiques.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Flags As HostSecurityManagerOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::HostSecurityManagerOptions Flags { System::Security::HostSecurityManagerOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Flags : System.Security.HostSecurityManagerOptions" Usage="System.Security.HostSecurityManager.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'indicateur représentant les composants de stratégie de sécurité pris en considération par l'hôte.</summary>
        <value>Une des valeurs d'énumération qui spécifie les composants de stratégie de sécurité. La valeur par défaut est <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut être substituée dans une classe dérivée. L'implémentation de base retourne toujours <xref:System.Security.HostSecurityManagerOptions.AllFlags>.  
  
 L’hôte dérivé peut modifier la valeur de cette propriété lorsque seul un sous-ensemble de la <xref:System.Security.HostSecurityManagerOptions> présente un intérêt.  Les sous-ensembles possibles sont none, le jeu refusé, le niveau de stratégie et une preuve d’assembly.  
  
   
  
## Examples  
 L’exemple suivant montre comment substituer la <xref:System.Security.HostSecurityManager.Flags%2A> propriété pour un gestionnaire de sécurité hôte personnalisé. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.HostSecurityManager> classe.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GenerateAppDomainEvidence (evidenceType As Type) As EvidenceBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAppDomainEvidence(Type ^ evidenceType);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAppDomainEvidence evidenceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Type de preuve.</param>
        <summary>Demande un type de preuve spécifique pour le domaine d'application.</summary>
        <returns>Preuve de domaine d'application demandée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée. L’implémentation de base retourne `null`.  
  
 Le common language runtime appelle cette méthode lors de la preuve du type spécifié est exigée pour actuel <xref:System.AppDomain>. La valeur retournée est utilisée comme preuve fournie par l’hôte et est stockée dans le <xref:System.AppDomain.Evidence%2A> collection de la <xref:System.AppDomain.CurrentDomain%2A> propriété. Vous pouvez utiliser la <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> méthode pour obtenir la preuve générée à partir de la collection.  
  
 Pour obtenir un rappel pour cette méthode, les hôtes doivent spécifier le <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence> indicateur dans le <xref:System.Security.HostSecurityManager.Flags%2A> propriété.  
  
 Cette méthode de génération de preuve permet aux hôtes de différer la génération de preuve pour une <xref:System.AppDomain> jusqu'à ce que la preuve est nécessaire. Dans le .NET Framework version 3.5 et les versions antérieures, il était nécessaire de fournir <xref:System.AppDomain> preuve au moment du chargement en substituant la <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> (méthode). Nous vous recommandons d’utiliser <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> pour fournir la preuve au lieu de remplacer <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>.  
  
 Le <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> méthode est rappelée uniquement pour les types de preuves que l’hôte a spécifiés dans la substitution de la <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A> (méthode).  
  
 La valeur de retour `null` indique que l’hôte ne peut pas générer la preuve d’un type spécifique.  
  
   
  
## Examples  
 L’exemple suivant montre comment substituer la <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> méthode pour un gestionnaire de sécurité hôte personnalisé. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.HostSecurityManager> classe.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAssemblyEvidence(Type ^ evidenceType, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAssemblyEvidence (evidenceType, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Type de preuve.</param>
        <param name="assembly">Assembly cible.</param>
        <summary>Demande un type de preuve spécifique pour l'assembly.</summary>
        <returns>Preuve d'assembly demandée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée. L’implémentation de base retourne `null`.  
  
 Le common language runtime appelle cette méthode lors de la preuve du type spécifié est exigée pour l’assembly actuel. La valeur retournée est utilisée comme preuve fournie par l’hôte et est stockée dans le <xref:System.Reflection.Assembly.Evidence%2A> propriété. Vous pouvez utiliser la <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> méthode pour obtenir la preuve générée à partir de la <xref:System.Reflection.Assembly.Evidence%2A> propriété.  
  
 Pour obtenir un rappel pour cette méthode, les hôtes doivent spécifier le <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence> indicateur dans le <xref:System.Security.HostSecurityManager.Flags%2A> propriété.  
  
 Cette méthode de génération de preuve permet aux hôtes de différer la génération de preuve pour une <xref:System.AppDomain> jusqu'à ce que la preuve est nécessaire. Dans le .NET Framework 3.5 et les versions antérieures, il était nécessaire de fournir <xref:System.AppDomain> preuve au moment du chargement en substituant la <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> (méthode). Nous vous recommandons d’utiliser <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> pour fournir la preuve au lieu de remplacer <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>.  
  
 Le <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> méthode est rappelée uniquement pour les types de preuves que l’hôte a spécifiés dans la substitution de la <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A> (méthode).  
  
 La valeur de retour `null` indique que l’hôte ne peut pas générer la preuve d’un type spécifique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHostSuppliedAppDomainEvidenceTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAppDomainEvidenceTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]&#xA;override this.GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine les types de preuves que l'hôte peut fournir pour le domaine d'application, en cas de besoin.</summary>
        <returns>Tableau de types de preuves.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée. L’implémentation de base retourne `null`.  
  
 Déterminent les types retournés par cette méthode si le <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> méthode est rappelée. La présence d’un type dans cette liste ne signifie pas que l’hôte doit être en mesure de générer ce type de preuve, mais qu’il peut être en mesure de. Pour cette raison, il est préférable de spécifier trop plutôt que de sous-spécifier les types dans cette liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAssemblyEvidenceTypes(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]&#xA;override this.GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Assembly cible.</param>
        <summary>Détermine les types de preuves que l'hôte peut fournir pour l'assembly, en cas de besoin.</summary>
        <returns>Tableau de types de preuves.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée. L’implémentation de base retourne `null`.  
  
 Déterminent les types retournés par cette méthode si le <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> méthode est rappelée. La présence d’un type dans cette liste ne signifie pas que l’hôte doit être en mesure de générer ce type de preuve, mais qu’il peut être en mesure de. Pour cette raison, il est préférable de spécifier trop plutôt que de sous-spécifier les types dans cette liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAppDomainEvidence (inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAppDomainEvidence(System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAppDomainEvidence inputEvidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Preuve supplémentaire à ajouter aux preuves de <see cref="T:System.AppDomain" />.</param>
        <summary>Fournit la preuve du domaine d'application pour un assembly en cours de chargement.</summary>
        <returns>Preuve à utiliser pour <see cref="T:System.AppDomain" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée dans une classe dérivée.  
  
 Cette méthode est appelée chaque fois qu’un <xref:System.AppDomain> objet est créé. Le `inputEvidence` paramètre est la preuve calculée du common language runtime. L’implémentation de l’hôte peut choisir d’étendre ou réduire la preuve. La valeur de retour est la preuve à utiliser pour le domaine d’application.  L’implémentation de base toujours retourne l’objet de preuve passé en tant que le `inputEvidence` paramètre.  
  
> [!IMPORTANT]
>  Consultez les remarques pour les héritiers pour la <xref:System.Security.HostSecurityManager> classe pour plus d’informations critiques.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAssemblyEvidence (loadedAssembly As Assembly, inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAssemblyEvidence(System::Reflection::Assembly ^ loadedAssembly, System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAssemblyEvidence (loadedAssembly, inputEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Assembly chargé.</param>
        <param name="inputEvidence">Preuve supplémentaire à ajouter aux preuves d'assembly.</param>
        <summary>Fournit la preuve de l'assembly pour un assembly en cours de chargement.</summary>
        <returns>Preuve à utiliser pour l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée dans une classe dérivée.  
  
 Cette méthode est appelée chaque fois qu’un assembly est chargé, implicitement ou explicitement. Les paramètres transmis sont l’assembly en cours de chargement et la preuve calculée du common language runtime. L’implémentation de l’hôte peut choisir d’étendre ou réduire la preuve. La valeur de retour est la preuve à utiliser pour l’assembly.  L’implémentation de base toujours retourne l’objet de preuve passé en tant que le `inputEvidence` paramètre.  
  
> [!IMPORTANT]
>  Consultez les remarques pour les héritiers pour la <xref:System.Security.HostSecurityManager> classe pour plus d’informations critiques.  
  
   
  
## Examples  
 L’exemple suivant montre comment substituer la <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A> méthode pour un gestionnaire de sécurité hôte personnalisé. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.HostSecurityManager> classe.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet&#xA;override this.ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="hostSecurityManager.ResolvePolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Ensemble de preuves utilisé pour évaluer la stratégie.</param>
        <summary>Détermine les autorisations à accorder au code en fonction de la preuve spécifiée.</summary>
        <returns>Jeu d'autorisations qui peuvent être accordées par le système de sécurité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité, en lui fournissant la preuve spécifiée. Le résultat est déterminé par la stratégie de sécurité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>