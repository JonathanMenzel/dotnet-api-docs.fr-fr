<Type Name="SecurityManager" FullName="System.Security.SecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f46a8c75bf7fe138986fd4197a87db42d75d75e7" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37629828" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class SecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed SecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class SecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityManager abstract sealed" />
  <TypeSignature Language="F#" Value="type SecurityManager = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides the main access point for classes interacting with the security system. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sécurité fournit des méthodes pour accéder et manipuler la configuration de stratégie de sécurité. Vous ne pouvez pas créer des instances de <xref:System.Security.SecurityManager>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CheckExecutionRights">
      <MemberSignature Language="C#" Value="public static bool CheckExecutionRights { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckExecutionRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.CheckExecutionRights" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckExecutionRights As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckExecutionRights { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckExecutionRights : bool with get, set" Usage="System.Security.SecurityManager.CheckExecutionRights" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether code must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> in order to execute.</summary>
        <value>
          <see langword="true" /> Si le code doit avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> pour s’exécuter ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété est `false`, y compris le code sans <xref:System.Security.Permissions.SecurityPermissionFlag.Execution> peuvent exécuter. Vérification de l’exécution est coûteuse et peut éliminer les avantages de la résolution de stratégie différé. Cette propriété est fournie pour désactiver l’exécution de la vérification si nécessaire.  
  
 Une modification de cette propriété n’est pas conservée jusqu'à ce que <xref:System.Security.SecurityManager.SavePolicy%2A> est appelée. Nouveaux processus ne seront pas affectés par la modification jusqu'à ce qu’il est conservé dans le Registre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The code that calls this method does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThreadRequiresSecurityContextCapture">
      <MemberSignature Language="C#" Value="public static bool CurrentThreadRequiresSecurityContextCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CurrentThreadRequiresSecurityContextCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CurrentThreadRequiresSecurityContextCapture () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CurrentThreadRequiresSecurityContextCapture();" />
      <MemberSignature Language="F#" Value="static member CurrentThreadRequiresSecurityContextCapture : unit -&gt; bool" Usage="System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the current thread requires a security context capture if its security state has to be re-created at a later point in time.</summary>
        <returns>
          <see langword="false" /> if the stack contains no partially trusted application domains, no partially trusted assemblies, and no currently active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> or <see cref="M:System.Security.CodeAccessPermission.Deny" /> modifiers; <see langword="true" /> if the common language runtime cannot guarantee that the stack contains none of these.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> méthode avant de vous mettre en cache des données sensibles obtenues après des demandes de sécurité réussies.  
  
 Si le <xref:System.Security.CodeAccessPermission.Assert%2A> méthode a été appelée supérieur sur la pile, les données ne doivent pas être mises en cache sans capturer le contexte de sécurité correspondant. Sinon, les données sensibles qui sont obtenues sous un <xref:System.Security.CodeAccessPermission.Assert%2A> peuvent devenir disponibles pour un code qui ne fonctionne plus avec qui <xref:System.Security.CodeAccessPermission.Assert%2A> en place.  
  
> [!IMPORTANT]
>  La valeur de retour est fiable uniquement lorsqu’il est `false`, ce qui signifie que le thread ne peut ne pas exiger la capture du contexte de sécurité. La méthode peut retourner true lors de la capture du contexte de sécurité n’est pas nécessaire, pour éviter les failles de sécurité.  
  
 <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> est critique de sécurité, car son utilisation principale est d’éviter le contexte de sécurité inutiles capture, qui indique que le code à l’aide d’elle est dépendante de la sécurité et doit être audité.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStandardSandbox">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet GetStandardSandbox(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ GetStandardSandbox(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member GetStandardSandbox : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.GetStandardSandbox evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">The host evidence to match to a permission set.</param>
        <summary>Gets a permission set that is safe to grant to an application that has the provided evidence.</summary>
        <returns>A permission set that can be used as a grant set for the application that has the provided evidence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l’hôte de preuve dans `evidence` doit contenir <xref:System.Security.Policy.Zone?displayProperty=nameWithType> preuve.  
>   
>  Le tableau suivant montre les jeux d’autorisations qui sont renvoyés pour chaque zone.  
  
|Zone|Jeu d’autorisations|  
|----------|--------------------|  
|<xref:System.Security.SecurityZone.MyComputer>|`FullTrust`|  
|<xref:System.Security.SecurityZone.Intranet>|`LocalIntranet`|  
|<xref:System.Security.SecurityZone.Trusted>|`Internet`|  
|<xref:System.Security.SecurityZone.Internet>|`Internet`|  
|<xref:System.Security.SecurityZone.Untrusted>|Aucun.|  
|<xref:System.Security.SecurityZone.NoZone>|Aucun.|  
  
 Autre preuve, telle que <xref:System.Security.Policy.Url> ou <xref:System.Security.Policy.Site>, peut être considéré comme.  
  
 Le jeu d’autorisations retourné peut être utilisé par un bac à sable pour exécuter l’application. Notez que cette méthode ne spécifie pas de stratégie, mais aide un hôte pour déterminer si le jeu d’autorisations demandé par une application est raisonnable. Cette méthode peut être utilisée pour mapper une zone à un bac à sable.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Security.SecurityManager.GetStandardSandbox%2A> méthode pour obtenir l’autorisation définie pour une application sandbox. Pour plus d’informations sur l’exécution d’une application dans un bac à sable, consultez [Comment : exécuter partiellement approuvé du Code dans un bac à sable](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).  
  
 [!code-csharp[sandboxingApis#1](~/samples/snippets/csharp/VS_Snippets_CLR/SandboxingAPIs/CS/program.cs#1)]
 [!code-vb[sandboxingApis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SandboxingAPIs/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetZoneAndOrigin">
      <MemberSignature Language="C#" Value="public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetZoneAndOrigin([out] class System.Collections.ArrayList&amp; zone, [out] class System.Collections.ArrayList&amp; origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetZoneAndOrigin (ByRef zone As ArrayList, ByRef origin As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetZoneAndOrigin([Runtime::InteropServices::Out] System::Collections::ArrayList ^ % zone, [Runtime::InteropServices::Out] System::Collections::ArrayList ^ % origin);" />
      <MemberSignature Language="F#" Value="static member GetZoneAndOrigin :  *  -&gt; unit" Usage="System.Security.SecurityManager.GetZoneAndOrigin (zone, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="zone" Type="System.Collections.ArrayList&amp;" RefType="out" />
        <Parameter Name="origin" Type="System.Collections.ArrayList&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="zone">An output parameter that contains an <see cref="T:System.Collections.ArrayList" /> of granted <see cref="P:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone" /> objects.</param>
        <param name="origin">An output parameter that contains an <see cref="T:System.Collections.ArrayList" /> of granted <see cref="T:System.Security.Permissions.UrlIdentityPermission" /> objects.</param>
        <summary>Gets the granted zone identity and URL identity permission sets for the current assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’alternative recommandée à cette méthode consiste à utiliser la preuve d’URL et le fuseau horaire de l’assembly en cours d’exécution pour appeler <xref:System.Security.SecurityManager.ResolvePolicy%2A> pour chaque type de preuve. Les jeux d’autorisations retournés à partir de la <xref:System.Security.SecurityManager.ResolvePolicy%2A> appels identifient les autorisations accordées à l’assembly en cours d’exécution selon sa zone et l’URL d’origine.  
  
> [!NOTE]
>  Ce membre effectue une demande de liaison pour la clé publique ECMA, qui n’est pas une clé de chiffrement valide, mais une pseudo-clé. Dans le .NET Framework la demande de liaison pour la pseudo-clé ECMA est automatiquement convertie en une demande de liaison pour la clé publique de Microsoft. L’exception de sécurité est basée sur la clé publique de Microsoft, pas la pseudo-clé ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The request for <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> failed.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsGranted">
      <MemberSignature Language="C#" Value="public static bool IsGranted (System.Security.IPermission perm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsGranted(class System.Security.IPermission perm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.IsGranted(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsGranted (perm As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsGranted(System::Security::IPermission ^ perm);" />
      <MemberSignature Language="F#" Value="static member IsGranted : System.Security.IPermission -&gt; bool" Usage="System.Security.SecurityManager.IsGranted perm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="perm" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="perm">The permission to test against the grant of the caller.</param>
        <summary>Determines whether a permission is granted to the caller.</summary>
        <returns>
          <see langword="true" /> if the permissions granted to the caller include the permission <paramref name="perm" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’octroi d’autorisations est déterminé par la stratégie et diffère d’une demande soumis à des remplacements, comme une assertion. En outre, <xref:System.Security.SecurityManager.IsGranted%2A> teste uniquement l’octroi de l’assembly de code appelant, indépendamment des autres appelants sur la pile.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromFile">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile(string path, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromFile (path As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromFile(System::String ^ path, System::Security::PolicyLevelType type);" />
      <MemberSignature Language="F#" Value="static member LoadPolicyLevelFromFile : string * System.Security.PolicyLevelType -&gt; System.Security.Policy.PolicyLevel" Usage="System.Security.SecurityManager.LoadPolicyLevelFromFile (path, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="path">The physical file path to a file containing the security policy information.</param>
        <param name="type">One of the enumeration values that specifies the type of the policy level to be loaded.</param>
        <summary>Loads a <see cref="T:System.Security.Policy.PolicyLevel" /> from the specified file.</summary>
        <returns>The loaded policy level.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The file indicated by the <paramref name="path" /> parameter does not exist.</exception>
        <exception cref="T:System.Security.SecurityException">The code that calls this method does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.  -or-  The code that calls this method does not have <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.  -or-  The code that calls this method does not have <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.  -or-  The code that calls this method does not have <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</exception>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir afficher et modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromString">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromString(string str, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromString (str As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromString(System::String ^ str, System::Security::PolicyLevelType type);" />
      <MemberSignature Language="F#" Value="static member LoadPolicyLevelFromString : string * System.Security.PolicyLevelType -&gt; System.Security.Policy.PolicyLevel" Usage="System.Security.SecurityManager.LoadPolicyLevelFromString (str, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="str">The XML representation of a security policy level in the same form in which it appears in a configuration file.</param>
        <param name="type">One of the enumeration values that specifies the type of the policy level to be loaded.</param>
        <summary>Loads a <see cref="T:System.Security.Policy.PolicyLevel" /> from the specified string.</summary>
        <returns>The loaded policy level.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="str" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="str" /> parameter is not valid.</exception>
        <exception cref="T:System.Security.SecurityException">The code that calls this method does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir afficher et modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PolicyHierarchy">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator PolicyHierarchy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator PolicyHierarchy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.PolicyHierarchy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PolicyHierarchy () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ PolicyHierarchy();" />
      <MemberSignature Language="F#" Value="static member PolicyHierarchy : unit -&gt; System.Collections.IEnumerator" Usage="System.Security.SecurityManager.PolicyHierarchy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provides an enumerator to access the security policy hierarchy by levels, such as computer policy and user policy.</summary>
        <returns>An enumerator for <see cref="T:System.Security.Policy.PolicyLevel" /> objects that compose the security policy hierarchy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’énumérateur retourné fournit successives <xref:System.Security.Policy.PolicyLevel> objets qui représentent la stratégie aux différents (ordinateur, utilisateur, entreprise, domaine d’application) au niveau de la hiérarchie. Ces objets sont les objets de stratégie active ; modification de ces objets peut avoir des résultats imprévisibles.  
  
 Hiérarchie de stratégie minimale se compose d’un niveau de la machine, niveau de l’entreprise et un niveau de l’utilisateur. Toutefois, la hiérarchie peut inclure des niveaux supplémentaires.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">The code that calls this method does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir afficher et modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolvePolicy">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determines what permissions to grant to code.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.ResolvePolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">The evidence set used to evaluate policy.</param>
        <summary>Determines what permissions to grant to code based on the specified evidence.</summary>
        <returns>The set of permissions that can be granted by the security system.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité, lui fournit la preuve de l’identité du code appelant. Le résultat est déterminé par la stratégie de sécurité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence[] evidences) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ResolvePolicy (evidences As Evidence()) As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(cli::array &lt;System::Security::Policy::Evidence ^&gt; ^ evidences);" />
      <MemberSignature Language="F#" Value="static member ResolvePolicy : System.Security.Policy.Evidence[] -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.ResolvePolicy evidences" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidences" Type="System.Security.Policy.Evidence[]" />
      </Parameters>
      <Docs>
        <param name="evidences">An array of evidence objects used to evaluate policy.</param>
        <summary>Determines what permissions to grant to code based on the specified evidence.</summary>
        <returns>The set of permissions that is appropriate for all of the provided evidence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité, en lui fournissant un tableau de <xref:System.Security.Policy.Evidence> objets. Le jeu d’autorisations retourné représente uniquement les autorisations qui s’appliquent à chaque preuve dans le tableau. Ces autorisations sont équivalent à ou un sous-ensemble des autorisations qui stratégie aurait accordées à chaque preuve individuelle. Cette méthode se comporte comme si vous exécutiez une intersection sur les résultats de la résolution de la stratégie sur chacun de la <xref:System.Security.Policy.Evidence> objets dans le tableau.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet reqdPset, class System.Security.PermissionSet optPset, class System.Security.PermissionSet denyPset, [out] class System.Security.PermissionSet&amp; denied) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ reqdPset, System::Security::PermissionSet ^ optPset, System::Security::PermissionSet ^ denyPset, [Runtime::InteropServices::Out] System::Security::PermissionSet ^ % denied);" />
      <MemberSignature Language="F#" Value="static member ResolvePolicy : System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet *  -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.ResolvePolicy (evidence, reqdPset, optPset, denyPset, denied)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="reqdPset" Type="System.Security.PermissionSet" />
        <Parameter Name="optPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denyPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denied" Type="System.Security.PermissionSet&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="evidence">The evidence set used to evaluate policy.</param>
        <param name="reqdPset">The required permissions the code needs to run.</param>
        <param name="optPset">The optional permissions that will be used if granted, but aren't required for the code to run.</param>
        <param name="denyPset">The denied permissions that must never be granted to the code even if policy otherwise permits it.</param>
        <param name="denied">An output parameter that contains the set of permissions not granted.</param>
        <summary>Determines what permissions to grant to code based on the specified evidence and requests.</summary>
        <returns>The set of permissions that would be granted by the security system.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité, en lui fournissant les preuves de l’identité du code appelant, ainsi que le jeu d’autorisations le code de demandes. Le résultat est déterminé par la stratégie de sécurité. Cette méthode retourne le jeu d’autorisations qui pourraient être accordées par le système de sécurité et retourne le jeu d’autorisations qui serait refusé comme paramètre de sortie. Les autorisations effectives sont celles dans le jeu accordé qui ne sont pas dans le jeu refusé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Policy fails to grant the minimum required permissions specified by the <paramref name="reqdPset" /> parameter.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicyGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator ResolvePolicyGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ ResolvePolicyGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member ResolvePolicyGroups : System.Security.Policy.Evidence -&gt; System.Collections.IEnumerator" Usage="System.Security.SecurityManager.ResolvePolicyGroups evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">The evidence set against which the policy is evaluated.</param>
        <summary>Gets a collection of code groups matching the specified evidence.</summary>
        <returns>An enumeration of the set of code groups matching the evidence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utile pour analyser le fonctionne d’une configuration de stratégie spécifié avec des types de preuves.  
  
 Les groupes de code sont retournés à partir de tous les niveaux de la hiérarchie de stratégie de correspondance applicables le `evidence` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSystemPolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolveSystemPolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolveSystemPolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member ResolveSystemPolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.ResolveSystemPolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">The evidence set used to evaluate policy.</param>
        <summary>Determines which permissions to grant to code based on the specified evidence, excluding the policy for the <see cref="T:System.AppDomain" /> level.</summary>
        <returns>The set of permissions that can be granted by the security system.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité et fournit la preuve de l’identité du code appelant. Le résultat est déterminé par la stratégie de sécurité système exclusion de toute <xref:System.AppDomain> stratégie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="SavePolicy">
      <MemberSignature Language="C#" Value="public static void SavePolicy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicy();" />
      <MemberSignature Language="F#" Value="static member SavePolicy : unit -&gt; unit" Usage="System.Security.SecurityManager.SavePolicy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves the modified security policy state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode enregistre la stratégie exposée par <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, et d’autres classes qui représentent la configuration de la stratégie de sécurité. Sauf si cette méthode est appelée, les modifications apportées aux objets de stratégie ne seront pas enregistrées et n’affecteront pas les exécutions de l’application suivante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">The code that calls this method does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SavePolicyLevel">
      <MemberSignature Language="C#" Value="public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicyLevel(class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicyLevel (level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicyLevel(System::Security::Policy::PolicyLevel ^ level);" />
      <MemberSignature Language="F#" Value="static member SavePolicyLevel : System.Security.Policy.PolicyLevel -&gt; unit" Usage="System.Security.SecurityManager.SavePolicyLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="level">The policy level object to be saved.</param>
        <summary>Saves a modified security policy level loaded with <see cref="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.Policy.PolicyLevel> sera enregistré dans le même emplacement que celui à partir duquel il est chargé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The code that calls this method does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <exception cref="T:System.NotSupportedException">This method uses code access security (CAS) policy, which is obsolete in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. To enable CAS policy for compatibility with earlier versions of the .NET Framework, use the [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityEnabled">
      <MemberSignature Language="C#" Value="public static bool SecurityEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SecurityEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.SecurityEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SecurityEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityEnabled : bool with get, set" Usage="System.Security.SecurityManager.SecurityEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The security manager cannot be turned off on MS runtime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether security is enabled.</summary>
        <value>
          <see langword="true" /> Si la sécurité est activée ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée par le [Caspol.exe (outil de stratégie de sécurité d’accès de Code)](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md)  
  
 `-security` (`-s`) permet de désactiver la sécurité basée sur le code.  
  
 <xref:System.Security.SecurityManager.SecurityEnabled%2A> fournit un moyen pour les administrateurs désactiver la sécurité d’accès du code. Lorsque la sécurité d'accès du code est désactivée, toutes les demandes d'accès au code aboutissent. En effet, ce paramètre accorde à tout le code `FullTrust`. Désactivation de la sécurité permet de contourner le système de sécurité afin que le code peut effectuer légèrement supérieures à celles de l’octroi de stratégie de sécurité équivalentes `FullTrust` à tout le code. Cette propriété ne désactive pas la sécurité en fonction du rôle ; Par conséquent, <xref:System.Security.Permissions.PrincipalPermission> demandes ne sont pas affectées.  
  
> [!CAUTION]
>  La désactivation de la sécurité expose le système aux attaques de code nuisible tel que les virus et les vers. Désactivation de la sécurité ne bloque pas automatiquement le code managé de s’exécuter dans n’importe quel moyen. Informatique causes uniquement du code à s’exécuter sans restriction par le système de sécurité d’accès du code managé et ne doivent être effectuées avec une extrême prudence. La désactivation de la sécurité à des fins de performances supplémentaire doit être effectuée uniquement lorsque d’autres mesures de sécurité ont été prises pour vous aider à protéger la sécurité du système. Ces autres mesures de sécurité consistent notamment à déconnecter les réseaux publics, à sécuriser physiquement les ordinateurs, etc.  
  
 Une modification de cette propriété n’est pas conservée dans le Registre jusqu'à ce que <xref:System.Security.SecurityManager.SavePolicy%2A> est appelée. Nouveaux processus ne seront pas affectés par la modification jusqu'à ce qu’il est conservé dans le Registre. Modification de la valeur de cette propriété dans un processus en cours d’exécution ne modifie pas nécessairement l’état de la manière attendue. Pour que les modifications ont pris effet, vous devez appeler <xref:System.Security.SecurityManager.SavePolicy%2A> et démarre un nouveau processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The code that calls this method does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>