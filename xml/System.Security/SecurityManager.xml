<Type Name="SecurityManager" FullName="System.Security.SecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="51b52be500a5be1b9b263e9528638a7f09b2cb2a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500683" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class SecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed SecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class SecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityManager abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit le point d'accès principal pour les classes en interaction avec le système de sécurité. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sécurité fournit des méthodes pour accéder et de manipuler la configuration de stratégie de sécurité. Vous ne pouvez pas créer des instances de <xref:System.Security.SecurityManager>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CheckExecutionRights">
      <MemberSignature Language="C#" Value="public static bool CheckExecutionRights { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckExecutionRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.CheckExecutionRights" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckExecutionRights As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckExecutionRights { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le code doit avoir un indicateur <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> pour s'exécuter.</summary>
        <value>
          <see langword="true" /> si le code doit avoir <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> pour s'exécuter ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété est `false`, même le code sans <xref:System.Security.Permissions.SecurityPermissionFlag.Execution> peuvent exécuter. Vérification de l’exécution est coûteuse et permet d’éliminer les avantages de la résolution de stratégie différée. Cette propriété est fournie pour désactiver l’exécution de la vérification si nécessaire.  
  
 Une modification de cette propriété n’est pas conservée jusqu'à ce que <xref:System.Security.SecurityManager.SavePolicy%2A> est appelée. Nouveaux processus ne seront pas affectées par la modification jusqu'à ce qu’elle est persistante dans le Registre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThreadRequiresSecurityContextCapture">
      <MemberSignature Language="C#" Value="public static bool CurrentThreadRequiresSecurityContextCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CurrentThreadRequiresSecurityContextCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CurrentThreadRequiresSecurityContextCapture () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CurrentThreadRequiresSecurityContextCapture();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si le thread actuel nécessite la capture du contexte de sécurité si son état de sécurité doit être recréé ultérieurement.</summary>
        <returns>
          <see langword="false" /> si la pile ne contient pas de domaines d'application partiellement fiables, pas d'assembly partiellement fiable et pas de <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> actuellement actif ou modificateur <see cref="M:System.Security.CodeAccessPermission.Deny" /> ; <see langword="true" /> si le common language runtime ne peut pas garantir que la pile ne contient aucun de ces éléments.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> avant de mettre en cache les données sensibles obtenues après des demandes de sécurité réussi.  
  
 Si le <xref:System.Security.CodeAccessPermission.Assert%2A> méthode a été appelée plus élevée dans la pile, les données ne doivent pas être mis en cache sans capturer le contexte de sécurité correspondant. Sinon, les données sensibles obtenues sous un <xref:System.Security.CodeAccessPermission.Assert%2A> devraient être disponibles pour un code qui ne fonctionne plus avec qui <xref:System.Security.CodeAccessPermission.Assert%2A> en place.  
  
> [!IMPORTANT]
>  La valeur de retour est fiable uniquement lorsqu’il est `false`, ce qui signifie que le thread ne peut ne pas nécessiter la capture du contexte de sécurité. La méthode peut retourner la valeur true lors de la capture du contexte de sécurité n’est pas nécessaire, pour éviter des failles de sécurité.  
  
 <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> est critique de sécurité, car son utilisation principale consiste à éviter le contexte de sécurité inutiles capture, qui indique que le code à l’aide d’elle est dépendante de la sécurité et doit être audité.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStandardSandbox">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet GetStandardSandbox(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ GetStandardSandbox(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Preuve hôte à associer à un jeu d'autorisations.</param>
        <summary>Obtient un jeu d'autorisations qui peut être accordé en toute sécurité à une application qui dispose de la preuve fournie.</summary>
        <returns>Jeu d'autorisations qui peut être utilisé comme un jeu accordé pour l'application qui dispose de la preuve fournie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la preuve hôte dans `evidence` doit contenir <xref:System.Security.Policy.Zone?displayProperty=nameWithType> preuve.  
>   
>  Le tableau suivant présente les jeux d’autorisations qui sont renvoyés pour chaque zone.  
  
|Zone|Jeu d’autorisations|  
|----------|--------------------|  
|<xref:System.Security.SecurityZone.MyComputer>|`FullTrust`|  
|<xref:System.Security.SecurityZone.Intranet>|`LocalIntranet`|  
|<xref:System.Security.SecurityZone.Trusted>|`Internet`|  
|<xref:System.Security.SecurityZone.Internet>|`Internet`|  
|<xref:System.Security.SecurityZone.Untrusted>|Aucun.|  
|<xref:System.Security.SecurityZone.NoZone>|Aucun.|  
  
 Autres preuves, telles que <xref:System.Security.Policy.Url> ou <xref:System.Security.Policy.Site>, peut être considéré comme.  
  
 Le jeu d’autorisations retourné peut être utilisé par un bac à sable pour exécuter l’application. Notez que cette méthode ne spécifie pas de stratégie, mais aide un hôte pour déterminer si le jeu d’autorisations demandé par une application est raisonnable. Cette méthode peut être utilisée pour mapper une zone à un bac à sable.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la <xref:System.Security.SecurityManager.GetStandardSandbox%2A> méthode pour obtenir l’autorisation définie pour une application en sandbox. Pour plus d’informations sur l’exécution d’une application dans un bac à sable, consultez [Comment : exécuter Partially Trusted Code dans un bac à sable](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).  
  
 [!code-csharp[sandboxingApis#1](~/samples/snippets/csharp/VS_Snippets_CLR/SandboxingAPIs/CS/program.cs#1)]
 [!code-vb[sandboxingApis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SandboxingAPIs/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetZoneAndOrigin">
      <MemberSignature Language="C#" Value="public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetZoneAndOrigin([out] class System.Collections.ArrayList&amp; zone, [out] class System.Collections.ArrayList&amp; origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetZoneAndOrigin (ByRef zone As ArrayList, ByRef origin As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetZoneAndOrigin([Runtime::InteropServices::Out] System::Collections::ArrayList ^ % zone, [Runtime::InteropServices::Out] System::Collections::ArrayList ^ % origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="zone" Type="System.Collections.ArrayList&amp;" RefType="out" />
        <Parameter Name="origin" Type="System.Collections.ArrayList&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="zone">Paramètre de sortie qui contient un <see cref="T:System.Collections.ArrayList" /> des objets <see cref="P:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone" /> accordés.</param>
        <param name="origin">Paramètre de sortie qui contient un <see cref="T:System.Collections.ArrayList" /> des objets <see cref="T:System.Security.Permissions.UrlIdentityPermission" /> accordés.</param>
        <summary>Obtient les jeux d'autorisations accordées à l'identité de zone et à l'identité d'URL pour l'assembly en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’alternative recommandée à cette méthode consiste à utiliser la preuve d’URL et le fuseau horaire de l’assembly en cours d’exécution pour appeler <xref:System.Security.SecurityManager.ResolvePolicy%2A> pour chaque type de preuve. Les jeux d’autorisations retournés à partir de la <xref:System.Security.SecurityManager.ResolvePolicy%2A> appels identifient les autorisations accordées à l’assembly en cours d’exécution en fonction de sa zone et l’URL d’origine.  
  
> [!NOTE]
>  Ce membre effectue une demande de liaison pour la clé publique ECMA, qui n’est pas une clé de chiffrement valide, mais une pseudo-clé. Dans le .NET Framework la demande de liaison pour la pseudo-clé ECMA est automatiquement convertie en une demande de liaison pour la clé publique de Microsoft. L’exception de sécurité est basée sur la clé publique Microsoft, pas la pseudo-clé ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">La demande de <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> a échoué.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsGranted">
      <MemberSignature Language="C#" Value="public static bool IsGranted (System.Security.IPermission perm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsGranted(class System.Security.IPermission perm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.IsGranted(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsGranted (perm As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsGranted(System::Security::IPermission ^ perm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="perm" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="perm">Autorisation à tester par rapport aux autorisations attribuées à l'appelant.</param>
        <summary>Détermine si une autorisation est accordée à l'appelant.</summary>
        <returns>
          <see langword="true" /> si les autorisations accordées à l'appelant comprennent l'autorisation <paramref name="perm" /> ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’octroi d’autorisations est déterminé par la stratégie et diffère d’une demande soumise à des remplacements, comme une assertion. En outre, <xref:System.Security.SecurityManager.IsGranted%2A> teste uniquement l’octroi de l’assembly de code appelant, indépendamment des autres appelants sur la pile.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromFile">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile(string path, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromFile (path As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromFile(System::String ^ path, System::Security::PolicyLevelType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès physique vers un fichier contenant les informations de stratégie de sécurité.</param>
        <param name="type">Une des valeurs d’énumération qui spécifie le type du niveau de stratégie à charger.</param>
        <summary>Charge un <see cref="T:System.Security.Policy.PolicyLevel" /> à partir du fichier spécifié.</summary>
        <returns>Le niveau de stratégie chargé.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le fichier indiqué par le paramètre <paramref name="path" /> n’existe pas.</exception>
        <exception cref="T:System.Security.SecurityException">Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.  
  
 - ou -  
  
 Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.  
  
 - ou -  
  
 Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.  
  
 - ou -  
  
 Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir afficher et modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromString">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromString(string str, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromString (str As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromString(System::String ^ str, System::Security::PolicyLevelType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="str">Représentation XML d'un niveau de stratégie de sécurité dans le même format que celui dans lequel il apparaît dans un fichier de configuration.</param>
        <param name="type">Une des valeurs d’énumération qui spécifie le type du niveau de stratégie à charger.</param>
        <summary>Charge <see cref="T:System.Security.Policy.PolicyLevel" /> à partir de la chaîne spécifiée.</summary>
        <returns>Le niveau de stratégie chargé.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="str" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="str" /> n'est pas valide.</exception>
        <exception cref="T:System.Security.SecurityException">Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir afficher et modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PolicyHierarchy">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator PolicyHierarchy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator PolicyHierarchy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.PolicyHierarchy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PolicyHierarchy () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ PolicyHierarchy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit un énumérateur pour accéder à la hiérarchie de stratégie de sécurité par niveaux, par exemple les stratégies d'ordinateur et d'utilisateur.</summary>
        <returns>Un énumérateur pour les objets <see cref="T:System.Security.Policy.PolicyLevel" /> qui constituent la hiérarchie de stratégie de sécurité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’énumérateur retourné fournit une successives <xref:System.Security.Policy.PolicyLevel> objets qui représentent la stratégie aux différents (ordinateur, utilisateur, entreprise, domaine d’application) au niveau de la hiérarchie. Ces objets sont les objets de stratégie dynamique ; modification de ces objets peut avoir des résultats imprévisibles.  
  
 Hiérarchie de la stratégie minimale se compose d’un niveau de l’ordinateur, un niveau de l’entreprise et un niveau de l’utilisateur. Toutefois, la hiérarchie peut inclure des niveaux supplémentaires.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir afficher et modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolvePolicy">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine les autorisations à accorder au code.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Ensemble de preuves utilisé pour évaluer la stratégie.</param>
        <summary>Détermine les autorisations à accorder au code en fonction de la preuve spécifiée.</summary>
        <returns>Le jeu d’autorisations qui peuvent être accordées par le système de sécurité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité et lui fournit la preuve de l’identité du code appelant. Le résultat est déterminé par la stratégie de sécurité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence[] evidences) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ResolvePolicy (evidences As Evidence()) As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(cli::array &lt;System::Security::Policy::Evidence ^&gt; ^ evidences);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidences" Type="System.Security.Policy.Evidence[]" />
      </Parameters>
      <Docs>
        <param name="evidences">Tableau d’objets de preuve utilisés pour évaluer la stratégie.</param>
        <summary>Détermine les autorisations à accorder au code en fonction de la preuve spécifiée.</summary>
        <returns>Jeu d’autorisations appropriées pour l’ensemble des preuves fournies.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité, en lui donnant un tableau de <xref:System.Security.Policy.Evidence> objets. Le jeu d’autorisations retourné représente uniquement les autorisations qui s’appliquent à chaque preuve dans le tableau. Ces autorisations sont équivalent à, ou un sous-ensemble des autorisations stratégie aurait accordées à chaque preuve individuelle. Cette méthode se comporte comme si vous exécutiez une intersection sur les résultats de la résolution de la stratégie sur chacun de la <xref:System.Security.Policy.Evidence> objets dans le tableau.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet reqdPset, class System.Security.PermissionSet optPset, class System.Security.PermissionSet denyPset, [out] class System.Security.PermissionSet&amp; denied) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ reqdPset, System::Security::PermissionSet ^ optPset, System::Security::PermissionSet ^ denyPset, [Runtime::InteropServices::Out] System::Security::PermissionSet ^ % denied);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="reqdPset" Type="System.Security.PermissionSet" />
        <Parameter Name="optPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denyPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denied" Type="System.Security.PermissionSet&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="evidence">Ensemble de preuves utilisé pour évaluer la stratégie.</param>
        <param name="reqdPset">Les autorisations requises que le code doit exécuter.</param>
        <param name="optPset">Les autorisations facultatives qui seront utilisées si elles sont accordées, mais qui ne sont pas requises pour l’exécution du code.</param>
        <param name="denyPset">Les autorisations refusées qui ne doivent jamais être accordées au code même si la stratégie le permet.</param>
        <param name="denied">Paramètre de sortie qui contient le jeu d’autorisations non accordées.</param>
        <summary>Détermine les autorisations à accorder au code en fonction de la preuve et des demandes spécifiées.</summary>
        <returns>Le jeu d’autorisations qui pourraient être accordées par le système de sécurité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité, fournissant une preuve d’identité du code appelant et le jeu d’autorisations le code de demandes. Le résultat est déterminé par la stratégie de sécurité. Cette méthode retourne le jeu d’autorisations qui seraient accordées par le système de sécurité et retourne le jeu d’autorisations qui serait refusé comme paramètre de sortie. Les autorisations effectives sont ceux contenus dans le jeu accordé qui ne sont pas dans le jeu refusé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.Policy.PolicyException">La stratégie ne parvient pas à accorder les autorisations minimales requises spécifiées par le paramètre <paramref name="reqdPset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicyGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator ResolvePolicyGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ ResolvePolicyGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Ensemble de preuves sur lequel la stratégie est évaluée.</param>
        <summary>Obtient une collection de groupes de codes correspondant à la preuve spécifiée.</summary>
        <returns>Énumération de l’ensemble des groupes de codes correspondant à la preuve.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utile dans les analyser le fonctionne d’une configuration de stratégie spécifiée avec des types de preuves.  
  
 Les groupes de code sont retournés à partir de tous les niveaux de la hiérarchie de la stratégie de correspondance applicables le `evidence` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSystemPolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolveSystemPolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolveSystemPolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Ensemble de preuves utilisé pour évaluer la stratégie.</param>
        <summary>Détermine les autorisations à accorder au code selon la preuve spécifiée, à l’exclusion de la stratégie pour le niveau <see cref="T:System.AppDomain" />.</summary>
        <returns>Le jeu d’autorisations qui peuvent être accordées par le système de sécurité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le moteur de stratégie de sécurité et fournit la preuve de l’identité du code appelant. Le résultat est déterminé par la stratégie de sécurité système exclusion de toute <xref:System.AppDomain> stratégie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="SavePolicy">
      <MemberSignature Language="C#" Value="public static void SavePolicy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre l’état de stratégie de sécurité modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode enregistre la stratégie exposée par <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, et d’autres classes qui représentent la configuration de la stratégie de sécurité. Sauf si cette méthode est appelée, les modifications apportées aux objets de stratégie ne seront pas enregistrées et n’affectent pas les exécutions suivantes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SavePolicyLevel">
      <MemberSignature Language="C#" Value="public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicyLevel(class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicyLevel (level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicyLevel(System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="level">Objet de niveau de stratégie à enregistrer.</param>
        <summary>Enregistre un niveau de stratégie de sécurité modifié chargé avec <see cref="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.Policy.PolicyLevel> sera enregistré dans le même emplacement que celui à partir duquel il est chargé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode utilise la stratégie de sécurité d’accès du code (CAS), qui est obsolète dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Pour activer la stratégie de sécurité d’accès du code (CAS) pour la compatibilité avec les versions antérieures de .NET Framework, utilisez l’[élément &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityEnabled">
      <MemberSignature Language="C#" Value="public static bool SecurityEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SecurityEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.SecurityEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SecurityEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The security manager cannot be turned off on MS runtime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la sécurité est activée.</summary>
        <value>
          <see langword="true" /> si la sécurité est activée ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée par le [Caspol.exe (Code Access Security Policy Tool)](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md)  
  
 `-security` (`-s`) permet de désactiver la sécurité basée sur le code.  
  
 <xref:System.Security.SecurityManager.SecurityEnabled%2A> permet aux administrateurs de désactiver la sécurité d’accès du code. Lorsque la sécurité d'accès du code est désactivée, toutes les demandes d'accès au code aboutissent. En effet, cette valeur autorise tout le code `FullTrust`. La désactivation de la sécurité d’accès contourne le système de sécurité afin que le code peut s’exécuter légèrement supérieures à celles de l’octroi de stratégie de sécurité équivalentes `FullTrust` à tout le code. Cette propriété ne désactive pas la sécurité basée sur les rôles ; Par conséquent, <xref:System.Security.Permissions.PrincipalPermission> demandes ne sont pas affectées.  
  
> [!CAUTION]
>  La désactivation de la sécurité expose le système aux attaques de code nuisible tel que les virus et les vers. La désactivation de sécurité d’accès du code ne bloque pas automatiquement du code managé à partir de l’exécution. Informatique causes uniquement du code pour une exécution sans restriction par le système de sécurité d’accès du code managé et ne doivent être effectuées avec une extrême prudence. La désactivation de la sécurité à des fins de performances supplémentaire doit être effectuée uniquement lorsque d’autres mesures de sécurité ont été prises pour protéger la sécurité du système. Ces autres mesures de sécurité consistent notamment à déconnecter les réseaux publics, à sécuriser physiquement les ordinateurs, etc.  
  
 Une modification de cette propriété n’est pas conservée dans le Registre jusqu'à ce que <xref:System.Security.SecurityManager.SavePolicy%2A> est appelée. Nouveaux processus ne seront pas affectées par la modification jusqu'à ce qu’elle est persistante dans le Registre. Modification de la valeur de cette propriété dans un processus en cours d’exécution ne change pas nécessairement l’état de la manière attendue. Pour vérifier les modifications ont pris effet, vous devez appeler <xref:System.Security.SecurityManager.SavePolicy%2A> et démarre un nouveau processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Le code qui appelle cette méthode ne dispose pas de <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir modifier la stratégie. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>