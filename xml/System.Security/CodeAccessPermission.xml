<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CodeAccessPermission.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b497a3cd20cb1d0ae8172ce6caf259ae001ddee0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b497a3cd20cb1d0ae8172ce6caf259ae001ddee0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.CodeAccessPermission">
          <source>Defines the underlying structure of all code access permissions.</source>
          <target state="translated">Définit la structure sous-jacente de toutes les autorisations d’accès au code.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</source>
          <target state="translated">Autorisations d’accès de code utilisent une pile pour vous assurer que tous les appelants du code ont été accordées à une autorisation.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>If a permission object is <ph id="ph1">`null`</ph>, it is handled the same as a permission object with the state <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si un objet d’autorisation est <ph id="ph1">`null`</ph>, il est géré comme un objet d’autorisation avec l’état <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">La pile des appels est généralement représentée comme étant descendante, afin que le plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Inheritors of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class must be granted full trust to function correctly as permissions extending the security infrastructure.</source>
          <target state="translated">Les héritiers de la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe doit être de confiance totale pour fonctionner correctement comme des autorisations étendant l’infrastructure de sécurité.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>To determine that the inheritors are fully trusted, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> issues an <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> for <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence&gt;</ph><ph id="ph4"> = </ph><ph id="ph5">`true`</ph> and <ph id="ph6">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy&gt;</ph><ph id="ph7"> = </ph><ph id="ph8">`true`</ph>.</source>
          <target state="translated">Pour déterminer que les héritiers sont entièrement fiables, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> problèmes un <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> pour <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence&gt;</ph> <ph id="ph4"> = </ph> <ph id="ph5">`true`</ph> et <ph id="ph6">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy&gt;</ph> <ph id="ph7"> = </ph> <ph id="ph8">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The following code example shows a permission derived from the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">L’exemple de code suivant montre une autorisation dérivée de la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>for the ability of inheritors to provide evidence and view and modify policy.</source>
          <target state="translated">pour la capacité des héritiers fournissent la preuve, d’afficher et modifier la stratégie.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, you must also implement the <ph id="ph2">&lt;see cref="T:System.Security.Permissions.IUnrestrictedPermission" /&gt;</ph> interface.</source>
          <target state="translated">Lorsque vous héritez de <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, vous devez également implémenter la <ph id="ph2">&lt;see cref="T:System.Security.Permissions.IUnrestrictedPermission" /&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The following <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> members must be overridden: <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Copy" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Security.CodeAccessPermission.ToXml" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /&gt;</ph>, and <ph id="ph7">&lt;see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /&gt;</ph>.</source>
          <target state="translated">Les éléments suivants <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> membres doivent être substitués : <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Copy" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Security.CodeAccessPermission.ToXml" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /&gt;</ph>, et <ph id="ph7">&lt;see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>You must also define a constructor that takes a <ph id="ph1">&lt;see cref="T:System.Security.Permissions.PermissionState" /&gt;</ph> as its only parameter.</source>
          <target state="translated">Vous devez également définir un constructeur qui accepte un <ph id="ph1">&lt;see cref="T:System.Security.Permissions.PermissionState" /&gt;</ph> comme son seul paramètre.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>You must apply the <ph id="ph1">&lt;see cref="T:System.SerializableAttribute" /&gt;</ph> attribute to a class that inherits from <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">Vous devez appliquer le <ph id="ph1">&lt;see cref="T:System.SerializableAttribute" /&gt;</ph> une classe qui hérite de l’attribut <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>This constructor is called to initialize state in the type whenever an instance of the derived class is created.</source>
          <target state="translated">Ce constructeur est appelé pour initialiser l’état dans le type chaque fois qu’une instance de la classe dérivée est créée.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</source>
          <target state="translated">Bien que vous pouvez appeler explicitement ce constructeur dans la déclaration du constructeur du constructeur de classe dérivée, il est généralement pas nécessaire ; la plupart des compilateurs généreront automatiquement l’appel pour vous.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">Déclare que le code appelant peut accéder à la ressource protégée par une demande d’autorisation via le code qui appelle cette méthode, même si les appelants situés plus haut dans la pile n’ont pas reçu l’autorisation d’accéder à la ressource.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Using <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> can create security issues.</source>
          <target state="translated">L’utilisation de <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> peut créer des problèmes de sécurité.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">La pile des appels est généralement représentée comme étant descendante, afin que le plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Calling <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</source>
          <target state="translated">Appel de <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> empêche un parcours de pile provenant de réduire la pile des appels de procédure dans la pile des appels au-delà du code qui appelle cette méthode.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</source>
          <target state="translated">Par conséquent, même si les appelants situés plus haut dans la pile des appels n’ont pas les autorisations requises pour accéder à une ressource, ils peuvent toujours y accéder via le code qui appelle cette méthode sur l’autorisation nécessaire.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>An assertion is effective only if the code that calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> passes the security check for the permission that it is asserting.</source>
          <target state="translated">Une assertion n’est efficace uniquement si le code qui appelle <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> passe la vérification de sécurité pour l’autorisation qu’il confirme.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">L’appel à <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> est effective jusqu'à ce que le code appelant retourne à son appelant.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Seul <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> peut être actif sur un frame.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Toute tentative d’appel <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> lorsque actif <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> existe sur les résultats du frame dans un <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Appelez <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> pour supprimer un actif <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> est ignoré pour une autorisation refusée, car une demande concernant cette autorisation ne réussira pas.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>However, if code lower on the call stack calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Toutefois, si le code situé plus bas dans la pile des appels appelle <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> pour cette autorisation, un <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> est levée lorsque le parcours de pile atteint le code qui a tenté d’appeler <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>This happens because the code that called <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> has not been granted the permission, even though it tried to <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> it.</source>
          <target state="translated">Cela se produit car le code qui a appelé <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> n’a pas reçu l’autorisation, même s’il a tenté de <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> il.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Because calling <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</source>
          <target state="translated">Étant donné que l’appel <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> supprime l’exigence que tout le code dans la chaîne d’appel doit être autorisé à accéder à la ressource spécifiée, il peut ouvrir des problèmes de sécurité si l’utilisation incorrecte ou inappropriée.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">Par conséquent, elle doit être utilisée avec précaution.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The calling code does not have <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</source>
          <target state="translated">Le code appelant n’a pas <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame.</source>
          <target state="translated">Il existe déjà un <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> actif pour l’image actuelle.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>for the ability to call <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>.</source>
          <target state="translated">Pour pouvoir appeler <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>You cannot override this method.</source>
          <target state="translated">Vous ne pouvez pas substituer cette méthode.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>When implemented by a derived class, creates and returns an identical copy of the current permission object.</source>
          <target state="translated">En cas d’implémentation par une classe dérivée, crée et retourne une copie identique de l’objet d’autorisation actuel.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>A copy of the current permission object.</source>
          <target state="translated">Copie de l’objet d’autorisation actuel.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>A copy of a permission object represents the same access to resources as the original permission object.</source>
          <target state="translated">Une copie d’un objet d’autorisation représente le même accès aux ressources que l’objet d’autorisation d’origine.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Copy%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une substitution de la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Copy%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Vous devez substituer cette méthode dans une classe dérivée.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>Forces a <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</source>
          <target state="translated">Force un <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> au moment de l’exécution si tous les appelants figurant plus haut dans la pile des appels ne disposent pas des autorisations spécifiées par l’instance actuelle.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">Cette méthode est généralement utilisée par des bibliothèques sécurisées pour garantir que les appelants ont l’autorisation d’accéder à une ressource.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>For example, a file class in a secure class library calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for the necessary <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> before performing a file operation requested by the caller.</source>
          <target state="translated">Par exemple, une classe de fichier dans une bibliothèque de classes sécurisée appelle <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> pour nécessaires <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> avant d’effectuer une opération de fichier demandée par l’appelant.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">Les autorisations du code qui appelle cette méthode ne sont pas examinées ; la vérification commence à partir de l’appelant immédiat de ce code et se déroule la pile.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">La pile des appels est généralement représentée comme étant descendante, afin que le plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> succeeds only if no <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> réussit uniquement si aucune <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> est déclenché.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>A caller higher in the call stack does not have the permission specified by the current instance.</source>
          <target state="translated">Un appelant figurant plus haut dans la pile des appels ne dispose pas de l’autorisation spécifiée par l’instance actuelle.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>A caller higher in the call stack has called <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> on the current permission object.</source>
          <target state="translated">Un appelant figurant plus haut dans la pile des appels a appelé <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> sur l’objet d’autorisation actuel.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>You cannot override this method.</source>
          <target state="translated">Vous ne pouvez pas substituer cette méthode.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</source>
          <target state="translated">Empêche les appelants plus hauts dans la pile des appels d’utiliser le code qui appelle cette méthode pour accéder à la ressource spécifiée par l’instance actuelle.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> méthode doit être utilisée uniquement pour protéger les ressources contre l’accès accidentel par du code de confiance totale.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">Ne doit pas être utilisé pour protéger les ressources à partir d’abusive par du code non fiable.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> for a permission and then calls method <ph id="ph3">`B`</ph>, method <ph id="ph4">`B`</ph> can overtly override the <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> by issuing an <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Par exemple, si (méthode) <ph id="ph1">`A`</ph> problèmes un <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> pour une autorisation, puis appelle la méthode <ph id="ph3">`B`</ph>, méthode <ph id="ph4">`B`</ph> peut substituer ouvertement la <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> en émettant un <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">La méthode appelée est toujours plus haut dans la pile.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lower in the stack.</source>
          <target state="translated">Par conséquent, si méthode <ph id="ph1">`B`</ph> tente d’accéder à une ressource protégée, le système de sécurité commence à contrôler les autorisations, car méthode <ph id="ph2">`B`</ph> est l’appelant immédiat, puis parcourt la pile pour confirmer qu’il y a aucune <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> plus bas dans la pile.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> method.</source>
          <target state="translated">Méthode <ph id="ph1">`B`</ph>, qui tente d’accéder à la ressource, peut arrêter le parcours de pile immédiatement à l’aide de la <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>In that case, the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> placed on the stack by method <ph id="ph2">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> placée sur la pile par la méthode <ph id="ph2">`A`</ph> (la méthode appelante) n’est jamais découverte.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">Cette méthode empêche les appelants situés plus haut dans la pile des appels d’accéder à la ressource protégée via le code qui appelle cette méthode, même si les appelants ont reçu l’autorisation d’y accéder.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">La pile des appels est généralement représentée comme étant descendante, afin que le plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> from being used to access the resource protected by the denied permission.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> peut limiter la responsabilité du programmeur ou éviter les problèmes de sécurité accidentelle, car elle contribue à empêcher la méthode qui appelle <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> d’être utilisé pour accéder à la ressource protégée par l’autorisation refusée.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>If a method calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> on a permission, and if a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</source>
          <target state="translated">Si une méthode appelle <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> sur une autorisation et si un <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> pour cette autorisation est appelée par un appelant plus bas dans la pile des appels, cette vérification de sécurité échoue lorsqu’elle atteint la <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">L’appel à <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> est effective jusqu'à ce que le code appelant retourne à son appelant.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Seul <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> peut être actif sur un frame.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Toute tentative d’appel <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> lorsque actif <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> existe sur les résultats du frame dans un <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</source>
          <target state="translated">Appelez <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> pour supprimer un actif <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> est ignoré pour une autorisation refusée, car une demande concernant cette autorisation ne réussira pas.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame.</source>
          <target state="translated">Il existe déjà un <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> actif pour l’image actuelle.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>You cannot override this method.</source>
          <target state="translated">Vous ne pouvez pas substituer cette méthode.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object to compare with the current <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> à comparer au <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object is equal to the current <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">Détermine si l’objet <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> spécifié est égal au <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object is equal to the current <ph id="ph3">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l’objet <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> spécifié est égal à l’élément <ph id="ph3">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> actuel ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The XML encoding to use to reconstruct the security object.</source>
          <target state="translated">Encodage XML à utiliser pour reconstruire l’objet de sécurité.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</source>
          <target state="translated">En cas de remplacement dans une classe dérivée, reconstruit un objet de sécurité avec un état spécifié à partir d’un encodage XML.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>Custom code that extends security objects needs to implement the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> methods to make the objects security-encodable.</source>
          <target state="translated">Code personnalisé qui étend les objets de sécurité doit implémenter les <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> méthodes pour rendre les objets puissent être codés en sécurité.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une substitution de la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter does not contain the XML encoding for an instance of the same type as the current instance.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> ne contient pas l'encodage XML pour une instance du même type que l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The version number of the <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter is not supported.</source>
          <target state="translated">Le numéro de version du paramètre <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> n'est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Vous devez substituer cette méthode dans une classe dérivée.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>Gets a hash code for the <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object that is suitable for use in hashing algorithms and data structures such as a hash table.</source>
          <target state="translated">Obtient un code de hachage pour l’objet <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> qui peut être utilisé dans des structures de données et des algorithmes de hachage, comme une table de hachage.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>A hash code for the current <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object.</source>
          <target state="translated">Code de hachage pour l’objet <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> objects.</source>
          <target state="translated">Code de hachage de deux instances de la même autorisation pouvant différer, par conséquent, un code de hachage ne doit pas être utilisé pour comparer deux <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>A permission to intersect with the current permission.</source>
          <target state="translated">Autorisation à croiser avec l’autorisation actuelle.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Elle doit être du même type que l’autorisation actuelle.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</source>
          <target state="translated">En cas d’implémentation par une classe dérivée, crée et retourne une autorisation qui constitue l’intersection entre l’autorisation actuelle et l’autorisation spécifiée.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>A new permission that represents the intersection of the current permission and the specified permission.</source>
          <target state="translated">Nouvelle autorisation qui représente l’intersection entre l’autorisation actuelle et l’autorisation spécifiée.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>This new permission is <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the intersection is empty.</source>
          <target state="translated">Cette nouvelle autorisation est <ph id="ph1">&lt;see langword="null" /&gt;</ph> si l'intersection est vide.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The intersection of two permissions is a permission that describes the set of operations they both describe in common.</source>
          <target state="translated">L’intersection de deux autorisations est une autorisation qui décrit l’ensemble des opérations qu’elles décrivent en commun.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>Only a demand that passes both original permissions will pass the intersection.</source>
          <target state="translated">Seule une demande qui passe les deux autorisations d’origine passera l’intersection.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Intersect%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une substitution de la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Intersect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not an instance of the same class as the current permission.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="target" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et n'est pas une instance de la même classe que l'autorisation en cours.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Vous devez substituer cette méthode dans une classe dérivée.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>A permission that is to be tested for the subset relationship.</source>
          <target state="translated">Autorisation qui doit être testée pour la relation de sous-ensemble.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This permission must be of the same type as the current permission.</source>
          <target state="translated">Cette autorisation doit être du même type que l’autorisation actuelle.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</source>
          <target state="translated">En cas d’implémentation par une classe dérivée, détermine si l’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current permission is a subset of the specified permission; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'autorisation en cours est un sous-ensemble de l'autorisation spécifiée ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</source>
          <target state="translated">L’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée si l’autorisation actuelle spécifie un ensemble d’opérations qui est entièrement contenu par l’autorisation spécifiée.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:<ph id="ph1">\\</ph>.</source>
          <target state="translated">Par exemple, une autorisation qui représente l’accès à C:\example.txt est un sous-ensemble d’une autorisation qui représente l’accès à C:<ph id="ph1">\\</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If this method returns <ph id="ph1">`true`</ph>, the current permission represents no more access to the protected resource than does the specified permission.</source>
          <target state="translated">Si cette méthode retourne <ph id="ph1">`true`</ph>, l’autorisation en cours ne représente pas plus d’accès à la ressource protégée que l’autorisation spécifiée.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following statements are required to be <ph id="ph1">`true`</ph> for all overrides of the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">Les instructions suivantes doivent être <ph id="ph1">`true`</ph> pour tous les remplacements de la <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>, <bpt id="p2">*</bpt>Y<ept id="p2">*</ept>, and <bpt id="p3">*</bpt>Z<ept id="p3">*</ept> represent custom code access permission objects that are not null references, <bpt id="p4">*</bpt>U<ept id="p4">*</ept> represents an unrestricted code access permission, and <bpt id="p5">*</bpt>N<ept id="p5">*</ept> represents an empty permission with a <ph id="ph1">&lt;xref:System.Security.Permissions.PermissionState&gt;</ph> of <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>, <bpt id="p2">*</bpt>Y<ept id="p2">*</ept>, et <bpt id="p3">*</bpt>Z<ept id="p3">*</ept> représentent des objets d’autorisation d’accès code personnalisé qui ne sont pas des références null, <bpt id="p4">*</bpt>U<ept id="p4">*</ept> représente une autorisation d’accès de code non restreint, et <bpt id="p5">*</bpt>N<ept id="p5">*</ept> représente une autorisation vide avec un <ph id="ph1">&lt;xref:System.Security.Permissions.PermissionState&gt;</ph> de <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) renvoie <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) returns the same value as <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>X<ept id="p4">*</ept>) if and only if <bpt id="p5">*</bpt>X<ept id="p5">*</ept> and <bpt id="p6">*</bpt>Y<ept id="p6">*</ept> represent the same set of permissions.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) retourne la même valeur que <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>X<ept id="p4">*</ept>) si et seulement si <bpt id="p5">*</bpt>X<ept id="p5">*</ept> et <bpt id="p6">*</bpt>Y<ept id="p6">*</ept> représentent le même jeu d’autorisations.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) and <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) both return <ph id="ph1">`true`</ph>, <bpt id="p5">*</bpt>X<ept id="p5">*</ept>.IsSubsetOf(<bpt id="p6">*</bpt>Z<ept id="p6">*</ept>) returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Si <bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) et <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) retournent tous deux <ph id="ph1">`true`</ph>, <bpt id="p5">*</bpt>X<ept id="p5">*</ept>. IsSubsetOf (<bpt id="p6">*</bpt>Z<ept id="p6">*</ept>) renvoie <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>U<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>U<ept id="p2">*</ept>) renvoie <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>N<ept id="p2">*</ept>) returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>N<ept id="p2">*</ept>) renvoie <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>N<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>N<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) renvoie <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>X<ept id="p1">*</ept> and <bpt id="p2">*</bpt>Y<ept id="p2">*</ept> represent custom code access permission objects that are null references, <bpt id="p3">*</bpt>X<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>Y<ept id="p4">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Si <bpt id="p1">*</bpt>X<ept id="p1">*</ept> et <bpt id="p2">*</bpt>Y<ept id="p2">*</ept> représentent des objets d’autorisation d’accès code personnalisé qui sont des références null, <bpt id="p3">*</bpt>X<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>Y<ept id="p4">*</ept>) renvoie <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>Z<ept id="p1">*</ept> is also null, the compound set operation <bpt id="p2">*</bpt>X<ept id="p2">*</ept>.Union(<bpt id="p3">*</bpt>Y<ept id="p3">*</ept>).IsSubsetOf(<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) also returns <ph id="ph1">`true`</ph> because the union of two null permissions is a null permission.</source>
          <target state="translated">Si <bpt id="p1">*</bpt>Z<ept id="p1">*</ept> est également null, l’opération ensembliste composée <bpt id="p2">*</bpt>X<ept id="p2">*</ept>. Union (<bpt id="p3">*</bpt>Y<ept id="p3">*</ept>). IsSubsetOf (<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) retourne également <ph id="ph1">`true`</ph> , car l’union de deux autorisations null constitue une autorisation null.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une substitution de la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not of the same type as the current permission.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="target" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et n'est pas du même type que l'autorisation en cours.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Vous devez substituer cette méthode dans une classe dérivée.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</source>
          <target state="translated">Empêche les appelants plus hauts dans la pile des appels d’utiliser le code qui appelle cette méthode pour accéder à toutes les ressources à l’exception de la ressource spécifiée par l’instance actuelle.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> méthode doit être utilisée uniquement pour protéger les ressources contre l’accès accidentel par du code de confiance totale.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">Ne doit pas être utilisé pour protéger les ressources à partir d’abusive par du code non fiable.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for a permission and then calls method <ph id="ph3">`B`</ph>, method <ph id="ph4">`B`</ph> can overtly override the <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> by issuing an <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Par exemple, si (méthode) <ph id="ph1">`A`</ph> problèmes un <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> pour une autorisation, puis appelle la méthode <ph id="ph3">`B`</ph>, méthode <ph id="ph4">`B`</ph> peut substituer ouvertement la <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> en émettant un <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">La méthode appelée est toujours plus haut dans la pile.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lower in the stack.</source>
          <target state="translated">Par conséquent, si méthode <ph id="ph1">`B`</ph> tente d’accéder à une ressource protégée, le système de sécurité commence à contrôler les autorisations, car méthode <ph id="ph2">`B`</ph> est l’appelant immédiat, puis parcourt la pile pour confirmer qu’il y a aucune <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> plus bas dans la pile.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> method.</source>
          <target state="translated">Méthode <ph id="ph1">`B`</ph>, qui tente d’accéder à la ressource, peut arrêter le parcours de pile immédiatement à l’aide de la <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>In that case, the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> placed on the stack by method <ph id="ph2">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> placée sur la pile par la méthode <ph id="ph2">`A`</ph> (la méthode appelante) n’est jamais découverte.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> est semblable à <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, dans la mesure où les deux font des parcours de pile échouent lorsqu’ils devraient normalement réussir.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The difference is that <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> specifies permissions that will cause the stack walk to fail, but <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">La différence est que <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> spécifie les autorisations qui provoqueront l’échec, le parcours de pile mais <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> spécifie les seules autorisations qui ne provoquent pas l’échec du parcours de pile.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">Appelez cette méthode pour vous assurer que votre code peut être utilisé pour accéder uniquement aux ressources spécifiées.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">L’appel à <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> est effective jusqu'à ce que le code appelant retourne à son appelant.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Seul <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> peut être actif sur un frame.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Toute tentative d’appel <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lorsque actif <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> existe sur les résultats du frame dans un <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">Appelez <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> pour supprimer un actif <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> est ignoré pour une autorisation refusée, car une demande concernant cette autorisation ne réussira pas.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>However, if code lower on the call stack later calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">Toutefois, si le code plus bas dans l’appel de pile ultérieurement les appels <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> pour cette autorisation, un <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> est levée lorsque le parcours de pile atteint le code qui a tenté d’appeler <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>This is because the code that called <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> has not been granted the permission, even though it called <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for that permission.</source>
          <target state="translated">C’est parce que le code qui a appelé <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> n’a pas reçu l’autorisation, même s’il a appelé <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> pour cette autorisation.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">La pile des appels est généralement représentée comme étant descendante, afin que le plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Il existe déjà un <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> actif pour l’image actuelle.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>You cannot override this method.</source>
          <target state="translated">Vous ne pouvez pas substituer cette méthode.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>Causes all previous overrides for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Entraîne la suppression définitive de toutes les substitutions antérieures pour le frame actuel.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>If there are no overrides (<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>) for the current frame, an <ph id="ph4">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">S’il n’y a aucuns substitutions (<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>) pour le frame actuel, un <ph id="ph4">&lt;xref:System.ExecutionEngineException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>, or <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Il n'existe aucun <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> ou <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> précédent pour le frame en cours.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Provoque la suppression et la désactivation du <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> précédent pour le frame en cours.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">S’il existe aucune <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> pour le frame actuel, un <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame.</source>
          <target state="translated">Il n'existe aucun <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> précédent pour le frame en cours.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Provoque la suppression et la désactivation du <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> précédent pour le frame en cours.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">S’il existe aucune <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> pour le frame actuel, un <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame.</source>
          <target state="translated">Il n'existe aucun <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> précédent pour le frame en cours.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Provoque la suppression et la désactivation du <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> précédent pour le frame en cours.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">S’il existe aucune <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> pour le frame actuel, un <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Il n'existe aucun <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> précédent pour le frame en cours.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>Creates and returns a string representation of the current permission object.</source>
          <target state="translated">Crée et retourne une chaîne représentant l’objet d’autorisation actuel.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>A string representation of the current permission object.</source>
          <target state="translated">Chaîne représentant l’objet d’autorisation actuel.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>This method is useful in debugging when you need to display the permission as a string.</source>
          <target state="translated">Cette méthode est utile dans le débogage lorsque vous avez besoin afficher l’autorisation sous forme de chaîne.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>When overridden in a derived class, creates an XML encoding of the security object and its current state.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, crée un encodage XML de l’objet de sécurité et de son état actuel.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>An XML encoding of the security object, including any state information.</source>
          <target state="translated">Encodage XML de l’objet de sécurité, y compris les informations d’état éventuelles.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>Custom code that extends security objects needs to implement the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> methods to make the objects security-encodable.</source>
          <target state="translated">Code personnalisé qui étend les objets de sécurité doit implémenter les <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> méthodes pour rendre les objets puissent être codés en sécurité.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une substitution de la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Vous devez substituer cette méthode dans une classe dérivée.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>A permission to combine with the current permission.</source>
          <target state="translated">Autorisation à combiner avec l’autorisation actuelle.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Elle doit être du même type que l’autorisation actuelle.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</source>
          <target state="translated">Lors de son remplacement dans une classe dérivée, crée une autorisation qui est l’union de l’autorisation actuelle et de l’autorisation spécifiée.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>A new permission that represents the union of the current permission and the specified permission.</source>
          <target state="translated">Nouvelle autorisation qui représente l’union de l’autorisation actuelle et de l’autorisation spécifiée.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The result of a call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> is a permission that represents all the operations represented by both the current permission and the specified permission.</source>
          <target state="translated">Le résultat d’un appel à <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> est une autorisation qui représente toutes les opérations représentées par l’autorisation actuelle et l’autorisation spécifiée.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>Any demand that passes either permission passes their union.</source>
          <target state="translated">Toute demande qui transmet une autorisation passe leur union.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une substitution de la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="other" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>This method is only supported at this level when passed <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cette méthode est uniquement prise en charge à ce niveau lorsqu'elle est passée <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Vous devez substituer cette méthode dans une classe dérivée.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>You should return a copy of the permission if the value of the <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Vous devez retourner une copie de l’autorisation si la valeur de la <ph id="ph1">&lt;paramref name="other" /&gt;</ph> paramètre est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>