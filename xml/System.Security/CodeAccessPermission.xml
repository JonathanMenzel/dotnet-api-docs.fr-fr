<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0db6f622c9c8c143d57875ed3c232bf5b1d39578" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52913372" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <TypeSignature Language="F#" Value="type CodeAccessPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Définit la structure sous-jacente de toutes les autorisations d’accès au code.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Autorisations d’accès de code utilisent un parcours de pile pour vous assurer que tous les appelants du code ont reçu une autorisation. Si un objet d’autorisation est `null`, il est géré comme un objet d’autorisation avec l’état <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.  
  
 La pile des appels est généralement représentée comme étant descendante, afin que plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.  
  
 Les héritiers de la <xref:System.Security.CodeAccessPermission> classe doit être de confiance totale pour fonctionner correctement en tant qu’extension de l’infrastructure de sécurité des autorisations. Pour déterminer que les héritiers sont entièrement fiables, <xref:System.Security.CodeAccessPermission> problèmes un <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> pour <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` et <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`.  
  
   
  
## Examples  
 L’exemple de code suivant montre une autorisation dérivée de la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la capacité des héritiers pour fournir la preuve, d’afficher et modifier la stratégie. Énumérations associées : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</permission>
    <block subset="none" type="overrides"><para>Lorsque vous héritez de <see cref="T:System.Security.CodeAccessPermission" />, vous devez également implémenter la <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.  
  
Ce qui suit <see cref="T:System.Security.CodeAccessPermission" /> membres doivent être substitués : <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, et <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.  
  
Vous devez également définir un constructeur qui accepte un <see cref="T:System.Security.Permissions.PermissionState" /> comme seul paramètre.  
  
Vous devez appliquer le <see cref="T:System.SerializableAttribute" /> attribut à une classe qui hérite de <see cref="T:System.Security.CodeAccessPermission" />.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.CodeAccessPermission" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé pour initialiser l’état dans le type chaque fois qu’une instance de la classe dérivée est créée. Bien que vous pouvez appeler explicitement ce constructeur dans la déclaration de constructeur du constructeur de classe dérivée, il est généralement pas nécessaire ; la plupart des compilateurs généreront automatiquement l’appel pour vous.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit&#xA;override this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déclare que le code appelant peut accéder à la ressource protégée par une demande d’autorisation via le code qui appelle cette méthode, même si les appelants situés plus haut dans la pile n’ont pas reçu l’autorisation d’accéder à la ressource. L’utilisation de <see cref="M:System.Security.CodeAccessPermission.Assert" /> peut créer des problèmes de sécurité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La pile des appels est généralement représentée comme étant descendante, afin que plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels. Appel <xref:System.Security.CodeAccessPermission.Assert%2A> empêche un parcours de pile provenant de réduire la pile des appels de procédure de la pile des appels au-delà du code qui appelle cette méthode. Par conséquent, même si les appelants plus hauts dans la pile des appels n’ont pas les autorisations requises pour accéder à une ressource, ils peuvent toujours y accéder via le code qui appelle cette méthode sur l’autorisation nécessaire. Une assertion est efficace uniquement si le code qui appelle <xref:System.Security.CodeAccessPermission.Assert%2A> passe la vérification de sécurité pour l’autorisation qu’il confirme.  
  
 L’appel à <xref:System.Security.CodeAccessPermission.Assert%2A> est effectif jusqu'à ce que le code appelant retourne à son appelant. Seul <xref:System.Security.CodeAccessPermission.Assert%2A> peut être actif sur un frame. Toute tentative d’appel <xref:System.Security.CodeAccessPermission.Assert%2A> quand un actif <xref:System.Security.CodeAccessPermission.Assert%2A> existe sur les résultats du frame dans une <xref:System.Security.SecurityException>. Appelez <xref:System.Security.CodeAccessPermission.RevertAssert%2A> ou <xref:System.Security.CodeAccessPermission.RevertAll%2A> pour supprimer un actif <xref:System.Security.CodeAccessPermission.Assert%2A>.  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A> est ignoré pour une autorisation refusée, car une demande pour cette autorisation ne réussira pas. Toutefois, si le code situé plus bas dans la pile des appels appelle <xref:System.Security.CodeAccessPermission.Demand%2A> pour cette autorisation, un <xref:System.Security.SecurityException> est levée lorsque le parcours de pile atteint le code qui a tenté d’appeler <xref:System.Security.CodeAccessPermission.Assert%2A>. Cela se produit car le code qui a appelé <xref:System.Security.CodeAccessPermission.Assert%2A> n’a pas reçu l’autorisation, même si elle a tenté un <xref:System.Security.CodeAccessPermission.Assert%2A> il.  
  
> [!CAUTION]
>  Étant donné que l’appel <xref:System.Security.CodeAccessPermission.Assert%2A> supprime l’exigence que tout le code dans la chaîne d’appel doit être autorisé à accéder à la ressource spécifiée, il peut ouvrir des problèmes de sécurité si l’utilisation incorrecte ou inappropriée. Par conséquent, il doit être utilisé avec précaution.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Le code appelant n’a pas <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.  
  
- ou - 
Il existe déjà un <see cref="M:System.Security.CodeAccessPermission.Assert" /> actif pour l’image actuelle.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la possibilité d’appeler <see cref="M:System.Security.CodeAccessPermission.Assert" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></permission>
        <block subset="none" type="overrides"><para>Vous ne pouvez pas substituer cette méthode.</para></block>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md">Utilisation de la méthode Assert</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="codeAccessPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas d’implémentation par une classe dérivée, crée et retourne une copie identique de l’objet d’autorisation actuel.</summary>
        <returns>Copie de l’objet d’autorisation actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie d’un objet d’autorisation représente le même accès aux ressources que l’objet d’autorisation d’origine.  
  
   
  
## Examples  
 L’exemple de code suivant illustre une substitution de la <xref:System.Security.CodeAccessPermission.Copy%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode dans une classe dérivée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Force un <see cref="T:System.Security.SecurityException" /> au moment de l’exécution si tous les appelants figurant plus haut dans la pile des appels ne disposent pas des autorisations spécifiées par l’instance actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est généralement utilisée par des bibliothèques sécurisées pour vous assurer que les appelants sont autorisés à accéder à une ressource. Par exemple, une classe de fichier dans une bibliothèque de classes sécurisée appelle <xref:System.Security.CodeAccessPermission.Demand%2A> pour nécessaires <xref:System.Security.Permissions.FileIOPermission> avant d’effectuer une opération de fichier demandée par l’appelant.  
  
 Les autorisations du code qui appelle cette méthode ne sont pas examinées ; la vérification commence à partir de l’appelant immédiat de ce code et remonte la pile. La pile des appels est généralement représentée comme étant descendante, afin que plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels. <xref:System.Security.CodeAccessPermission.Demand%2A> réussit uniquement si aucune <xref:System.Security.SecurityException> est déclenché.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant figurant plus haut dans la pile des appels ne dispose pas de l’autorisation spécifiée par l’instance actuelle.  
  
- ou - 
Un appelant figurant plus haut dans la pile des appels a appelé <see cref="M:System.Security.CodeAccessPermission.Deny" /> sur l’objet d’autorisation actuel.</exception>
        <block subset="none" type="overrides"><para>Vous ne pouvez pas substituer cette méthode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit&#xA;override this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empêche les appelants plus hauts dans la pile des appels d’utiliser le code qui appelle cette méthode pour accéder à la ressource spécifiée par l’instance actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le <xref:System.Security.CodeAccessPermission.Deny%2A> méthode doit être utilisée uniquement pour protéger les ressources contre tout accès accidentel par le code totalement approuvé. Il ne doit pas servir à protéger les ressources à partir d’abusive par du code non approuvé. Par exemple, si méthode `A` problèmes un <xref:System.Security.CodeAccessPermission.Deny%2A> pour une autorisation, puis appelle la méthode `B`, méthode `B` peut substituer ouvertement la <xref:System.Security.CodeAccessPermission.Deny%2A> en émettant un <xref:System.Security.CodeAccessPermission.Assert%2A>. La méthode appelée est toujours plus haut dans la pile. Par conséquent, si méthode `B` tente d’accéder à une ressource protégée, le système de sécurité commence la vérification des autorisations avec lui, car méthode `B` est l’appelant immédiat, puis parcourt la pile pour confirmer qu’il y a aucune <xref:System.Security.CodeAccessPermission.Deny%2A> ou <xref:System.Security.CodeAccessPermission.PermitOnly%2A> plus bas dans la pile. Méthode `B`, qui tente d’accéder à la ressource, peut arrêter le parcours de pile immédiatement à l’aide de la <xref:System.Security.CodeAccessPermission.Assert%2A> (méthode). Dans ce cas, le <xref:System.Security.CodeAccessPermission.Deny%2A> placée sur la pile par la méthode `A` (la méthode d’appel) n’est jamais découverts.  
  
 Cette méthode empêche les appelants plus hauts dans la pile des appels de l’accès à la ressource protégée via le code qui appelle cette méthode, même si les appelants ont reçu l’autorisation d’y accéder. La pile des appels est généralement représentée comme étant descendante, afin que plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.  
  
 <xref:System.Security.CodeAccessPermission.Deny%2A> peut limiter la responsabilité du programmeur ou empêcher les problèmes de sécurité accidentels, car elle contribue à empêcher la méthode qui appelle <xref:System.Security.CodeAccessPermission.Deny%2A> soit utilisé pour accéder à la ressource protégée par l’autorisation refusée. Si une méthode appelle <xref:System.Security.CodeAccessPermission.Deny%2A> sur une autorisation et si un <xref:System.Security.CodeAccessPermission.Demand%2A> pour cette autorisation est appelée par un appelant plus bas dans la pile des appels, cette vérification de sécurité échoue lorsqu’elle atteint le <xref:System.Security.CodeAccessPermission.Deny%2A>.  
  
 L’appel à <xref:System.Security.CodeAccessPermission.Deny%2A> est effectif jusqu'à ce que le code appelant retourne à son appelant. Seul <xref:System.Security.CodeAccessPermission.Deny%2A> peut être actif sur un frame. Toute tentative d’appel <xref:System.Security.CodeAccessPermission.Deny%2A> quand un actif <xref:System.Security.CodeAccessPermission.Deny%2A> existe sur les résultats du frame dans une <xref:System.Security.SecurityException>. Appelez <xref:System.Security.CodeAccessPermission.RevertDeny%2A> ou <xref:System.Security.CodeAccessPermission.RevertAll%2A> pour supprimer un actif <xref:System.Security.CodeAccessPermission.Deny%2A>. <xref:System.Security.CodeAccessPermission.Deny%2A> est ignoré pour une autorisation refusée, car une demande pour cette autorisation ne réussira pas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il existe déjà un <see cref="M:System.Security.CodeAccessPermission.Deny" /> actif pour l’image actuelle.</exception>
        <block subset="none" type="overrides"><para>Vous ne pouvez pas substituer cette méthode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="codeAccessPermission.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet <see cref="T:System.Security.CodeAccessPermission" /> à comparer au <see cref="T:System.Security.CodeAccessPermission" /> actuel.</param>
        <summary>Détermine si l’objet <see cref="T:System.Security.CodeAccessPermission" /> spécifié est égal au <see cref="T:System.Security.CodeAccessPermission" /> actuel.</summary>
        <returns><see langword="true" /> si l’objet <see cref="T:System.Security.CodeAccessPermission" /> spécifié est égal à l’élément <see cref="T:System.Security.CodeAccessPermission" /> actuel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, consultez <xref:System.Object.Equals%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit" Usage="codeAccessPermission.FromXml elem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">Encodage XML à utiliser pour reconstruire l’objet de sécurité.</param>
        <summary>En cas de remplacement dans une classe dérivée, reconstruit un objet de sécurité avec un état spécifié à partir d’un encodage XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Code personnalisé qui étend les objets de sécurité doit implémenter les <xref:System.Security.CodeAccessPermission.ToXml%2A> et <xref:System.Security.CodeAccessPermission.FromXml%2A> méthodes pour rendre les objets puissent être codés en sécurité.  
  
   
  
## Examples  
 L’exemple de code suivant illustre une substitution de la <xref:System.Security.CodeAccessPermission.FromXml%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="elem" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="elem" /> ne contient pas l’encodage XML pour une instance du même type que l’instance actuelle.  
  
- ou - 
Le numéro de version du paramètre <paramref name="elem" /> n’est pas pris en charge.</exception>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode dans une classe dérivée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="codeAccessPermission.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un code de hachage pour l’objet <see cref="T:System.Security.CodeAccessPermission" /> qui peut être utilisé dans des structures de données et des algorithmes de hachage, comme une table de hachage.</summary>
        <returns>Code de hachage pour l’objet <see cref="T:System.Security.CodeAccessPermission" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Code de hachage de deux instances de la même autorisation pouvant différer, par conséquent, un code de hachage ne doit pas être utilisé pour comparer deux <xref:System.Security.CodeAccessPermission> objets.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorisation à croiser avec l’autorisation actuelle. Elle doit être du même type que l’autorisation actuelle.</param>
        <summary>En cas d’implémentation par une classe dérivée, crée et retourne une autorisation qui constitue l’intersection entre l’autorisation actuelle et l’autorisation spécifiée.</summary>
        <returns>Nouvelle autorisation qui représente l’intersection entre l’autorisation actuelle et l’autorisation spécifiée. Cette nouvelle autorisation est <see langword="null" /> si l’intersection est vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’intersection de deux autorisations est une autorisation qui décrit l’ensemble des opérations qu’elles décrivent en commun. Seule une demande qui passe les deux autorisations d’origine transmettra l’intersection.  
  
   
  
## Examples  
 L’exemple de code suivant illustre une substitution de la <xref:System.Security.CodeAccessPermission.Intersect%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="target" /> n’a pas la valeur <see langword="null" /> et n’est pas une instance de la même classe que l’autorisation actuelle.</exception>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode dans une classe dérivée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="codeAccessPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorisation qui doit être testée pour la relation de sous-ensemble. Cette autorisation doit être du même type que l’autorisation actuelle.</param>
        <summary>En cas d’implémentation par une classe dérivée, détermine si l’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée.</summary>
        <returns><see langword="true" /> si l’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée si l’autorisation en cours spécifie un ensemble d’opérations qui est entièrement contenu par l’autorisation spécifiée. Par exemple, une autorisation qui représente l’accès à C:\example.txt est un sous-ensemble d’une autorisation qui représente l’accès à C:\\. Si cette méthode retourne `true`, l’autorisation en cours ne représente pas plus d’accès à la ressource protégée que l’autorisation spécifiée.  
  
 Les instructions suivantes sont requises pour être `true` pour tous les remplacements de la <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> (méthode). *X*, *Y*, et *Z* représentent des objets d’autorisation d’accès code personnalisé qui ne sont pas des références null, *U* représente une autorisation d’accès de code non restreint, et *N* représente une autorisation vide avec un <xref:System.Security.Permissions.PermissionState> de <xref:System.Security.Permissions.PermissionState.None>.  
  
-   *X*. IsSubsetOf (*X*) renvoie `true`.  
  
-   *X*. IsSubsetOf (*Y*) retourne la même valeur que *Y*. IsSubsetOf (*X*) si et seulement si *X* et *Y* représentent le même jeu d’autorisations.  
  
-   Si *X*. IsSubsetOf (*Y*) et *Y*. IsSubsetOf (*Z*) retournent `true`, *X*. IsSubsetOf (*Z*) renvoie `true`.  
  
-   *X*. IsSubsetOf (*U*) renvoie `true`.  
  
-   *X*. IsSubsetOf (*N*) renvoie `false`.  
  
-   *N*. IsSubsetOf (*X*) renvoie `true`.  
  
 Si *X* et *Y* représentent des objets d’autorisation d’accès code personnalisé qui sont des références null, *X*. IsSubsetOf (*Y*) renvoie `true`. Si *Z* est également null, l’opération ensembliste composée *X*. Union (*Y*). IsSubsetOf (*Z*) retourne également `true` , car l’union de deux autorisations null constitue une autorisation null.  
  
   
  
## Examples  
 L’exemple de code suivant illustre une substitution de la <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="target" /> n’est pas <see langword="null" /> et n’est pas du même type que l’autorisation actuelle.</exception>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode dans une classe dérivée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit&#xA;override this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empêche les appelants plus hauts dans la pile des appels d’utiliser le code qui appelle cette méthode pour accéder à toutes les ressources à l’exception de la ressource spécifiée par l’instance actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le <xref:System.Security.CodeAccessPermission.PermitOnly%2A> méthode doit être utilisée uniquement pour protéger les ressources contre tout accès accidentel par le code totalement approuvé. Il ne doit pas servir à protéger les ressources à partir d’abusive par du code non approuvé. Par exemple, si méthode `A` problèmes un <xref:System.Security.CodeAccessPermission.PermitOnly%2A> pour une autorisation, puis appelle la méthode `B`, méthode `B` peut substituer ouvertement la <xref:System.Security.CodeAccessPermission.PermitOnly%2A> en émettant un <xref:System.Security.CodeAccessPermission.Assert%2A>. La méthode appelée est toujours plus haut dans la pile. Par conséquent, si méthode `B` tente d’accéder à une ressource protégée, le système de sécurité commence la vérification des autorisations avec lui, car méthode `B` est l’appelant immédiat, puis parcourt la pile pour confirmer qu’il y a aucune <xref:System.Security.CodeAccessPermission.Deny%2A> ou <xref:System.Security.CodeAccessPermission.PermitOnly%2A> plus bas dans la pile. Méthode `B`, qui tente d’accéder à la ressource, peut arrêter le parcours de pile immédiatement à l’aide de la <xref:System.Security.CodeAccessPermission.Assert%2A> (méthode). Dans ce cas, le <xref:System.Security.CodeAccessPermission.PermitOnly%2A> placée sur la pile par la méthode `A` (la méthode d’appel) n’est jamais découverts.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> est similaire à <xref:System.Security.CodeAccessPermission.Deny%2A>, car les deux font échouent lorsqu’ils réussirait autrement des parcours de pile. La différence est que <xref:System.Security.CodeAccessPermission.Deny%2A> spécifie les autorisations que le parcours de pile à échouer, mais <xref:System.Security.CodeAccessPermission.PermitOnly%2A> spécifie les seules autorisations qui ne provoquent pas l’échec du parcours de pile.  
  
 Appelez cette méthode pour vous assurer que votre code peut être utilisé pour accéder uniquement aux ressources spécifiées. L’appel à <xref:System.Security.CodeAccessPermission.PermitOnly%2A> est effectif jusqu'à ce que le code appelant retourne à son appelant. Seul <xref:System.Security.CodeAccessPermission.PermitOnly%2A> peut être actif sur un frame. Toute tentative d’appel <xref:System.Security.CodeAccessPermission.PermitOnly%2A> quand un actif <xref:System.Security.CodeAccessPermission.PermitOnly%2A> existe sur les résultats du frame dans une <xref:System.Security.SecurityException>. Appelez <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> ou <xref:System.Security.CodeAccessPermission.RevertAll%2A> pour supprimer un actif <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> est ignoré pour une autorisation refusée, car une demande pour cette autorisation ne réussira pas. Toutefois, si le code plus bas dans l’appel de la pile ultérieurement appels <xref:System.Security.CodeAccessPermission.Demand%2A> pour cette autorisation, un <xref:System.Security.SecurityException> est levée lorsque le parcours de pile atteint le code qui a tenté d’appeler <xref:System.Security.CodeAccessPermission.PermitOnly%2A>. Il s’agit, car le code qui a appelé <xref:System.Security.CodeAccessPermission.PermitOnly%2A> n’a pas reçu l’autorisation, même s’il a appelé <xref:System.Security.CodeAccessPermission.PermitOnly%2A> pour cette autorisation. La pile des appels est généralement représentée comme étant descendante, afin que plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il existe déjà un <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> actif pour l’image actuelle.</exception>
        <block subset="none" type="overrides"><para>Vous ne pouvez pas substituer cette méthode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberSignature Language="F#" Value="static member RevertAll : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entraîne la suppression définitive de toutes les substitutions antérieures pour le frame actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il y a aucune substitution (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, ou <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) pour le frame actuel, un <xref:System.ExecutionEngineException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il n’existe pas d’<see cref="M:System.Security.CodeAccessPermission.Assert" />, de <see cref="M:System.Security.CodeAccessPermission.Deny" /> ou de <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> antérieur pour le frame actuel.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberSignature Language="F#" Value="static member RevertAssert : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAssert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entraîne la suppression définitive de tout <see cref="M:System.Security.CodeAccessPermission.Assert" /> antérieur pour le frame actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe aucune <xref:System.Security.CodeAccessPermission.Assert%2A> pour le frame actuel, un <xref:System.ExecutionEngineException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucun <see cref="M:System.Security.CodeAccessPermission.Assert" /> antérieur pour le frame actuel.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberSignature Language="F#" Value="static member RevertDeny : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertDeny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entraîne la suppression définitive de tout <see cref="M:System.Security.CodeAccessPermission.Deny" /> antérieur pour le frame actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe aucune <xref:System.Security.CodeAccessPermission.Deny%2A> pour le frame actuel, un <xref:System.ExecutionEngineException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucun <see cref="M:System.Security.CodeAccessPermission.Deny" /> antérieur pour le frame actuel.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberSignature Language="F#" Value="static member RevertPermitOnly : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertPermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entraîne la suppression définitive de tout <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> antérieur pour le frame actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe aucune <xref:System.Security.CodeAccessPermission.PermitOnly%2A> pour le frame actuel, un <xref:System.ExecutionEngineException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucun <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> antérieur pour le frame actuel.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="codeAccessPermission.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée et retourne une chaîne représentant l’objet d’autorisation actuel.</summary>
        <returns>Chaîne représentant l’objet d’autorisation actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utile pour déboguer lorsque vous avez besoin afficher l’autorisation en tant que chaîne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement" Usage="codeAccessPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un encodage XML de l’objet de sécurité et de son état actuel.</summary>
        <returns>Encodage XML de l’objet de sécurité, y compris les informations d’état éventuelles.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Code personnalisé qui étend les objets de sécurité doit implémenter les <xref:System.Security.CodeAccessPermission.ToXml%2A> et <xref:System.Security.CodeAccessPermission.FromXml%2A> méthodes pour rendre les objets puissent être codés en sécurité.  
  
   
  
## Examples  
 L’exemple de code suivant illustre une substitution de la <xref:System.Security.CodeAccessPermission.ToXml%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode dans une classe dérivée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Union other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">Autorisation à combiner avec l’autorisation actuelle. Elle doit être du même type que l’autorisation actuelle.</param>
        <summary>Lors de son remplacement dans une classe dérivée, crée une autorisation qui est l’union de l’autorisation actuelle et de l’autorisation spécifiée.</summary>
        <returns>Nouvelle autorisation qui représente l’union de l’autorisation actuelle et de l’autorisation spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat d’un appel à <xref:System.Security.CodeAccessPermission.Union%2A> est une autorisation qui représente toutes les opérations représentées par l’autorisation actuelle et l’autorisation spécifiée. Toutes les demandes qui transmet une autorisation passent leur union.  
  
   
  
## Examples  
 L’exemple de code suivant illustre une substitution de la <xref:System.Security.CodeAccessPermission.Union%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le paramètre <paramref name="other" /> n’est pas <see langword="null" />. Cette méthode est uniquement prise en charge à ce niveau quand <see langword="null" /> lui est passé.</exception>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode dans une classe dérivée. Vous devez retourner une copie de l’autorisation si la valeur de la <paramref name="other" /> paramètre est <see langword="null" />.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>