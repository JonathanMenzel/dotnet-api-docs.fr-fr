<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b37ff083eff27618aa07c0a744562f3f8a613708" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30499163" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gère le parcours de pile qui détermine si tous les appelants dans la pile des appels ont les autorisations nécessaires pour accéder à une ressource protégée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Code partiellement fiable présente toujours un risque de sécurité. Il peut parfois être manipulé pour effectuer des actions au nom d’un code malveillant qui n’est pas autorisé à accéder à une ressource. De cette façon, le code nuisible peut atteindre des accès de sécurité plus élevé qu’il doit être autorisé.  
  
 Le common language runtime permet de protéger le code managé à partir de ces attaques en exécutant un parcours de pile sur tous les appels. Le parcours de pile requiert que tout le code dans la pile des appels a l’autorisation d’accéder à une ressource protégée. Étant donné que le code de l’attaque sera toujours quelque part dans la pile des appels, il sera pas aller au-delà de ses propres autorisations de sécurité.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déclare que le code appelant peut accéder à la ressource identifiée par l’objet d’autorisation actuel, même si les appelants situés plus haut dans la pile n’ont pas reçu l’autorisation d’accéder à la ressource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Security.IStackWalk.Assert%2A> arrête le contrôle d’autorisation des appelants plus hauts dans la pile des appels. Par conséquent, même si ces appelants n’ont pas les autorisations requises, ils peuvent toujours accéder aux ressources. Une assertion n’est efficace uniquement si le code qui appelle <xref:System.Security.IStackWalk.Assert%2A> passe la vérification de sécurité pour l’autorisation qu’il confirme.  
  
 Un appel à <xref:System.Security.IStackWalk.Assert%2A> est effective jusqu'à ce que le code appelant retourne à son appelant ou jusqu'à ce que d’un appel ultérieur à <xref:System.Security.IStackWalk.Assert%2A> rende l’assertion précédente inefficace. En outre, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> ou <xref:System.Security.CodeAccessPermission.RevertAll%2A> supprime une attente <xref:System.Security.IStackWalk.Assert%2A>.  
  
 <xref:System.Security.IStackWalk.Assert%2A> est ignoré pour une autorisation refusée, car une demande concernant cette autorisation ne réussira pas. Toutefois, si le code situé plus bas dans la pile des appels appelle <xref:System.Security.IStackWalk.Demand%2A> pour cette autorisation, un <xref:System.Security.SecurityException> est levée lorsque le parcours de pile atteint le code qui a tenté d’appeler <xref:System.Security.IStackWalk.Assert%2A>. Cela se produit car le code qui a appelé <xref:System.Security.IStackWalk.Assert%2A> n’a pas reçu l’autorisation, même s’il a tenté de <xref:System.Security.IStackWalk.Assert%2A> il.  
  
> [!CAUTION]
>  Étant donné que l’appel <xref:System.Security.IStackWalk.Assert%2A> supprime l’exigence que tout le code dans la chaîne d’appel doit être autorisé à accéder à la ressource spécifiée, il peut ouvrir des failles de sécurité si l’utilisation incorrecte ou inappropriée. Par conséquent, elle doit être utilisée avec précaution.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Le code appelant n’a pas <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine au moment de l’exécution si tous les appelants dans la pile des appels ont reçu l’autorisation spécifiée par l’objet d’autorisation actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est généralement utilisée par des bibliothèques sécurisées pour garantir que les appelants ont l’autorisation d’accéder à une ressource. Par exemple, une classe de fichier dans une bibliothèque de classes sécurisée appelle <xref:System.Security.IStackWalk.Demand%2A> pour nécessaires <xref:System.Security.Permissions.FileIOPermission> avant d’effectuer une opération de fichier demandée par l’appelant.  
  
 Les autorisations du code qui appelle cette méthode ne sont pas examinées ; la vérification commence à partir de l’appelant immédiat de ce code et se déroule la pile. <xref:System.Security.IStackWalk.Demand%2A> réussit uniquement si aucune <xref:System.Security.SecurityException> est déclenché.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation spécifiée par l’objet d’autorisation actuel.  
  
 - ou -  
  
 Un appelant dans la pile des appels a appelé <see cref="M:System.Security.IStackWalk.Deny" /> sur l’objet d’autorisation actuel.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoque l’échec de chaque <see cref="M:System.Security.IStackWalk.Demand" /> pour l’objet actuel qui passe par le code appelant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode empêche les appelants situés plus haut dans la pile des appels d’accéder à la ressource protégée via le code qui appelle cette méthode, même si les appelants ont reçu l’autorisation d’y accéder. La pile des appels est généralement représentée comme étant descendante, afin que le plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.  
  
 <xref:System.Security.IStackWalk.Deny%2A> peut limiter la responsabilité du programmeur ou éviter de failles de sécurité accidentelle, car elle contribue à empêcher la méthode qui appelle <xref:System.Security.IStackWalk.Deny%2A> d’être utilisé pour accéder à la ressource protégée par l’autorisation refusée. Si une méthode appelle <xref:System.Security.IStackWalk.Deny%2A> sur une autorisation et si un <xref:System.Security.IStackWalk.Demand%2A> pour cette autorisation est appelée par un appelant plus bas dans la pile des appels, cette vérification de sécurité échoue lorsqu’elle atteint la <xref:System.Security.IStackWalk.Deny%2A>.  
  
 <xref:System.Security.IStackWalk.Deny%2A> est ignoré pour une autorisation refusée, car une demande concernant cette autorisation ne réussira pas.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous ne pouvez pas substituer cette méthode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entraîne l'échec de chaque <see cref="M:System.Security.IStackWalk.Demand" /> pour tous les objets excepté celui en cours qui passe par le code appelant, même si des autorisations d'accès à d'autres ressources ont été attribuées au code qui plus haut dans la pile des appels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A> est semblable à <xref:System.Security.IStackWalk.Deny%2A>, dans la mesure où les deux font des parcours de pile échouent lorsqu’ils devraient normalement réussir. La différence est que <xref:System.Security.IStackWalk.Deny%2A> spécifie les autorisations qui provoqueront l’échec, le parcours de pile mais <xref:System.Security.IStackWalk.PermitOnly%2A> spécifie les seules autorisations qui ne provoquent pas l’échec du parcours de pile. Appelez cette méthode pour vous assurer que votre code peut être utilisé pour accéder uniquement aux ressources spécifiées.  
  
 <xref:System.Security.IStackWalk.PermitOnly%2A> est ignoré pour une autorisation refusée, car une demande concernant cette autorisation ne réussira pas. Toutefois, si le code plus bas dans l’appel de pile ultérieurement les appels <xref:System.Security.IStackWalk.Demand%2A> pour cette autorisation, un <xref:System.Security.SecurityException> est levée lorsque le parcours de pile atteint le code qui a tenté d’appeler <xref:System.Security.IStackWalk.PermitOnly%2A>. C’est parce que le code qui a appelé <xref:System.Security.IStackWalk.PermitOnly%2A> n’a pas reçu l’autorisation, même s’il a appelé <xref:System.Security.IStackWalk.PermitOnly%2A> pour cette autorisation. La pile des appels est généralement représentée comme étant descendante, afin que le plus haut dans la pile des appels de méthodes appelle des méthodes inférieur dans la pile des appels.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>