<Type Name="SecureString" FullName="System.Security.SecureString">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a1b83b7cb358be3a46e68daac29ed99f5f5e062e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36527813" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SecureString : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed SecureString extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecureString" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SecureString&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecureString sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type SecureString = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Security.SecureString</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente le texte qui doit rester confidentiel, par exemple en le supprimant de la mémoire de l'ordinateur quand il n'est plus nécessaire. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecureString> est un type de chaîne qui fournit une mesure de sécurité. Il tente d’éviter de stocker des chaînes potentiellement sensibles dans la mémoire de processus en tant que texte brut.  (Pour connaître les limitations, toutefois, consultez la [est-il sécurisé SecureString ?](#HowSecure) section.) La valeur d’une instance de <xref:System.Security.SecureString> est alors automatiquement protégé à l’aide d’un mécanisme de prise en charge par la plateforme sous-jacente lorsque l’instance est initialisée ou lorsque la valeur est modifiée. Votre application peut rendre l’instance immuable et empêcher toute autre modification en appelant le <xref:System.Security.SecureString.MakeReadOnly%2A> (méthode).  
  
 La longueur maximale d’un <xref:System.Security.SecureString> instance est 65 536 caractères.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser une instance du type, vous devez la supprimer directement ou indirectement. Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.  
  
 La <xref:System.Security.SecureString> classe et ses membres ne sont pas visibles par COM. Pour plus d'informations, consultez <xref:System.Runtime.InteropServices.ComVisibleAttribute>.  
  
 Dans cette section :  
  
 [Chaîne de Visual Studio. SecureString](#vsString)   
 [Opérations de SecureString](#Ops)   
 [SecureString et l’interopérabilité](#interop)   
 [SecureString d’est-il sécurisé ?](#HowSecure)  
  
<a name="vsString"></a>   
## <a name="string-versus-securestring"></a>Chaîne par rapport à SecureString  
 Une instance de la <xref:System.String?displayProperty=nameWithType> classe est immuable et, lorsque vous n’est plus nécessaire, ne peut pas être planifiée par programme pour le garbage collection ; autrement dit, l’instance est en lecture seule après sa création, et il n’est pas possible de prédire quand l’instance supprimé de la mémoire de l’ordinateur. Étant donné que <xref:System.String?displayProperty=nameWithType> les instances sont immuables, les opérations qui semblent modifier une instance existante créent en fait une copie pour manipuler. Par conséquent, si un <xref:System.String> objet contient des informations sensibles telles qu’un mot de passe, numéro de carte de crédit ou les données personnelles, il existe un risque qu’elles soient révélées après leur utilisation car votre application ne peut pas supprimer les données de la mémoire de l’ordinateur .  
  
 A <xref:System.Security.SecureString> objet est semblable à un <xref:System.String> de l’objet car il a une valeur de texte. Toutefois, la valeur d’un <xref:System.Security.SecureString> de l’objet est épinglé en mémoire, peut utiliser un mécanisme de protection, telles que le chiffrement, fourni par le système d’exploitation sous-jacent, qui peut être modifié jusqu'à ce que votre application la marque comme étant en lecture seule et peut être supprimé de la mémoire de l’ordinateur soit par votre application appelant le <xref:System.Security.SecureString.Dispose%2A> méthode ou par le garbage collector .NET Framework.  
  
 Pour en savoir plus sur les limitations de la <xref:System.Security.SecureString> de classe, consultez la [est-il sécurisé SecureString ?](#HowSecure) section.  
  
 [Retour au début](#top)  
  
<a name="Ops"></a>   
## <a name="securestring-operations"></a>Opérations de SecureString  
 La <xref:System.Security.SecureString> classe contient des membres qui vous permettent d’effectuer les opérations suivantes :  
  
 Instancier une <xref:System.Security.SecureString> objet  
 Vous instanciez un <xref:System.Security.SecureString> objet en appelant son constructeur sans paramètre.  
  
 Ajouter des caractères à un <xref:System.Security.SecureString> objet  
 Vous pouvez ajouter un seul caractère à la fois à un <xref:System.Security.SecureString> objet en appelant son <xref:System.Security.SecureString.AppendChar%2A> ou <xref:System.Security.SecureString.InsertAt%2A> (méthode).  
  
> [!IMPORTANT]
>  A <xref:System.Security.SecureString> objet ne doit jamais être construit à partir d’un <xref:System.String>, car les données sensibles seront déjà soumise aux conséquences de persistance de mémoire de la liste immuable <xref:System.String> classe. La meilleure façon de construire un <xref:System.Security.SecureString> objet porte d’une source de non managée de caractère à temps, telles que le <xref:System.Console.ReadKey%2A?displayProperty=nameWithType> (méthode).  
  
 Supprimez les caractères d’un <xref:System.Security.SecureString> objet  
 Vous pouvez remplacer un caractère individuel en appelant le <xref:System.Security.SecureString.SetAt%2A> (méthode), supprimer un caractère individuel en appelant le <xref:System.Security.SecureString.RemoveAt%2A> (méthode), ou supprimez tous les caractères à partir de la <xref:System.Security.SecureString> instance en appelant le <xref:System.Security.SecureString.Clear%2A> (méthode).  
  
 Rendre le <xref:System.Security.SecureString> objet en lecture seule  
 Une fois que vous avez défini la chaîne qui le <xref:System.Security.SecureString> objet représente, vous appelez ses <xref:System.Security.SecureString.MakeReadOnly%2A> méthode afin que la chaîne en lecture seule.  
  
 Obtenir des informations sur la <xref:System.Security.SecureString> objet  
 Le <xref:System.Security.SecureString> classe possède uniquement deux membres qui fournissent des informations sur la chaîne : son <xref:System.Security.SecureString.Length%2A> qui indique le nombre d’unités de code encodée en UTF16 dans la chaîne ; et le <xref:System.Security.SecureString.IsReadOnly%2A>, méthode, ce qui indique si l’instance est en lecture seule.  
  
 Libérer la mémoire allouée à la <xref:System.Security.SecureString> instance  
 Étant donné que <xref:System.Security.SecureString> implémente la <xref:System.IDisposable> interface, vous libérer sa mémoire en appelant le <xref:System.Security.SecureString.Dispose%2A> (méthode).  
  
 Le <xref:System.Security.SecureString> classe ne possède aucun membre qui inspecte, compare ou convertit la valeur d’un <xref:System.Security.SecureString>. L’absence de ces membres permet de protéger la valeur de l’instance d’une exposition accidentelle ou malveillante. Utilisez les membres appropriés de le <xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType> class, telle que la <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> (méthode), pour manipuler la valeur d’un <xref:System.Security.SecureString> objet.  
  
 La bibliothèque de classes .NET Framework utilise couramment <xref:System.Security.SecureString> instances comme suit :  
  
-   Pour fournir des informations de mot de passe à un processus à l’aide de la <xref:System.Diagnostics.ProcessStartInfo> de la structure ou en appelant une surcharge de la <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> méthode qui a un paramètre de type <xref:System.Security.SecureString>.  
  
-   Pour fournir des informations de mot de passe réseau en appelant un <xref:System.Net.NetworkCredential> constructeur de classe qui a un paramètre de type <xref:System.Security.SecureString> ou à l’aide de la <xref:System.Net.NetworkCredential.SecurePassword%2A?displayProperty=nameWithType> propriété.  
  
-   Pour fournir des informations de mot de passe pour l’authentification SQL Server en appelant le <xref:System.Data.SqlClient.SqlCredential.%23ctor%2A?displayProperty=nameWithType> constructeur ou la récupération de la valeur de la <xref:System.Data.SqlClient.SqlCredential.Password%2A?displayProperty=nameWithType> propriété.  
  
-   Pour passer une chaîne en code non managé. Pour plus d’informations, consultez la [SecureString et interopérabilité](#interop) section.  
  
 [Retour au début](#top)  
  
<a name="interop"></a>   
## <a name="securestring-and-interop"></a>SecureString et l’interopérabilité  
 Étant donné que le système d’exploitation ne prend pas en charge directement <xref:System.Security.SecureString>, vous devez convertir la valeur de la <xref:System.Security.SecureString> objet vers le type de chaîne requis avant de passer la chaîne à une méthode native.  La <xref:System.Runtime.InteropServices.Marshal> classe a cinq méthodes que cela :  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=nameWithType>, qui convertit le <xref:System.Security.SecureString> valeur de chaîne à une chaîne binaire (BSTR) reconnue par COM.  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=nameWithType>, qui copie le <xref:System.Security.SecureString> valeur de chaîne à une chaîne ANSI dans la mémoire non managée.  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>, qui copie le <xref:System.Security.SecureString> valeur de chaîne à une chaîne Unicode dans la mémoire non managée.  
  
 Chacune de ces méthodes crée une chaîne de texte en clair dans la mémoire non managée. Il incombe au développeur de zéro et libérer cette mémoire dès qu’il n’est plus nécessaire. Chacune des méthodes d’allocation mémoire et de conversion de chaîne a une méthode correspondante à zéro et libérer la mémoire allouée :  
  
|Méthode d’allocation et de conversion|Zéro et free (méthode)|  
|--------------------------------------|--------------------------|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A?displayProperty=nameWithType>|  
  
 [Retour au début](#top)  
  
<a name="HowSecure"></a>   
## <a name="how-secure-is-securestring"></a>SecureString d’est-il sécurisé ?  
 Lors de la création correctement, un <xref:System.Security.SecureString> instance fournit plus de protection de données qu’un <xref:System.String>. Lors de la création d’une chaîne à partir d’une source de caractère à temps <xref:System.String> crée plusieurs intermédiaires dans la mémoire, tandis que <xref:System.Security.SecureString> crée une seule instance.  Le garbage collection de <xref:System.String> objets est non déterministe. En outre, étant donné que sa mémoire n’est pas épinglée, le garbage collector effectuer des copies supplémentaires de <xref:System.String> valeurs lors du déplacement et le compactage de mémoire. En revanche, la mémoire allouée à un <xref:System.Security.SecureString> objet est épinglé, et que la mémoire peut être libérée en appelant le <xref:System.Security.SecureString.Dispose%2A> (méthode).  
  
 Bien que les données stockées dans un <xref:System.Security.SecureString> instance est plus sécurisée que les données stockées dans un <xref:System.String> d’une instance, il existe des limitations importantes sur la sécurisation un <xref:System.Security.SecureString> est de l’instance. Elles incluent notamment :  
  
 Plateforme  
 Sur le système d’exploitation Windows, le contenu d’un <xref:System.Security.SecureString> tableau de caractères interne de l’instance sont chiffrés. Toutefois, si car il manque des API ou des problèmes de gestion de clés, le chiffrement n’est pas disponible sur toutes les plateformes. En raison de cette dépendance de plateforme, <xref:System.Security.SecureString> ne chiffre pas le stockage interne sur la plateforme non Windows. Autres techniques permettent de fournir une protection supplémentaire sur ces plateformes.
  
 Duration  
 Même si le <xref:System.Security.SecureString> implémentation est en mesure de tirer parti de chiffrement, le texte brut est attribué à la <xref:System.Security.SecureString> instance peut-être être exposée à des moments différents :  
  
-   Étant donné que Windows n’offre pas une implémentation de la chaîne sécurisée au niveau du système d’exploitation, le .NET Framework a toujours convertir la valeur de chaîne sécurisée en sa représentation sous forme de texte brut pour pouvoir le pour utiliser.  
  
-   Chaque fois que la valeur de la chaîne sécurisée est modifiée par les méthodes telles que <xref:System.Security.SecureString.AppendChar%2A> ou <xref:System.Security.SecureString.RemoveAt%2A>, il doit être déchiffré (c'est-à-dire converti précédent en texte brut), modifié, puis chiffrées à nouveau.  
  
-   Si la chaîne sécurisée est utilisée dans un appel d’interopérabilité, il doit être converti pour une chaîne ANSI, une chaîne Unicode ou une chaîne binaire (BSTR). Pour plus d’informations, consultez la [SecureString et interopérabilité](#interop) section.  
  
 L’intervalle de temps pour lequel le <xref:System.Security.SecureString> valeur de l’instance est exposée est simplement réduit par rapport à la <xref:System.String> classe.  
  
 Stockage et d’utilisation  
 En règle générale, la <xref:System.Security.SecureString> classe définit un mécanisme de stockage pour les valeurs de chaîne qui doit être protégé ou rester confidentiel. Toutefois, en dehors de .NET Framework lui-même, pas de mécanisme d’utilisation prend en charge <xref:System.Security.SecureString>. Cela signifie que la chaîne sécurisée doit être convertie en un format exploitable (généralement un formulaire de texte en clair) qui peut être reconnu par sa cible, et que le déchiffrement et conversion doivent se trouver dans l’espace de l’utilisateur.  
  
 Globale, <xref:System.Security.SecureString> est plus sûre que <xref:System.String> car elle limite l’exposition des données de chaîne qui tient compte. Toutefois, ces chaînes peuvent toujours être exposées à n’importe quel processus ou une opération qui a accès à la mémoire brute, par exemple un processus malveillant en cours d’exécution sur l’ordinateur hôte, un vidage de processus ou un fichier d’échange visible à l’utilisateur. Au lieu d’utiliser <xref:System.Security.SecureString> pour protéger les mots de passe, l’alternative recommandée consiste à utiliser un handle opaque aux informations d’identification sont stockées en dehors du processus.  
  
 [Retour au début](#top)  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Security.SecureString> pour sécuriser un mot de passe utilisateur à utiliser comme informations d’identification pour démarrer un nouveau processus.  
  
 [!code-csharp[System.Security.SecureString.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/ctor4.cs#4)]
 [!code-vb[System.Security.SecureString.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/ctor4.vb#4)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
    <altmember cref="T:System.Runtime.InteropServices.Marshal" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
    <altmember cref="T:System.IDisposable" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.SecureString" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SecureString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SecureString();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.SecureString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise la valeur par défaut (ou sans paramètre) pour instancier un nouvel constructeur <xref:System.Security.SecureString> objet. Il appelle ensuite la <xref:System.Security.SecureString.AppendChar%2A> méthode pour lui ajouter un tableau de caractères.  
  
 [!code-cpp[System.Security.SecureString.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cpp/Ctor2.cpp#2)]
 [!code-csharp[System.Security.SecureString.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/Ctor2.cs#2)]
 [!code-vb[System.Security.SecureString.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/ctor2.vb#2)]  
  
 L’exemple suivant crée un <xref:System.Security.SecureString> objet à partir de la valeur d’un <xref:System.String> objet.  
  
 [!code-cpp[System.Security.SecureString.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cpp/Ctor3.cpp#3)]
 [!code-csharp[System.Security.SecureString.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/Ctor3.cs#3)]
 [!code-vb[System.Security.SecureString.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/Ctor3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite au moment de la protection ou de l’annulation de la protection de la valeur de cette instance.</exception>
        <exception cref="T:System.NotSupportedException">Cette opération n’est pas prise en charge sur cette plateforme.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SecureString (char* value, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.#ctor(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SecureString(char* value, int length);" />
      <MemberSignature Language="F#" Value="new System.Security.SecureString : nativeptr&lt;char&gt; * int -&gt; System.Security.SecureString" Usage="new System.Security.SecureString (value, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau d'objets <see cref="T:System.Char" />.</param>
        <param name="length">Nombre d’éléments de <c>value</c> à inclure dans la nouvelle instance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.SecureString" /> à partir d'un sous-tableau d'objets <see cref="T:System.Char" />.  Ce constructeur n’est pas conforme CLS. L’alternative conforme CLS est <see cref="M:System.Security.SecureString.#ctor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise la nouvelle <xref:System.Security.SecureString> objet pour le nombre de caractères dans `value` spécifié par `length`; la valeur de l’instance est ensuite chiffrée.  
  
 En c#, ce constructeur est défini uniquement dans le contexte de code unsafe.  
  
   
  
## Examples  
 L’exemple suivant instancie une nouvelle <xref:System.Security.SecureString> en passant à son constructeur un pointeur vers un tableau de caractères.  
  
 [!code-cpp[System.Security.SecureString.Ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.security.securestring.ctor2/cpp/ctor1.cpp#1)]
 [!code-csharp[System.Security.SecureString.Ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.securestring.ctor2/cs/ctor1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> est inférieur à 0 ou supérieur à 65 536.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de la protection ou de l’annulation de la protection de la valeur de cette chaîne sécurisée.</exception>
        <exception cref="T:System.NotSupportedException">Cette opération n’est pas prise en charge sur cette plateforme.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendChar">
      <MemberSignature Language="C#" Value="public void AppendChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.AppendChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendChar (c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendChar(char c);" />
      <MemberSignature Language="F#" Value="member this.AppendChar : char -&gt; unit" Usage="secureString.AppendChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Caractère à ajouter à cette chaîne sécurisée.</param>
        <summary>Ajoute un caractère à la fin de la chaîne sécurisée actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’implémentation utilise un mécanisme de protection, telles que le chiffrement, la valeur de cette chaîne sécurisée, le cas échéant, est non protégée ; `c` est ajouté ; la nouvelle valeur de la chaîne sécurisée est de nouveau protégée.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, et <xref:System.Security.SecureString.Clear%2A> méthodes affectent la valeur d’un <xref:System.Security.SecureString> objet.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 L’exemple suivant montre comment la <xref:System.Security.SecureString.AppendChar%2A> et <xref:System.Security.SecureString.RemoveAt%2A> méthodes peuvent être utilisées pour rassembler les caractères dans un mot de passe.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Cette chaîne sécurisée est en lecture seule.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’exécution de cette opération rendrait la longueur de cette chaîne sécurisée supérieure à 65 536 caractères.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de la protection ou de l’annulation de la protection de la valeur de cette chaîne sécurisée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="secureString.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime la valeur de la chaîne sécurisée actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mémoire de l’ordinateur qui contient la valeur de cette chaîne sécurisée est remis à zéro, puis la longueur de la valeur de cette chaîne sécurisée est définie à zéro.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, et <xref:System.Security.SecureString.Clear%2A> méthodes affectent la valeur d’un <xref:System.Security.SecureString> objet.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Cette chaîne sécurisée est en lecture seule.</exception>
        <altmember cref="P:System.Security.SecureString.Length" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.SecureString Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::SecureString ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Security.SecureString" Usage="secureString.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie de la chaîne sécurisée actuelle.</summary>
        <returns>Doublon de cette chaîne sécurisée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une instance d’un <xref:System.Security.SecureString> est marqué en lecture seule, la copie de cette instance ne sera pas en lecture seule.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de la protection ou de l’annulation de la protection de la valeur de cette chaîne sécurisée.</exception>
        <altmember cref="M:System.Security.SecureString.MakeReadOnly" />
        <altmember cref="M:System.Security.SecureString.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="secureString.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'objet <see cref="T:System.Security.SecureString" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.SecureString.Dispose%2A> méthode écrit des zéros binaires vers la mémoire allouée qui contient la valeur de ce <xref:System.Security.SecureString> de l’objet, puis libère la mémoire allouée.  
  
 Pour plus d’informations, consultez [le Garbage Collection](~/docs/standard/garbage-collection/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public void InsertAt (int index, char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertAt(int32 index, char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.InsertAt(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertAt (index As Integer, c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertAt(int index, char c);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : int * char -&gt; unit" Usage="secureString.InsertAt (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Position d’index à laquelle le paramètre <c>c</c> est inséré.</param>
        <param name="c">Caractère à insérer.</param>
        <summary>Insère un caractère dans cette chaîne sécurisée à la position d'index spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’index est zéro ; le premier caractère dans cette chaîne sécurisée est à la position d’index zéro.  
  
 Si l’implémentation utilise un mécanisme de protection, telles que le chiffrement, la valeur de la chaîne sécurisée, le cas échéant, est non protégée ; `c` est inséré à la position d’index spécifiée ; la nouvelle valeur est de nouveau protégée. Le <xref:System.Security.SecureString.InsertAt%2A> méthode produit les mêmes résultats que la <xref:System.Security.SecureString.AppendChar%2A> (méthode), qui insère un caractère à la fin d’une chaîne sécurisée, si le `index` paramètre de <xref:System.Security.SecureString.InsertAt%2A> est définie à la longueur de cette instance.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, et <xref:System.Security.SecureString.Clear%2A> méthodes affectent la valeur d’un <xref:System.Security.SecureString> objet.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Cette chaîne sécurisée est en lecture seule.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette chaîne sécurisée.  -ou- L’exécution de cette opération rend la longueur de cette chaîne sécurisée supérieure à 65 536 caractères.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de la protection ou de l’annulation de la protection de la valeur de cette chaîne sécurisée.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function IsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : unit -&gt; bool" Usage="secureString.IsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique si cette chaîne sécurisée est en lecture seule.</summary>
        <returns>
          <see langword="true" /> si cette chaîne sécurisée est en lecture seule ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois qu’une instance de <xref:System.Security.SecureString> est marqué en lecture seule par le <xref:System.Security.SecureString.MakeReadOnly%2A> (méthode), toute tentative de modifier la valeur de cette instance lève une <xref:System.InvalidOperationException>. Utilisez le <xref:System.Security.SecureString.IsReadOnly%2A> méthode pour tester si une <xref:System.Security.SecureString> est en lecture seule avant de tenter de le modifier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
        <altmember cref="M:System.Security.SecureString.MakeReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecureString.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Security.SecureString.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de caractères dans la chaîne sécurisée actuelle.</summary>
        <value>Nombre d'objets <see cref="T:System.Char" /> de cette chaîne sécurisée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.SecureString.Length%2A> propriété retourne le nombre de <xref:System.Char> objets dans cette instance, pas le nombre de caractères Unicode. Un caractère Unicode peut être représenté par plusieurs <xref:System.Char> objet.  
  
 La longueur maximale d’un <xref:System.Security.SecureString> instance est 65 536 caractères.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeReadOnly">
      <MemberSignature Language="C#" Value="public void MakeReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.MakeReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeReadOnly();" />
      <MemberSignature Language="F#" Value="member this.MakeReadOnly : unit -&gt; unit" Usage="secureString.MakeReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met en lecture seule la valeur texte de cette chaîne sécurisée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Initialiser la valeur de texte d’une instance de la <xref:System.Security.SecureString> classe avec le <xref:System.Security.SecureString.%23ctor%2A> constructeurs et modifiez la valeur avec le <xref:System.Security.SecureString.Clear%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, <xref:System.Security.SecureString.InsertAt%2A>, et <xref:System.Security.SecureString.AppendChar%2A> méthodes.  
  
 Après avoir effectué vos dernières modifications, utilisez la <xref:System.Security.SecureString.MakeReadOnly%2A> méthode pour rendre la valeur de l’instance immuable (lecture seule). Une fois que la valeur est marquée en lecture seule, toute tentative supplémentaire de la modifier lève une <xref:System.InvalidOperationException>.  
  
 L’effet de l’appel <xref:System.Security.SecureString.MakeReadOnly%2A> est permanente, car la <xref:System.Security.SecureString> classe ne fournit aucun moyen de rendre la chaîne sécurisée à nouveau modifiable. Utilisez le <xref:System.Security.SecureString.IsReadOnly%2A> méthode pour tester si une instance de <xref:System.Security.SecureString> est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Security.SecureString.AppendChar%2A> et <xref:System.Security.SecureString.RemoveAt%2A> méthodes peuvent être utilisées pour rassembler les caractères dans un mot de passe. Une fois que le mot de passe est collecté, elle est définie en lecture seule.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
        <altmember cref="M:System.Security.SecureString.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; unit" Usage="secureString.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Position d'index d'un caractère dans cette chaîne sécurisée.</param>
        <summary>Supprime de cette chaîne sécurisée le caractère situé à la position d'index spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’index est zéro ; le premier caractère dans cette instance est à la position d’index zéro.  
  
 Si l’implémentation utilise un mécanisme de protection, telles que le chiffrement, la valeur de cette chaîne sécurisée, le cas échéant, est non protégée ; le caractère situé à la position d’index spécifiée est supprimé ; Ensuite, la nouvelle valeur est nouveau protégée.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, et <xref:System.Security.SecureString.Clear%2A> méthodes affectent la valeur d’un <xref:System.Security.SecureString> objet.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 L’exemple suivant montre comment la <xref:System.Security.SecureString.AppendChar%2A> et <xref:System.Security.SecureString.RemoveAt%2A> méthodes peuvent être utilisées pour rassembler les caractères dans un mot de passe.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Cette chaîne sécurisée est en lecture seule.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro, ou encore supérieur ou égal à la longueur de cette chaîne sécurisée.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de la protection ou de l’annulation de la protection de la valeur de cette chaîne sécurisée.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAt">
      <MemberSignature Language="C#" Value="public void SetAt (int index, char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAt(int32 index, char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.SetAt(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAt (index As Integer, c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAt(int index, char c);" />
      <MemberSignature Language="F#" Value="member this.SetAt : int * char -&gt; unit" Usage="secureString.SetAt (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Position d'index d'un caractère existant dans cette chaîne sécurisée.</param>
        <param name="c">Caractère qui remplace le caractère existant.</param>
        <summary>Remplace le caractère existant à la position d'index spécifiée par un autre caractère.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’index est zéro ; le premier caractère dans cette instance est à la position d’index zéro.  
  
 Si l’implémentation utilise un mécanisme de protection, telles que le chiffrement, la valeur de la chaîne sécurisée, le cas échéant, est non protégée ; `c` est affectée à la position d’index spécifiée ; la nouvelle valeur est de nouveau protégée.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, et <xref:System.Security.SecureString.Clear%2A> méthodes affectent la valeur d’un <xref:System.Security.SecureString> objet.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette chaîne sécurisée a déjà été supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Cette chaîne sécurisée est en lecture seule.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro, ou encore supérieur ou égal à la longueur de cette chaîne sécurisée.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Une erreur s’est produite lors de la protection ou de l’annulation de la protection de la valeur de cette chaîne sécurisée.</exception>
      </Docs>
    </Member>
  </Members>
</Type>