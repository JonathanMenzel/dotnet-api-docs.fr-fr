<Type Name="Debug" FullName="System.Diagnostics.Debug">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e1f2f5cb8de12cc67dfb0178935452c56a2348ef" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061113" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Debug" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Debug extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Debug" />
  <TypeSignature Language="VB.NET" Value="Public Class Debug" />
  <TypeSignature Language="C++ CLI" Value="public ref class Debug abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Debug</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un ensemble de méthodes et propriétés qui permettent de déboguer votre code.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez les méthodes dans la <xref:System.Diagnostics.Debug> classe pour imprimer les informations de débogage et vérifier votre logique avec des assertions, vous pouvez renforcer votre code sans affecter la taille de performances et le code de votre produit d’envoi.  
  
 Cette classe fournit des méthodes pour afficher une <xref:System.Diagnostics.Debug.Assert%2A> boîte de dialogue et permet d’envoyer une assertion qui échouera toujours. Cette classe fournit des méthodes d’écriture avec les variations suivantes : <xref:System.Diagnostics.Debug.Write%2A>, <xref:System.Diagnostics.Debug.WriteLine%2A>, <xref:System.Diagnostics.Debug.WriteIf%2A> et <xref:System.Diagnostics.Debug.WriteLineIf%2A>.  
  
 Le <xref:System.Diagnostics.BooleanSwitch> et <xref:System.Diagnostics.TraceSwitch> classes fournissent des moyens de contrôler de manière dynamique la sortie de traçage. Vous pouvez modifier les valeurs de ces commutateurs sans recompiler votre application. Pour plus d’informations sur l’utilisation du fichier de configuration pour définir un commutateur, consultez la <xref:System.Diagnostics.Switch> classe et le [commutateurs de Trace](~/docs/framework/debug-trace-profile/trace-switches.md) rubrique.  
  
 Vous pouvez personnaliser la cible de la sortie du traçage en ajoutant <xref:System.Diagnostics.TraceListener> instances à ou la suppression d’instances à partir de la <xref:System.Diagnostics.Debug.Listeners%2A> collection. Le <xref:System.Diagnostics.Debug.Listeners%2A> collection est partagée par les deux le <xref:System.Diagnostics.Debug> et <xref:System.Diagnostics.Trace> classes ; Ajout d’un écouteur de suivi à chaque classe ajoute l’écouteur à la fois. Par défaut, la <xref:System.Diagnostics.DefaultTraceListener> classe émet une sortie de trace.  
  
> [!NOTE]
>  Ajout d’un écouteur de trace à le <xref:System.Diagnostics.Debug.Listeners%2A> collection peut provoquer une exception levée lors du traçage, si une ressource utilisée par l’écouteur de suivi n’est pas disponible. Les conditions et l’exception levée dépendent de l’écouteur de suivi et ne peut pas être énumérés dans cette rubrique. Il peut être utile de placer des appels à la <xref:System.Diagnostics.Debug> méthodes dans `try` / `catch` blocs pour détecter et gérer toutes les exceptions dans les écouteurs de la trace.  
  
 Vous pouvez modifier le niveau de mise en retrait à l’aide de la <xref:System.Diagnostics.Debug.Indent%2A> méthode ou le <xref:System.Diagnostics.Debug.IndentLevel%2A> propriété. Pour modifier l’espacement de la mise en retrait, utilisez la <xref:System.Diagnostics.Debug.IndentSize%2A> propriété. Vous pouvez spécifier s’il faut automatiquement vider le tampon de sortie après chaque écriture en définissant le <xref:System.Diagnostics.Debug.AutoFlush%2A> propriété `true`.  
  
 Pour définir le <xref:System.Diagnostics.Debug.AutoFlush%2A> et <xref:System.Diagnostics.Debug.IndentSize%2A> pour <xref:System.Diagnostics.Debug>, vous pouvez modifier le fichier de configuration correspondant au nom de votre application. Le fichier de configuration doit être mis en forme comme illustré dans l’exemple suivant.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 Le <xref:System.Diagnostics.ConditionalAttribute> attribut est appliqué aux méthodes de <xref:System.Diagnostics.Debug>. Les compilateurs qui prennent en charge <xref:System.Diagnostics.ConditionalAttribute> ignorent les appels à ces méthodes, sauf si « DEBUG » est défini comme un symbole de compilation conditionnelle. Reportez-vous à la documentation d’un compilateur pour déterminer si <xref:System.Diagnostics.ConditionalAttribute> est pris en charge et la syntaxe permettant de définir un symbole de compilation conditionnelle.  
  
> [!NOTE]
> Dans les projets Visual Studio c# et Visual Basic, par défaut, le symbole de compilation conditionnelle « DEBUG » est défini pour les versions debug, et le symbole « TRACE » est défini pour les deux de débogage et les versions release. Pour plus d’informations sur la manière de désactiver ce comportement, consultez la documentation de Visual Studio. Pour plus d’informations sur le débogage conditionnel dans Visual C++, consultez [Debug, classe (C + c++ / CLI)](/cpp/dotnet/debug-class-cpp-cli).
  
 Pour définir le symbole de compilation conditionnelle « DEBUG » en c#, ajoutez le `/d:DEBUG` option à la ligne de commande du compilateur lorsque vous compilez votre code à l’aide d’une ligne de commande, ou ajoutez `#define DEBUG` vers le haut de votre fichier. Dans Visual Basic, ajoutez le `/d:DEBUG=True` option à la ligne de commande du compilateur ou ajoutez `#Const DEBUG=True` au fichier.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Diagnostics.Debug> pour indiquer le début et la fin de l’exécution d’un programme. L’exemple utilise également <xref:System.Diagnostics.Debug.Indent%2A> et <xref:System.Diagnostics.Debug.Unindent%2A> pour distinguer la sortie de traçage.  
  
 [!code-cpp[Classic Debug Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug Example/CS/source.cs#1)]
 [!code-vb[Classic Debug Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.Diagnostics.Trace" />
    <altmember cref="T:System.Diagnostics.Switch" />
    <altmember cref="T:System.Diagnostics.BooleanSwitch" />
    <altmember cref="T:System.Diagnostics.TraceSwitch" />
    <altmember cref="T:System.Diagnostics.TraceListener" />
    <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
    <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
    <altmember cref="T:System.Diagnostics.EventLogTraceListener" />
    <altmember cref="T:System.Diagnostics.TraceListenerCollection" />
    <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vérifie une condition ; si la condition est <see langword="false" />, affiche des messages et une boîte de message qui montre la pile des appels.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, aucun message d’échec n’est envoyé et la boîte de message ne s’affiche pas.</param>
        <summary>Vérifie une condition ; si la condition est <see langword="false" />, affiche une boîte de message qui montre la pile des appels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> méthode fonctionne uniquement dans les versions debug. Utilisez le <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> génère de méthode si vous souhaitez faire des assertions dans la mise en production. Pour plus d’informations, consultez [Assertions dans du Code managé](/visualstudio/debugger/assertions-in-managed-code).  
  
> [!IMPORTANT]
>  Le `Assert` méthodes ne sont pas disponibles pour [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] applications.  
  
 En règle générale, le <xref:System.Diagnostics.Debug.Assert%28System.Boolean%29> méthode est utilisée pour identifier des erreurs de logique pendant le développement de programme. <xref:System.Diagnostics.Debug.Assert%2A> évalue la condition. Si le résultat est `false`, il envoie un message d’échec pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection. Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
 Lorsque l’application s’exécute en mode d’interface utilisateur, il affiche un message qui montre la pile des appels avec des numéros de fichier et de ligne. La boîte de message contient trois boutons : **abandonner**, **réessayer**, et **ignorer**. En cliquant sur le **abandonner** bouton met fin à l’application. En cliquant sur **réessayer** vous renvoie vers le code dans le débogueur si votre application s’exécute dans un débogueur ou vous propose d’ouvrir un débogueur si ce n’est pas. En cliquant sur **ignorer** se poursuit avec l’instruction suivante dans le code.  
  
> [!NOTE]
>  [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] les applications ne gèrent pas les boîtes de dialogue modales, afin qu’ils comportent de la même en mode d’interface utilisateur et en mode interface utilisateur non. Le message est écrit dans les écouteurs de la trace active en mode débogage, ou aucun message n’est écrit en mode release.  
  
> [!NOTE]
>  L’affichage de la boîte de message dépend de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez modifier le comportement de la <xref:System.Diagnostics.DefaultTraceListener> dans le fichier de configuration qui correspond au nom de votre application. Dans ce fichier, vous pouvez activer et désactiver la boîte de message d’assertion ou définir le <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> propriété. Le fichier de configuration doit être mis en forme comme suit :  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 L’exemple suivant crée un index pour un tableau, effectue une action pour définir la valeur de l’index, puis appelle <xref:System.Diagnostics.Debug.Assert%2A> pour confirmer que la valeur d’index est valide. S’il n’est pas valide, <xref:System.Diagnostics.Debug.Assert%2A> génère la pile des appels.  
  
 [!code-cpp[Classic Debug.Assert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition a la valeur <see langword="true" />, le message spécifié n’est pas envoyé et la boîte de message ne s’affiche pas.</param>
        <param name="message">Message à envoyer à la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Vérifie une condition ; si la condition a la valeur <see langword="false" />, affiche un message spécifié et une boîte de message qui montre la pile des appels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> méthode fonctionne uniquement dans les versions debug. Utilisez le <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> génère de méthode si vous souhaitez faire des assertions dans la mise en production. Pour plus d’informations, consultez [Assertions dans du Code managé](/visualstudio/debugger/assertions-in-managed-code).  
  
 En règle générale, le <xref:System.Diagnostics.Debug.Assert%2A> méthode est utilisée pour identifier des erreurs de logique pendant le développement de programme. <xref:System.Diagnostics.Debug.Assert%2A> évalue la condition. Si le résultat est `false`, il envoie le message de diagnostic spécifié à la <xref:System.Diagnostics.Debug.Listeners%2A> collection. Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
 Lorsque l’application s’exécute en mode d’interface utilisateur, il affiche un message qui montre la pile des appels avec des numéros de fichier et de ligne. La boîte de message contient trois boutons : **abandonner**, **réessayer**, et **ignorer**. En cliquant sur le **abandonner** bouton met fin à l’application. En cliquant sur **réessayer** vous renvoie vers le code dans le débogueur si votre application s’exécute dans un débogueur ou vous propose d’ouvrir un débogueur si ce n’est pas. En cliquant sur **ignorer** se poursuit avec l’instruction suivante dans le code.  
  
> [!NOTE]
>  L’affichage de la boîte de message dépend de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez modifier le comportement de la <xref:System.Diagnostics.DefaultTraceListener> dans le fichier de configuration qui correspond au nom de votre application. Dans ce fichier, vous pouvez activer et désactiver la boîte de message d’assertion ou définir le <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> propriété. Le fichier de configuration doit être mis en forme comme suit :  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 L’exemple suivant vérifie si le `type` paramètre n’est valide. Si `type` est `null`, <xref:System.Diagnostics.Trace.Assert%2A> , un message s’affiche.  
  
 [!code-cpp[Classic Debug.Assert1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message, System::String ^ detailMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, les messages spécifiés ne sont pas envoyés et la boîte de message ne s’affiche pas.</param>
        <param name="message">Message à envoyer à la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="detailMessage">Message détaillé à envoyer à la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Vérifie une condition ; si la condition est <see langword="false" />, affiche deux messages spécifiés et une boîte de message qui montre la pile des appels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> méthode fonctionne uniquement dans les versions debug. Utilisez le <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> génère de méthode si vous souhaitez faire des assertions dans la mise en production. Pour plus d’informations, consultez [Assertions dans du Code managé](/visualstudio/debugger/assertions-in-managed-code).  
  
 En règle générale, le <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%29> méthode est utilisée pour identifier des erreurs de logique pendant le développement de programme. <xref:System.Diagnostics.Debug.Assert%2A> évalue la condition. Si le résultat est `false`, il envoie le message de diagnostic spécifié et le message détaillé à la <xref:System.Diagnostics.Debug.Listeners%2A> collection. Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
 Lorsque l’application s’exécute en mode d’interface utilisateur, il affiche un message qui montre la pile des appels avec des numéros de fichier et de ligne. La boîte de message contient trois boutons : **abandonner**, **réessayer**, et **ignorer**. En cliquant sur le **abandonner** bouton met fin à l’application. En cliquant sur **réessayer** vous renvoie vers le code dans le débogueur si votre application s’exécute dans un débogueur ou vous propose d’ouvrir un débogueur si ce n’est pas. En cliquant sur **ignorer** se poursuit avec l’instruction suivante dans le code.  
  
> [!NOTE]
>  L’affichage de la boîte de message dépend de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez modifier le comportement de la <xref:System.Diagnostics.DefaultTraceListener> dans le fichier de configuration qui correspond au nom de votre application. Dans ce fichier, vous pouvez activer et désactiver la boîte de message d’assertion ou définir le <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> propriété. Le fichier de configuration doit être mis en forme comme suit :  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 L’exemple suivant vérifie si le `type` paramètre n’est valide. Si `type` est `null`, <xref:System.Diagnostics.Trace.Assert%2A> affiche deux messages.  
  
 [!code-cpp[Classic Debug.Assert2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessageFormat, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessageFormat, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String, detailMessageFormat As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message, System::String ^ detailMessageFormat, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessageFormat" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, les messages spécifiés ne sont pas envoyés et la boîte de message ne s’affiche pas.</param>
        <param name="message">Message à envoyer à la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="detailMessageFormat">Chaîne de format composite à envoyer à la collection <see cref="P:System.Diagnostics.Trace.Listeners" />. Ce message contient du texte avec aucun ou plusieurs éléments de mise en forme qui correspondent à des objets dans le tableau <c>args</c>.</param>
        <param name="args">Tableau d'objets contenant aucun ou plusieurs objets à mettre en forme.</param>
        <summary>Vérifie une condition ; si la condition est <see langword="false" />, affiche deux messages (simples et mis en forme) et une boîte de message qui mentionne la pile des appels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne résultante est envoyée à la <xref:System.Diagnostics.Trace.Listeners%2A> collection.  
  
 Par défaut, le <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> méthode fonctionne uniquement dans les versions debug. Utilisez le <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> génère de méthode si vous souhaitez faire des assertions dans la mise en production. Pour plus d’informations, consultez [Assertions dans du Code managé](/visualstudio/debugger/assertions-in-managed-code).  
  
 En règle générale, le <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%2CSystem.Object%5B%5D%29> méthode est utilisée pour identifier des erreurs de logique pendant le développement de programme. <xref:System.Diagnostics.Debug.Assert%2A> évalue la condition. Si le résultat est `false`, le <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> méthode est appelée et la `detailMessageFormat` chaîne et `args` tableau sont passés comme paramètres. <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%2CSystem.Object%5B%5D%29> envoie ensuite le message texte spécifié et le message de texte mis en forme à le <xref:System.Diagnostics.Debug.Listeners%2A> collection. Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
 Lorsque l’application s’exécute en mode d’interface utilisateur, il affiche un message qui montre la pile des appels avec des numéros de fichier et de ligne. La boîte de message contient trois boutons : **abandonner**, **réessayer**, et **ignorer**. En cliquant sur le **abandonner** bouton met fin à l’application. En cliquant sur **réessayer** vous renvoie vers le code dans le débogueur si votre application s’exécute dans un débogueur ou vous propose d’ouvrir un débogueur si ce n’est pas. En cliquant sur **ignorer** se poursuit avec l’instruction suivante dans le code.  
  
> [!NOTE]
>  L’affichage de la boîte de message est dépendante de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez modifier le comportement de la <xref:System.Diagnostics.DefaultTraceListener> dans le fichier de configuration qui correspond au nom de votre application. Dans ce fichier, vous pouvez activer et désactiver la boîte de message d’assertion ou définir le <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> propriété. Le fichier de configuration doit être mis en forme comme suit :  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public static bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur permettant de savoir si <see cref="M:System.Diagnostics.Debug.Flush" /> doit être appelé sur les <see cref="P:System.Diagnostics.Debug.Listeners" /> après chaque écriture.</summary>
        <value>
          <see langword="true" /> si <see cref="M:System.Diagnostics.Debug.Flush" /> est appelé sur <see cref="P:System.Diagnostics.Debug.Listeners" /> après chaque écriture ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut est `false`.  
  
 Vider le flux n’effacera pas son encodeur sous-jacent sauf si vous appelez explicitement <xref:System.Diagnostics.Debug.Flush%2A> ou <xref:System.Diagnostics.Debug.Close%2A>. Paramètre <xref:System.Diagnostics.Debug.AutoFlush%2A> à `true` signifie que les données sont supprimées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Cela permet à l’encodeur de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7 où certains caractères peuvent uniquement être encodés après que l’encodeur a reçu les caractères adjacents.  
  
 Pour définir le <xref:System.Diagnostics.Debug.AutoFlush%2A> et <xref:System.Diagnostics.Debug.IndentSize%2A> pour <xref:System.Diagnostics.Debug>, vous pouvez également modifier le fichier de configuration correspondant au nom de votre application. Le fichier de configuration doit être mis en forme comme illustré dans l’exemple suivant.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Valeur de la demande <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public static void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Close" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide la mémoire tampon de sortie, puis appelle la méthode <see langword="Close" /> sur chaque <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque la sortie doit être dirigée vers un fichier, par exemple le <xref:System.Diagnostics.TextWriterTraceListener>.  
  
 Vider le flux n’effacera pas son encodeur sous-jacent sauf si vous appelez explicitement <xref:System.Diagnostics.Debug.Flush%2A> ou <xref:System.Diagnostics.Debug.Close%2A>. Paramètre <xref:System.Diagnostics.Debug.AutoFlush%2A> à `true` signifie que les données sont supprimées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Cela permet à l’encodeur de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7 où certains caractères peuvent uniquement être encodés après que l’encodeur a reçu les caractères adjacents.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TextWriterTraceListener> nommé `myTextListener`. `myTextListener` utilise un <xref:System.IO.StreamWriter> appelé `myOutputWriter` à écrire dans un fichier nommé `TestFile.txt`. L’exemple crée le fichier, le flux et le writer, écrit une ligne de texte dans le fichier, puis vide et ferme la sortie.  
  
 [!code-cpp[Classic Debug.Close Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Close Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Valeur de la demande <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Fail">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Émet un message d'erreur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Fail(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à émettre.</param>
        <summary>Émet le message d’erreur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut est que le <xref:System.Diagnostics.DefaultTraceListener> génère le message à une boîte de message lors de l’application s’exécute en mode d’interface utilisateur et en le <xref:System.Diagnostics.TraceListener> instances dans le <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
> [!NOTE]
>  L’affichage de la boîte de message est dépendante de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Diagnostics.Debug.Fail%2A> méthode pour imprimer un message lors de la gestion des exceptions.  
  
 [!code-cpp[Classic Debug.Fail Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Fail Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Fail Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail Example/VB/source.vb#1)]  
  
 Vous pouvez également utiliser le <xref:System.Diagnostics.Debug.Fail%2A> méthode dans une instruction switch.  
  
 [!code-cpp[Classic Debug.Fail Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Debug.Fail Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CS/source.cs#2)]
 [!code-vb[Classic Debug.Fail Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Fail(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message, System::String ^ detailMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à émettre.</param>
        <param name="detailMessage">Message détaillé à émettre.</param>
        <summary>Envoie un message d'erreur ainsi qu'un message d'erreur détaillé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut est que le <xref:System.Diagnostics.DefaultTraceListener> génère le message à une boîte de message lors de l’application s’exécute en mode d’interface utilisateur et en le <xref:System.Diagnostics.TraceListener> instances dans le <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
> [!NOTE]
>  L’affichage de la boîte de message est dépendante de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Diagnostics.Debug.Fail%2A> méthode pour imprimer un message lors de la gestion des exceptions.  
  
 [!code-cpp[Classic Debug.Fail1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Fail1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Fail1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/VB/source.vb#1)]  
  
 Vous pouvez également utiliser le <xref:System.Diagnostics.Debug.Fail%2A> méthode dans une instruction switch.  
  
 [!code-cpp[Classic Debug.Fail1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Debug.Fail1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CS/source.cs#2)]
 [!code-vb[Classic Debug.Fail1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public static void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide la mémoire tampon de sortie et entraîne l'écriture des données de la mémoire tampon dans la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vider le flux n’effacera pas son encodeur sous-jacent sauf si vous appelez explicitement <xref:System.Diagnostics.Debug.Flush%2A> ou <xref:System.Diagnostics.Debug.Close%2A>. Paramètre <xref:System.Diagnostics.Debug.AutoFlush%2A> à `true` signifie que les données sont supprimées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Cela permet à l’encodeur de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7 où certains caractères peuvent uniquement être encodés après que l’encodeur a reçu les caractères adjacents.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TextWriterTraceListener> nommé `myTextListener`. `myTextListener` utilise un <xref:System.IO.FileStream> appelé `myFileStream` à écrire dans un fichier nommé `TestFile.txt`. L’exemple crée le flux, ouvre le fichier si elle existe ou crée un nouveau, écrit une ligne de texte dans le fichier, puis vide et ferme la sortie.  
  
 [!code-cpp[Classic Debug.Close Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Close Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Indent">
      <MemberSignature Language="C#" Value="public static void Indent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Indent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Indent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Indent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Indent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Augmente le <see cref="P:System.Diagnostics.Debug.IndentLevel" /> actuel d’une unité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant définit le niveau de retrait et émet des messages de débogage.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Cet exemple génère la sortie suivante :  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Debug.Unindent" />
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="IndentLevel">
      <MemberSignature Language="C#" Value="public static int IndentLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.IndentLevel" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentLevel { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le niveau de retrait.</summary>
        <value>Niveau de retrait. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Debug.IndentLevel%2A> propriété représente le nombre de fois où le retrait de taille <xref:System.Diagnostics.Debug.IndentSize%2A> est appliqué.  
  
   
  
## Examples  
 L’exemple suivant définit le niveau de retrait et émet des messages de débogage.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Cet exemple génère la sortie suivante :  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IndentSize">
      <MemberSignature Language="C#" Value="public static int IndentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.IndentSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre d'espaces dans un retrait.</summary>
        <value>Nombre d'espaces dans un retrait. La valeur par défaut est quatre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.TextWriterTraceListener> interprète ce nombre comme des espaces. Un <xref:System.Diagnostics.EventLogTraceListener> ignore cette valeur.  
  
 Pour définir le <xref:System.Diagnostics.Debug.AutoFlush%2A> et <xref:System.Diagnostics.Debug.IndentSize%2A> pour <xref:System.Diagnostics.Debug>, vous pouvez également modifier le fichier de configuration correspondant au nom de votre application. Le fichier de configuration doit être mis en forme comme illustré dans l’exemple suivant.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Listeners">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.TraceListenerCollection Listeners { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Diagnostics.TraceListenerCollection Listeners" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.Listeners" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Listeners As TraceListenerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Diagnostics::TraceListenerCollection ^ Listeners { System::Diagnostics::TraceListenerCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.TraceListenerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des écouteurs qui surveillent la sortie de débogage.</summary>
        <value>
          <see cref="T:System.Diagnostics.TraceListenerCollection" /> représentant une collection du type <see cref="T:System.Diagnostics.TraceListener" /> qui surveille la sortie de débogage.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les écouteurs produisent une sortie mise en forme à partir de la sortie de débogage. Par défaut, la collection contient une instance de la <xref:System.Diagnostics.DefaultTraceListener> classe. Pour supprimer l’écouteur par défaut, appelez le <xref:System.Diagnostics.TraceListenerCollection.Remove%2A> (méthode) et le passer à l’instance de la <xref:System.Diagnostics.DefaultTraceListener>. Pour rediriger la sortie vers la fenêtre de console, ajoutez une instance de la <xref:System.Diagnostics.ConsoleTraceListener>. Pour rediriger la sortie vers un fichier ou un flux, ajoutez une instance de la <xref:System.Diagnostics.TextWriterTraceListener>.  
  
> [!NOTE]
>  Le <xref:System.Diagnostics.Debug.Listeners%2A> collection est partagée par les deux le <xref:System.Diagnostics.Debug> et <xref:System.Diagnostics.Trace> classes ; Ajout d’un écouteur de suivi à chaque classe ajoute l’écouteur à la fois.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TextWriterTraceListener> qui renvoie à l’écran de la console. Le code ajoute ensuite le nouvel écouteur à le <xref:System.Diagnostics.Debug.Listeners%2A>.  
  
 [!code-cpp[Classic Debug.Listeners Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Listeners Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Listeners Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Valeur de la demande <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Print">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit un message suivi d'un terminateur de ligne sur les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Print(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Print (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message suivi d'un terminateur de ligne sur les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le terminateur de ligne par défaut est un retour chariot suivi d’un saut de ligne. Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Print(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Print (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite qui contient du texte avec aucun ou plusieurs éléments de mise en forme qui correspondent à des objets dans le tableau <c>args</c>.</param>
        <param name="args">Tableau d'objets qui contient zéro ou plusieurs objets à mettre en forme.</param>
        <summary>Écrit une chaîne mise en forme, suivie d'un terminateur de ligne sur les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
 - ou -  
  
 Le nombre qui indique un argument à mettre en forme est inférieur à zéro ou supérieur ou égal au nombre d'objets spécifiés à mettre en forme.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unindent">
      <MemberSignature Language="C#" Value="public static void Unindent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unindent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Unindent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unindent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unindent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réduit la propriété <see cref="P:System.Diagnostics.Debug.IndentLevel" /> actuelle d’une unité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant définit le niveau de retrait et émet des messages de débogage.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Cet exemple génère la sortie suivante :  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Debug.Indent" />
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les informations sur la version déboguée sur les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet dont le nom est transmis à <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Écrit la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Objet dont le nom est transmis à <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit le nom de la catégorie et la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs Trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Utilisez le `category` paramètre au groupe de messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Utilisez le `category` paramètre au groupe de messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les informations sur la version déboguée sur les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" /> si une condition a la valeur <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, la valeur est écrite dans les écouteurs de la trace de la collection.</param>
        <param name="value">Objet dont le nom est transmis à <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Écrit la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier nom du paramètre de valeur pour le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie un message sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" />, vous n’appelez pas <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 Premier exemple :  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Deuxième exemple :  
  
```csharp  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, le message est écrit dans les écouteurs de la trace de la collection.</param>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur à la <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" />, vous n’appelez pas <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 Premier exemple :  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Deuxième exemple :  
  
```csharp  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, le nom de catégorie et la valeur sont écrits dans les écouteurs de la trace de la collection.</param>
        <param name="value">Objet dont le nom est transmis à <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />, si une condition a la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Verbose`, l’exemple renvoie le nom de la `myObject` et `category` à la <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Error` ou une version ultérieure, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" />, vous n’appelez pas <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 Premier exemple :  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Deuxième exemple :  
  
```csharp  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, le nom de catégorie et le message sont écrits dans les écouteurs de la trace de la collection.</param>
        <param name="message">Message à écrire.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et un message dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A?displayProperty=nameWithType> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Verbose`, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Error` ou une version ultérieure, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" />, vous n’appelez pas <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 Premier exemple :  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Deuxième exemple :  
  
```csharp  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les informations sur la version déboguée sur les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet dont le nom est transmis à <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Écrit la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le nom de l’objet sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteLine1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message suivi d'un terminateur de ligne sur les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteLine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Objet dont le nom est transmis à <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit le nom de la catégorie et la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs Trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Debug.WriteLine3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite qui contient du texte avec aucun ou plusieurs éléments de mise en forme qui correspondent à des objets dans le tableau <c>args</c>.</param>
        <param name="args">Tableau d'objets contenant aucun ou plusieurs objets à mettre en forme.</param>
        <summary>Écrit un message mis en forme suivi d'un terminateur de ligne dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne.  
  
 Le mot clé dans la syntaxe de cette méthode implique que le tableau d’objets peut être une valeur unique. L’exception concerne le <xref:System.String> objet. Les surcharges explicites sont prioritaires, de sorte qu’une `arg` par défaut la valeur d’une chaîne unique sera le <xref:System.Diagnostics.Debug.WriteLine%28System.String%2CSystem.String%29?displayProperty=nameWithType> de surcharge.  
  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> méthode de l’écouteur de trace.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur et le `category` sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteLine2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLineIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les informations sur la version déboguée sur les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" /> si une condition a la valeur <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, la valeur est écrite dans les écouteurs de la trace de la collection.</param>
        <param name="value">Objet dont le nom est transmis à <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Écrit la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le nom de l’objet sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" />, vous n’appelez pas <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 Premier exemple :  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Deuxième exemple :  
  
```csharp  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, le message est écrit dans les écouteurs de la trace de la collection.</param>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur à la <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteLineIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" />, vous n’appelez pas <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 Premier exemple :  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Deuxième exemple :  
  
```csharp  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, le nom de catégorie et la valeur sont écrits dans les écouteurs de la trace de la collection.</param>
        <param name="value">Objet dont le nom est transmis à <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Debug.Listeners" />, si une condition a la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" />, vous n’appelez pas <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 Premier exemple :  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Deuxième exemple :  
  
```csharp  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="message">Message à écrire.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et un message dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Debug.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Debug.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Debug.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur et le `category` sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" />, vous n’appelez pas <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 Premier exemple :  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Deuxième exemple :  
  
```csharp  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
  </Members>
</Type>