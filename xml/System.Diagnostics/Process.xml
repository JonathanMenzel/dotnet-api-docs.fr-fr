<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="10bf0daa3bd3743fd402cdd8f360d421086b0ea5" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48662916" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit l'accès à des processus locaux ainsi que distants, et vous permet de démarrer et d'arrêter des processus système locaux.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Diagnostics.Process> composant fournit l’accès à un processus qui s’exécute sur un ordinateur. Un processus, d’autres termes, est une application en cours d’exécution. Un thread est l’unité de base à laquelle le système d’exploitation alloue du temps processeur. Un thread peut exécuter n’importe quelle partie du code du processus, y compris des parties en cours d’exécution par un autre thread.  
  
 Le <xref:System.Diagnostics.Process> composant est un outil utile pour démarrer, arrêter, contrôler et surveiller les applications. Vous pouvez utiliser le <xref:System.Diagnostics.Process> composant, pour obtenir une liste des processus en cours d’exécution, ou vous pouvez démarrer un nouveau processus. Un <xref:System.Diagnostics.Process> composant est utilisé pour accéder aux processus système. Après un <xref:System.Diagnostics.Process> composant a été initialisé, il peut être utilisé pour obtenir des informations sur le processus en cours d’exécution. Ces informations incluent l’ensemble des threads, les modules chargés (fichiers .dll et .exe), et à l’aide d’informations sur les performances telles que la quantité de mémoire du processus.  
  
 Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `finally` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
> [!NOTE]
>  processus 32 bits ne peut pas accéder aux modules d’un processus 64 bits. Si vous essayez d’obtenir des informations sur un processus 64 bits à partir d’un processus 32 bits, vous obtiendrez un <xref:System.ComponentModel.Win32Exception> exception. Un processus 64 bits, peuvent quant à eux, accéder aux modules d’un processus 32 bits.  
  
 Le composant de processus obtient des informations sur un groupe de propriétés à la fois. Après le <xref:System.Diagnostics.Process> composant a obtenu des informations sur un membre d’un groupe, il sera mettre en cache les valeurs pour les autres propriétés de ce groupe et d’obtenir des nouvelles informations sur les autres membres du groupe jusqu'à ce que vous appeliez la <xref:System.Diagnostics.Process.Refresh%2A> (méthode). Par conséquent, une valeur de propriété n’est pas garantie pour être plus récente que le dernier appel à la <xref:System.Diagnostics.Process.Refresh%2A> (méthode). Les répartitions des groupes dépendent du système d’exploitation.  
  
 Si vous avez une variable de chemin d’accès déclarée dans votre système à l’aide de guillemets, vous devez qualifier entièrement ce chemin d’accès lors du démarrage de n’importe quel processus trouvé dans cet emplacement. Sinon, le système ne trouvera pas le chemin d’accès. Par exemple, si `c:\mypath` n’est pas dans votre chemin d’accès, et l’ajouter à l’aide de guillemets : `path = %path%;"c:\mypath"`, vous devez qualifier complètement tout processus dans `c:\mypath` lorsque vous le démarrez.  
  
 Un processus système est identifié de manière unique sur le système par son identificateur de processus. Comme de nombreuses ressources de Windows, un processus est également identifié par son handle, qui peut ne pas être unique sur l’ordinateur. Un handle est le terme générique pour un identificateur d’une ressource. Le système d’exploitation conserve le handle du processus, qui est accessible via la <xref:System.Diagnostics.Process.Handle%2A> propriété de la <xref:System.Diagnostics.Process> composant, même lorsque le processus est terminé. Par conséquent, vous pouvez obtenir des informations le processus d’administration, telles que la <xref:System.Diagnostics.Process.ExitCode%2A> (généralement zéro en cas de réussite ou un code d’erreur différent de zéro) et le <xref:System.Diagnostics.Process.ExitTime%2A>. Handles constituent une ressource extrêmement précieuse, par conséquent, les pertes de handles sont plus virulents à une fuite de mémoire.  
  
> [!NOTE]
>  Cette classe contient une demande de liaison et une demande d’héritage au niveau de la classe qui s’applique à tous les membres. Un <xref:System.Security.SecurityException> est levée lorsque l’appelant immédiat ou la classe dérivée n’a pas d’autorisations de confiance totale. Pour plus d’informations sur les demandes de sécurité, consultez [demandes de liaison](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Notes de publication  
 Dans le .NET Framework, le <xref:System.Diagnostics.Process> classe par défaut, utilise <xref:System.Console> encodages, qui sont en général des codages de page, pour les flux d’entrée, sortie et d’erreur de code. Par exemple de code, sur les systèmes dont la culture est anglais (États-Unis), page de codes 437 est l’encodage par défaut pour le <xref:System.Console> classe. Toutefois, [!INCLUDE[net_core](~/includes/net-core-md.md)] peut effectuer uniquement un sous-ensemble limité de ces encodages disponibles. Si c’est le cas, il utilise <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> comme l’encodage par défaut.  
  
 Si un <xref:System.Diagnostics.Process> objet dépend des codages de page de codes spécifique, vous pouvez toujours les rendre disponibles de la manière suivante *avant* vous appeler les <xref:System.Diagnostics.Process> méthodes :  
  
1.  Ajoutez une référence à l’assembly System.Text.Encoding.CodePages.dll à votre projet.  
  
2.  Récupérer le <xref:System.Text.EncodingProvider> de l’objet à partir de la <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propriété.  
  
3.  Passer le <xref:System.Text.EncodingProvider> de l’objet à la <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> méthode permettant d’apporter les autres encodages pris en charge par le fournisseur d’encodage disponible.  
  
 Le <xref:System.Diagnostics.Process> classe puis utilisent automatiquement l’encodage du système par défaut au lieu d’UTF-8, sous réserve que vous avez enregistré le fournisseur d’encodage avant d’appeler une <xref:System.Diagnostics.Process> méthodes.  
  
   
  
## Examples  
 L’exemple suivant utilise une instance de la <xref:System.Diagnostics.Process> classe démarre un processus.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 L’exemple suivant utilise le <xref:System.Diagnostics.Process> lui-même et statique de la classe <xref:System.Diagnostics.Process.Start%2A> méthode pour démarrer un processus.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 L’exemple F # suivant définit un `runProc` fonction qui démarre un processus, capture toutes les informations de sortie et d’erreur et enregistre le nombre de millisecondes pendant lesquelles l’exécution du processus.  Le `runProc` fonction a trois paramètres : le nom de l’application au lancement, les arguments à fournir à l’application et le répertoire de démarrage.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Le code pour le `runProc` fonction a été écrit par [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) et est disponible sous le [Microsoft Public License](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Cette classe ne peut pas être héritée par du code partiellement fiable.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">À l’aide de la classe Process .NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous ne spécifiez pas le <xref:System.Diagnostics.Process.MachineName%2A> propriété, la valeur par défaut est l’ordinateur local, («. »).  
  
 Vous avez deux options pour associer un nouveau <xref:System.Diagnostics.Process> composant avec un processus sur l’ordinateur. La première option consiste à utiliser le constructeur pour créer le <xref:System.Diagnostics.Process> jeu de composants, les membres appropriés de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété et appelez <xref:System.Diagnostics.Process.Start%2A> pour associer le <xref:System.Diagnostics.Process> avec un nouveau processus système. La deuxième option consiste à associer le <xref:System.Diagnostics.Process> avec un processus système en cours d’exécution à l’aide de <xref:System.Diagnostics.Process.GetProcessById%2A> ou l’un de le <xref:System.Diagnostics.Process.GetProcesses%2A> retournent des valeurs.  
  
 Si vous utilisez un `static` surcharge de la <xref:System.Diagnostics.Process.Start%2A> méthode pour démarrer un nouveau processus système, la méthode crée un nouveau <xref:System.Diagnostics.Process> composant et l’associe avec le processus.  
  
 Lorsque le <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> propriété est définie sur sa valeur par défaut, `true`, vous pouvez démarrer des applications et documents d’une manière qui est similaire à l’utilisation de la `Run` boîte de dialogue de la Windows `Start` menu. Lorsque <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> est `false`, vous pouvez démarrer que des exécutables.  
  
 N’importe quel fichier exécutable que vous pouvez appeler à partir de la ligne de commande peut être démarré de deux manières : en définissant les membres appropriés de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété et en appelant le <xref:System.Diagnostics.Process.Start%2A> méthode sans paramètres, ou en passant le paramètre approprié pour le `static` <xref:System.Diagnostics.Process.Start%2A> membre.  
  
 Vous pouvez créer un <xref:System.Diagnostics.Process> composant en utilisant le constructeur, une des statiques <xref:System.Diagnostics.Process.Start%2A> surcharges ou l’un de la <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> méthodes. Une fois que vous l’avez fait, vous avez une vue dans le processus associé. Cela n’est pas une vue dynamique qui se met à jour automatiquement lorsque les propriétés de processus ont été modifiés en mémoire. Au lieu de cela, vous devez appeler <xref:System.Diagnostics.Process.Refresh%2A> pour le composant à mettre à jour le <xref:System.Diagnostics.Process> les informations de propriété dans votre application.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la priorité de base du processus associé.</summary>
        <value>Priorité de base, calculée à partir du <see cref="P:System.Diagnostics.Process.PriorityClass" /> du processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.BasePriority%2A> du processus est la priorité de départ pour les threads créés dans le processus associé. Vous pouvez afficher des informations sur la priorité de base via le compteur de Base de priorité de l’analyse système.  
  
 En fonction du temps écoulé ou d’autres augmente, le système d’exploitation peut modifier la priorité de base lorsqu’un processus doit être placé devant les autres.  
  
 Le <xref:System.Diagnostics.Process.BasePriority%2A> propriété vous permet d’afficher la priorité de départ assignée à un processus. Toutefois, il est en lecture seule, vous ne pouvez pas utiliser le <xref:System.Diagnostics.Process.BasePriority%2A> pour définir la priorité du processus. Pour modifier la priorité, utilisez le <xref:System.Diagnostics.Process.PriorityClass%2A> propriété. Le <xref:System.Diagnostics.Process.BasePriority%2A> peuvent être affichées à l’aide du Moniteur système, tandis que le <xref:System.Diagnostics.Process.PriorityClass%2A> n’est pas. À la fois le <xref:System.Diagnostics.Process.BasePriority%2A> et <xref:System.Diagnostics.Process.PriorityClass%2A> peuvent être affichés par programme. Le tableau suivant montre la relation entre <xref:System.Diagnostics.Process.BasePriority%2A> valeurs et <xref:System.Diagnostics.Process.PriorityClass%2A> valeurs.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; définissez la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus s’est fermé.  
  
- ou - 
Le processus n’a pas démarré. De ce fait, il n’existe aucun ID de processus.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence des opérations de lecture asynchrones sur le flux de données <see cref="P:System.Diagnostics.Process.StandardError" /> redirigé de l'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.StandardError%2A> flux peut être lu de façon synchrone ou asynchrone. Méthodes telles que <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, et <xref:System.IO.StreamReader.ReadToEnd%2A> effectuer des opérations de lecture synchrones sur le flux de sortie d’erreur du processus. Ces synchrone lire les opérations ne se terminent pas jusqu'à ce qu’associé <xref:System.Diagnostics.Process> écrit dans son <xref:System.Diagnostics.Process.StandardError%2A> diffuser en continu ou ferme le flux.  
  
 En revanche, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> démarre asynchrone des opérations de lecture sur le <xref:System.Diagnostics.Process.StandardError%2A> flux. Cette méthode permet au gestionnaire d’événements désigné pour la sortie de flux de données et retourne immédiatement à l’appelant, ce qui peut effectuer d’autres tâches pendant que la sortie de flux est dirigée vers le Gestionnaire d’événements.  
  
 Suivez ces étapes pour effectuer des opérations de lecture asynchrones sur <xref:System.Diagnostics.Process.StandardError%2A> pour un <xref:System.Diagnostics.Process> :  
  
1.  Affectez la valeur `false` à <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>.  
  
2.  Affectez la valeur `true` à <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>.  
  
3.  Ajoutez votre gestionnaire d’événements pour le <xref:System.Diagnostics.Process.ErrorDataReceived> événement. Le Gestionnaire d’événements doit correspondre à la <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> signature du délégué.  
  
4.  Démarrer le <xref:System.Diagnostics.Process>.  
  
5.  Appelez <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> pour le <xref:System.Diagnostics.Process>. Cet appel démarre des opérations de lecture asynchrones sur <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Lorsque le démarrage des opérations de lecture asynchrone, le Gestionnaire d’événements est appelé chaque fois associé <xref:System.Diagnostics.Process> écrit une ligne de texte à son <xref:System.Diagnostics.Process.StandardError%2A> flux.  
  
 Vous pouvez annuler une opération de lecture asynchrone en appelant <xref:System.Diagnostics.Process.CancelErrorRead%2A>. L’opération de lecture peut être annulée par l’appelant ou par le Gestionnaire d’événements. Après l’annulation, vous pouvez appeler <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> à nouveau pour reprendre les opérations de lecture asynchrones.  
  
> [!NOTE]
>  Vous ne pouvez pas mélanger des opérations de lecture synchrones et asynchrones sur un flux redirigé. Une fois le flux redirigé d’une <xref:System.Diagnostics.Process> est ouvert en mode asynchrone ou synchrone, toutes les autres de lecture des opérations sur ce flux de données doivent être dans le même mode. Par exemple, ne suivez pas <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> avec un appel à <xref:System.IO.StreamReader.ReadLine%2A> sur la <xref:System.Diagnostics.Process.StandardError%2A> flux, ou vice versa. Toutefois, vous pouvez lire deux flux différents dans des modes différents. Par exemple, vous pouvez appeler <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> , puis appelez <xref:System.IO.StreamReader.ReadLine%2A> pour le <xref:System.Diagnostics.Process.StandardOutput%2A> flux.  
  
   
  
## Examples  
 L’exemple suivant utilise la `net view` commande pour répertorier les ressources réseau disponibles sur un ordinateur distant. L’utilisateur fournit le nom de l’ordinateur cible comme un argument de ligne de commande. L’utilisateur peut également fournir un nom de fichier de sortie d’erreur. L’exemple rassemble la sortie de la commande net, attend la fin du processus, puis écrit les résultats dans la console. Si l’utilisateur fournit le fichier d’erreur facultatif, l’exemple écrit les erreurs dans le fichier.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> a la valeur <see langword="false" />.  
  
\- ou - 
Une opération de lecture asynchrone est déjà en cours sur le flux <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
\- ou - 
Le flux <see cref="P:System.Diagnostics.Process.StandardError" /> a été utilisé par une opération de lecture synchrone.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence des opérations de lecture asynchrones sur le flux de données <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigé de l'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.StandardOutput%2A> flux peut être lu de façon synchrone ou asynchrone. Méthodes telles que <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, et <xref:System.IO.StreamReader.ReadToEnd%2A> effectuer des opérations de lecture synchrones sur le flux de sortie du processus. Ces synchrone lire les opérations ne se terminent pas jusqu'à ce qu’associé <xref:System.Diagnostics.Process> écrit dans son <xref:System.Diagnostics.Process.StandardOutput%2A> diffuser en continu ou ferme le flux.  
  
 En revanche, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> démarre asynchrone des opérations de lecture sur le <xref:System.Diagnostics.Process.StandardOutput%2A> flux. Cette méthode permet à un gestionnaire d’événements désigné pour la sortie de flux de données et retourne immédiatement à l’appelant, ce qui peut effectuer d’autres tâches pendant que la sortie de flux est dirigée vers le Gestionnaire d’événements.  
  
 Suivez ces étapes pour effectuer des opérations de lecture asynchrones sur <xref:System.Diagnostics.Process.StandardOutput%2A> pour un <xref:System.Diagnostics.Process> :  
  
1.  Affectez la valeur `false` à <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>.  
  
2.  Affectez la valeur `true` à <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>.  
  
3.  Ajoutez votre gestionnaire d’événements pour le <xref:System.Diagnostics.Process.OutputDataReceived> événement. Le Gestionnaire d’événements doit correspondre à la <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> signature du délégué.  
  
4.  Démarrer le <xref:System.Diagnostics.Process>.  
  
5.  Appelez <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> pour le <xref:System.Diagnostics.Process>. Cet appel démarre des opérations de lecture asynchrones sur <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Lorsque le démarrage des opérations de lecture asynchrone, le Gestionnaire d’événements est appelé chaque fois associé <xref:System.Diagnostics.Process> écrit une ligne de texte à son <xref:System.Diagnostics.Process.StandardOutput%2A> flux.  
  
 Vous pouvez annuler une opération de lecture asynchrone en appelant <xref:System.Diagnostics.Process.CancelOutputRead%2A>. L’opération de lecture peut être annulée par l’appelant ou par le Gestionnaire d’événements. Après l’annulation, vous pouvez appeler <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> à nouveau pour reprendre les opérations de lecture asynchrones.  
  
> [!NOTE]
>  Vous ne pouvez pas mélanger des opérations de lecture synchrones et asynchrones sur un flux redirigé. Une fois le flux redirigé d’une <xref:System.Diagnostics.Process> est ouvert en mode asynchrone ou synchrone, toutes les autres de lecture des opérations sur ce flux de données doivent être dans le même mode. Par exemple, ne suivez pas <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> avec un appel à <xref:System.IO.StreamReader.ReadLine%2A> sur la <xref:System.Diagnostics.Process.StandardOutput%2A> flux, ou vice versa. Toutefois, vous pouvez lire deux flux différents dans des modes différents. Par exemple, vous pouvez appeler <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , puis appelez <xref:System.IO.StreamReader.ReadLine%2A> pour le <xref:System.Diagnostics.Process.StandardError%2A> flux.  
  
   
  
## Examples  
 L’exemple suivant illustre comment effectuer des opérations de lecture asynchrones sur le redirigé <xref:System.Diagnostics.Process.StandardOutput%2A> flux de la `sort` commande. Le `sort` commande est une application console qui lit et trie les entrées de texte.  
  
 L’exemple crée un délégué d’événement pour le `SortOutputHandler` Gestionnaire d’événements et l’associe le <xref:System.Diagnostics.Process.OutputDataReceived> événement. Le Gestionnaire d’événements reçoit des lignes de texte à partir de la redirection <xref:System.Diagnostics.Process.StandardOutput%2A> stream, met en forme le texte et écrit le texte dans l’écran.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> a la valeur <see langword="false" />.  
  
\- ou - 
Une opération de lecture asynchrone est déjà en cours sur le flux <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
\- ou - 
Le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> a été utilisé par une opération de lecture synchrone.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule l'opération de lecture asynchrone sur le flux <see cref="P:System.Diagnostics.Process.StandardError" /> redirigé d'une application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> démarre une lecture asynchrone opération sur le <xref:System.Diagnostics.Process.StandardError%2A> flux. <xref:System.Diagnostics.Process.CancelErrorRead%2A> fin de l’opération de lecture asynchrone.  
  
 Après l’annulation, vous pouvez reprendre l’opération de lecture asynchrone en appelant <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> à nouveau.  
  
 Lorsque vous appelez <xref:System.Diagnostics.Process.CancelErrorRead%2A>, tous les en cours de lecture pour les opérations <xref:System.Diagnostics.Process.StandardError%2A> sont terminées puis le Gestionnaire d’événements est désactivé. Tous les sortie redirigée ultérieure vers <xref:System.Diagnostics.Process.StandardError%2A> est enregistré dans une mémoire tampon. Si vous activez à nouveau le Gestionnaire d’événements avec un appel à <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, la sortie enregistrée est envoyée au gestionnaire d’événements et reprennent les opérations de lecture asynchrones. Si vous souhaitez modifier le Gestionnaire d’événements avant de reprendre les opérations de lecture asynchrones, vous devez supprimer le Gestionnaire d’événements existant avant d’ajouter le nouveau gestionnaire d’événements :  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Vous ne pouvez pas mélanger des opérations de lecture asynchrones et synchrones sur le redirigé <xref:System.Diagnostics.Process.StandardError%2A> flux. Une fois le flux redirigé d’une <xref:System.Diagnostics.Process> est ouvert en mode asynchrone ou synchrone, toutes les autres de lecture des opérations sur ce flux de données doivent être dans le même mode. Si vous annulez une opération de lecture asynchrone sur <xref:System.Diagnostics.Process.StandardError%2A> puis devez lire le flux de nouveau, vous devez utiliser <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> pour reprendre les opérations de lecture asynchrones. Ne suivez pas <xref:System.Diagnostics.Process.CancelErrorRead%2A> avec un appel à l’une méthodes de lecture <xref:System.Diagnostics.Process.StandardError%2A> comme <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 L’exemple suivant démarre la `nmake` commande avec un utilisateur des arguments fournis. Les flux de sortie et d’erreurs sont lus de façon asynchrone ; les lignes de texte collectées sont affichées dans la console mais aussi écrites dans un fichier journal. Si la sortie de commande dépasse un nombre spécifié de lignes, les opérations de lecture asynchrones sont annulées.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardError" /> n’est pas activé pour des opérations de lecture asynchrones.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule l'opération de lecture asynchrone sur le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigé d'une application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> démarre une lecture asynchrone opération sur le <xref:System.Diagnostics.Process.StandardOutput%2A> flux. <xref:System.Diagnostics.Process.CancelOutputRead%2A> fin de l’opération de lecture asynchrone.  
  
 Après l’annulation, vous pouvez reprendre les opérations de lecture asynchrones en appelant <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> à nouveau.  
  
 Lorsque vous appelez <xref:System.Diagnostics.Process.CancelOutputRead%2A>, tous les en cours de lecture pour les opérations <xref:System.Diagnostics.Process.StandardOutput%2A> sont terminées puis le Gestionnaire d’événements est désactivé. Tous les sortie redirigée ultérieure vers <xref:System.Diagnostics.Process.StandardOutput%2A> est enregistré dans une mémoire tampon. Si vous activez à nouveau le Gestionnaire d’événements avec un appel à <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, la sortie enregistrée est envoyée au gestionnaire d’événements et reprennent les opérations de lecture asynchrones. Si vous souhaitez modifier le Gestionnaire d’événements avant de reprendre les opérations de lecture asynchrones, vous devez supprimer le Gestionnaire d’événements existant avant d’ajouter le nouveau gestionnaire d’événements :  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Vous ne pouvez pas mélanger des opérations de lecture asynchrones et synchrones sur le redirigé <xref:System.Diagnostics.Process.StandardOutput%2A> flux. Une fois le flux redirigé d’une <xref:System.Diagnostics.Process> est ouvert en mode asynchrone ou synchrone, toutes les autres de lecture des opérations sur ce flux de données doivent être dans le même mode. Si vous annulez une opération de lecture asynchrone sur <xref:System.Diagnostics.Process.StandardOutput%2A> puis devez lire le flux de nouveau, vous devez utiliser <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> pour reprendre les opérations de lecture asynchrones. Ne suivez pas <xref:System.Diagnostics.Process.CancelOutputRead%2A> avec un appel à l’une méthodes de lecture <xref:System.Diagnostics.Process.StandardOutput%2A> comme <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 L’exemple suivant démarre la `nmake` commande avec un utilisateur des arguments fournis. Les flux de sortie et d’erreurs sont lus de façon asynchrone ; les lignes de texte collectées sont affichées dans la console mais aussi écrites dans un fichier journal. Si la sortie de commande dépasse un nombre spécifié de lignes, les opérations de lecture asynchrones sont annulées.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> n’est pas activé pour des opérations de lecture asynchrones.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources associées à ce composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.Close%2A> méthode provoque le processus d’arrêt en attente de sortie si elle était en attente, ferme le handle de processus et efface les propriétés spécifiques au processus. <xref:System.Diagnostics.Process.Close%2A> ne ferme pas les lecteurs de sortie, d’entrée et d’erreur standards et les enregistreurs au cas où ils sont référencés en externe.  
  
> [!NOTE]
>  La méthode <xref:System.Diagnostics.Process.Dispose%2A> appelle <xref:System.Diagnostics.Process.Close%2A>. Placer le <xref:System.Diagnostics.Process> de l’objet dans un `using` bloc supprime les ressources sans devoir appeler <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Il récupère ensuite l’utilisation de la mémoire physique du processus associé à des intervalles de 2 secondes pour un maximum de 10 secondes. L’exemple détecte si le processus se termine avant que les 10 secondes se soient écoulées. L’exemple ferme le processus s’il s’exécute toujours après 10 secondes.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme un processus possédant une interface utilisateur en envoyant un message de fermeture à sa fenêtre principale.</summary>
        <returns>
          <see langword="true" /> si le message de fermeture a été correctement envoyé ; <see langword="false" /> si le processus associé ne possède pas de fenêtre principale ou si celle-ci est désactivée (par exemple si une boîte de dialogue modale est affichée).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un processus s’exécute, sa boucle de message est dans un état d’attente. La boucle de messages s’exécute chaque fois qu’un message Windows est envoyé au processus par le système d’exploitation. Appel <xref:System.Diagnostics.Process.CloseMainWindow%2A> envoie une demande pour fermer la fenêtre principale, qui, dans une application correcte, ferme les fenêtres enfants et révoque les boucles de messages en cours d’exécution pour l’application. La demande pour quitter le processus en appelant <xref:System.Diagnostics.Process.CloseMainWindow%2A> ne force pas l’application de quitter. L’application peut demander une vérification de l’utilisateur avant de quitter, ou elle peut refuser quitter. Pour forcer l’application à se fermer, utilisez la <xref:System.Diagnostics.Process.Kill%2A> (méthode). Le comportement de <xref:System.Diagnostics.Process.CloseMainWindow%2A> est identique à celui d’un utilisateur de fermer la fenêtre principale d’une application à l’aide du menu système. Par conséquent, la demande pour quitter le processus en fermant la fenêtre principale ne force pas l’application à se fermer immédiatement.  
  
 Les données modifiées par le processus ou les ressources allouées au processus peuvent être perdues si vous appelez <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> provoque un arrêt anormal du processus et doit être utilisé uniquement lorsque cela est nécessaire. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Active un arrêt ordonné du processus et ferme toutes les fenêtres, par conséquent, il est préférable pour les applications avec une interface. Si <xref:System.Diagnostics.Process.CloseMainWindow%2A> échoue, vous pouvez utiliser <xref:System.Diagnostics.Process.Kill%2A> pour terminer le processus. <xref:System.Diagnostics.Process.Kill%2A> est la seule façon d’arrêter les processus qui n’ont pas d’interfaces graphiques.  
  
 Vous pouvez appeler <xref:System.Diagnostics.Process.Kill%2A> et <xref:System.Diagnostics.Process.CloseMainWindow%2A> uniquement pour les processus qui sont exécutent sur l’ordinateur local. Vous ne peut pas provoquer des processus sur des ordinateurs distants pour quitter. Vous pouvez uniquement afficher des informations pour les processus exécutés sur des ordinateurs distants.  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Il récupère ensuite l’utilisation de la mémoire physique du processus associé à des intervalles de 2 secondes pour un maximum de 10 secondes. L’exemple détecte si le processus se termine avant que les 10 secondes se soient écoulées. L’exemple ferme le processus s’il s’exécute toujours après 10 secondes.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; définissez la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus est déjà terminé.  
  
- ou - 
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère toutes les ressources utilisées par ce processus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si l'événement <see cref="E:System.Diagnostics.Process.Exited" /> est déclenché quand le processus ne s'exécute plus.</summary>
        <value>
          <see langword="true" /> si l'événement <see cref="E:System.Diagnostics.Process.Exited" /> doit être déclenché une fois que le processus associé n'est plus exécuté (sortie ou appel à <see cref="M:System.Diagnostics.Process.Kill" />) ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />. Notez que le <see cref="E:System.Diagnostics.Process.Exited" /> événement est déclenché même si la valeur de <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> est <see langword="false" /> quand le processus s’arrête pendant ou avant que l’utilisateur effectue un <see cref="P:System.Diagnostics.Process.HasExited" /> vérifier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Le <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriété suggère si le composant doit être averti lorsque le système d’exploitation arrête un processus. Le <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriété est utilisée dans le traitement asynchrone pour avertir votre application un processus s’est arrêté. Pour forcer votre application à attendre de manière synchrone un événement de sortie (ce qui interrompt le traitement de l’application jusqu'à ce que l’événement de sortie s’est produite), utilisez le <xref:System.Diagnostics.Process.WaitForExit%2A> (méthode).

> [!NOTE]
> Si vous utilisez Visual Studio et double-cliquez sur un <xref:System.Diagnostics.Process> composant dans votre projet, un <xref:System.Diagnostics.Process.Exited> délégué d’événement et le Gestionnaire d’événements sont générés automatiquement. Jeux de code supplémentaire le <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriété `false`. Vous devez modifier cette propriété sur `true` pour votre gestionnaire d’événements à exécuter lorsque le processus associé s’arrête.

Si le composant <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> valeur est `true`, ou lorsque <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> est `false` et un <xref:System.Diagnostics.Process.HasExited%2A> à cocher est appelée par le composant, le composant peut accéder aux informations d’administration pour le processus associé, qui reste stockées par le système d’exploitation. Ces informations incluent le <xref:System.Diagnostics.Process.ExitTime%2A> et <xref:System.Diagnostics.Process.ExitCode%2A>.

Une fois que le processus associé s’arrête, le <xref:System.Diagnostics.Process.Handle%2A> du composant ne pointe plus vers une ressource de processus existante. Au lieu de cela, il peut uniquement être utilisé pour accéder aux informations du système d’exploitation sur la ressource de processus. Le système d’exploitation est de savoir qu’il existe des handles de processus terminés n’ont pas été libérés par <xref:System.Diagnostics.Process> composants, et il conserve donc le <xref:System.Diagnostics.Process.ExitTime%2A> et <xref:System.Diagnostics.Process.Handle%2A> informations en mémoire.

Il existe un coût associé à la regarder pour un processus s’arrête. Si <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> est `true`, le <xref:System.Diagnostics.Process.Exited> événement est déclenché lorsque le processus associé s’arrête. Vos procédures pour le <xref:System.Diagnostics.Process.Exited> événement exécuté à ce moment-là.

Parfois, votre application démarre un processus, mais ne nécessite pas la notification de sa fermeture. Par exemple, votre application peut démarrer le bloc-notes pour autoriser l’utilisateur à modifier du texte mais n’effectuez aucune autre utilisation de l’application Bloc-notes. Vous pouvez choisir éviter la notification lorsque le processus s’arrête, car il n’est pas pertinente pour le fonctionnement continu de votre application. Paramètre <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> à `false` peut économiser les ressources système.

## Examples  
L’exemple de code suivant crée un processus qui imprime un fichier. Il définit le <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriété pour que le processus déclenche le <xref:System.Diagnostics.Process.Exited> événement lors de sa sortie. Le <xref:System.Diagnostics.Process.Exited> Gestionnaire d’événements affiche des informations de processus.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met un composant <see cref="T:System.Diagnostics.Process" /> en état d'interagir avec des processus du système d'exploitation qui s'exécutent en mode spécial en activant la propriété native <see langword="SeDebugPrivilege" /> sur le thread actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains processus de système d’exploitation s’exécutent dans un mode spécial. Tente de lire les propriétés ou attacher à ces processus n’est pas possible, sauf si vous avez appelé <xref:System.Diagnostics.Process.EnterDebugMode%2A> sur le composant. Appelez <xref:System.Diagnostics.Process.LeaveDebugMode%2A> lorsque vous n’avez plus accès à ces processus qui s’exécutent en mode spécial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand une application écrit dans son flux <see cref="P:System.Diagnostics.Process.StandardError" /> redirigé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.ErrorDataReceived> événement indique que le processus associé a écrit dans son redirigé <xref:System.Diagnostics.Process.StandardError%2A> flux.  
  
 L’événement se produit uniquement pendant les opérations de lecture asynchrones sur <xref:System.Diagnostics.Process.StandardError%2A>. Pour démarrer des opérations de lecture asynchrones, vous devez rediriger le <xref:System.Diagnostics.Process.StandardError%2A> flux d’un <xref:System.Diagnostics.Process>, ajouter votre gestionnaire d’événements pour le <xref:System.Diagnostics.Process.ErrorDataReceived> événements et les appels <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Par la suite, le <xref:System.Diagnostics.Process.ErrorDataReceived> des signaux d’événements chaque fois que le processus écrit une ligne dans le redirigé <xref:System.Diagnostics.Process.StandardError%2A> diffuser en continu, jusqu'à ce que le processus se termine ou appelle <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  L’application qui traite la sortie asynchrone doit appeler la <xref:System.Diagnostics.Process.WaitForExit> méthode pour vous assurer que le tampon de sortie a été vidé. Notez qu’en spécifiant un délai d’attente à l’aide de la <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> surcharge est *pas* vous assurer de la mémoire tampon de sortie a été vidé.
  
   
  
## Examples  
 L’exemple suivant utilise la `net view` commande pour répertorier les ressources réseau disponibles sur un ordinateur distant. L’utilisateur fournit le nom de l’ordinateur cible comme un argument de ligne de commande. L’utilisateur peut également fournir un nom de fichier de sortie d’erreur. L’exemple rassemble la sortie de la commande net, attend la fin du processus, puis écrit les résultats dans la console. Si l’utilisateur fournit le fichier d’erreur facultatif, l’exemple écrit les erreurs dans le fichier.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur spécifiée par le processus associé au moment où il s'est terminé.</summary>
        <value>Code spécifié par le processus associé une fois celui-ci terminé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Diagnostics.Process.ExitCode%2A> pour obtenir l’état retourné par le système processus quand il s’est arrêté. Vous pouvez utiliser le code de sortie beaucoup comme entier retournent la valeur à partir d’un `main()` procédure.  
  
 Le <xref:System.Diagnostics.Process.ExitCode%2A> valeur pour un processus reflète la convention spécifique implémentée par le développeur d’applications pour ce processus. Si vous utilisez la valeur de code de sortie pour prendre des décisions dans votre code, n’oubliez pas que vous connaissez la convention de code de sortie utilisée par le processus d’application.  
  
 Les développeurs indiquent généralement un arrêt réussi par une <xref:System.Diagnostics.Process.ExitCode%2A> valeur de zéro et désignent les erreurs par des valeurs différentes de zéro que la méthode d’appel peut utiliser pour identifier la cause d’un arrêt anormal du processus. Il n’est pas nécessaire de suivre ces instructions, mais ils sont la convention.  
  
 Si vous tentez d’obtenir le <xref:System.Diagnostics.Process.ExitCode%2A> avant que le processus est terminé, la tentative lève une exception. Examiner le <xref:System.Diagnostics.Process.HasExited%2A> propriété pour vérifier si le processus associé s’est terminé.  
  
> [!NOTE]
>  Lors de la sortie standard a été redirigée vers les gestionnaires d’événements asynchrones, il est possible que le traitement de sortie ne soit pas terminé lorsque <xref:System.Diagnostics.Process.HasExited%2A> retourne `true`. Pour vous assurer que la gestion des événements asynchrone sont terminée, appelez le <xref:System.Diagnostics.Process.WaitForExit> surcharge qui ne prend aucun paramètre avant de vérifier <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Vous pouvez utiliser la <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A> méthode pour provoquer un processus associé s’arrête.  
  
 Il existe deux façons d’être informé quand le processus associé s’arrête : façon synchrone et asynchrone. Une notification synchrone repose sur l’appel la <xref:System.Diagnostics.Process.WaitForExit%2A> méthode pour suspendre le traitement de votre application jusqu'à ce que le composant associé s’arrête. Notification asynchrone s’appuie sur le <xref:System.Diagnostics.Process.Exited> événement. Lors de l’utilisation de la notification asynchrone, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> doit être définie sur `true` pour le <xref:System.Diagnostics.Process> composant averti que le processus est terminé.  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le processus ne s’est pas fermé.  
  
- ou - 
Le processus <see cref="P:System.Diagnostics.Process.Handle" /> n’est pas valide.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.ExitCode" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand un processus se termine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.Exited> événement indique que le processus associé s’est terminé. Cet événement signifie que le processus terminé (abandonnée) ou a été fermé. Cet événement peut se produire uniquement si la valeur de la <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriété est `true`.  
  
 Il existe deux façons d’être informé quand le processus associé s’arrête : façon synchrone et asynchrone. Une notification synchrone signifie appeler le <xref:System.Diagnostics.Process.WaitForExit%2A> méthode pour bloquer le thread actuel jusqu'à ce que le processus se termine. Notification asynchrone utilise les <xref:System.Diagnostics.Process.Exited> événement, ce qui permet au thread appelant de continuer l’exécution en attendant. Dans ce cas, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> doit être définie sur `true` pour l’application appelante recevoir l’événement a quitté.  
  
 Lorsque le système d’exploitation arrête un processus, il avertit tous les autres processus qui ont inscrit des gestionnaires pour l’événement a quitté. À ce stade, le handle du processus qui vient de quitter peut être utilisé pour accéder à certaines propriétés telles que <xref:System.Diagnostics.Process.ExitTime%2A> et <xref:System.Diagnostics.Process.HasExited%2A> que le système d’exploitation gère jusqu'à ce qu’il libère ce handle complètement.  
  
> [!NOTE]
>  Même si vous disposez d’un handle vers le processus terminé, vous ne pouvez pas appeler <xref:System.Diagnostics.Process.Start%2A> à nouveau pour vous reconnecter au même processus. Appel <xref:System.Diagnostics.Process.Start%2A> automatiquement libère le processus associé et se connecte à un processus avec le même fichier, mais une toute nouvelle <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Pour plus d’informations sur l’utilisation de la <xref:System.Diagnostics.Process.Exited> événement dans les applications Windows Forms, consultez le <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant crée un processus qui imprime un fichier. Il déclenche le <xref:System.Diagnostics.Process.Exited> événement lorsque le processus se termine parce que le <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriété a été définie lorsque le processus a été créé. Le <xref:System.Diagnostics.Process.Exited> Gestionnaire d’événements affiche des informations de processus.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'heure à laquelle le processus associé s'est terminé.</summary>
        <value>
          <see cref="T:System.DateTime" /> qui indique le moment où le processus associé s'est terminé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le processus n’a pas été arrêté, tentez de récupérer le <xref:System.Diagnostics.Process.ExitTime%2A> propriété lève une exception. Utilisez <xref:System.Diagnostics.Process.HasExited%2A> avant d’obtenir le <xref:System.Diagnostics.Process.ExitTime%2A> propriété afin de déterminer si le processus associé s’est terminé.  
  
   
  
## Examples  
 L’exemple de code suivant crée un processus qui imprime un fichier. Déclenche le processus le <xref:System.Diagnostics.Process.Exited> événement quand il s’arrête et le Gestionnaire d’événements affiche les <xref:System.Diagnostics.Process.ExitTime%2A> traitement les propriété et autres informations.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.ExitTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un nouveau composant <see cref="T:System.Diagnostics.Process" /> et l'associe au processus actuellement actif.</summary>
        <returns>Nouveau composant <see cref="T:System.Diagnostics.Process" /> associé à la ressource de processus qui exécute l'application appelante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un nouveau <xref:System.Diagnostics.Process> d’instance et l’associer à la ressource de processus sur l’ordinateur local.  
  
 Comme le similaire <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, et <xref:System.Diagnostics.Process.GetProcesses%2A> méthodes, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associe une ressource existante à un nouveau <xref:System.Diagnostics.Process> composant.  
  
   
  
## Examples  
 L’exemple suivant récupère les informations du processus en cours, les processus en cours d’exécution sur l’ordinateur local, toutes les instances du bloc-notes en cours d’exécution sur l’ordinateur local et un processus spécifique sur l’ordinateur local. Il récupère ensuite des informations pour les mêmes processus sur un ordinateur distant.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nouveau composant <see cref="T:System.Diagnostics.Process" /> et l'associe à la ressource de processus existante que vous spécifiez.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Identificateur unique au système d'une ressource de processus.</param>
        <summary>Retourne un nouveau composant <see cref="T:System.Diagnostics.Process" />, en fonction de l'identificateur d'un processus sur l'ordinateur local.</summary>
        <returns>Composant <see cref="T:System.Diagnostics.Process" /> associé à la ressource de processus locale identifiée par le paramètre <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un nouveau <xref:System.Diagnostics.Process> composant et l’associer à une ressource de processus sur l’ordinateur local. La ressource de processus doit déjà exister sur l’ordinateur, car <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> ne crée pas une ressource système, mais associe plutôt une ressource à un générés par l’application <xref:System.Diagnostics.Process> composant. Un processus <xref:System.Diagnostics.Process.Id%2A> peuvent être récupérées uniquement pour un processus en cours d’exécution sur l’ordinateur. Une fois que le processus se termine, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> lève une exception si vous lui passez un identificateur qui a expiré.  
  
 Sur n’importe quel ordinateur particulier, l’identificateur d’un processus est unique. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Retourne un processus au maximum. Si vous souhaitez obtenir tous les processus en cours d’exécution une application particulière, utilisez <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Si plusieurs processus sur l’ordinateur exécutant l’application spécifiée, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> retourne un tableau contenant tous les processus associés. Vous pouvez interroger chacun de ces processus à son tour pour son identificateur. L’identificateur de processus peut être affiché dans le `Processes` Panneau de configuration du Gestionnaire des tâches Windows. Le `PID` colonne affiche l’identificateur de processus qui est attribué à un processus.  
  
 Le `processId` paramètre est un <xref:System.Int32> (un entier 32 bits signé), bien que l’API Windows sous-jacente utilise un `DWORD` (entier non signé 32 bits) pour les API similaire. Il s’agit pour des raisons historiques.
  
## Examples  
 L’exemple suivant récupère les informations du processus en cours, les processus en cours d’exécution sur l’ordinateur local, toutes les instances du bloc-notes en cours d’exécution sur l’ordinateur local et un processus spécifique sur l’ordinateur local. Il récupère ensuite des informations pour les mêmes processus sur un ordinateur distant.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le processus spécifié par le paramètre <paramref name="processId" /> n’est pas en cours d’exécution. L’identificateur peut avoir expiré.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus n’a pas été démarré par cet objet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Identificateur unique au système d'une ressource de processus.</param>
        <param name="machineName">Nom d'un ordinateur du réseau.</param>
        <summary>Retourne un nouveau composant <see cref="T:System.Diagnostics.Process" />, en fonction d'un identificateur de processus et du nom d'un ordinateur du réseau.</summary>
        <returns>Composant <see cref="T:System.Diagnostics.Process" /> associé à une ressource de processus distante identifiée par le paramètre <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un nouveau <xref:System.Diagnostics.Process> composant et l’associer à une ressource de processus sur un ordinateur distant sur le réseau. La ressource de processus doit déjà exister sur l’ordinateur spécifié, car <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> ne crée pas une ressource système, mais associe plutôt une ressource à un générés par l’application <xref:System.Diagnostics.Process> composant. Un processus <xref:System.Diagnostics.Process.Id%2A> peuvent être récupérées uniquement pour un processus en cours d’exécution sur l’ordinateur. Une fois que le processus se termine, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> lève une exception si vous lui passez un identificateur qui a expiré.  
  
 Sur n’importe quel ordinateur particulier, l’identificateur d’un processus est unique. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Retourne un processus au maximum. Si vous souhaitez obtenir tous les processus en cours d’exécution une application particulière, utilisez <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Si plusieurs processus sur l’ordinateur exécutant l’application spécifiée, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> retourne un tableau contenant tous les processus associés. Vous pouvez interroger chacun de ces processus à son tour pour son identificateur. L’identificateur de processus peut être affiché dans le `Processes` Panneau de configuration du Gestionnaire des tâches Windows. Le `PID` colonne affiche l’identificateur de processus qui est attribué à un processus.  
  
 Si vous ne spécifiez pas un `machineName`, l’ordinateur local est utilisé. Vous pouvez également spécifier l’ordinateur local en définissant `machineName` à la valeur «. » ou une chaîne vide (« »).  
  
 Le `processId` paramètre est un <xref:System.Int32> (un entier 32 bits signé), bien que l’API Windows sous-jacente utilise un `DWORD` (entier non signé 32 bits) pour les API similaire. Il s’agit pour des raisons historiques.   
  
## Examples  
 L’exemple suivant récupère les informations du processus en cours, les processus en cours d’exécution sur l’ordinateur local, toutes les instances du bloc-notes en cours d’exécution sur l’ordinateur local et un processus spécifique sur l’ordinateur local. Il récupère ensuite des informations pour les mêmes processus sur un ordinateur distant.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le processus spécifié par le paramètre <paramref name="processId" /> n’est pas en cours d’exécution. L’identificateur peut avoir expiré.  
  
- ou - 
La syntaxe du paramètre <paramref name="machineName" /> n’est pas valide. Le nom peut être de longueur zéro (0).</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="machineName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus n’a pas été démarré par cet objet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un tableau de nouveaux composants <see cref="T:System.Diagnostics.Process" /> et les associe à des ressources de processus existantes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un composant <see cref="T:System.Diagnostics.Process" /> pour chaque ressource de processus sur l'ordinateur local.</summary>
        <returns>Tableau de type <see cref="T:System.Diagnostics.Process" /> représentant toutes les ressources de processus exécutées sur l'ordinateur local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un tableau de nouveaux <xref:System.Diagnostics.Process> composants et les associer à toutes les ressources de processus sur l’ordinateur local. Les ressources de processus doivent déjà exister sur l’ordinateur local, car <xref:System.Diagnostics.Process.GetProcesses%2A> ne crée pas de ressources système, mais associe plutôt les ressources générés par l’application <xref:System.Diagnostics.Process> composants. Étant donné que le système d’exploitation lui-même est en cours d’exécution des processus d’arrière-plan, ce tableau n’est jamais vide.  
  
 Si vous ne souhaitez pas récupérer tous les processus en cours d’exécution sur l’ordinateur, vous pouvez restreindre leur nombre à l’aide de la <xref:System.Diagnostics.Process.GetProcessById%2A> ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> (méthode). <xref:System.Diagnostics.Process.GetProcessById%2A> Crée un <xref:System.Diagnostics.Process> composant qui est associé au processus identifié sur le système par l’identificateur de processus que vous passez à la méthode. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Crée un tableau de <xref:System.Diagnostics.Process> composants dont les ressources des processus associés partagent le fichier exécutable que vous passez à la méthode.  
  
> [!NOTE]
>  Plusieurs services Windows peuvent être chargées dans la même instance du processus hôte de Service (svchost.exe). GetProcesses n’identifie pas ces services individuels ; Pour ce faire, consultez <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 L’exemple suivant récupère les informations du processus en cours, les processus en cours d’exécution sur l’ordinateur local, toutes les instances du bloc-notes en cours d’exécution sur l’ordinateur local et un processus spécifique sur l’ordinateur local. Il récupère ensuite des informations pour les mêmes processus sur un ordinateur distant.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Ordinateur à partir duquel lire la liste de processus.</param>
        <summary>Crée un composant <see cref="T:System.Diagnostics.Process" /> pour chaque ressource de processus sur l'ordinateur spécifié.</summary>
        <returns>Tableau de type <see cref="T:System.Diagnostics.Process" /> représentant toutes les ressources de processus exécutées sur l'ordinateur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un tableau de nouveaux <xref:System.Diagnostics.Process> composants et les associer à toutes les ressources de processus sur l’ordinateur spécifié (généralement à distance). Les ressources de processus doivent déjà exister sur l’ordinateur local, car <xref:System.Diagnostics.Process.GetProcesses%2A> ne crée pas de ressources système, mais associe plutôt les ressources générés par l’application <xref:System.Diagnostics.Process> composants. Étant donné que le système d’exploitation lui-même est en cours d’exécution des processus d’arrière-plan, ce tableau n’est jamais vide.  
  
 Si vous ne souhaitez pas récupérer tous les processus en cours d’exécution sur l’ordinateur, vous pouvez restreindre leur nombre à l’aide de la <xref:System.Diagnostics.Process.GetProcessById%2A> ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> (méthode). <xref:System.Diagnostics.Process.GetProcessById%2A> Crée un <xref:System.Diagnostics.Process> composant qui est associé au processus identifié sur le système par l’identificateur de processus que vous passez à la méthode. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Crée un tableau de <xref:System.Diagnostics.Process> composants dont les ressources des processus associés partagent le fichier exécutable que vous passez à la méthode.  
  
 Cette surcharge de la <xref:System.Diagnostics.Process.GetProcesses%2A> méthode est généralement utilisée pour récupérer la liste des ressources de processus en cours d’exécution sur un ordinateur distant sur le réseau, mais vous pouvez spécifier l’ordinateur local en passant «. ».  
  
> [!NOTE]
>  Plusieurs services Windows peuvent être chargées dans la même instance du processus hôte de Service (svchost.exe). GetProcesses n’identifie pas ces services individuels ; Pour ce faire, consultez <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 L’exemple suivant récupère les informations du processus en cours, les processus en cours d’exécution sur l’ordinateur local, toutes les instances du bloc-notes en cours d’exécution sur l’ordinateur local et un processus spécifique sur l’ordinateur local. Il récupère ensuite des informations pour les mêmes processus sur un ordinateur distant.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La syntaxe du paramètre <paramref name="machineName" /> n’est pas valide. Sa longueur est peut-être égale à zéro (0).</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="machineName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme du système d’exploitation ne prend pas en charge cette opération sur les ordinateurs distants.</exception>
        <exception cref="T:System.InvalidOperationException">L’accès à l’API du compteur de performance pour obtenir des informations sur les processus présente des problèmes. Cette exception est propre à Windows NT, Windows 2000 et Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Un problème s’est produit pendant l’accès à l’API système sous-jacente.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un tableau de nouveaux composants <see cref="T:System.Diagnostics.Process" /> et les associe à des ressources de processus existantes qui partagent toutes le nom de processus spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Nom convivial du processus.</param>
        <summary>Crée un tableau de nouveaux composants <see cref="T:System.Diagnostics.Process" /> et les associe à toutes les ressources de processus de l'ordinateur local qui partagent le nom de processus spécifié.</summary>
        <returns>Tableau de type <see cref="T:System.Diagnostics.Process" /> représentant les ressources de processus exécutant l'application ou le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un tableau de nouveaux <xref:System.Diagnostics.Process> composants et les associer à toutes les ressources de processus qui exécutent le même fichier exécutable sur l’ordinateur local. Les ressources de processus doivent déjà exister sur l’ordinateur, car <xref:System.Diagnostics.Process.GetProcessesByName%2A> ne crée pas de ressources système, mais plutôt les associe générés par l’application <xref:System.Diagnostics.Process> composants. Un `processName` peut être spécifié pour un fichier exécutable qui n'est pas en cours d’exécution sur l’ordinateur local, le tableau retourné par la méthode peut être vide.  
  
 Le nom du processus est un nom convivial pour le processus, tel qu’Outlook, qui n’inclut pas l’extension .exe ou le chemin d’accès. <xref:System.Diagnostics.Process.GetProcessesByName%2A> est utile pour l’obtention et la manipulation de tous les processus qui sont associés au même fichier exécutable. Par exemple, vous pouvez passer un nom de fichier exécutable en tant que le `processName` paramètre, afin d’arrêter toutes les instances en cours d’exécution de ce fichier exécutable.  
  
 Bien qu’un processus <xref:System.Diagnostics.Process.Id%2A> est unique dans une seule ressource de processus sur le système, plusieurs processus sur l’ordinateur local peuvent exécuter l’application spécifiée par la `processName` paramètre. Par conséquent, <xref:System.Diagnostics.Process.GetProcessById%2A> retourne un processus au maximum, mais <xref:System.Diagnostics.Process.GetProcessesByName%2A> retourne un tableau contenant tous les processus associés. Si vous avez besoin manipuler le processus à l’aide d’appels d’API standard, vous pouvez interroger chacun de ces processus à son tour pour son identificateur. Vous ne peut pas accéder aux ressources de processus uniquement par le processus nom mais une fois que vous avez récupéré un tableau de <xref:System.Diagnostics.Process> composants qui ont été associées avec les ressources de processus, vous pouvez démarrer, arrêter et sinon manipuler les ressources système.  
  
   
  
## Examples  
 L’exemple suivant récupère les informations du processus en cours, les processus en cours d’exécution sur l’ordinateur local, toutes les instances du bloc-notes en cours d’exécution sur l’ordinateur local et un processus spécifique sur l’ordinateur local. Il récupère ensuite des informations pour les mêmes processus sur un ordinateur distant.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L’accès à l’API du compteur de performance pour obtenir des informations sur les processus présente des problèmes. Cette exception est spécifique à Windows NT, Windows 2000 et Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Nom convivial du processus.</param>
        <param name="machineName">Nom d'un ordinateur du réseau.</param>
        <summary>Crée un tableau de nouveaux composants <see cref="T:System.Diagnostics.Process" /> et les associe à toutes les ressources de processus sur l'ordinateur distant qui partagent le nom de processus spécifié.</summary>
        <returns>Tableau de type <see cref="T:System.Diagnostics.Process" /> représentant les ressources de processus exécutant l'application ou le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un tableau de nouveaux <xref:System.Diagnostics.Process> composants et les associer à toutes les ressources de processus qui exécutent le même fichier exécutable sur l’ordinateur spécifié. Les ressources de processus doivent déjà exister sur l’ordinateur, car <xref:System.Diagnostics.Process.GetProcessesByName%2A> ne crée pas de ressources système, mais plutôt les associe générés par l’application <xref:System.Diagnostics.Process> composants. Un `processName` peut être spécifié pour un fichier exécutable qui n'est pas en cours d’exécution sur l’ordinateur local, le tableau retourné par la méthode peut être vide.  
  
 Le nom du processus est un nom convivial pour le processus, tel qu’Outlook, qui n’inclut pas l’extension .exe ou le chemin d’accès. <xref:System.Diagnostics.Process.GetProcessesByName%2A> est utile pour l’obtention et la manipulation de tous les processus qui sont associés au même fichier exécutable. Par exemple, vous pouvez passer un nom de fichier exécutable en tant que le `processName` paramètre, afin d’arrêter toutes les instances en cours d’exécution de ce fichier exécutable.  
  
 Bien qu’un processus <xref:System.Diagnostics.Process.Id%2A> est unique dans une seule ressource de processus sur le système, plusieurs processus sur l’ordinateur local peuvent exécuter l’application spécifiée par la `processName` paramètre. Par conséquent, <xref:System.Diagnostics.Process.GetProcessById%2A> retourne un processus au maximum, mais <xref:System.Diagnostics.Process.GetProcessesByName%2A> retourne un tableau contenant tous les processus associés. Si vous avez besoin manipuler le processus à l’aide d’appels d’API standard, vous pouvez interroger chacun de ces processus à son tour pour son identificateur. Vous ne peut pas accéder aux ressources de processus uniquement par le processus nom mais une fois que vous avez récupéré un tableau de <xref:System.Diagnostics.Process> composants qui ont été associées avec les ressources de processus, vous pouvez démarrer, arrêter et sinon manipuler les ressources système.  
  
 Vous pouvez utiliser cette surcharge pour obtenir des processus sur l’ordinateur local ainsi que sur un ordinateur distant. Utilisez «. » pour spécifier l’ordinateur local. Il existe une autre surcharge qui utilise l’ordinateur local par défaut.  
  
 Vous pouvez accéder à des processus sur des ordinateurs distants uniquement pour afficher les informations, telles que les statistiques, les processus. Vous ne pouvez pas fermer, arrêter (à l’aide de <xref:System.Diagnostics.Process.Kill%2A>), ou démarrer des processus sur des ordinateurs distants.  
  
   
  
## Examples  
 L’exemple suivant récupère les informations du processus en cours, les processus en cours d’exécution sur l’ordinateur local, toutes les instances du bloc-notes en cours d’exécution sur l’ordinateur local et un processus spécifique sur l’ordinateur local. Il récupère ensuite des informations pour les mêmes processus sur un ordinateur distant.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La syntaxe du paramètre <paramref name="machineName" /> n’est pas valide. Sa longueur est peut-être égale à zéro (0).</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="machineName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme du système d’exploitation ne prend pas en charge cette opération sur les ordinateurs distants.</exception>
        <exception cref="T:System.InvalidOperationException">L’accès à l’API du compteur de performance pour obtenir des informations sur les processus présente des problèmes. Cette exception est propre à Windows NT, Windows 2000 et Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Un problème s’est produit pendant l’accès à l’API système sous-jacente.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle natif du processus associé.</summary>
        <value>Handle que le système d'exploitation a assigné au processus associé au moment du démarrage du processus. Le système utilise ce handle pour assurer le suivi des attributs du processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application peut obtenir un handle à un processus qui peut être utilisé en tant que paramètre dans de nombreuses fonctions de contrôle et les informations de processus. Vous pouvez utiliser ce handle pour initialiser un <xref:System.Threading.WaitHandle> ou d’appeler des méthodes natives avec plateforme appellent.  
  
 Ce handle de processus est privé pour une application, en d’autres termes, processus handles ne peuvent pas être partagés. Un processus possède également un processus <xref:System.Diagnostics.Process.Id%2A> qui, contrairement à la <xref:System.Diagnostics.Process.Handle%2A>, est unique et, par conséquent, valide dans le système.  
  
 Seuls les processus démarrés par un appel à <xref:System.Diagnostics.Process.Start%2A> définir le <xref:System.Diagnostics.Process.Handle%2A> propriété correspondante <xref:System.Diagnostics.Process> instances.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le processus n’a pas été démarré ou s’est arrêté. La propriété <see cref="P:System.Diagnostics.Process.Handle" /> ne peut pas être lue, car il n’existe aucun processus associé à cette instance <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
L’instance <see cref="T:System.Diagnostics.Process" /> a été attachée à un processus en cours d’exécution, mais vous n’avez pas les autorisations nécessaires pour obtenir un handle avec des droits d’accès complets.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.Handle" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de handles ouverts par le processus.</summary>
        <value>Nombre de handles du système d'exploitation ouverts par le processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handles fournissent un moyen pour un processus faire référence aux objets. Un processus peut obtenir des handles de fichiers, de ressources, de files d’attente et de nombreux autres objets de système d’exploitation. Le système d’exploitation libère la mémoire associée au processus uniquement lorsque le nombre de handles est égal à zéro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; définissez la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le processus associé s'est terminé.</summary>
        <value>
          <see langword="true" /> si le processus du système d'exploitation référencé par le composant <see cref="T:System.Diagnostics.Process" /> s'est terminé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur `true` pour <xref:System.Diagnostics.Process.HasExited%2A> indique que le processus associé s’est terminée, normale ou anormale. Vous pouvez demander ou forcer le processus associé s’arrête en appelant <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Si un handle est ouvert pour le processus, le système d’exploitation libère la mémoire de processus lorsque le processus s’est arrêté, mais conserve les informations d’administration sur le processus, tels que le handle, le code de sortie et le moment de la sortie. Pour obtenir ces informations, vous pouvez utiliser la <xref:System.Diagnostics.Process.ExitCode%2A> et <xref:System.Diagnostics.Process.ExitTime%2A> propriétés. Ces propriétés sont remplies automatiquement pour les processus qui ont été démarrés par ce composant. Les informations d’administration sont libérées lorsque tous les le <xref:System.Diagnostics.Process> composants qui sont associées au processus système sont détruits et maintenez n’y a plus de handles du processus arrêté.  
  
 Un processus peut se terminer indépendamment de votre code. Si vous avez démarré le processus à l’aide de ce composant, le système met à jour la valeur de <xref:System.Diagnostics.Process.HasExited%2A> automatiquement, même si le processus associé s’arrête de manière indépendante.  
  
> [!NOTE]
>  Lors de la sortie standard a été redirigée vers les gestionnaires d’événements asynchrones, il est possible que le traitement de sortie ne soit pas terminé lorsque cette propriété retourne `true`. Pour vous assurer que la gestion des événements asynchrone sont terminée, appelez le <xref:System.Diagnostics.Process.WaitForExit> surcharge qui ne prend aucun paramètre avant de vérifier <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Il récupère ensuite l’utilisation de la mémoire physique du processus associé à des intervalles de 2 secondes pour un maximum de 10 secondes. L’exemple détecte si le processus se termine avant que les 10 secondes se soient écoulées. L’exemple ferme le processus s’il s’exécute toujours après 10 secondes.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun processus n’est associé à l’objet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Nous n’avons pas pu récupéré le code de sortie pour le processus.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.HasExited" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur unique du processus associé.</summary>
        <value>Identificateur unique généré par le système du processus référencé par cette instance <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le processus <xref:System.Diagnostics.Process.Id%2A> n’est pas valide si le processus associé n’est pas en cours d’exécution. Par conséquent, vous devez vous assurer que le processus est en cours d’exécution avant de tenter de récupérer le <xref:System.Diagnostics.Process.Id%2A> propriété. Jusqu'à ce que le processus se termine, l’identificateur de processus identifie de façon unique le processus dans tout le système.  
  
 Vous pouvez vous connecter à un processus qui s’exécute sur un ordinateur local ou distant vers un nouveau <xref:System.Diagnostics.Process> instance en passant l’identificateur de processus pour le <xref:System.Diagnostics.Process.GetProcessById%2A> (méthode). <xref:System.Diagnostics.Process.GetProcessById%2A> est un `static` méthode qui crée un nouveau composant et définit le <xref:System.Diagnostics.Process.Id%2A> propriété pour le nouveau <xref:System.Diagnostics.Process> automatiquement l’instance.  
  
 Identificateurs de processus peuvent être réutilisées par le système. Le <xref:System.Diagnostics.Process.Id%2A> valeur de propriété est unique que pendant l’exécution du processus associé. Une fois que le processus est terminé, le système peut réutiliser la <xref:System.Diagnostics.Process.Id%2A> valeur de propriété pour un processus non apparenté.  
  
 Étant donné que l’identificateur est unique sur le système, vous pouvez le passer à d’autres threads comme alternative à passer un <xref:System.Diagnostics.Process> instance. Cette action peut économiser les ressources système encore garantir que le processus est identifié correctement.  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir le <xref:System.Diagnostics.Process.Id%2A> pour tous les exécutant des instances d’une application. Le code crée une nouvelle instance du bloc-notes, répertorie toutes les instances du bloc-notes, puis permet à l’utilisateur à entrer le <xref:System.Diagnostics.Process.Id%2A> valeur afin de supprimer une instance spécifique.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.Process.Id" /> du processus n’a pas été définie.  
  
- ou - 
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; définissez la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête immédiatement le processus associé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> force un arrêt du processus, tandis que <xref:System.Diagnostics.Process.CloseMainWindow%2A> demande uniquement un arrêt. Quand un processus avec une interface graphique s’exécute, sa boucle de message est dans un état d’attente. La boucle de messages s’exécute chaque fois qu’un message Windows est envoyé au processus par le système d’exploitation. Appel <xref:System.Diagnostics.Process.CloseMainWindow%2A> envoie une demande pour fermer la fenêtre principale, qui, dans une application correcte, ferme les fenêtres enfants et révoque les boucles de messages en cours d’exécution pour l’application. La demande pour quitter le processus en appelant <xref:System.Diagnostics.Process.CloseMainWindow%2A> ne force pas l’application de quitter. L’application peut demander une vérification de l’utilisateur avant de quitter, ou elle peut refuser quitter. Pour forcer l’application à se fermer, utilisez la <xref:System.Diagnostics.Process.Kill%2A> (méthode). Le comportement de <xref:System.Diagnostics.Process.CloseMainWindow%2A> est identique à celui d’un utilisateur de fermer la fenêtre principale d’une application à l’aide du menu système. Par conséquent, la demande pour quitter le processus en fermant la fenêtre principale ne force pas l’application à se fermer immédiatement.  
  
> [!NOTE]
>  Le <xref:System.Diagnostics.Process.Kill%2A> méthode s’exécute de façon asynchrone. Après avoir appelé la <xref:System.Diagnostics.Process.Kill%2A> méthode, appelez le <xref:System.Diagnostics.Process.WaitForExit%2A> méthode pour attendre le processus s’arrête ou vérifiez le <xref:System.Diagnostics.Process.HasExited%2A> propriété afin de déterminer si le processus s’est arrêté.  
  
 Les données modifiées par le processus ou les ressources allouées au processus peuvent être perdues si vous appelez <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> provoque un arrêt anormal du processus et doit être utilisé uniquement lorsque cela est nécessaire. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Active un arrêt ordonné du processus et ferme toutes les fenêtres, par conséquent, il est préférable pour les applications avec une interface. Si <xref:System.Diagnostics.Process.CloseMainWindow%2A> échoue, vous pouvez utiliser <xref:System.Diagnostics.Process.Kill%2A> pour terminer le processus. <xref:System.Diagnostics.Process.Kill%2A> est la seule façon d’arrêter les processus qui n’ont pas d’interfaces graphiques.  
  
 Vous pouvez appeler <xref:System.Diagnostics.Process.Kill%2A> et <xref:System.Diagnostics.Process.CloseMainWindow%2A> uniquement pour les processus qui sont exécutent sur l’ordinateur local. Vous ne peut pas provoquer des processus sur des ordinateurs distants pour quitter. Vous pouvez uniquement afficher des informations pour les processus exécutés sur des ordinateurs distants.  
  
> [!NOTE]
>  Si l’appel à la <xref:System.Diagnostics.Process.Kill%2A> méthode est effectuée lorsque le processus s’arrête, un <xref:System.ComponentModel.Win32Exception> est levée pour accès refusé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Le processus associé n’a pas pu être arrêté.  
  
- ou - 
Le processus est en train de se terminer.  
  
- ou - 
Le processus associé est un fichier exécutable Win16.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’appeler <see cref="M:System.Diagnostics.Process.Kill" /> pour un processus en cours d’exécution sur un ordinateur distant. La méthode est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus est déjà terminé.  
  
- ou - 
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met un composant <see cref="T:System.Diagnostics.Process" /> hors de l'état qui lui permet d'interagir avec des processus du système d'exploitation qui s'exécutent en mode spécial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains processus de système d’exploitation s’exécutent dans un mode spécial. Tente de lire les propriétés ou attacher à ces processus n’est pas possible, sauf si vous avez appelé <xref:System.Diagnostics.Process.EnterDebugMode%2A> sur le composant. Appelez <xref:System.Diagnostics.Process.LeaveDebugMode%2A> lorsque vous n’avez plus accès à ces processus qui s’exécutent en mode spécial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de l'ordinateur sur lequel s'exécute le processus associé.</summary>
        <value>Nom de l'ordinateur sur lequel s'exécute le processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez afficher des données statistiques et informations sur les processus en cours d’exécution sur des ordinateurs distants, mais vous ne pouvez pas appeler <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, ou <xref:System.Diagnostics.Process.Kill%2A> sur des ordinateurs distants.  
  
> [!NOTE]
>  Lorsque le processus associé s’exécute sur l’ordinateur local, cette propriété retourne un point («. ») pour le nom de l’ordinateur. Vous devez utiliser le <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriété à obtenir le nom d’ordinateur correct.  
  
   
  
## Examples  
 Pour utiliser l’exemple suivant, vous devez d’abord démarrer au moins une instance de bloc-notes sur un ordinateur distant. L’exemple demande le nom de l’ordinateur distant sur lequel le bloc-notes est en cours d’exécution, puis affiche le texte respectives <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, et <xref:System.Diagnostics.Process.MachineName%2A> propriétés pour chaque instance.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le module principal pour le processus associé.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessModule" /> qui a été utilisé pour démarrer le processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un module de processus représente un fichier.dll ou .exe chargé dans un processus particulier. Le <xref:System.Diagnostics.Process.MainModule%2A> propriété vous permet d’afficher des informations sur l’exécutable utilisé pour démarrer le processus, y compris le nom du module, nom de fichier et détails du module de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MainModule" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Un processus 32 bits tente d’accéder aux modules d’un processus 64 bits.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; définissez <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.  
  
- ou - 
Le processus s’est fermé.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle de la fenêtre principale du processus associé.</summary>
        <value>Handle, généré par le système, de la fenêtre principale du processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La fenêtre principale est la fenêtre ouverte par le processus qui a actuellement le focus (le <xref:System.Windows.Forms.Form.TopLevel%2A> formulaire). Vous devez utiliser le <xref:System.Diagnostics.Process.Refresh%2A> méthode pour actualiser le <xref:System.Diagnostics.Process> objet pour lequel obtenir le handle de fenêtre principale actuelle si elle a changé. En général, étant donné que le handle de fenêtre est mis en cache, utilisez <xref:System.Diagnostics.Process.Refresh%2A> avance pour garantir que vous allez récupérer le handle actuel.  
  
 Vous pouvez obtenir le <xref:System.Diagnostics.Process.MainWindowHandle%2A> propriété uniquement pour les processus qui s’exécutent sur l’ordinateur local. Le <xref:System.Diagnostics.Process.MainWindowHandle%2A> propriété est une valeur qui identifie de façon unique la fenêtre qui est associée au processus.  
  
 Un processus possède une fenêtre principale associée uniquement si le processus a une interface graphique. Si le processus associé ne possède pas de fenêtre principale, le <xref:System.Diagnostics.Process.MainWindowHandle%2A> valeur est égale à zéro. La valeur est également zéro pour les processus qui ont été masqués, autrement dit, les processus qui ne sont pas visibles dans la barre des tâches. Cela peut être le cas pour les processus qui s’affichent sous forme d’icônes dans la zone de notification à l’extrême droite de la barre des tâches.  
  
 Si vous venez de démarrer un processus et que vous souhaitez utiliser son handle de fenêtre principale, envisagez d’utiliser le <xref:System.Diagnostics.Process.WaitForInputIdle%2A> méthode pour autoriser le processus se termine à partir de, en garantissant que le handle de fenêtre principale a été créé. Sinon, une exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> n'est pas défini, car le processus s'est terminé.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; affectez à <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> la valeur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la légende de la fenêtre principale du processus.</summary>
        <value>Titre de la fenêtre principale du processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un processus possède une fenêtre principale associée uniquement si le processus a une interface graphique. Si le processus associé ne possède pas de fenêtre principale (afin que <xref:System.Diagnostics.Process.MainWindowHandle%2A> est égal à zéro), <xref:System.Diagnostics.Process.MainWindowTitle%2A> est une chaîne vide ( » »). Si vous venez de démarrer un processus et que vous souhaitez utiliser son titre de la fenêtre principale, envisagez d’utiliser le <xref:System.Diagnostics.Process.WaitForInputIdle%2A> méthode pour autoriser le processus se termine à partir de, en garantissant que le handle de fenêtre principale a été créé. Si cette consigne n'est pas respectée, le système lèvera une exception.  
  
> [!NOTE]
>  La fenêtre principale est la fenêtre qui a actuellement le focus ; Notez que cela est peut-être pas la fenêtre principale pour le processus. Vous devez utiliser le <xref:System.Diagnostics.Process.Refresh%2A> méthode pour actualiser le <xref:System.Diagnostics.Process> objet pour lequel obtenir le handle de fenêtre principale actuelle si elle a changé.  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes et récupère la légende de la fenêtre principale du processus.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> n'est pas définie, car le processus s'est terminé.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; affectez à <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> la valeur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille maximale autorisée du jeu de travail, en octets, pour le processus associé.</summary>
        <value>Taille maximale du jeu de travail pouvant être mise en mémoire pour le processus, en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plage de travail d’un processus est l’ensemble de pages de mémoire actuellement visibles par le processus dans la mémoire RAM physique. Ces pages sont résidentes et disponibles pour une application sans déclencher une erreur de page.  
  
 La plage de travail inclut des données partagées et privées. Les données partagées incluent les pages qui contiennent toutes les instructions que votre application s’exécute, y compris les pages dans vos fichiers .dll et les fichiers system.dll. Augmentation de la taille du jeu de travail, à la demande de mémoire augmente.  
  
 Un processus possède des tailles de jeu de travail minimale et maximale. Chaque fois qu’une ressource de processus est créée, le système réserve une quantité de mémoire égal à la taille minimale de travail ensemble pour le processus. Le Gestionnaire de mémoire virtuelle tente de conserver au moins la quantité minimale de mémoire résidente lorsque le processus est actif, mais il ne conserve jamais plus de la taille maximale.  
  
 Le système définit la valeur par défaut des tailles de jeu de travail. Vous pouvez modifier ces tailles à l’aide de la <xref:System.Diagnostics.Process.MaxWorkingSet%2A> et <xref:System.Diagnostics.Process.MinWorkingSet%2A> membres. Toutefois, la définition de ces valeurs ne garantit pas que la mémoire sera réservée ou résident.  
  
> [!NOTE]
>  Lorsque vous augmentez la taille du jeu de travail d’un processus, vous prenez la mémoire physique en dehors du reste du système. Assurez-vous que vous ne demandez pas une taille de jeu de travail minimale ou maximale qui est trop volumineux, car cela peut dégrader les performances du système.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La taille maximale du jeu de travail n’est pas valide. Elle doit être supérieure ou égale à la taille minimale du jeu de travail.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Les informations sur le jeu de travail ne peuvent pas être récupérées de la ressource de processus associée.  
  
- ou - 
L’identificateur ou le handle du processus est zéro, car le processus n’a pas été démarré.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.  
  
- ou - 
Le processus est terminé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille minimale autorisée du jeu de travail, en octets, pour le processus associé.</summary>
        <value>Taille minimale du jeu de travail requise en mémoire pour le processus, en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plage de travail d’un processus est l’ensemble de pages de mémoire actuellement visibles par le processus dans la mémoire RAM physique. Ces pages sont résidentes et disponibles pour une application sans déclencher une erreur de page.  
  
 La plage de travail inclut des données partagées et privées. Les données partagées incluent les pages qui contiennent toutes les instructions que votre application s’exécute, y compris les pages dans vos fichiers .dll et les fichiers system.dll. Augmentation de la taille du jeu de travail, à la demande de mémoire augmente.  
  
 Un processus possède des tailles de jeu de travail minimale et maximale. Chaque fois qu’une ressource de processus est créée, le système réserve une quantité de mémoire égal à la taille minimale de travail ensemble pour le processus. Le Gestionnaire de mémoire virtuelle tente de conserver au moins la quantité minimale de mémoire résidente lorsque le processus est actif, mais il ne conserve jamais plus de la taille maximale.  
  
 Le système définit la valeur par défaut des tailles de jeu de travail. Vous pouvez modifier ces tailles à l’aide de la <xref:System.Diagnostics.Process.MaxWorkingSet%2A> et <xref:System.Diagnostics.Process.MinWorkingSet%2A> membres. Toutefois, la définition de ces valeurs ne garantit pas que la mémoire sera réservée ou résident.  
  
> [!NOTE]
>  Lorsque vous augmentez la taille du jeu de travail d’un processus, vous prenez la mémoire physique en dehors du reste du système. Assurez-vous que vous ne demandez pas une taille de jeu de travail minimale ou maximale qui est trop volumineux, car cela peut dégrader les performances du système.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La taille minimale du jeu de travail n’est pas valide. Elle doit être inférieure ou égale à la taille maximale du jeu de travail.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Les informations sur le jeu de travail ne peuvent pas être récupérées de la ressource de processus associée.  
  
- ou - 
L’identificateur ou le handle du processus est zéro, car le processus n’a pas été démarré.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.  
  
- ou - 
Le processus est terminé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les modules qui ont été chargés par le processus associé.</summary>
        <value>Tableau de type <see cref="T:System.Diagnostics.ProcessModule" /> représentant les modules qui ont été chargés par le processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un module de processus représente un fichier.dll ou .exe chargé dans un processus particulier. Un <xref:System.Diagnostics.ProcessModule> instance vous permet d’afficher des informations sur un module, y compris le nom du module, nom de fichier et détails du module de mémoire.  
  
 Un processus peut charger plusieurs modules en mémoire. Par exemple, les fichiers .exe qui chargent des fichiers .dll supplémentaires ont plusieurs modules.  
  
 Après avoir démarré le processus, cette collection est vide jusqu'à ce que le système a chargé le processus. Si le processus possède une fenêtre principale, vous pouvez appeler <xref:System.Diagnostics.Process.WaitForInputIdle%2A> avant la récupération de cette propriété pour vous assurer que la collection n’est pas vide lorsque vous obtenez la liste.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.Modules" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; affectez à <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> la valeur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.Modules" /> du processus système ou du processus inactif. Ces processus n’ont pas de modules.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire système non paginée, en octets, allouée pour le processus associé.</summary>
        <value>Quantité de mémoire, en octets, que le système a allouée au processus associé qui ne peut pas être écrite dans le fichier d'échange de la mémoire virtuelle.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire système non paginée, en octets, allouée pour le processus associé.</summary>
        <value>Quantité de mémoire système, en octets, allouée au processus associé qui ne peut pas être écrite dans le fichier d'échange de la mémoire virtuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété représente la taille actuelle de la mémoire système non paginée utilisée par le processus, en octets. Mémoire système est la mémoire physique utilisée par le système d’exploitation et est divisée en pools paginées et non paginés. Allocations de mémoire de réserve non paginée restent dans la mémoire système et ne sont pas paginées dans le fichier de pagination de mémoire virtuelle.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **octets de réserve non paginée** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déclenche l'événement <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> est la méthode API qui déclenche le <xref:System.Diagnostics.Process.Exited> événement. Appel <xref:System.Diagnostics.Process.OnExited%2A> provoque la <xref:System.Diagnostics.Process.Exited> événement se produise et est le seul moyen pour déclencher l’événement à l’aide de la <xref:System.Diagnostics.Process> composant. <xref:System.Diagnostics.Process.OnExited%2A> est principalement utilisé lors de la dérivation des classes à partir du composant.  
  
 Comme alternative à <xref:System.Diagnostics.Process.OnExited%2A>, vous pouvez écrire votre propre gestionnaire d’événements. Vous créez votre propre délégué de gestionnaire d’événements et votre propre méthode de gestion des événements.  
  
> [!NOTE]
>  Si vous utilisez l’environnement Visual Studio, un délégué de gestionnaire d’événements (AddOnExited) et une méthode de gestion d’événements (Process1_Exited) sont créés pour vous lorsque vous faites glisser un <xref:System.Diagnostics.Process> composant sur un formulaire et double-cliquez sur l’icône. Le code que vous créez pour s’exécuter lorsque le <xref:System.Diagnostics.Process.Exited> événement se produit est entré dans la procédure Process1_Exited. Vous n’avez pas besoin créer le <xref:System.Diagnostics.Process.OnExited%2A> membre, car il est implémenté pour vous.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Diagnostics.Process.OnExited%2A> méthode dans une classe dérivée.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand une application écrit dans son flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.OutputDataReceived> événement indique que le texte associé <xref:System.Diagnostics.Process> a écrit une ligne, se terminent par un caractère de saut de ligne, à son redirigé <xref:System.Diagnostics.Process.StandardOutput%2A> flux.  
  
 L’événement est activé pendant les opérations de lecture asynchrones sur <xref:System.Diagnostics.Process.StandardOutput%2A>. Pour démarrer des opérations de lecture asynchrones, vous devez rediriger le <xref:System.Diagnostics.Process.StandardOutput%2A> flux d’un <xref:System.Diagnostics.Process>, ajouter votre gestionnaire d’événements pour le <xref:System.Diagnostics.Process.OutputDataReceived> événements et les appels <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Par la suite, le <xref:System.Diagnostics.Process.OutputDataReceived> des signaux d’événements chaque fois que le processus écrit une ligne dans le redirigé <xref:System.Diagnostics.Process.StandardOutput%2A> diffuser en continu, jusqu'à ce que le processus se termine ou appelle <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  L’application qui traite la sortie asynchrone doit appeler la <xref:System.Diagnostics.Process.WaitForExit%2A> méthode pour vous assurer que le tampon de sortie a été vidé.  
  
   
  
## Examples  
 L’exemple suivant illustre comment effectuer des opérations de lecture asynchrones sur le redirigé <xref:System.Diagnostics.Process.StandardOutput%2A> flux de la `ipconfig` commande.  
  
 L’exemple crée un délégué d’événement pour le `OutputHandler` Gestionnaire d’événements et l’associe le <xref:System.Diagnostics.Process.OutputDataReceived> événement. Le Gestionnaire d’événements reçoit des lignes de texte à partir de la redirection <xref:System.Diagnostics.Process.StandardOutput%2A> stream, met en forme le texte et l’enregistre dans une chaîne de sortie qui est illustrée plus loin dans la fenêtre de console de l’exemple.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire paginée, en octets, allouée au processus associé.</summary>
        <value>Quantité de mémoire, en octets, allouée par le processus associé qui peut être écrite dans le fichier d'échange de la mémoire virtuelle.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire paginée, en octets, allouée au processus associé.</summary>
        <value>Quantité de mémoire, en octets, allouée dans le fichier d'échange de la mémoire virtuelle pour le processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété représente la taille actuelle de la mémoire dans le fichier de pagination de mémoire virtuelle utilisée par le processus, en octets. Le système d’exploitation utilise le fichier de pagination de mémoire virtuelle conjointement avec la mémoire physique pour gérer l’espace d’adressage virtuel pour chaque processus. Lorsque la mémoire paginable n’est pas en cours d’utilisation, elles peuvent être transférées vers le fichier de pagination de mémoire virtuelle sur le disque. Pour obtenir la taille de mémoire utilisée par le système d’exploitation pour le processus, utilisez le <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> propriété.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **octets de fichier de Page** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes, puis récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire système paginable, en octets, allouée pour le processus associé.</summary>
        <value>Quantité de mémoire, en octets, que le système a allouée au processus associé qui peut être écrite dans le fichier d'échange de la mémoire virtuelle.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire système paginable, en octets, allouée pour le processus associé.</summary>
        <value>Quantité de mémoire système, en octets, allouée au processus associé qui peut être écrite dans le fichier d'échange de la mémoire virtuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette valeur de propriété représente la taille actuelle de la mémoire système paginable utilisée par le processus, en octets. Mémoire système est la mémoire physique utilisée par le système d’exploitation et est divisée en pools paginées et non paginés. Lorsque la mémoire paginable n’est pas en cours d’utilisation, elles peuvent être transférées vers le fichier de pagination de mémoire virtuelle sur le disque. Pour obtenir la taille de la mémoire de l’application utilisée par le processus, utilisez le <xref:System.Diagnostics.Process.PagedMemorySize64%2A> propriété.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **octets de réserve paginée** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité maximale de mémoire dans le fichier d’échange de la mémoire virtuelle, en octets, utilisé par le processus associé.</summary>
        <value>Quantité maximale de mémoire, en octets, allouée par le processus associé qui peut être écrite dans le fichier d'échange de la mémoire virtuelle.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité maximale de mémoire dans le fichier d’échange de la mémoire virtuelle, en octets, utilisé par le processus associé.</summary>
        <value>Quantité de mémoire maximale, en octets, allouée dans le fichier d'échange de la mémoire virtuelle pour le processus associé depuis son démarrage.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette valeur de propriété représente la taille maximale de mémoire dans le fichier de pagination de mémoire virtuelle utilisée par le processus depuis son démarrage, en octets. Le système d’exploitation utilise le fichier de pagination de mémoire virtuelle conjointement avec la mémoire physique pour gérer l’espace d’adressage virtuel pour chaque processus. Lorsque la mémoire paginable n’est pas en cours d’utilisation, elles peuvent être transférées vers le fichier de pagination de mémoire virtuelle sur le disque.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **octets maximum du fichier de Page** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité maximale de la mémoire virtuelle, en octets, utilisée par le processus associé.</summary>
        <value>Quantité maximale de mémoire virtuelle, en octets, demandée par le processus associé.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité maximale de la mémoire virtuelle, en octets, utilisée par le processus associé.</summary>
        <value>Quantité maximale de la mémoire virtuelle, en octets, allouée pour le processus associé depuis son démarrage.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété représente la taille maximale de mémoire virtuelle utilisée par le processus depuis son démarrage, en octets. Le système d’exploitation mappe l’espace d’adressage virtuel pour chaque processus aux pages chargées dans la mémoire physique ou aux pages stockées dans le fichier de pagination de mémoire virtuelle sur le disque.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **virtuelle (octets)** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille maximale du jeu de travail du processus associé, en octets.</summary>
        <value>Quantité maximale de mémoire physique requise simultanément par le processus associé, en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plage de travail d’un processus est l’ensemble de pages de mémoire actuellement visibles par le processus dans la mémoire RAM physique. Ces pages sont résidentes et disponibles pour une application sans déclencher une erreur de page.  
  
 La plage de travail inclut des données partagées et privées. Les données partagées incluent les pages qui contiennent toutes les instructions que le processus s’exécute, y compris les modules de processus et les bibliothèques système.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité maximale de mémoire physique, en octets, utilisée par le processus associé.</summary>
        <value>Quantité maximale de la mémoire physique, en octets, allouée pour le processus associé depuis son démarrage.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété représente la taille maximale de l’utilisation de définir la mémoire utilisée par le processus depuis son démarrage, en octets. La plage de travail d’un processus est l’ensemble de pages de mémoire actuellement visibles par le processus dans la mémoire RAM physique. Ces pages sont résidentes et disponibles pour une application sans déclencher une erreur de page.  
  
 La plage de travail inclut des données partagées et privées. Les données partagées incluent les pages qui contiennent toutes les instructions que le processus s’exécute, y compris les instructions dans les modules de processus et les bibliothèques système.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **plage de travail max** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la priorité du processus associée doit être temporairement renforcée par le système d'exploitation quand la fenêtre principale a le focus.</summary>
        <value>
          <see langword="true" /> si un renforcement dynamique de la priorité du processus doit être effectué pour un processus lorsqu'il quitte l'état d'attente ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un thread s’exécute dans un processus dont la classe de priorité possède une des valeurs d’énumération priorité dynamique (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), le système renforce temporairement la priorité du thread lorsqu’il quitte un état d’attente. Cette action empêche d’autres processus d’interrompre le traitement du thread actuel. Le <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> paramètre affecte tous les threads existants et les threads créés ultérieurement par le processus. Pour rétablir le comportement normal, affectez la <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propriété `false`.  
  
> [!NOTE]
>  Renforcement de la priorité trop élevée peut priver de ressources essentielles du système d’exploitation et des fonctions de réseau, à l’origine de problèmes avec d’autres tâches du système d’exploitation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nous n’avons pas pu récupérer les informations de renforcement de priorité à partir de la ressource de processus associée.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.  
  
- ou - 
L’identificateur ou le handle de processus correspond à zéro. (Le processus n’a pas été démarré.)</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la catégorie de priorité générale pour le processus associé.</summary>
        <value>Catégorie de priorité pour le processus associé, à partir de laquelle le <see cref="P:System.Diagnostics.Process.BasePriority" /> du processus est calculé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une classe de priorité de processus comprend une plage de niveaux de priorité de thread. Threads avec des priorités différentes qui sont exécutent dans le processus s’exécutent par rapport à la classe de priorité du processus. Win32 utilise quatre classes de priorité avec sept niveaux de priorité de base par classe. Ces classes de priorité de processus sont capturées dans le <xref:System.Diagnostics.ProcessPriorityClass> énumération, qui vous permet de définie la priorité de processus <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. En fonction du temps écoulé ou d’autres augmente, le niveau de priorité de base sont modifiables par le système d’exploitation lorsqu’un processus doit être placé devant les autres pour l’accès au processeur. En outre, vous pouvez définir le <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> afin de renforcer temporairement le niveau de priorité de threads qui ont été effectuées en dehors de l’état d’attente. La priorité est réinitialisée lorsque le processus revient à l’état d’attente.  
  
 Le <xref:System.Diagnostics.Process.BasePriority%2A> propriété vous permet d’afficher la priorité de départ qui est attribuée à un processus. Toutefois, il est en lecture seule, vous ne pouvez pas utiliser le <xref:System.Diagnostics.Process.BasePriority%2A> propriété pour définir la priorité d’un processus. Pour modifier la priorité, utilisez le <xref:System.Diagnostics.Process.PriorityClass%2A> propriété qui obtient ou définit la catégorie de priorité générale pour le processus.  
  
 La classe de priorité ne peut pas être affichée à l’aide du Moniteur système. Le tableau suivant montre la relation entre la <xref:System.Diagnostics.Process.BasePriority%2A> et <xref:System.Diagnostics.Process.PriorityClass%2A> valeurs.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Impossible de définir ou de récupérer les informations de priorité des processus dans la ressource de processus associée.  
  
- ou - 
L’identificateur ou le handle de processus correspond à zéro. (Le processus n’a pas été démarré.)</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.PriorityClass" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’est pas disponible.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Vous avez défini <see cref="P:System.Diagnostics.Process.PriorityClass" /> sur <see langword="AboveNormal" /> ou <see langword="BelowNormal" /> lors de l’utilisation de Windows 98 ou Windows Millennium Edition (Windows Me). Ces plateformes ne prennent pas en charge ces valeurs pour la classe de priorité.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Impossible de définir la classe de priorité, car elle n’utilise pas une valeur valide, telle que définie dans l’énumération <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire privée, en octets, allouée pour le processus associé.</summary>
        <value>Nombre d'octets alloués par le processus associé qui ne peuvent pas être partagés avec d'autres processus.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire privée, en octets, allouée pour le processus associé.</summary>
        <value>Quantité de mémoire, en octets, allouée pour le processus associé qui ne peut pas être partagé avec d'autres processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété représente la taille actuelle de la mémoire utilisée par le processus, en octets, qui ne peut pas être partagée avec d’autres processus.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **octets privés** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le temps processeur privilégié pour ce processus.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> indiquant la durée d'exécution du code par le processus à l'intérieur du noyau du système d'exploitation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom du processus.</summary>
        <value>Nom utilisé par le système pour identifier le processus à l'intention de l'utilisateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.ProcessName%2A> propriété contient un nom de fichier exécutable, tel qu’Outlook, qui n’inclut pas l’extension .exe ou le chemin d’accès. Il est utile pour l’obtention et la manipulation de tous les processus qui sont associés au même fichier exécutable.  
  
> [!NOTE]
>  Sur [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] systèmes d’exploitation, le <xref:System.Diagnostics.Process.ProcessName%2A> propriété peut être tronquée à 15 caractères si les informations de module de processus ne peut pas être obtenues.  
  
 Vous pouvez appeler <xref:System.Diagnostics.Process.GetProcessesByName%2A>, en lui passant un nom de fichier exécutable, pour récupérer un tableau qui contient toutes les instances en cours d’exécution sur l’ordinateur spécifié. Vous pouvez utiliser ce tableau, par exemple, pour arrêter toutes les instances en cours d’exécution du fichier exécutable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le processus n’a pas d’identificateur ou aucun processus n’est associé à <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
Le processus associé s’est arrêté.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; affectez à <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> la valeur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">Le processus n’est pas sur cet ordinateur.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les processeurs sur lesquels l'exécution des threads de ce processus peut être planifiée.</summary>
        <value>Masque de bits représentant les processeurs sur lesquels les threads du processus associé peuvent s'exécuter. La valeur par défaut dépend du nombre de processeurs dont est équipé l'ordinateur. La valeur par défaut est 2 <sup>n</sup> -1, où n est le nombre de processeurs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans Windows 2000 et versions ultérieures, un thread dans un processus peut migrer d’un processeur à l’autre, chaque migration rechargement du cache du processeur. La charge système est importante, spécifier le processeur doit exécuter un thread spécifique peut améliorer les performances en réduisant le nombre de fois où que le cache de processeur est rechargé. L’association entre un processeur et un thread est appelée l’affinité du processeur.  
  
 Chaque processeur est représenté par un bit. Bit 0 est le premier processeur, le bit 1 processeur deux et ainsi de suite. Si vous définissez un peu à la valeur 1, le processeur correspondant est sélectionné pour l’attribution de thread. Lorsque vous définissez la <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valeur égale à zéro, le système d’exploitation de planification du jeu d’algorithmes l’affinité du thread. Lorsque le <xref:System.Diagnostics.Process.ProcessorAffinity%2A> est défini sur n’importe quelle valeur différente de zéro, la valeur est interprétée comme un masque de bits spécifiant les processeurs doit porter la sélection.  
  
 Le tableau suivant présente une sélection de <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valeurs pour un système à huit processeurs.  
  
|Masque de bits|Valeur binaire|Processeurs éligibles|  
|-------------|------------------|-------------------------|  
|0 x 0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 et 2|  
|0x0007|00000000 00000111|1, 2 et 3|  
|0x0009|00000000 00001001|1 et 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 et 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nous n’avons pas pu définir ou récupérer des informations <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> à partir de la ressource de processus associée.  
  
- ou - 
L’identificateur ou le handle de processus correspond à zéro. (Le processus n’a pas été démarré.)</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus <see cref="P:System.Diagnostics.Process.Id" /> n’était pas disponible.  
  
- ou - 
Le processus s’est fermé.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ignore toute information concernant le processus associé qui a été mis en cache dans le composant du processus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après avoir <xref:System.Diagnostics.Process.Refresh%2A> est appelée, la première demande pour plus d’informations sur chaque propriété entraîne le composant de processus pour obtenir une nouvelle valeur à partir du processus associé.  
  
 Quand un <xref:System.Diagnostics.Process> composant est associé à une ressource de processus, les valeurs de propriété de la <xref:System.Diagnostics.Process> sont renseignées immédiatement en fonction de l’état du processus associé. Si les informations sur le processus associé est modifié par la suite, les modifications ne sont pas reflétées dans le <xref:System.Diagnostics.Process> du composant de valeurs mises en cache. Le <xref:System.Diagnostics.Process> composant est un instantané de la ressource de processus au moment où ils sont associés. Pour afficher les valeurs actuelles pour le processus associé, appelez le <xref:System.Diagnostics.Process.Refresh%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Il récupère ensuite l’utilisation de la mémoire physique du processus associé à des intervalles de 2 secondes pour un maximum de 10 secondes. L’exemple détecte si le processus se termine avant que les 10 secondes se soient écoulées. L’exemple ferme le processus s’il s’exécute toujours après 10 secondes.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'interface utilisateur du processus répond.</summary>
        <value>
          <see langword="true" /> si l'interface utilisateur du processus associé répond au système ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un processus possède une interface utilisateur, le <xref:System.Diagnostics.Process.Responding%2A> propriété contacte l’interface utilisateur pour déterminer si le processus répond aux entrées d’utilisateur. Si l’interface ne répond pas immédiatement, le <xref:System.Diagnostics.Process.Responding%2A> retourne de la propriété `false`. Utilisez cette propriété pour déterminer si l’interface du processus associé a cessé de répondre.  
  
 Si le processus n’a pas un <xref:System.Diagnostics.Process.MainWindowHandle%2A>, cette propriété retourne `true`.  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; affectez à <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> la valeur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.Responding" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle natif de ce processus.</summary>
        <value>Handle natif de ce processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le handle est disponible uniquement si le composant appelant a démarré le processus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur de session Terminal Server du processus associé.</summary>
        <value>Identificateur de session Terminal Server du processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Process.SessionId%2A> propriété identifie la session dans laquelle l’application est en cours d’exécution.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Aucune session n’est associée à ce processus.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun processus n’est associé à cet identificateur de session.  
  
- ou - 
Le processus associé n’est pas sur cet ordinateur.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La propriété <see cref="P:System.Diagnostics.Process.SessionId" /> n’est pas prise en charge sur Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un flux utilisé pour lire la sortie d'erreur de l'application.</summary>
        <value>
          <see cref="T:System.IO.StreamReader" /> qui peut être utilisé pour lire le flux d'erreurs standard de l'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un <xref:System.Diagnostics.Process> écrit du texte dans son flux d’erreurs standard, texte est normalement affiché dans la console. En redirigeant le <xref:System.Diagnostics.Process.StandardError%2A> stream, vous pouvez manipuler ou supprimer la sortie d’erreur d’un processus. Par exemple, vous pouvez filtrer le texte, mettre en forme différemment ou écrire la sortie dans la console et un fichier journal choisi.  
  
> [!NOTE]
>  Pour utiliser <xref:System.Diagnostics.Process.StandardError%2A>, vous devez définir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> à `false`, et vous devez définir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> à `true`. Sinon, la lecture à partir de la <xref:System.Diagnostics.Process.StandardError%2A> flux lève une exception.  
  
 Redirigé <xref:System.Diagnostics.Process.StandardError%2A> flux peut être lu de façon synchrone ou asynchrone. Méthodes telles que <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, et <xref:System.IO.StreamReader.ReadToEnd%2A> effectuer des opérations de lecture synchrones sur le flux de sortie d’erreur du processus. Ces synchrone lire les opérations ne se terminent pas jusqu'à ce qu’associé <xref:System.Diagnostics.Process> écrit dans son <xref:System.Diagnostics.Process.StandardError%2A> diffuser en continu ou ferme le flux.  
  
 En revanche, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> démarre asynchrone des opérations de lecture sur le <xref:System.Diagnostics.Process.StandardError%2A> flux. Cette méthode permet à un gestionnaire d’événements désigné pour la sortie de flux de données et retourne immédiatement à l’appelant, ce qui peut effectuer d’autres tâches pendant que la sortie de flux est dirigée vers le Gestionnaire d’événements.  
  
 Synchrone lire opérations introduisent une dépendance entre l’appelant qui lit à partir de la <xref:System.Diagnostics.Process.StandardError%2A> flux et l’enfant traitement l’écriture dans ce flux. Ces dépendances peuvent entraîner des conditions d’interblocage. Lorsque l’appelant lit le flux redirigé d’un processus enfant, il est dépendant de l’enfant. L’appelant attend l’opération de lecture jusqu'à l’enfant écrit dans le flux ou ferme le flux. Lorsque le processus enfant écrit suffisamment de données pour remplir son flux redirigé, il est dépendant du parent. Le processus enfant attend sur l’opération d’écriture suivante jusqu'à ce que le parent lit dans le flux complet ou ferme le flux. La condition de blocage se produit lorsque l’appelant et le processus enfant attendent mutuellement pour effectuer une opération, et aucun ne puisse continuer. Vous pouvez éviter les interblocages en évaluant les dépendances entre l’appelant et le processus enfant.  
  
 Le code c# suivant, par exemple, comment lire un flux redirigé et attendez que le processus enfant s’arrête.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 L’exemple de code permet d’éviter une condition de blocage en appelant `p.StandardError.ReadToEnd` avant `p.WaitForExit`. Une condition de blocage peut se produire si le processus parent appelle `p.WaitForExit` avant `p.StandardError.ReadToEnd` et le processus enfant écrit suffisamment de texte pour remplir le flux redirigé. Le processus parent attendre indéfiniment que le processus enfant s’arrête. Le processus enfant attend indéfiniment que le parent lire à partir de la version complète <xref:System.Diagnostics.Process.StandardError%2A> flux.  
  
 Il existe un problème similaire lorsque vous lisez tout le texte à partir de la sortie standard et le flux d’erreur standard. Le code c# suivant, par exemple, effectue une opération de lecture sur les deux flux.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 L’exemple de code permet d’éviter la condition de blocage en effectuant asynchrone des opérations de lecture sur le <xref:System.Diagnostics.Process.StandardOutput%2A> flux. Un blocage survient si le processus parent appelle `p.StandardOutput.ReadToEnd` suivie `p.StandardError.ReadToEnd` et le processus enfant écrit suffisamment de texte pour remplir son flux d’erreurs. Le processus parent attend indéfiniment que le processus enfant ferme son <xref:System.Diagnostics.Process.StandardOutput%2A> flux. Le processus enfant attend indéfiniment que le parent lire à partir de la version complète <xref:System.Diagnostics.Process.StandardError%2A> flux.  
  
 Vous pouvez utiliser des opérations de lecture asynchrones pour éviter ces dépendances et leur blocage potentiel. Vous pouvez également éviter la condition de blocage en créant deux threads et en lisant la sortie de chaque flux sur un thread distinct.  
  
> [!NOTE]
>  Vous ne pouvez pas mélanger des opérations de lecture synchrones et asynchrones sur un flux redirigé. Une fois le flux redirigé d’une <xref:System.Diagnostics.Process> est ouvert en mode asynchrone ou synchrone, toutes les autres de lecture des opérations sur ce flux de données doivent être dans le même mode. Par exemple, ne suivez pas <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> avec un appel à <xref:System.IO.StreamReader.ReadLine%2A> sur la <xref:System.Diagnostics.Process.StandardError%2A> flux, ou vice versa. Toutefois, vous pouvez lire deux flux différents dans des modes différents. Par exemple, vous pouvez appeler <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , puis appelez <xref:System.IO.StreamReader.ReadLine%2A> pour le <xref:System.Diagnostics.Process.StandardError%2A> flux.  
  
   
  
## Examples  
 L’exemple suivant utilise la `net use` commande avec un utilisateur fourni d’argument pour mapper une ressource réseau. Ensuite, il lit le flux d’erreur standard de la commande net et l’écrit dans la console.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardError" /> n’a pas été défini pour la redirection ; vérifiez que les propriétés <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> et <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> ont respectivement pour valeur <see langword="true" /> et <see langword="false" />.  
  
\- ou - 
Le flux <see cref="P:System.Diagnostics.Process.StandardError" /> a été ouvert pour des opérations de lecture asynchrones avec <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un flux utilisé pour écrire l'entrée de l'application.</summary>
        <value>
          <see cref="T:System.IO.StreamWriter" /> qui peut être utilisé pour écrire le flux d'entrée standard de l'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Diagnostics.Process> peut lire le texte d’entrée à partir de son flux d’entrée standard, généralement le clavier. En redirigeant le <xref:System.Diagnostics.Process.StandardInput%2A> stream, vous pouvez spécifier par programme l’entrée. Par exemple, au lieu d’utiliser l’entrée au clavier, vous pouvez fournir le texte à partir du contenu d’un fichier désigné ou sortie à partir d’une autre application.  
  
> [!NOTE]
>  Pour utiliser <xref:System.Diagnostics.Process.StandardInput%2A>, vous devez définir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> à `false`, et vous devez définir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> à `true`. Écriture dans le cas contraire, dans le <xref:System.Diagnostics.Process.StandardInput%2A> flux lève une exception.  
  
   
  
## Examples  
 L’exemple suivant illustre comment rediriger le <xref:System.Diagnostics.Process.StandardInput%2A> flux d’un processus. L’exemple démarre la `sort` commande avec une entrée redirigée. Il invite ensuite l’utilisateur pour le texte et le passe à la `sort` processus au moyen de la redirection <xref:System.Diagnostics.Process.StandardInput%2A> flux. Le `sort` résultats sont affichés à l’utilisateur sur la console.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardInput" /> n’a pas été défini, car <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> a la valeur <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un flux utilisé pour lire la sortie textuelle de l'application.</summary>
        <value>
          <see cref="T:System.IO.StreamReader" /> qui peut être utilisé pour lire le flux de sortie standard de l'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un <xref:System.Diagnostics.Process> écrit du texte dans son flux standard, texte est normalement affiché dans la console. En redirigeant le <xref:System.Diagnostics.Process.StandardOutput%2A> stream, vous pouvez manipuler ou supprimer la sortie d’un processus. Par exemple, vous pouvez filtrer le texte, mettre en forme différemment ou écrire la sortie dans la console et un fichier journal choisi.  
  
> [!NOTE]
>  Pour utiliser <xref:System.Diagnostics.Process.StandardOutput%2A>, vous devez définir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> à `false`, et vous devez définir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> à `true`. Sinon, la lecture à partir de la <xref:System.Diagnostics.Process.StandardOutput%2A> flux lève une exception.  
  
 Redirigé <xref:System.Diagnostics.Process.StandardOutput%2A> flux peut être lu de façon synchrone ou asynchrone. Méthodes telles que <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, et <xref:System.IO.StreamReader.ReadToEnd%2A> effectuer des opérations de lecture synchrones sur le flux de sortie du processus. Ces synchrone lire les opérations ne se terminent pas jusqu'à ce qu’associé <xref:System.Diagnostics.Process> écrit dans son <xref:System.Diagnostics.Process.StandardOutput%2A> diffuser en continu ou ferme le flux.  
  
 En revanche, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> démarre asynchrone des opérations de lecture sur le <xref:System.Diagnostics.Process.StandardOutput%2A> flux. Cette méthode permet à un gestionnaire d’événements désigné pour la sortie de flux de données et retourne immédiatement à l’appelant, ce qui peut effectuer d’autres tâches pendant que la sortie de flux est dirigée vers le Gestionnaire d’événements.  
  
 Synchrone lire opérations introduisent une dépendance entre l’appelant qui lit à partir de la <xref:System.Diagnostics.Process.StandardOutput%2A> flux et l’enfant traitement l’écriture dans ce flux. Ces dépendances peuvent entraîner des conditions d’interblocage. Lorsque l’appelant lit le flux redirigé d’un processus enfant, il est dépendant de l’enfant. L’appelant attend l’opération de lecture jusqu'à l’enfant écrit dans le flux ou ferme le flux. Lorsque le processus enfant écrit suffisamment de données pour remplir son flux redirigé, il est dépendant du parent. Le processus enfant attend sur l’opération d’écriture suivante jusqu'à ce que le parent lit dans le flux complet ou ferme le flux. La condition de blocage se produit lorsque l’appelant et le processus enfant attendent mutuellement pour effectuer une opération, et aucun ne puisse continuer. Vous pouvez éviter les interblocages en évaluant les dépendances entre l’appelant et le processus enfant.  
  
 Le code c# suivant, par exemple, comment lire un flux redirigé et attendez que le processus enfant s’arrête.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 L’exemple de code permet d’éviter une condition de blocage en appelant `p.StandardOutput.ReadToEnd` avant `p.WaitForExit`. Une condition de blocage peut se produire si le processus parent appelle `p.WaitForExit` avant `p.StandardOutput.ReadToEnd` et le processus enfant écrit suffisamment de texte pour remplir le flux redirigé. Le processus parent attendre indéfiniment que le processus enfant s’arrête. Le processus enfant attend indéfiniment que le parent lire à partir de la version complète <xref:System.Diagnostics.Process.StandardOutput%2A> flux.  
  
 Il existe un problème similaire lorsque vous lisez tout le texte à partir de la sortie standard et le flux d’erreur standard. Le code c# suivant, par exemple, effectue une opération de lecture sur les deux flux.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 L’exemple de code permet d’éviter la condition de blocage en effectuant asynchrone des opérations de lecture sur le <xref:System.Diagnostics.Process.StandardOutput%2A> flux. Un blocage survient si le processus parent appelle `p.StandardOutput.ReadToEnd` suivie `p.StandardError.ReadToEnd` et le processus enfant écrit suffisamment de texte pour remplir son flux d’erreurs. Le processus parent attend indéfiniment que le processus enfant ferme son <xref:System.Diagnostics.Process.StandardOutput%2A> flux. Le processus enfant attend indéfiniment que le parent lire à partir de la version complète <xref:System.Diagnostics.Process.StandardError%2A> flux.  
  
 Vous pouvez utiliser des opérations de lecture asynchrones pour éviter ces dépendances et leur blocage potentiel. Vous pouvez également éviter la condition de blocage en créant deux threads et en lisant la sortie de chaque flux sur un thread distinct.  
  
> [!NOTE]
>  Vous ne pouvez pas mélanger des opérations de lecture synchrones et asynchrones sur un flux redirigé. Une fois le flux redirigé d’une <xref:System.Diagnostics.Process> est ouvert en mode asynchrone ou synchrone, toutes les autres de lecture des opérations sur ce flux de données doivent être dans le même mode. Par exemple, ne suivez pas <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> avec un appel à <xref:System.IO.StreamReader.ReadLine%2A> sur la <xref:System.Diagnostics.Process.StandardOutput%2A> flux, ou vice versa. Toutefois, vous pouvez lire deux flux différents dans des modes différents. Par exemple, vous pouvez appeler <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , puis appelez <xref:System.IO.StreamReader.ReadLine%2A> pour le <xref:System.Diagnostics.Process.StandardError%2A> flux.  
  
   
  
## Examples  
 L’exemple suivant exécute la commande ipconfig.exe et redirige la sortie standard à la fenêtre de console de l’exemple.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> n’a pas été défini pour la redirection ; vérifiez que les propriétés <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> et <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> ont respectivement pour valeur <see langword="true" /> et <see langword="false" />.  
  
\- ou - 
Le flux <see cref="P:System.Diagnostics.Process.StandardOutput" /> a été ouvert pour des opérations de lecture asynchrones avec <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lance une ressource de processus et l'associe à un composant <see cref="T:System.Diagnostics.Process" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Démarre (ou réutilise) la ressource de processus qui est spécifiée par la propriété <see cref="P:System.Diagnostics.Process.StartInfo" /> de ce composant <see cref="T:System.Diagnostics.Process" /> et l'associe au composant.</summary>
        <returns>
          <see langword="true" /> si une ressource de processus est démarrée ; <see langword="false" /> si aucune ressource de processus n'est démarrée (par exemple, si un processus existant est réutilisé).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour démarrer une ressource de processus et l’associer à l’actuel <xref:System.Diagnostics.Process> composant. La valeur de retour `true` indique qu’une nouvelle ressource de processus a été démarrée. Si la ressource de processus spécifié par le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membre de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété est déjà en cours d’exécution sur l’ordinateur, aucune ressource de processus supplémentaire est démarrée. Ressource de processus au lieu de cela, l’exécution est réutilisé et `false` est retourné.  
  
 Vous pouvez démarrer une application ClickOnce en spécifiant l’emplacement (par exemple, une adresse Web) à partir duquel vous avez installé l’application. Ne démarrez pas une application ClickOnce en spécifiant son emplacement d’installation sur votre disque dur.  
  
> [!NOTE]
>  Si vous utilisez Visual Studio, cette surcharge de la <xref:System.Diagnostics.Process.Start%2A> méthode est celle que vous insérez dans votre code une fois que vous faites glisser un <xref:System.Diagnostics.Process> composant sur le concepteur. Utilisez le `Properties` fenêtre pour développer le `StartInfo` catégorie et écrire la valeur appropriée dans le `FileName` propriété. Vos modifications apparaissent dans le formulaire `InitializeComponent` procédure.  
  
 Cette surcharge de <xref:System.Diagnostics.Process.Start%2A> n’est pas un `static` (méthode). Vous devez l’appeler à partir d’une instance de la <xref:System.Diagnostics.Process> classe. Avant d’appeler <xref:System.Diagnostics.Process.Start%2A>, vous devez d’abord spécifier <xref:System.Diagnostics.Process.StartInfo%2A> les informations de propriété pour ce <xref:System.Diagnostics.Process> de l’instance, car ces informations sont utilisées pour déterminer la ressource de processus à démarrer.  
  
 Les autres surcharges de la <xref:System.Diagnostics.Process.Start%2A> méthode sont `static` membres. Vous n’avez pas besoin créer une instance de la <xref:System.Diagnostics.Process> composant avant d’appeler ces surcharges de la méthode. Au lieu de cela, vous pouvez appeler <xref:System.Diagnostics.Process.Start%2A> pour le <xref:System.Diagnostics.Process> classe lui-même et un nouveau <xref:System.Diagnostics.Process> composant est créé si le processus a démarré. Ou, `null` est retournée si un processus a été réutilisé. La ressource de processus est automatiquement associée au nouveau <xref:System.Diagnostics.Process> composant qui est retourné par la <xref:System.Diagnostics.Process.Start%2A> (méthode).  
  
 Le <xref:System.Diagnostics.Process.StartInfo%2A> membres peuvent être utilisés pour reproduire les fonctionnalités de la `Run` boîte de dialogue de la Windows `Start` menu. Tout ce qui peuvent être tapés dans une ligne de commande peut être démarré en définissant les valeurs appropriées dans le <xref:System.Diagnostics.Process.StartInfo%2A> propriété. La seule <xref:System.Diagnostics.Process.StartInfo%2A> propriété doit avoir la valeur est le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété. Le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété ne doit pas être un fichier exécutable. Il peut être de n’importe quel type de fichier pour lequel l’extension a été associée à une application qui est installée sur le système. Par exemple, le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété peut avoir une extension .txt si vous avez associé les fichiers texte à un éditeur, tel que le bloc-notes, ou il peut avoir une extension .doc si vous avez les fichiers.doc à un outil de traitement de texte, tel que Microsoft Word.  
  
 Dans la ligne de commande, vous pouvez spécifier les actions à entreprendre pour certains types de fichiers. Par exemple, vous pouvez imprimer des documents ou modifier des fichiers texte. Spécifiez ces actions à l’aide de la <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> membre de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété. Pour les autres types de fichiers, vous pouvez spécifier des arguments de ligne de commande lorsque vous démarrez le fichier à partir de la `Run` boîte de dialogue. Par exemple, vous pouvez passer une URL en tant qu’argument si vous spécifiez votre navigateur en tant que le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Ces arguments peuvent être spécifiés dans le <xref:System.Diagnostics.Process.StartInfo%2A> la propriété <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membre.  
  
 Si vous avez une variable de chemin d’accès déclarée dans votre système à l’aide de guillemets, vous devez qualifier entièrement ce chemin d’accès lors du démarrage de n’importe quel processus trouvé dans cet emplacement. Sinon, le système ne trouvera pas le chemin d’accès. Par exemple, si `c:\mypath` n’est pas dans votre chemin d’accès, et l’ajouter à l’aide de guillemets : `path = %path%;"c:\mypath"`, vous devez qualifier complètement tout processus dans `c:\mypath` lorsque vous le démarrez.  
  
> [!NOTE]
>  Code de contrôle de page et de serveur Web ASP.NET s’exécute dans le contexte du processus de travail ASP.NET sur le serveur Web.  Si vous utilisez le <xref:System.Diagnostics.Process.Start%2A> méthode dans une page Web ASP.NET ou un contrôle de serveur, le nouveau processus s’exécute sur le serveur Web avec des autorisations restreintes. Le processus ne démarre pas dans le même contexte que le navigateur client et n’a pas accès au bureau de l’utilisateur.  
  
 Lorsque vous utilisez <xref:System.Diagnostics.Process.Start%2A> pour démarrer un processus, vous devrez peut-être fermer ou vous risquez de perdre des ressources système. Fermez les processus à l’aide de <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Vous pouvez vérifier si un processus a déjà été fermé à l’aide de son <xref:System.Diagnostics.Process.HasExited%2A> propriété.  
  
 Remarque à propos des États de cloisonnement dans les threads managés est nécessaire ici. Lorsque <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> est `true` sur le composant de traitement <xref:System.Diagnostics.Process.StartInfo%2A> propriété, vérifiez que vous avez défini un modèle de thread sur votre application en définissant l’attribut `[STAThread]` sur la `main()` (méthode). Sinon, un thread managé peut être dans un `unknown` d’état ou placé dans le `MTA` d’état, ce dernier qui est en conflit avec <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> en cours `true`. Certaines méthodes exigent que l’état de cloisonnement ne soit ne pas `unknown`. Si l’état n’est pas explicitement défini dans la lorsque l’application rencontre une telle méthode, il est par défaut `MTA`, et une fois définie, l’état de cloisonnement ne peut pas être modifié. Toutefois, `MTA` provoque une exception levée lorsque l’interpréteur de commandes du système d’exploitation gère le thread.  
  
   
  
## Examples  
 L’exemple suivant utilise une instance de la <xref:System.Diagnostics.Process> classe démarre un processus.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun nom de fichier n’a été spécifié dans le <see cref="P:System.Diagnostics.Process.StartInfo" /> du composant <see cref="T:System.Diagnostics.Process" />.
Ou le membre <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> de la propriété <see cref="P:System.Diagnostics.Process.StartInfo" /> est <see langword="true" /> alors que <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> ou <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> a la valeur <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite à l’ouverture du fichier associé.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Méthode non prise en charge sur les systèmes d’exploitation sans prise en charge de l’interpréteur de commandes comme Nano Server (.NET Core uniquement).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> qui contient les informations utilisées pour démarrer le processus, y compris le nom de fichier et d'éventuels arguments de ligne de commande.</param>
        <summary>Démarre la ressource de processus qui est spécifiée par le paramètre contenant les informations de démarrage du processus (par exemple, le nom de fichier du processus à démarrer) et l'associe à un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu'un nouveau processus qui est démarré en même temps que les instances du même processus déjà en cours d'exécution sera indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour démarrer une ressource de processus en spécifiant un <xref:System.Diagnostics.ProcessStartInfo> instance. La surcharge associe la ressource à un nouveau <xref:System.Diagnostics.Process> objet.  
  
> [!NOTE]
>  Si l’adresse du fichier exécutable à démarrer est une URL, le processus n’est pas démarré et `null` est retourné.  
  
 Cette surcharge vous permet de démarrer un processus sans d’abord créer un nouveau <xref:System.Diagnostics.Process> instance. À l’aide de cette surcharge avec un <xref:System.Diagnostics.ProcessStartInfo> paramètre est une alternative aux étapes explicites de création d’un nouveau <xref:System.Diagnostics.Process> instance, en définissant son <xref:System.Diagnostics.Process.StartInfo%2A> propriétés et l’appel <xref:System.Diagnostics.Process.Start%2A> pour le <xref:System.Diagnostics.Process> instance.  
  
 À l’aide un <xref:System.Diagnostics.ProcessStartInfo> instance comme le paramètre vous permet d’appeler <xref:System.Diagnostics.Process.Start%2A> avec un meilleur contrôle sur ce qui est passé dans l’appel pour démarrer le processus. Si vous devez passer uniquement un nom de fichier ou un nom de fichier et des arguments, il n’est pas nécessaire de créer un nouveau <xref:System.Diagnostics.ProcessStartInfo> d’instance, même si c’est une option. La seule <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> propriété doit avoir la valeur est le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété. Le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété n’a pas besoin de représenter un fichier exécutable. Il peut être de n’importe quel type de fichier pour lequel l’extension a été associée à une application qui est installée sur le système. Par exemple, le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété peut avoir une extension .txt si vous avez associé les fichiers texte à un éditeur, tel que le bloc-notes, ou il peut avoir une extension .doc si vous avez les fichiers.doc à un outil de traitement de texte, tel que Microsoft Word.  
  
 Vous pouvez démarrer une application ClickOnce en spécifiant l’emplacement (par exemple, une adresse Web) à partir duquel vous avez installé l’application. Ne démarrez pas une application ClickOnce en spécifiant son emplacement d’installation sur votre disque dur.  
  
 Si le <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> et <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propriétés de la <xref:System.Diagnostics.Process.StartInfo%2A> instance sont définies, non managé `CreateProcessWithLogonW` fonction est appelée, ce qui démarre le processus dans une nouvelle fenêtre, même lorsque le <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> valeur de propriété est `true` ou le <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> valeur de propriété est <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Si le <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> propriété est `null`, le <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> propriété doit être au format UPN, *utilisateur*@*nom_domaine DNS*.   
  
 Contrairement aux autres surcharges, la surcharge de <xref:System.Diagnostics.Process.Start%2A> qui n’a aucun paramètre n’est pas un `static` membre. Utilisez cette surcharge lorsque vous avez déjà créé un <xref:System.Diagnostics.Process> de l’instance, les informations de début spécifiée (y compris le nom de fichier) et voulez démarrer une ressource de processus et l’associer avec le <xref:System.Diagnostics.Process> instance. Utilisez une de la `static` surcharges lorsque vous souhaitez créer un nouveau <xref:System.Diagnostics.Process> composant au lieu de démarrer un processus pour un composant existant. Cette surcharge et la surcharge sans paramètre permettent de spécifier les informations de démarrage pour la ressource de processus à l’aide un <xref:System.Diagnostics.ProcessStartInfo> instance.  
  
 Si vous avez une variable de chemin d’accès déclarée dans votre système à l’aide de guillemets, vous devez qualifier entièrement ce chemin d’accès lors du démarrage de n’importe quel processus trouvé dans cet emplacement. Sinon, le système ne trouvera pas le chemin d’accès. Par exemple, si `c:\mypath` n’est pas dans votre chemin d’accès, et l’ajouter à l’aide de guillemets : `path = %path%;"c:\mypath"`, vous devez qualifier complètement tout processus dans `c:\mypath` lorsque vous le démarrez.  
  
> [!NOTE]
>  Code de contrôle de page et de serveur Web ASP.NET s’exécute dans le contexte du processus de travail ASP.NET sur le serveur Web.  Si vous utilisez le <xref:System.Diagnostics.Process.Start%2A> méthode dans une page Web ASP.NET ou un contrôle de serveur, le nouveau processus s’exécute sur le serveur Web avec des autorisations restreintes. Le processus ne démarre pas dans le même contexte que le navigateur client et n’a pas accès au bureau de l’utilisateur.  
  
 Lorsque vous utilisez <xref:System.Diagnostics.Process.Start%2A> pour démarrer un processus, vous devrez peut-être fermer ou vous risquez de perdre des ressources système. Fermez les processus à l’aide de <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Vous pouvez vérifier si un processus a déjà été fermé à l’aide de son <xref:System.Diagnostics.Process.HasExited%2A> propriété.  
  
 Remarque à propos des États de cloisonnement dans les threads managés est nécessaire ici. Lorsque <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> est `true` sur le `startInfo` paramètre, vérifiez que vous avez défini un modèle de thread sur votre application en définissant l’attribut `[STAThread]` sur la `main()` (méthode). Sinon, un thread managé peut être dans un `unknown` d’état ou placé dans le `MTA` d’état, ce dernier qui est en conflit avec <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> en cours `true`. Certaines méthodes exigent que l’état de cloisonnement ne soit ne pas `unknown`. Si l’état n’est pas explicitement défini dans la lorsque l’application rencontre une telle méthode, il est par défaut `MTA`, et une fois définie, l’état de cloisonnement ne peut pas être modifié. Toutefois, `MTA` provoque une exception levée lorsque l’interpréteur de commandes du système d’exploitation gère le thread.  
  
   
  
## Examples  
 Tout d’abord, l’exemple suivant génère une instance d’Internet Explorer et affiche le contenu du dossier Favoris dans le navigateur. Ensuite, il démarre d’autres instances d’Internet Explorer et affiche certaines pages ou sites spécifiques. Enfin, il démarre Internet Explorer avec la fenêtre réduite pendant la navigation vers un site spécifique.  
  
 Pour obtenir des exemples supplémentaires d’autres utilisations de cette méthode, consultez les propriétés individuelles de la <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun nom de fichier n’a été spécifié dans la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> du paramètre <paramref name="startInfo" />.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> du paramètre <paramref name="startInfo" /> a la valeur <see langword="true" />, et la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> ou <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> a également la valeur <see langword="true" />.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> du paramètre <paramref name="startInfo" /> a la valeur <see langword="true" /> et la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> n’a pas la valeur <see langword="null" /> ou est vide ou la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> n’a pas la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="startInfo" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans la propriété <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> du paramètre <paramref name="startInfo" /> est introuvable.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite à l’ouverture du fichier associé.  
  
- ou - 
La somme de la longueur des arguments et de la longueur du chemin d’accès complet au processus dépasse 2 080. Le message d’erreur associé à cette exception peut être un des suivants : « La zone de données passée à un appel système est insuffisante. » ou « Accès refusé. »</exception>
        <exception cref="T:System.PlatformNotSupportedException">Méthode non prise en charge sur les systèmes d’exploitation sans prise en charge de l’interpréteur de commandes comme Nano Server (.NET Core uniquement).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom d'un document ou d'un fichier d'application à exécuter dans le processus.</param>
        <summary>Démarre une ressource de processus en spécifiant le nom d'un document ou d'un fichier d'application et l'associe à un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu'un nouveau processus qui est démarré en même temps que les instances du même processus déjà en cours d'exécution sera indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour démarrer une ressource de processus en spécifiant son nom de fichier. La surcharge associe la ressource à un nouveau <xref:System.Diagnostics.Process> objet.  
  
> [!NOTE]
>  Si l’adresse du fichier exécutable à démarrer est une URL, le processus n’est pas démarré et `null` est retourné.  
  
 Cette surcharge vous permet de démarrer un processus sans d’abord créer un nouveau <xref:System.Diagnostics.Process> instance. La surcharge est une alternative aux étapes explicites de création d’un nouveau <xref:System.Diagnostics.Process> instance, en définissant le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membre de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété et l’appel <xref:System.Diagnostics.Process.Start%2A> pour le <xref:System.Diagnostics.Process> instance.  
  
 Vous pouvez démarrer une application ClickOnce en définissant le `fileName` paramètre à l’emplacement (par exemple, une adresse Web) à partir duquel vous avez installé l’application. Ne démarrez pas une application ClickOnce en spécifiant son emplacement d’installation sur votre disque dur.  
  
 Démarrage d’un processus en spécifiant son nom de fichier est similaire à taper les informations contenues dans le `Run` boîte de dialogue de la Windows `Start` menu. Par conséquent, le nom de fichier est inutile représenter un fichier exécutable. Il peut être de n’importe quel type de fichier pour lequel l’extension a été associé à une application installée sur le système. Par exemple, le nom de fichier peut avoir une extension .txt si vous avez associé les fichiers texte à un éditeur, tel que le bloc-notes, ou il peut avoir un .doc si vous avez les fichiers.doc à un outil de traitement de texte, tel que Microsoft Word. De même, dans la même façon que le `Run` boîte de dialogue peut accepter un nom de fichier exécutable avec ou sans l’extension .exe, l’extension .exe est facultative dans le `fileName` paramètre. Par exemple, vous pouvez définir le `fileName` paramètre « Notepad.exe » ou « Notepad ».  
  
 Cette surcharge n’autorise pas les arguments de ligne de commande pour le processus. Si vous devez spécifier un ou plusieurs arguments de ligne de commande pour le processus, utilisez le <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> ou <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> surcharges.  
  
 Contrairement aux autres surcharges, la surcharge de <xref:System.Diagnostics.Process.Start%2A> qui n’a aucun paramètre n’est pas un `static` membre. Utilisez cette surcharge lorsque vous avez déjà créé un <xref:System.Diagnostics.Process> de l’instance, les informations de début spécifiée (y compris le nom de fichier) et voulez démarrer une ressource de processus et l’associer avec le <xref:System.Diagnostics.Process> instance. Utilisez une de la `static` surcharges lorsque vous souhaitez créer un nouveau <xref:System.Diagnostics.Process> composant au lieu de démarrer un processus pour un composant existant. Cette surcharge et permettent tous deux la surcharge qui n’a aucun paramètre vous permet de spécifier le nom de fichier de la ressource de processus à démarrer.  
  
 Si vous avez une variable de chemin d’accès déclarée dans votre système à l’aide de guillemets, vous devez qualifier entièrement ce chemin d’accès lors du démarrage de n’importe quel processus trouvé dans cet emplacement. Sinon, le système ne trouvera pas le chemin d’accès. Par exemple, si `c:\mypath` n’est pas dans votre chemin d’accès, et l’ajouter à l’aide de guillemets : `path = %path%;"c:\mypath"`, vous devez qualifier complètement tout processus dans `c:\mypath` lorsque vous le démarrez.  
  
> [!NOTE]
>  Code de contrôle de page et de serveur Web ASP.NET s’exécute dans le contexte du processus de travail ASP.NET sur le serveur Web.  Si vous utilisez le <xref:System.Diagnostics.Process.Start%2A> méthode dans une page Web ASP.NET ou un contrôle de serveur, le nouveau processus s’exécute sur le serveur Web avec des autorisations restreintes. Le processus ne démarre pas dans le même contexte que le navigateur client et n’a pas accès au bureau de l’utilisateur.  
  
 Lorsque vous utilisez <xref:System.Diagnostics.Process.Start%2A> pour démarrer un processus, vous devrez peut-être fermer ou vous risquez de perdre des ressources système. Fermez les processus à l’aide de <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Vous pouvez vérifier si un processus a déjà été fermé à l’aide de son <xref:System.Diagnostics.Process.HasExited%2A> propriété.  
  
 Remarque à propos des États de cloisonnement dans les threads managés est nécessaire ici. Lorsque <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> est `true` sur le composant de traitement <xref:System.Diagnostics.Process.StartInfo%2A> propriété, vérifiez que vous avez défini un modèle de thread sur votre application en définissant l’attribut `[STAThread]` sur la `main()` (méthode). Sinon, un thread managé peut être dans un `unknown` d’état ou placé dans le `MTA` d’état, ce dernier qui est en conflit avec <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> en cours `true`. Certaines méthodes exigent que l’état de cloisonnement ne soit ne pas `unknown`. Si l’état n’est pas explicitement défini dans la lorsque l’application rencontre une telle méthode, il est par défaut `MTA`, et une fois définie, l’état de cloisonnement ne peut pas être modifié. Toutefois, `MTA` provoque une exception levée lorsque l’interpréteur de commandes du système d’exploitation gère le thread.  
  
   
  
## Examples  
 Tout d’abord, l’exemple suivant génère une instance d’Internet Explorer et affiche le contenu du dossier Favoris dans le navigateur. Ensuite, il démarre d’autres instances d’Internet Explorer et affiche certaines pages ou sites spécifiques. Enfin, il démarre Internet Explorer avec la fenêtre réduite pendant la navigation vers un site spécifique.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite lors de l’ouverture du fichier associé.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La variable d’environnement PATH a une chaîne contenant des guillemets.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom d'un fichier d'application à exécuter dans le processus.</param>
        <param name="arguments">Arguments de ligne de commande à passer au moment du démarrage du processus.</param>
        <summary>Démarre une ressource de processus en spécifiant le nom d'une application et un jeu d'arguments de ligne de commande et l'associe à la ressource avec un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu'un nouveau processus qui est démarré en même temps que les instances du même processus déjà en cours d'exécution sera indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour démarrer une ressource de processus en spécifiant son nom de fichier et les arguments de ligne de commande. La surcharge associe la ressource à un nouveau <xref:System.Diagnostics.Process> objet.  
  
> [!NOTE]
>  Si l’adresse du fichier exécutable à démarrer est une URL, le processus n’est pas démarré et `null` est retourné.  
  
 Cette surcharge vous permet de démarrer un processus sans d’abord créer un nouveau <xref:System.Diagnostics.Process> instance. La surcharge est une alternative aux étapes explicites de création d’un nouveau <xref:System.Diagnostics.Process> instance, en définissant le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> et <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membres de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété et l’appel <xref:System.Diagnostics.Process.Start%2A> pour le <xref:System.Diagnostics.Process> instance.  
  
 Démarrage d’un processus en spécifiant son nom de fichier et des arguments est similaire à entrer le nom de fichier et les arguments de ligne de commande dans le `Run` boîte de dialogue de la Windows `Start` menu. Par conséquent, le nom de fichier est inutile représenter un fichier exécutable. Il peut être de n’importe quel type de fichier pour lequel l’extension a été associé à une application installée sur le système. Par exemple, le nom de fichier peut avoir une extension .txt si vous avez associé les fichiers texte à un éditeur, tel que le bloc-notes, ou il peut avoir un .doc si vous avez les fichiers.doc à un outil de traitement de texte, tel que Microsoft Word. De même, dans la même façon que le `Run` boîte de dialogue peut accepter un nom de fichier exécutable avec ou sans l’extension .exe, l’extension .exe est facultative dans le `fileName` paramètre. Par exemple, vous pouvez définir le `fileName` paramètre « Notepad.exe » ou « Notepad ». Si le `fileName` paramètre représente un fichier exécutable, le `arguments` paramètre peut représenter un fichier sur lequel agir, tel que le fichier texte dans `Notepad.exe myfile.txt`. Si le `fileName` paramètre représente un fichier de commandes (.cmd), le `arguments` paramètre doit inclure un «`/c`« ou »`/k`» argument pour spécifier si la fenêtre de commande se termine ou qu’il reste après la saisie semi-automatique.  
  
 Contrairement aux autres surcharges, la surcharge de <xref:System.Diagnostics.Process.Start%2A> qui n’a aucun paramètre n’est pas un `static` membre. Utilisez cette surcharge lorsque vous avez déjà créé un <xref:System.Diagnostics.Process> de l’instance, les informations de début spécifiée (y compris le nom de fichier) et voulez démarrer une ressource de processus et l’associer avec le <xref:System.Diagnostics.Process> instance. Utilisez une de la `static` surcharges lorsque vous souhaitez créer un nouveau <xref:System.Diagnostics.Process> composant au lieu de démarrer un processus pour un composant existant. Cette surcharge et permettent tous deux la surcharge qui n’a aucun paramètre vous permet de spécifier le nom de fichier de la ressource de processus à démarrer et les arguments de ligne de commande à passer.  
  
 Si vous avez une variable de chemin d’accès déclarée dans votre système à l’aide de guillemets, vous devez qualifier entièrement ce chemin d’accès lors du démarrage de n’importe quel processus trouvé dans cet emplacement. Sinon, le système ne trouvera pas le chemin d’accès. Par exemple, si `c:\mypath` n’est pas dans votre chemin d’accès, et l’ajouter à l’aide de guillemets : `path = %path%;"c:\mypath"`, vous devez qualifier complètement tout processus dans `c:\mypath` lorsque vous le démarrez.  
  
> [!NOTE]
>  Code de contrôle de page et de serveur Web ASP.NET s’exécute dans le contexte du processus de travail ASP.NET sur le serveur Web.  Si vous utilisez le <xref:System.Diagnostics.Process.Start%2A> méthode dans une page Web ASP.NET ou un contrôle de serveur, le nouveau processus s’exécute sur le serveur Web avec des autorisations restreintes. Le processus ne démarre pas dans le même contexte que le navigateur client et n’a pas accès au bureau de l’utilisateur.  
  
 Lorsque vous utilisez <xref:System.Diagnostics.Process.Start%2A> pour démarrer un processus, vous devrez peut-être fermer ou vous risquez de perdre des ressources système. Fermez les processus à l’aide de <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Vous pouvez vérifier si un processus a déjà été fermé à l’aide de son <xref:System.Diagnostics.Process.HasExited%2A> propriété...  
  
 Remarque à propos des États de cloisonnement dans les threads managés est nécessaire ici. Lorsque <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> est `true` sur le composant de traitement <xref:System.Diagnostics.Process.StartInfo%2A> propriété, vérifiez que vous avez défini un modèle de thread sur votre application en définissant l’attribut `[STAThread]` sur la `main()` (méthode). Sinon, un thread managé peut être dans un `unknown` d’état ou placé dans le `MTA` d’état, ce dernier qui est en conflit avec <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> en cours `true`. Certaines méthodes exigent que l’état de cloisonnement ne soit ne pas `unknown`. Si l’état n’est pas explicitement défini dans la lorsque l’application rencontre une telle méthode, il est par défaut `MTA`, et une fois définie, l’état de cloisonnement ne peut pas être modifié. Toutefois, `MTA` provoque une exception levée lorsque l’interpréteur de commandes du système d’exploitation gère le thread.  
  
   
  
## Examples  
 Tout d’abord, l’exemple suivant génère une instance d’Internet Explorer et affiche le contenu du dossier Favoris dans le navigateur. Ensuite, il démarre d’autres instances d’Internet Explorer et affiche certaines pages ou sites spécifiques. Enfin, il démarre Internet Explorer avec la fenêtre réduite pendant la navigation vers un site spécifique.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le paramètre <paramref name="fileName" /> ou <paramref name="arguments" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite lors de l’ouverture du fichier associé.  
  
- ou - 
La somme de la longueur des arguments et de la longueur du chemin d’accès complet au processus dépasse 2 080. Le message d’erreur associé à cette exception peut être un des suivants : « La zone de données passée à un appel système est insuffisante. » ou « Accès refusé. »</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La variable d’environnement PATH a une chaîne contenant des guillemets.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom d'un fichier d'application à exécuter dans le processus.</param>
        <param name="userName">Nom d'utilisateur à utiliser au moment du démarrage du processus.</param>
        <param name="password">
          <see cref="T:System.Security.SecureString" /> qui contient le mot de passe à utiliser lors du démarrage du processus.</param>
        <param name="domain">Domaine à utiliser au moment du démarrage du processus.</param>
        <summary>Démarre une ressource de processus en spécifiant le nom d'une application, un nom d'utilisateur, un mot de passe et un domaine et associe la ressource à un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu'un nouveau processus qui est démarré en même temps que les instances du même processus déjà en cours d'exécution sera indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer un nouveau processus et son thread principal en spécifiant son nom de fichier, le nom d’utilisateur, le mot de passe et le domaine. Le nouveau processus exécute ensuite le fichier exécutable spécifié dans le contexte de sécurité des informations d’identification spécifiées (utilisateur, domaine et mot de passe).  
  
> [!NOTE]
>  Lorsque le fichier exécutable se trouve sur un lecteur distant, vous devez identifier le partage réseau à l’aide d’un identificateur de ressource uniforme (URI), pas une lettre de lecteur associée.  
  
> [!NOTE]
>  Si l’adresse du fichier exécutable à démarrer est une URL, le processus n’est pas démarré et `null` est retourné.  
  
 Cette surcharge vous permet de démarrer un processus sans d’abord créer un nouveau <xref:System.Diagnostics.Process> instance. La surcharge est une alternative aux étapes explicites de création d’un nouveau <xref:System.Diagnostics.Process> instance, en définissant le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, et <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propriétés de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété et l’appel <xref:System.Diagnostics.Process.Start%2A> pour le <xref:System.Diagnostics.Process> instance.  
  
 De même, dans la même façon que le **exécuter** boîte de dialogue peut accepter un nom de fichier exécutable avec ou sans l’extension .exe, l’extension .exe est facultative dans le `fileName` paramètre. Par exemple, vous pouvez définir le `fileName` paramètre « Notepad.exe » ou « Notepad ». Si le `fileName` paramètre représente un fichier exécutable, le `arguments` paramètre peut représenter un fichier sur lequel agir, tel que le fichier texte dans `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Le nom de fichier doit représenter un fichier exécutable dans le <xref:System.Diagnostics.Process.Start%2A> surcharges ayant `userName`, `password`, et `domain` paramètres.  
  
 Lorsque vous utilisez <xref:System.Diagnostics.Process.Start%2A> pour démarrer un processus, vous devrez peut-être fermer ou vous risquez de perdre des ressources système. Fermez les processus à l’aide de <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Vous pouvez vérifier si un processus a déjà été fermé à l’aide de son <xref:System.Diagnostics.Process.HasExited%2A> propriété...  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette surcharge pour démarrer un fichier exécutable et montre également la levée d’une <xref:System.ComponentModel.Win32Exception> lorsqu’une tentative est effectuée pour démarrer une application associée à un fichier non exécutable.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun nom de fichier n’a été spécifié.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite à l’ouverture du fichier associé.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Méthode non prise en charge sur Linux ou macOS (.NET Core uniquement).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom d'un fichier d'application à exécuter dans le processus.</param>
        <param name="arguments">Arguments de ligne de commande à passer au moment du démarrage du processus.</param>
        <param name="userName">Nom d'utilisateur à utiliser au moment du démarrage du processus.</param>
        <param name="password">
          <see cref="T:System.Security.SecureString" /> qui contient le mot de passe à utiliser lors du démarrage du processus.</param>
        <param name="domain">Domaine à utiliser au moment du démarrage du processus.</param>
        <summary>Démarre une ressource de processus en spécifiant le nom d'une application, un jeu d'arguments de ligne de commande, un nom d'utilisateur, un mot de passe et un domaine, et associe la ressource à un nouveau composant <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nouvel élément <see cref="T:System.Diagnostics.Process" /> qui est associé à la ressource de processus, ou <see langword="null" /> si aucune ressource de processus n'est démarrée. Notez qu'un nouveau processus qui est démarré en même temps que les instances du même processus déjà en cours d'exécution sera indépendant des autres. En outre, le démarrage peut retourner un processus non null avec sa propriété <see cref="P:System.Diagnostics.Process.HasExited" /> déjà définie à <see langword="true" />. Dans ce cas, le processus démarré peut avoir activé une instance existante de lui-même, puis s'être arrêté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer un nouveau processus et son thread principal en spécifiant son nom de fichier, des arguments de ligne de commande, un nom d’utilisateur, un mot de passe et un domaine. Le nouveau processus exécute ensuite le fichier exécutable spécifié dans le contexte de sécurité des informations d’identification spécifiées (utilisateur, domaine et mot de passe).  
  
> [!NOTE]
>  Lorsque le fichier exécutable se trouve sur un lecteur distant, vous devez identifier le partage réseau à l’aide d’un identificateur de ressource uniforme (URI), pas une lettre de lecteur associée.  
  
> [!NOTE]
>  Si l’adresse du fichier exécutable à démarrer est une URL, le processus n’est pas démarré et `null` est retourné.  
  
 Cette surcharge vous permet de démarrer un processus sans d’abord créer un nouveau <xref:System.Diagnostics.Process> instance. La surcharge est une alternative aux étapes explicites de création d’un nouveau <xref:System.Diagnostics.Process> instance, en définissant le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, et <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propriétés de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété et l’appel <xref:System.Diagnostics.Process.Start%2A> pour le <xref:System.Diagnostics.Process> instance.  
  
 De même, dans la même façon que le **exécuter** boîte de dialogue peut accepter un nom de fichier exécutable avec ou sans l’extension .exe, l’extension .exe est facultative dans le `fileName` paramètre. Par exemple, vous pouvez définir le `fileName` paramètre « Notepad.exe » ou « Notepad ». Si le `fileName` paramètre représente un fichier exécutable, le `arguments` paramètre peut représenter un fichier sur lequel agir, tel que le fichier texte dans `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Le nom de fichier doit représenter un fichier exécutable dans le <xref:System.Diagnostics.Process.Start%2A> surcharges ayant `userName`, `password`, et `domain` paramètres.  
  
 Lorsque vous utilisez <xref:System.Diagnostics.Process.Start%2A> pour démarrer un processus, vous devrez peut-être fermer ou vous risquez de perdre des ressources système. Fermez les processus à l’aide de <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Vous pouvez vérifier si un processus a déjà été fermé à l’aide de son <xref:System.Diagnostics.Process.HasExited%2A> propriété...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun nom de fichier n’a été spécifié.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite lors de l’ouverture du fichier associé.  
  
- ou - 
La somme de la longueur des arguments et de la longueur du chemin d’accès complet au fichier associé dépasse 2080. Le message d’erreur associé à cette exception peut être un des suivants : « La zone de données passée à un appel système est insuffisante. » ou « Accès refusé. »</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet de processus a déjà été supprimé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Méthode non prise en charge sur Linux ou macOS (.NET Core uniquement).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les propriétés à passer à la méthode <see cref="M:System.Diagnostics.Process.Start" /> de <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> qui représente les données avec lesquelles démarrer le processus. Ces arguments comprennent le nom du fichier exécutable ou du document utilisé pour démarrer le processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> représente le jeu de paramètres à utiliser pour démarrer un processus. Lorsque <xref:System.Diagnostics.Process.Start%2A> est appelée, le <xref:System.Diagnostics.Process.StartInfo%2A> est utilisé pour spécifier le processus à démarrer. Nécessaire uniquement <xref:System.Diagnostics.Process.StartInfo%2A> membre à définir est le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété. Démarrage d’un processus en spécifiant le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété équivaut à taper les informations contenues dans le **exécuter** boîte de dialogue de la Windows **Démarrer** menu. Par conséquent, le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété n’a pas besoin de représenter un fichier exécutable. Il peut être de n’importe quel type de fichier pour lequel l’extension a été associé à une application installée sur le système. Par exemple le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> peut avoir une extension .txt si vous avez associé les fichiers texte à un éditeur, tel que le bloc-notes, ou il peut avoir un .doc si vous avez les fichiers.doc à un outil de traitement de texte, tel que Microsoft Word. De même, dans la même façon que le **exécuter** boîte de dialogue peut accepter un nom de fichier exécutable avec ou sans l’extension .exe, l’extension .exe est facultative dans le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membre. Par exemple, vous pouvez définir le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> « Notepad.exe » ou « Notepad » à la propriété.  
  
 Vous pouvez démarrer une application ClickOnce en définissant le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété à l’emplacement (par exemple, une adresse Web) à partir duquel vous avez installé l’application. Ne démarrez pas une application ClickOnce en spécifiant son emplacement d’installation sur votre disque dur.  
  
 Si le nom de fichier implique un fichier non exécutable, tel qu’un fichier .doc, vous pouvez inclure un verbe spécifiant l’action à réaliser sur le fichier. Par exemple, vous pouvez définir le <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> à « Impression » pour un fichier se terminant par l’extension .doc. Le nom de fichier spécifié dans le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété ne doit pas avoir une extension si vous entrez manuellement une valeur pour le <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> propriété. Toutefois, si vous utilisez le <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> propriété afin de déterminer les verbes sont disponibles, vous devez inclure l’extension.  
  
 Vous pouvez modifier les paramètres spécifiés dans le <xref:System.Diagnostics.Process.StartInfo%2A> propriété jusqu'à l’heure que vous appelez le <xref:System.Diagnostics.Process.Start%2A> méthode sur le processus. Après avoir démarré le processus, la modification la <xref:System.Diagnostics.Process.StartInfo%2A> valeurs n’affectent pas ou ne redémarrez le processus associé. Si vous appelez le <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> méthode avec le <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> et <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> non managé, de jeu de propriétés `CreateProcessWithLogonW` fonction est appelée, ce qui démarre le processus dans une nouvelle fenêtre, même lorsque le <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> valeur de propriété est `true` ou le <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> valeur de propriété est <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Si vous n’avez pas utilisé le <xref:System.Diagnostics.Process.Start%2A> méthode pour démarrer un processus, le <xref:System.Diagnostics.Process.StartInfo%2A> propriété ne reflète pas les paramètres utilisés pour démarrer le processus. Par exemple, si vous utilisez <xref:System.Diagnostics.Process.GetProcesses%2A> pour obtenir un tableau des processus en cours d’exécution sur l’ordinateur, le <xref:System.Diagnostics.Process.StartInfo%2A> propriété de chaque <xref:System.Diagnostics.Process> ne contient pas le nom de fichier d’origine ou les arguments utilisés pour démarrer le processus.  
  
 Lorsque le processus est démarré, le nom de fichier est le fichier qui remplit la (en lecture seule) <xref:System.Diagnostics.Process.MainModule%2A> propriété. Si vous souhaitez récupérer le fichier exécutable qui est associé au processus une fois que le processus a démarré, utilisez le <xref:System.Diagnostics.Process.MainModule%2A> propriété. Si vous souhaitez définir le fichier exécutable d’un <xref:System.Diagnostics.Process> de l’instance pour laquelle un processus associé n’a pas été démarré, utilisez le <xref:System.Diagnostics.Process.StartInfo%2A> la propriété <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membre. Car les membres de la <xref:System.Diagnostics.Process.StartInfo%2A> propriété sont des arguments qui sont passés à la <xref:System.Diagnostics.Process.Start%2A> (méthode) d’un processus, en modifiant le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriété une fois que le processus associé a démarré ne réinitialise pas le <xref:System.Diagnostics.Process.MainModule%2A> propriété. Ces propriétés sont utilisées uniquement pour initialiser le processus associé.  
  
   
  
## Examples  
 L’exemple suivant remplit un <xref:System.Diagnostics.Process.StartInfo%2A> avec le fichier à exécuter, l’action effectuée sur celui-ci et si elle doit afficher une interface utilisateur. Pour obtenir des exemples supplémentaires, consultez les pages de référence pour les propriétés de la <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Valeur qui spécifie que <see cref="P:System.Diagnostics.Process.StartInfo" /> a la valeur <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'heure à laquelle le processus associé a démarré.</summary>
        <value>Objet qui indique l'heure de démarrage du processus. Une exception est levée si le processus n'est pas en cours d'exécution.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.StartTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus s’est fermé.  
  
- ou - 
Le processus n’a pas été démarré.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s’est produite dans l’appel à la fonction Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’objet utilisé pour marshaler des appels du gestionnaire d’événements émis à la suite d’un événement de sortie de processus.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> utilisé pour marshaler les appels du gestionnaire d'événements émis à la suite d'un événement <see cref="E:System.Diagnostics.Process.Exited" /> sur le processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> est `null`, méthodes qui gèrent le <xref:System.Diagnostics.Process.Exited> événement sont appelées sur un thread du pool de threads système. Pour plus d’informations sur les pools de threads système, consultez <xref:System.Threading.ThreadPool>.  
  
 Lorsque le <xref:System.Diagnostics.Process.Exited> événement est géré par un composant Windows Forms visuel, comme un <xref:System.Windows.Forms.Button>, l’accès au composant via le pool de threads système peut ne pas fonctionner, ou peut entraîner une exception. Éviter ce problème en définissant <xref:System.Diagnostics.Process.SynchronizingObject%2A> à un composant Windows Forms, ce qui provoque les méthodes gérant le <xref:System.Diagnostics.Process.Exited> événement à appeler sur le même thread que celui sur lequel le composant a été créé.  
  
 Si le <xref:System.Diagnostics.Process> est utilisé à l’intérieur de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] dans un concepteur Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> est automatiquement défini sur le contrôle qui contient le <xref:System.Diagnostics.Process>. Par exemple, si vous placez un <xref:System.Diagnostics.Process> sur un concepteur pour `Form1` (qui hérite <xref:System.Windows.Forms.Form>) le <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriété du <xref:System.Diagnostics.Process> est défini sur l’instance de `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 En règle générale, cette propriété est définie lorsque le composant est placé dans un contrôle ou un formulaire, car ces composants sont liés à un thread spécifique.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le jeu des threads en cours d'exécution dans le processus associé.</summary>
        <value>Tableau de type <see cref="T:System.Diagnostics.ProcessThread" /> représentant les threads du système d'exploitation en cours d'exécution dans le processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread exécute le code dans un processus. Chaque processus est démarré avec un thread unique, son thread principal. N’importe quel thread peut créer des threads supplémentaires. Les threads dans un processus partagent l’espace d’adressage du processus.  
  
 Utilisez <xref:System.Diagnostics.ProcessThread> pour obtenir tous les threads associés au processus en cours. Le thread principal n’est pas nécessairement à l’index zéro dans le tableau.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Le processus n’a pas de <see cref="P:System.Diagnostics.Process.Id" />, ou aucun processus n’est associé à l’instance <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
Le processus associé s’est arrêté.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me) ; affectez à <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> la valeur <see langword="false" /> pour accéder à cette propriété sur Windows 98 et Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met en forme le nom du processus en tant que chaîne, combinée au type de composant parent, le cas échéant.</summary>
        <returns>
          <see cref="P:System.Diagnostics.Process.ProcessName" /> combiné avec la valeur de retour <see cref="M:System.Object.ToString" /> du composant de base.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> n’est pas pris en charge sur Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le temps processeur total pour ce processus.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> qui indique la durée d'utilisation de l'unité centrale par le processus associé. Cette valeur est la somme de <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> et de <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le temps processeur utilisateur pour ce processus.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> qui indique la durée d'exécution du code par le processus associé à l'intérieur de la partie application du processus (plutôt qu'à l'intérieur du noyau du système d'exploitation).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <exception cref="T:System.NotSupportedException">Vous tentez d’accéder à la propriété <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> d’un processus en cours d’exécution sur un ordinateur distant. Cette propriété est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille (en octets) de la mémoire virtuelle du processus.</summary>
        <value>Quantité de mémoire virtuelle, en octets, demandée par le processus associé.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire virtuelle, en octets, allouée au processus associé.</summary>
        <value>Quantité de la mémoire virtuelle, en octets, allouée pour le processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété représente la taille actuelle de mémoire virtuelle utilisée par le processus, en octets. Le système d’exploitation mappe l’espace d’adressage virtuel pour chaque processus aux pages chargées dans la mémoire physique ou aux pages stockées dans le fichier de pagination de mémoire virtuelle sur le disque.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **octets virtuels** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit le délai d'attente pour l'arrêt du processus associé et bloque le thread en cours d'exécution jusqu'à l'expiration du délai d'attente ou l'arrêt du processus. Pour éviter de bloquer le thread actif, utilisez l'événement <see cref="E:System.Diagnostics.Process.Exited" />.  
  
Pour des exemples de code, consultez les pages de référence des propriétés <see cref="P:System.Diagnostics.Process.StandardError" /> et <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique au composant <see cref="T:System.Diagnostics.Process" /> d'attendre indéfiniment que le processus associé s'arrête.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> rend le thread actuel d’attendre jusqu'à ce que le processus associé s’arrête.  Il doit être appelée une fois que toutes les autres méthodes sont appelées sur le processus. Pour éviter de bloquer le thread actif, utilisez l'événement <xref:System.Diagnostics.Process.Exited>.  
  
 Cette méthode indique à la <xref:System.Diagnostics.Process> composant d’attendre pendant une durée illimitée pour les gestionnaires d’événements et de processus quitter. Cela peut entraîner une application cesse de répondre. Par exemple, si vous appelez <xref:System.Diagnostics.Process.CloseMainWindow%2A> pour un processus qui possède une interface utilisateur, la demande au système d’exploitation pour arrêter le processus associé ne soient pas traitée si le processus est écrit à ne jamais accéder à sa boucle de message.  
  
> [!NOTE]
>  Dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] et versions antérieures, le <xref:System.Diagnostics.Process.WaitForExit> surcharge a attendu <xref:System.Int32.MaxValue> millisecondes (environ 24 jours), pas indéfiniment. En outre, les versions précédentes n’ont pas attendu pour les gestionnaires d’événements quitter si la version complète <xref:System.Int32.MaxValue> temps a été atteinte.  
  
 Cette surcharge permet de s’assurer que tout le traitement terminé, y compris la gestion des événements asynchrones pour la sortie standard redirigée. Vous devez utiliser cette surcharge après un appel à la <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> surcharge lorsque la sortie standard a été redirigée vers les gestionnaires d’événements asynchrones.  
  
 Quand un processus associé s’arrête (autrement dit, quand il est arrêté par le système d’exploitation via un arrêt normal ou anormal), le système stocke les informations d’administration sur le processus et retourne au composant qui avait appelé <xref:System.Diagnostics.Process.WaitForExit>. Le <xref:System.Diagnostics.Process> composant peut accéder ensuite les informations, qui incluant le <xref:System.Diagnostics.Process.ExitTime%2A>, à l’aide de la <xref:System.Diagnostics.Process.Handle%2A> du processus arrêté.  
  
 Étant donné que le processus associé s’est fermé, le <xref:System.Diagnostics.Process.Handle%2A> propriété du composant ne pointe plus vers une ressource de processus existante. Au lieu de cela, le handle peut être utilisé uniquement pour accéder aux informations du système d’exploitation sur la ressource de processus. Le système est informé de handles de processus terminés n’ont pas été libérées par <xref:System.Diagnostics.Process> composants, et il conserve donc le <xref:System.Diagnostics.Process.ExitTime%2A> et <xref:System.Diagnostics.Process.Handle%2A> informations contenues dans la mémoire jusqu'à ce que le <xref:System.Diagnostics.Process> composant libère plus précisément les ressources. Pour cette raison, chaque fois que vous appelez <xref:System.Diagnostics.Process.Start%2A> pour un <xref:System.Diagnostics.Process> d’une instance, appelez <xref:System.Diagnostics.Process.Close%2A> lorsque le processus associé s’est terminée et que vous n’avez plus besoin des informations administratives. <xref:System.Diagnostics.Process.Close%2A> Libère la mémoire allouée au processus terminé.  
  
   
  
## Examples  
 Consultez la section Notes de la <xref:System.Diagnostics.Process.StandardError%2A> page de référence de propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Impossible d’accéder au paramètre d’attente.</exception>
        <exception cref="T:System.SystemException">Aucun processus <see cref="P:System.Diagnostics.Process.Id" /> n’a été défini, et un <see cref="P:System.Diagnostics.Process.Handle" /> à partir duquel la propriété <see cref="P:System.Diagnostics.Process.Id" /> peut être déterminée n’existe pas.  
  
- ou - 
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
Vous tentez d’appeler <see cref="M:System.Diagnostics.Process.WaitForExit" /> pour un processus en cours d’exécution sur un ordinateur distant. Cette méthode est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Délai, en millisecondes, à attendre que le processus associé s'arrête. Le maximum est la plus grande valeur possible d'un entier 32 bits, qui représente l'infini pour le système d'exploitation.</param>
        <summary>Indique au composant <see cref="T:System.Diagnostics.Process" /> d'attendre le nombre de millisecondes spécifié que le processus associé s'arrête.</summary>
        <returns>
          <see langword="true" /> si le processus associé s'est arrêté ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> rend le thread actuel d’attendre jusqu'à ce que le processus associé s’arrête. Il doit être appelée une fois que toutes les autres méthodes sont appelées sur le processus. Pour éviter de bloquer le thread actif, utilisez l'événement <xref:System.Diagnostics.Process.Exited>.  
  
 Cette méthode indique à la <xref:System.Diagnostics.Process> composant à attendre pendant un laps de temps pour le processus s’arrête. Si le processus associé ne se ferme pas avant la fin de l’intervalle, car la demande d’arrêt est refusée, `false` est retournée à la procédure appelante. Vous pouvez spécifier <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pour `milliseconds`, et <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> se comporte comme le <xref:System.Diagnostics.Process.WaitForExit> de surcharge. Si vous passez 0 (zéro) à la méthode, elle retourne `true` uniquement si le processus s’est déjà arrêté ; sinon, elle retourne immédiatement `false`.  
  
> [!NOTE]
>  Dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] et versions antérieures, si `milliseconds` était -1, le <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> surcharge a attendu <xref:System.Int32.MaxValue> millisecondes (environ 24 jours), pas indéfiniment.  
  
 Lors de la sortie standard a été redirigée vers les gestionnaires d’événements asynchrones, il est possible que le traitement de sortie ne soit pas terminé lorsque cette méthode est retournée. Pour vous assurer que la gestion des événements asynchrone sont terminée, appelez le <xref:System.Diagnostics.Process.WaitForExit> surcharge qui ne prend aucun paramètre après avoir reçu un `true` à partir de cette surcharge. Pour vérifier que le <xref:System.Diagnostics.Process.Exited> événement est géré correctement dans les applications Windows Forms, définissez le <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriété.  
  
 Quand un processus associé s’arrête (est arrêtée par le système d’exploitation via un arrêt normal ou anormal), le système stocke les informations d’administration sur le processus et retourne au composant qui avait appelé <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. Le <xref:System.Diagnostics.Process> composant peut accéder ensuite les informations, qui incluant le <xref:System.Diagnostics.Process.ExitTime%2A>, à l’aide de la <xref:System.Diagnostics.Process.Handle%2A> du processus arrêté.  
  
 Étant donné que le processus associé s’est fermé, le <xref:System.Diagnostics.Process.Handle%2A> propriété du composant ne pointe plus vers une ressource de processus existante. Au lieu de cela, le handle peut être utilisé uniquement pour accéder aux informations du système d’exploitation sur la ressource de processus. Le système est informé de handles de processus terminés n’ont pas été libérées par <xref:System.Diagnostics.Process> composants, et il conserve donc le <xref:System.Diagnostics.Process.ExitTime%2A> et <xref:System.Diagnostics.Process.Handle%2A> informations contenues dans la mémoire jusqu'à ce que le <xref:System.Diagnostics.Process> composant libère plus précisément les ressources. Pour cette raison, chaque fois que vous appelez <xref:System.Diagnostics.Process.Start%2A> pour un <xref:System.Diagnostics.Process> d’une instance, appelez <xref:System.Diagnostics.Process.Close%2A> lorsque le processus associé s’est terminée et que vous n’avez plus besoin des informations administratives. <xref:System.Diagnostics.Process.Close%2A> Libère la mémoire allouée au processus terminé.  
  
   
  
## Examples  
 Consultez l’exemple de code pour le <xref:System.Diagnostics.Process.ExitCode%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Impossible d’accéder au paramètre d’attente.</exception>
        <exception cref="T:System.SystemException">Aucun processus <see cref="P:System.Diagnostics.Process.Id" /> n’a été défini, et un <see cref="P:System.Diagnostics.Process.Handle" /> à partir duquel la propriété <see cref="P:System.Diagnostics.Process.Id" /> peut être déterminée n’existe pas.  
  
- ou - 
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
Vous tentez d’appeler <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> pour un processus en cours d’exécution sur un ordinateur distant. Cette méthode est disponible uniquement pour les processus en cours d’exécution sur l’ordinateur local.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fait en sorte que le composant <see cref="T:System.Diagnostics.Process" /> attende que le processus associé passe à un état inactif.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait en sorte que le composant <see cref="T:System.Diagnostics.Process" /> attende indéfiniment que le processus associé passe à un état inactif. Cette surcharge s'applique uniquement aux processus dotés d'une interface utilisateur et, donc, d'une boucle de message.</summary>
        <returns>
          <see langword="true" /> si le processus associé est devenu inactif.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Diagnostics.Process.WaitForInputIdle> pour forcer le traitement de votre application à attendre jusqu'à ce que la boucle de message a retourné l’état inactif. Quand un processus avec une interface utilisateur s’exécute, sa boucle de messages s’exécute chaque fois qu’un message Windows est envoyé au processus par le système d’exploitation. Le processus revient alors à la boucle de message. Un processus est dite dans un état inactif lorsqu’il est en attente de messages à l’intérieur d’une boucle de message. Cet état est utile, par exemple, lorsque votre application doit attendre pour un processus de départ terminer la création de la fenêtre principale avant l’application communique avec cette fenêtre.  
  
 Si un processus n’a pas d’une boucle de message, <xref:System.Diagnostics.Process.WaitForInputIdle> lève une <xref:System.InvalidOperationException>.  
  
 Le <xref:System.Diagnostics.Process.WaitForInputIdle> surcharge demande le <xref:System.Diagnostics.Process> composant d’attendre indéfiniment que le processus devienne inactif dans la boucle de message. Cette instruction peut entraîner une application cesse de répondre. Par exemple, si le processus est écrit de manière à toujours fermer sa boucle de messages immédiatement, comme dans le fragment de code `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le processus ne dispose pas d’une interface graphique.  
  
- ou - 
Une erreur inconnue s'est produite. Le processus n’est pas parvenu à entrer dans un état inactif.  
  
- ou - 
Le processus est déjà terminé.  
  
- ou - 
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Une valeur de 1 à <see cref="F:System.Int32.MaxValue" /> qui spécifie la durée, en millisecondes, à attendre que le processus associé devienne inactif. Une valeur de 0 spécifie un retour immédiat et une valeur de -1 spécifie une attente infinie.</param>
        <summary>Fait en sorte que le composant <see cref="T:System.Diagnostics.Process" /> attende pendant le nombre spécifié de millisecondes que le processus associé passe à un état inactif. Cette surcharge s'applique uniquement aux processus dotés d'une interface utilisateur et, donc, d'une boucle de message.</summary>
        <returns>
          <see langword="true" /> si le processus associé a atteint un état inactif ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> pour forcer le traitement de votre application à attendre jusqu'à ce que la boucle de message a retourné l’état inactif. Quand un processus avec une interface utilisateur s’exécute, sa boucle de messages s’exécute chaque fois qu’un message Windows est envoyé au processus par le système d’exploitation. Le processus revient alors à la boucle de message. Un processus est dite dans un état inactif lorsqu’il est en attente de messages à l’intérieur d’une boucle de message. Cet état est utile, par exemple, lorsque votre application doit attendre pour un processus de départ terminer la création de la fenêtre principale avant l’application communique avec cette fenêtre.  
  
 Si un processus n’a pas d’une boucle de message, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> lève une <xref:System.InvalidOperationException>.  
  
 Le <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> surcharge demande le <xref:System.Diagnostics.Process> composant à attendre pendant un laps de temps pour le processus à l’état inactif dans la boucle de message. Si le processus associé ne devient pas inactif à la fin de l’intervalle, car la boucle est toujours traiter les messages, `false` est retournée à la procédure appelante.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le processus ne dispose pas d’une interface graphique.  
  
- ou - 
Une erreur inconnue s'est produite. Le processus n’est pas parvenu à entrer dans un état inactif.  
  
- ou - 
Le processus est déjà terminé.  
  
- ou - 
Aucun processus n’est associé à cet objet <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’utilisation de mémoire physique du processus associé, en octets.</summary>
        <value>Quantité totale de mémoire physique utilisée par le processus associé, en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété représente la taille actuelle de l’utilisation de définir la mémoire utilisée par le processus, en octets. La plage de travail d’un processus est l’ensemble de pages de mémoire actuellement visibles par le processus dans la mémoire RAM physique. Ces pages sont résidentes et disponibles pour une application sans déclencher une erreur de page.  
  
 La plage de travail inclut des données partagées et privées. Les données partagées incluent les pages qui contiennent toutes les instructions que le processus s’exécute, y compris les modules de processus et les bibliothèques système.  
  
   
  
## Examples  
 L’exemple suivant démarre une instance de bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche le code de sortie du processus.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire physique, en octets, allouée au processus associé.</summary>
        <value>Quantité de la mémoire physique, en octets, allouée pour le processus associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété représente la taille actuelle de l’utilisation de définir la mémoire utilisée par le processus, en octets. La plage de travail d’un processus est l’ensemble de pages de mémoire actuellement visibles par le processus dans la mémoire RAM physique. Ces pages sont résidentes et disponibles pour une application sans déclencher une erreur de page.  
  
 La plage de travail inclut des données partagées et privées. Les données partagées incluent les pages qui contiennent toutes les instructions que le processus s’exécute, y compris les instructions dans les modules de processus et les bibliothèques système.  
  
 Cette propriété peut être utilisée pour surveiller l’utilisation de la mémoire sur les ordinateurs avec les processeurs 32 bits ou 64 bits. La valeur de propriété est équivalente à la **jeu de travail** compteur de performances pour le processus.  
  
   
  
## Examples  
 L’exemple de code suivant démarre une instance de l’application Bloc-notes. Ensuite, l’exemple récupère et affiche les différentes propriétés du processus associé. L’exemple détecte lorsque le processus se termine et affiche ses statistiques de la mémoire de sortie de code et de pointe.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition (Windows Me), qui ne prennent pas en charge cette propriété.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>