<Type Name="Trace" FullName="System.Diagnostics.Trace">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9ce349e938cbbfe615cd631111cb2663fbd39683" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061491" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Trace" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Trace extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Trace" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Trace" />
  <TypeSignature Language="C++ CLI" Value="public ref class Trace sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un ensemble de méthodes et de propriétés qui vous permettent de tracer l'exécution de votre code. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser les propriétés et méthodes de la <xref:System.Diagnostics.Trace> classe à la version des informations relatives aux builds. Instrumentation vous permet d’analyser l’intégrité de votre application en cours d’exécution dans les paramètres de la vie réelle. Le traçage vous aide à isoler les problèmes et les résoudre sans porter atteinte à un système en cours d’exécution.  
  
 Cette classe fournit des méthodes pour afficher une <xref:System.Diagnostics.Trace.Assert%2A> boîte de dialogue et permet d’envoyer une assertion qui sera toujours <xref:System.Diagnostics.Trace.Fail%2A>. Cette classe fournit des méthodes d’écriture avec les variations suivantes : <xref:System.Diagnostics.Trace.Write%2A>, <xref:System.Diagnostics.Trace.WriteLine%2A>, <xref:System.Diagnostics.Trace.WriteIf%2A>, et <xref:System.Diagnostics.Trace.WriteLineIf%2A>.  
  
 Le <xref:System.Diagnostics.BooleanSwitch> et <xref:System.Diagnostics.TraceSwitch> classes fournissent des moyens de contrôler de manière dynamique la sortie de traçage. Vous pouvez modifier les valeurs de ces commutateurs sans recompiler votre application. Pour plus d’informations sur l’utilisation du fichier de configuration pour définir un commutateur, consultez la <xref:System.Diagnostics.Switch> classe et le [Comment : créer, initialiser et configurer des commutateurs de Trace](~/docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md) rubrique.  
  
 Vous pouvez personnaliser la cible de la sortie du traçage en ajoutant <xref:System.Diagnostics.TraceListener> instances à ou la suppression d’instances à partir de la <xref:System.Diagnostics.Trace.Listeners%2A> collection. Le <xref:System.Diagnostics.Trace.Listeners%2A> collection est partagée par les deux le <xref:System.Diagnostics.Debug> et <xref:System.Diagnostics.Trace> classes ; Ajout d’un écouteur de suivi à chaque classe ajoute l’écouteur à la fois. Par défaut, la sortie de trace est émise à l’aide de la <xref:System.Diagnostics.DefaultTraceListener> classe.  
  
> [!NOTE]
>  Ajout d’un écouteur de trace à le <xref:System.Diagnostics.Trace.Listeners%2A> collection peut provoquer une exception levée lors du traçage, si une ressource utilisée par l’écouteur de suivi n’est pas disponible. Les conditions et l’exception levée dépendent de l’écouteur de suivi et ne peut pas être énumérés dans cette rubrique. Il peut être utile de placer des appels à la <xref:System.Diagnostics.Trace> méthodes dans `try` / `catch` blocs pour détecter et gérer toutes les exceptions dans les écouteurs de la trace.  
  
> [!NOTE]
>  Si vous ajoutez des écouteurs de traçage au code partiellement fiable, vous obtiendrez un <xref:System.Security.SecurityException> nécessite l’exception, car l’ajout d’écouteurs de traçage <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> autorisation. Pour tracer le code partiellement fiable qui est en cours d’exécution dans un bac à sable dans Visual Studio, n’ajoutez pas d’écouteurs de la trace. Au lieu de cela, afficher le <xref:System.Diagnostics.Trace> et <xref:System.Diagnostics.Debug> des messages dans la **sortie** fenêtre.  
  
 Le <xref:System.Diagnostics.Trace> classe fournit des propriétés pour obtenir ou définir le niveau de <xref:System.Diagnostics.Trace.Indent%2A>, le <xref:System.Diagnostics.Trace.IndentSize%2A>et s’il faut <xref:System.Diagnostics.Trace.AutoFlush%2A> après chaque écriture.  
  
 Pour définir le <xref:System.Diagnostics.Trace.AutoFlush%2A> et <xref:System.Diagnostics.Trace.IndentSize%2A> pour <xref:System.Diagnostics.Trace>, vous pouvez modifier le fichier de configuration qui correspond au nom de votre application. Le fichier de configuration doit être mis en forme à l’exemple suivant :  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="false" indentsize="3" />  
  </system.diagnostics>  
</configuration>  
```  
  
 Le <xref:System.Diagnostics.ConditionalAttribute> attribut est appliqué aux méthodes de <xref:System.Diagnostics.Trace>. Les compilateurs qui prennent en charge <xref:System.Diagnostics.ConditionalAttribute> ignorent les appels à ces méthodes, sauf si « TRACE » est défini comme un symbole de compilation conditionnelle. Reportez-vous à la documentation d’un compilateur pour déterminer si <xref:System.Diagnostics.ConditionalAttribute> est pris en charge et la syntaxe permettant de définir un symbole de compilation conditionnelle.  
  
> [!NOTE]
>  Dans les projets Visual Studio, par défaut, le symbole de compilation conditionnelle « DEBUG » est défini pour les versions debug, et le symbole « TRACE » est défini pour les deux de débogage et les versions release. Pour plus d’informations sur la manière de désactiver ce comportement, consultez la documentation de Visual Studio.  
  
 Pour définir le symbole de compilation conditionnelle « TRACE » en c#, ajoutez le `/d:TRACE` option à la ligne de commande du compilateur lorsque vous compilez votre code à l’aide d’une ligne de commande, ou ajoutez `#define TRACE` vers le haut de votre fichier. Dans Visual Basic, ajoutez le `/d:TRACE=True` option à la ligne de commande du compilateur ou ajoutez `#Const TRACE=True` au fichier.  
  
 <xref:System.Diagnostics.ConditionalAttribute> n’est pas pris en charge par le compilateur C++. Pour fournir des fonctionnalités équivalentes, vous devez englober les appels aux méthodes de <xref:System.Diagnostics.Trace> dans un `#if defined(TRACE) ... #endif` bloquer, puis ajoutez le `/DTRACE` option à la ligne de commande du compilateur ou ajoutez `#define TRACE` au fichier.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Diagnostics.Trace> pour indiquer le début et la fin de l’exécution d’un programme. L’exemple utilise également la <xref:System.Diagnostics.Trace.Indent%2A?displayProperty=nameWithType> et <xref:System.Diagnostics.Trace.Unindent%2A?displayProperty=nameWithType> méthodes pour distinguer la sortie de traçage. Pour obtenir un exemple plus complet de l’utilisation de <xref:System.Diagnostics.Trace>, consultez [Comment : ajouter des instructions de traçage au Code d’Application](~/docs/framework/debug-trace-profile/how-to-add-trace-statements-to-application-code.md).  
  
 [!code-cpp[Classic Trace Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace Example/CS/source.cs#1)]
 [!code-vb[Classic Trace Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.Diagnostics.Debug" />
    <altmember cref="T:System.Diagnostics.Switch" />
    <altmember cref="T:System.Diagnostics.BooleanSwitch" />
    <altmember cref="T:System.Diagnostics.TraceSwitch" />
    <altmember cref="T:System.Diagnostics.TraceListener" />
    <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
    <altmember cref="T:System.Diagnostics.EventLogTraceListener" />
    <altmember cref="T:System.Diagnostics.TraceListenerCollection" />
    <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vérifie une condition ; si la condition est <see langword="false" />, affiche des messages et une boîte de message qui montre la pile des appels.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, aucun message d’échec n’est envoyé et la boîte de message ne s’affiche pas.</param>
        <summary>Vérifie une condition ; si la condition est <see langword="false" />, affiche une boîte de message qui montre la pile des appels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> génère de méthode si vous souhaitez faire des assertions dans la mise en production. Le <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> méthode fonctionne uniquement dans les versions debug. Pour plus d’informations, consultez [Assertions dans du Code managé](/visualstudio/debugger/assertions-in-managed-code).  
  
 En règle générale, le <xref:System.Diagnostics.Trace.Assert%28System.Boolean%29> méthode est utilisée pour identifier des erreurs de logique pendant le développement de programme. <xref:System.Diagnostics.Trace.Assert%28System.Boolean%29> évalue la condition. Si le résultat est `false`, il envoie un message d’échec pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection. Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Trace.Listeners%2A> collection.  
  
 Lorsque l’application s’exécute en mode interface utilisateur, il affiche un message qui montre la pile des appels avec des numéros de fichier et de ligne. La boîte de message contient trois boutons : **abandonner**, **réessayer**, et **ignorer**. En cliquant sur le **abandonner** bouton met fin à l’application. En cliquant sur **réessayer** vous renvoie vers le code dans le débogueur si votre application s’exécute dans un débogueur ou vous propose d’ouvrir un débogueur si ce n’est pas. En cliquant sur **ignorer** se poursuit avec l’instruction suivante dans le code.  
  
> [!NOTE]
>  L’affichage de la boîte de message dépend de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez modifier le comportement de la <xref:System.Diagnostics.DefaultTraceListener> dans le fichier de configuration qui correspond au nom de votre application. Dans ce fichier, vous pouvez activer et désactiver la boîte de message d’assertion ou définir le <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> propriété. Le fichier de configuration doit être mis en forme comme suit :  
  
```  
<configuration>  
  <system.diagnostics>  
    <switches>  
      <add name="mySwitch" value="4"/>  
    </switches>  
    <trace autoflush="false" indentsize="4"/>  
    <assert assertuienabled="true" logfilename=".\TraceLog.txt"/>  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 L’exemple suivant crée un index pour un tableau. Une action est effectuée qui définit la valeur de l’index. Le code appelle ensuite <xref:System.Diagnostics.Trace.Assert%2A> pour vérifier l’index de valeur n’est valide. S’il n’est pas valide, le <xref:System.Diagnostics.Trace.Assert%2A> génère la pile des appels.  
  
 [!code-cpp[Classic Trace.Assert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Assert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Assert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Assert Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Assert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Assert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition a la valeur <see langword="true" />, le message spécifié n’est pas envoyé et la boîte de message ne s’affiche pas.</param>
        <param name="message">Message à envoyer à la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Vérifie une condition ; si la condition a la valeur <see langword="false" />, affiche un message spécifié et une boîte de message qui montre la pile des appels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> génère de méthode si vous souhaitez faire des assertions dans la mise en production. Le <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> méthode fonctionne uniquement dans les versions debug. Pour plus d’informations, consultez [Assertions dans du Code managé](/visualstudio/debugger/assertions-in-managed-code).  
  
 En règle générale, le <xref:System.Diagnostics.Trace.Assert%28System.Boolean%2CSystem.String%29> méthode est utilisée pour identifier des erreurs de logique pendant le développement de programme. <xref:System.Diagnostics.Trace.Assert%28System.Boolean%2CSystem.String%29> évalue la condition. Si le résultat est `false`, il envoie le message de diagnostic spécifié à la <xref:System.Diagnostics.Trace.Listeners%2A> collection. Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Trace.Listeners%2A> collection.  
  
 Lorsque l’application s’exécute en mode interface utilisateur, il affiche un message qui montre la pile des appels avec des numéros de fichier et de ligne. La boîte de message contient trois boutons : **abandonner**, **réessayer**, et **ignorer**. En cliquant sur le **abandonner** bouton met fin à l’application. En cliquant sur **réessayer** vous renvoie vers le code dans le débogueur si votre application s’exécute dans un débogueur ou vous propose d’ouvrir un débogueur si ce n’est pas. En cliquant sur **ignorer** se poursuit avec l’instruction suivante dans le code.  
  
> [!NOTE]
>  L’affichage de la boîte de message dépend de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez modifier le comportement de la <xref:System.Diagnostics.DefaultTraceListener> dans le fichier de configuration qui correspond au nom de votre application. Dans ce fichier, vous pouvez activer et désactiver la boîte de message d’assertion ou définir le <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> propriété. Le fichier de configuration doit être mis en forme comme suit :  
  
```  
<configuration>  
  <system.diagnostics>  
    <switches>  
      <add name="mySwitch" value="4"/>  
    </switches>  
    <trace autoflush="false" indentsize="4"/>  
    <assert assertuienabled="true" logfilename=".\TraceLog.txt"/>  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 L’exemple suivant vérifie que le `type` paramètre n’est valide. Si le `type` passé est `null`, le <xref:System.Diagnostics.Trace.Assert%2A> , un message s’affiche.  
  
 [!code-cpp[Classic Trace.Assert1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Assert1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Assert1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Assert1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Assert1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Assert1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Assert(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message, System::String ^ detailMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Expression conditionnelle à évaluer. Si la condition est <see langword="true" />, les messages spécifiés ne sont pas envoyés et la boîte de message ne s’affiche pas.</param>
        <param name="message">Message à envoyer à la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="detailMessage">Message détaillé à envoyer à la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Vérifie une condition ; si la condition est <see langword="false" />, affiche deux messages spécifiés et une boîte de message qui montre la pile des appels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> génère de méthode si vous souhaitez faire des assertions dans la mise en production. Le <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> méthode fonctionne uniquement dans les versions debug. Pour plus d’informations, consultez [Assertions dans du Code managé](/visualstudio/debugger/assertions-in-managed-code).  
  
 En règle générale, le <xref:System.Diagnostics.Trace.Assert%28System.Boolean%2CSystem.String%2CSystem.String%29> méthode est utilisée pour identifier des erreurs de logique pendant le développement de programme. <xref:System.Diagnostics.Trace.Assert%2A> évalue la condition. Si le résultat est `false`, il envoie le message de diagnostic spécifié et le message détaillé à la <xref:System.Diagnostics.Trace.Listeners%2A> collection. Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> , ou en le supprimant, le <xref:System.Diagnostics.Trace.Listeners%2A> collection.  
  
 Lorsque l’application s’exécute en mode interface utilisateur, il affiche un message qui montre la pile des appels avec des numéros de fichier et de ligne. La boîte de message contient trois boutons : **abandonner**, **réessayer**, et **ignorer**. En cliquant sur le **abandonner** bouton met fin à l’application. En cliquant sur **réessayer** vous renvoie vers le code dans le débogueur si votre application s’exécute dans un débogueur ou vous propose d’ouvrir un débogueur si ce n’est pas. En cliquant sur **ignorer** se poursuit avec l’instruction suivante dans le code.  
  
> [!NOTE]
>  L’affichage de la boîte de message dépend de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez modifier le comportement de la <xref:System.Diagnostics.DefaultTraceListener> dans le fichier de configuration qui correspond au nom de votre application. Dans ce fichier, vous pouvez activer et désactiver la boîte de message d’assertion ou définir le <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> propriété. Le fichier de configuration doit être mis en forme comme suit :  
  
```  
<configuration>  
  <system.diagnostics>  
    <switches>  
      <add name="mySwitch" value="4"/>  
    </switches>  
    <trace autoflush="false" indentsize="4"/>  
    <assert assertuienabled="true" logfilename=".\TraceLog.txt"/>  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 L’exemple suivant vérifie que le `type` paramètre n’est valide. Si le `type` passé est `null`, le <xref:System.Diagnostics.Trace.Assert%2A> , un message s’affiche.  
  
 [!code-cpp[Classic Trace.Assert2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Assert2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Assert2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Assert2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Assert2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Assert2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public static bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see cref="M:System.Diagnostics.Trace.Flush" /> doit être appelé sur <see cref="P:System.Diagnostics.Trace.Listeners" /> après chaque écriture.</summary>
        <value>
          <see langword="true" /> si <see cref="M:System.Diagnostics.Trace.Flush" /> est appelé sur <see cref="P:System.Diagnostics.Trace.Listeners" /> après chaque écriture ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut est `false`.  
  
 Vider le flux n’effacera pas son encodeur sous-jacent sauf si vous appelez explicitement <xref:System.Diagnostics.Trace.Flush%2A> ou <xref:System.Diagnostics.Trace.Close%2A>. Paramètre <xref:System.Diagnostics.Trace.AutoFlush%2A> à `true` signifie que les données sont supprimées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Cela permet à l’encodeur de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7 où certains caractères peuvent uniquement être encodés après que l’encodeur a reçu les caractères adjacents.  
  
 Pour définir le <xref:System.Diagnostics.Trace.AutoFlush%2A> et <xref:System.Diagnostics.Trace.IndentSize%2A> pour <xref:System.Diagnostics.Trace>, vous pouvez également modifier le fichier de configuration qui correspond au nom de votre application. Le fichier de configuration doit être mis en forme à l’exemple suivant :  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="false" indentsize="3" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public static void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Close" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide la mémoire tampon de sortie, puis ferme <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque la sortie va vers un fichier, telles que le <xref:System.Diagnostics.TextWriterTraceListener>.  
  
 Vider le flux n’effacera pas son encodeur sous-jacent sauf si vous appelez explicitement <xref:System.Diagnostics.Trace.Flush%2A> ou <xref:System.Diagnostics.Trace.Close%2A>. Paramètre <xref:System.Diagnostics.Trace.AutoFlush%2A> à `true` signifie que les données sont supprimées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Cela permet à l’encodeur de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7 où certains caractères peuvent uniquement être encodés après que l’encodeur a reçu les caractères adjacents.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TextWriterTraceListener> nommé `myTextListener`. `myTextListener` utilise un <xref:System.IO.StreamWriter> appelé `myOutputWriter` à écrire dans un fichier nommé `TestFile.txt`. L’exemple crée le fichier, le flux et TextWriter, écrit une ligne de texte dans le fichier, puis vide et ferme la sortie.  
  
 [!code-cpp[Classic Trace.Flush Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Flush Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Flush Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Flush Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Flush Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Flush Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationManager">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.CorrelationManager CorrelationManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Diagnostics.CorrelationManager CorrelationManager" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.CorrelationManager" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrelationManager As CorrelationManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Diagnostics::CorrelationManager ^ CorrelationManager { System::Diagnostics::CorrelationManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CorrelationManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le gestionnaire de corrélation pour le thread de ce suivi.</summary>
        <value>Objet <see cref="T:System.Diagnostics.CorrelationManager" /> associé au thread de ce suivi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il s’agit d’une propriété avancée que la plupart des applications ne doit pas avoir à utiliser.  
  
 La <xref:System.Diagnostics.CorrelationManager> classe fournit des méthodes utilisées pour stocker une identité d’opération logique dans un contexte lié par thread et baliser automatiquement chaque événement de trace généré par le thread dont l’identité est stockée.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Diagnostics.CorrelationManager" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Fail">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Émet un message d'erreur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Fail(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à émettre.</param>
        <summary>Émet le message d’erreur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut pour l’écouteur de trace par défaut consiste à la sortie le `message` paramètre à une boîte de message lors de l’application s’exécute en mode interface utilisateur et vers le <xref:System.Diagnostics.TraceListener> instances dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection.  
  
> [!NOTE]
>  L’affichage de la boîte de message est dépendante de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> à, ou en supprimant le <xref:System.Diagnostics.Trace.Listeners%2A> collection.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Diagnostics.Trace.Fail%2A> méthode pour imprimer un message lors de la gestion des exceptions.  
  
 [!code-cpp[Classic Trace.Fail Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Fail Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Fail Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Fail Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Fail Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Fail Example/VB/source.vb#1)]  
  
 Vous pouvez également utiliser le <xref:System.Diagnostics.Trace.Fail%2A> méthode dans une instruction switch.  
  
 [!code-cpp[Classic Trace.Fail Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Fail Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Trace.Fail Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Fail Example/CS/source.cs#2)]
 [!code-vb[Classic Trace.Fail Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Fail Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Fail(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message, System::String ^ detailMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à émettre.</param>
        <param name="detailMessage">Message détaillé à émettre.</param>
        <summary>Émet un message d’erreur et un message d’erreur détaillé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut est de l’écouteur de trace par défaut vers la sortie le `message` paramètre et le `detailedMessage` paramètre à une boîte de message lors de l’application s’exécute en mode interface utilisateur et vers le <xref:System.Diagnostics.TraceListener> instances dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection .  
  
> [!NOTE]
>  L’affichage de la boîte de message est dépendante de la présence de la <xref:System.Diagnostics.DefaultTraceListener>. Si le <xref:System.Diagnostics.DefaultTraceListener> ne figure pas dans le <xref:System.Diagnostics.Trace.Listeners%2A> collection, la boîte de message n’est pas affichée. Le <xref:System.Diagnostics.DefaultTraceListener> peuvent être supprimés par le [ &lt;effacer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), le [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), ou en appelant le <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sur le (méthode)<xref:System.Diagnostics.Trace.Listeners%2A> propriété (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 Vous pouvez personnaliser ce comportement en ajoutant un <xref:System.Diagnostics.TraceListener> à, ou en supprimant le <xref:System.Diagnostics.Trace.Listeners%2A> collection.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Diagnostics.Trace.Fail%2A> méthode pour imprimer un message lors de la gestion des exceptions.  
  
 [!code-cpp[Classic Trace.Fail1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Fail1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Fail1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/VB/source.vb#1)]  
  
 Vous pouvez également utiliser le <xref:System.Diagnostics.Trace.Fail%2A> méthode dans une instruction switch.  
  
 [!code-cpp[Classic Trace.Fail1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Trace.Fail1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/CS/source.cs#2)]
 [!code-vb[Classic Trace.Fail1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public static void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide la mémoire tampon de sortie et entraîne l’écriture des données mises en mémoire dans <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vider le flux n’effacera pas son encodeur sous-jacent sauf si vous appelez explicitement <xref:System.Diagnostics.Trace.Flush%2A> ou <xref:System.Diagnostics.Trace.Close%2A>. Paramètre <xref:System.Diagnostics.Trace.AutoFlush%2A> à `true` signifie que les données sont supprimées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Cela permet à l’encodeur de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7 où certains caractères peuvent uniquement être encodés après que l’encodeur a reçu les caractères adjacents.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TextWriterTraceListener> nommé `myTextListener`. `myTextListener` utilise un <xref:System.IO.StreamWriter> appelé `myOutputWriter` à écrire dans un fichier nommé `TestFile.txt`. L’exemple crée le fichier, le flux et TextWriter, écrit une ligne de texte dans le fichier, puis vide et ferme la sortie.  
  
 [!code-cpp[Classic Trace.Flush Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Flush Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Flush Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Flush Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Flush Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Flush Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Indent">
      <MemberSignature Language="C#" Value="public static void Indent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Indent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Indent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Indent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Indent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Augmente le <see cref="P:System.Diagnostics.Trace.IndentLevel" /> actuel d’une unité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant incrémente et décrémente le niveau de retrait et envoie des messages de traçage.  
  
 [!code-cpp[Classic Trace.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/VB/source.vb#1)]  
  
 Cet exemple génère la sortie suivante :  
  
```  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Trace.Unindent" />
        <altmember cref="P:System.Diagnostics.Trace.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Trace.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="IndentLevel">
      <MemberSignature Language="C#" Value="public static int IndentLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.IndentLevel" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentLevel { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le niveau de retrait.</summary>
        <value>Niveau de retrait. La valeur par défaut est zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Trace.IndentLevel%2A> propriété représente le nombre de fois où le retrait de taille <xref:System.Diagnostics.Trace.IndentSize%2A> est appliqué. Cette propriété est stockée par thread/par demande.  
  
   
  
## Examples  
 L’exemple suivant incrémente et décrémente le niveau de retrait et envoie des messages de traçage.  
  
 [!code-cpp[Classic Trace.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/VB/source.vb#1)]  
  
 Cet exemple génère la sortie suivante :  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Trace.IndentSize" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IndentSize">
      <MemberSignature Language="C#" Value="public static int IndentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.IndentSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre d'espaces dans un retrait.</summary>
        <value>Nombre d'espaces dans un retrait. La valeur par défaut est quatre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.TextWriterTraceListener> interprète ce nombre comme des espaces. Un <xref:System.Diagnostics.EventLogTraceListener> ignore cette valeur.  
  
 Cette propriété est stockée par thread/par demande.  
  
 Pour définir le <xref:System.Diagnostics.Trace.AutoFlush%2A> et <xref:System.Diagnostics.Trace.IndentSize%2A> pour <xref:System.Diagnostics.Trace>, vous pouvez également modifier le fichier de configuration qui correspond au nom de votre application. Le fichier de configuration doit être mis en forme à l’exemple suivant :  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="false" indentsize="3" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Trace.IndentLevel" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Listeners">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.TraceListenerCollection Listeners { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Diagnostics.TraceListenerCollection Listeners" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.Listeners" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Listeners As TraceListenerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Diagnostics::TraceListenerCollection ^ Listeners { System::Diagnostics::TraceListenerCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.TraceListenerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d’écouteurs qui surveillent la sortie de suivi.</summary>
        <value>
          <see cref="T:System.Diagnostics.TraceListenerCollection" /> qui représente une collection de types <see cref="T:System.Diagnostics.TraceListener" /> qui surveillent la sortie de suivi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les écouteurs produisent une sortie mise en forme à partir de la sortie de trace. Par défaut, la collection contient une instance de la <xref:System.Diagnostics.DefaultTraceListener> classe. Si vous souhaitez supprimer l’écouteur par défaut, appelez le <xref:System.Diagnostics.TraceListenerCollection.Remove%2A> (méthode) et le passer à l’instance de la <xref:System.Diagnostics.DefaultTraceListener>. Pour rediriger la sortie vers la fenêtre de console, ajoutez une instance de la <xref:System.Diagnostics.ConsoleTraceListener> classe.  
  
> [!NOTE]
>  Le <xref:System.Diagnostics.Trace.Listeners%2A> collection est partagée par les deux le <xref:System.Diagnostics.Debug> et <xref:System.Diagnostics.Trace> classes ; Ajout d’un écouteur de suivi à chaque classe ajoute l’écouteur à la fois.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.ConsoleTraceListener> qui renvoie à l’écran de la console. Le code ajoute ensuite le nouvel écouteur à le <xref:System.Diagnostics.Trace.Listeners%2A>.  
  
 [!code-cpp[Classic Trace.Listeners Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Listeners Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Listeners Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Listeners Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Listeners Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Listeners Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Actualise les données de configuration de suivi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Configuration de la capture des données au démarrage de l’application de la trace. Si les données de configuration sont modifiées après le démarrage de l’application, appelez le <xref:System.Diagnostics.Trace.Refresh%2A> pour mettre à jour les données de configuration de trace.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceError">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des informations d'erreur dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceError">
      <MemberSignature Language="C#" Value="public static void TraceError (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceError(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceError(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceError (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceError(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message d'information à écrire.</param>
        <summary>Écrit un message d’erreur dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> à l’aide du message spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceError%2A> appelle le `TraceEvent` méthode pour chaque écouteur de trace, avec le type d’événement de trace <xref:System.Diagnostics.TraceEventType.Error>, en passant le message d’information comme chaîne de message.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="TraceError">
      <MemberSignature Language="C#" Value="public static void TraceError (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceError(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceError(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceError (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceError(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format qui contient zéro élément de format ou plus, lesquels correspondent aux objets dans le tableau <c>args</c>.</param>
        <param name="args">
          <see langword="object" /> Tableau qui contient zéro ou plusieurs objets à mettre en forme.</param>
        <summary>Écrit un message d’erreur dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> à l’aide du tableau d’objets et des informations de mise en forme spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceError%2A> appelle le `TraceEvent` méthodes dans les écouteurs de suivi avec le type d’événement de trace <xref:System.Diagnostics.TraceEventType.Error>, en passant le contenu du message en tant que tableau d’objets avec les informations de mise en forme. Consultez le <xref:System.String.Format%2A> méthode pour plus d’informations sur la `format` et `args` paramètres.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceInformation">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit un message d'information dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceInformation">
      <MemberSignature Language="C#" Value="public static void TraceInformation (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceInformation(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceInformation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceInformation (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceInformation(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message d'information à écrire.</param>
        <summary>Écrit un message d'information dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> à l'aide du message spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceInformation%2A> appelle le `TraceEvent` méthode pour chaque écouteur de trace, avec le type d’événement de trace <xref:System.Diagnostics.TraceEventType.Information>, en passant le message d’information comme chaîne de message.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="TraceInformation">
      <MemberSignature Language="C#" Value="public static void TraceInformation (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceInformation(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceInformation(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceInformation (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceInformation(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format qui contient zéro élément de format ou plus, lesquels correspondent aux objets dans le tableau <c>args</c>.</param>
        <param name="args">
          <see langword="object" /> Tableau qui contient zéro ou plusieurs objets à mettre en forme.</param>
        <summary>Écrit un message d’information dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> à l’aide du tableau d’objets et des informations de mise en forme spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceInformation%2A> appelle le `TraceEvent` méthodes dans les écouteurs de suivi avec le type d’événement de trace <xref:System.Diagnostics.TraceEventType.Information>, en passant le contenu du message en tant que tableau d’objets avec les informations de mise en forme. Consultez le <xref:System.String.Format%2A> méthode pour plus d’informations sur la `format` et `args` paramètres.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceWarning">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des informations d'avertissement dans les écouteurs de trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceWarning">
      <MemberSignature Language="C#" Value="public static void TraceWarning (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceWarning(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceWarning(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceWarning (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceWarning(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message d'information à écrire.</param>
        <summary>Écrit un message d’avertissement dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> à l’aide du message spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceWarning%2A> appelle le `TraceEvent` méthode pour chaque écouteur de trace avec le type d’événement de trace <xref:System.Diagnostics.TraceEventType.Warning>, en passant le message d’information comme chaîne de message.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="TraceWarning">
      <MemberSignature Language="C#" Value="public static void TraceWarning (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceWarning(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceWarning(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceWarning (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceWarning(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format qui contient zéro élément de format ou plus, lesquels correspondent aux objets dans le tableau <c>args</c>.</param>
        <param name="args">
          <see langword="object" /> Tableau qui contient zéro ou plusieurs objets à mettre en forme.</param>
        <summary>Écrit un message d’avertissement dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> à l’aide du tableau d’objets et des informations de mise en forme spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceWarning%2A> appelle le `TraceEvent` méthodes dans les écouteurs de suivi avec le type d’événement de trace <xref:System.Diagnostics.TraceEventType.Warning>, en passant le contenu du message en tant que tableau d’objets avec les informations de mise en forme. Consultez le <xref:System.String.Format%2A> méthode pour plus d’informations sur la `format` et `args` paramètres.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Unindent">
      <MemberSignature Language="C#" Value="public static void Unindent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unindent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Unindent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unindent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unindent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réduit la propriété <see cref="P:System.Diagnostics.Trace.IndentLevel" /> actuelle d’une unité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant incrémente et décrémente le niveau de retrait et envoie des messages de traçage.  
  
 [!code-cpp[Classic Trace.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/VB/source.vb#1)]  
  
 Cet exemple génère la sortie suivante :  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Trace.Indent" />
        <altmember cref="P:System.Diagnostics.Trace.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Trace.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="UseGlobalLock">
      <MemberSignature Language="C#" Value="public static bool UseGlobalLock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseGlobalLock" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.UseGlobalLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseGlobalLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseGlobalLock { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le verrouillage global doit être utilisé.</summary>
        <value>
          <see langword="true" /> si le verrouillage global est utilisé ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le verrouillage global est toujours utilisé si l’écouteur de suivi n’est pas thread-safe, quelle que soit la valeur de <xref:System.Diagnostics.Trace.UseGlobalLock%2A>. Le <xref:System.Diagnostics.TraceListener.IsThreadSafe%2A> propriété est utilisée pour déterminer si l’écouteur est thread-safe. Le verrouillage global n’est pas utilisé uniquement si la valeur de <xref:System.Diagnostics.Trace.UseGlobalLock%2A> est `false` et la valeur de <xref:System.Diagnostics.TraceListener.IsThreadSafe%2A> est `true`. Le comportement par défaut est d’utiliser le verrouillage global.  
  
 Pour définir le <xref:System.Diagnostics.Trace.UseGlobalLock%2A> pour <xref:System.Diagnostics.Trace>, vous pouvez également modifier le fichier de configuration qui correspond au nom de votre application. Le fichier de configuration doit être mis en forme à l’exemple suivant :  
  
```  
<configuration>  
  <system.diagnostics>  
    <trace useGlobalLock="false" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée :  <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des informations sur le traçage vers les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> dont le nom est envoyé au <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Écrit la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
> [!NOTE]
>  ASP.NET fournit des fonctionnalités de traçage adaptées aux pages Web. Pour écrire des messages de trace dans les pages ASP.NET, utilisez le <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> propriété.  
  
 Par défaut, dans le code associé à une page Web ASP.NET, l’instruction `Trace.Write("...")` est un appel à la <xref:System.Web.TraceContext.Write%2A> méthode de la <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> propriété. Pour utiliser le <xref:System.Diagnostics.Trace?displayProperty=nameWithType> classe dans des pages Web, vous devez inclure l’espace de noms, par exemple, `System.Diagnostics.Trace.Write("...")`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier nom de la `value` paramètre à la <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie un message sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.Write1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
> [!NOTE]
>  ASP.NET fournit des fonctionnalités de traçage adaptées aux pages Web. Pour écrire des messages de trace dans les pages ASP.NET, utilisez le <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> propriété.  
  
 Par défaut, dans le code associé à une page Web ASP.NET, l’instruction `Trace.Write("...")` est un appel à la <xref:System.Web.TraceContext.Write%2A> méthode de la <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> propriété. Pour utiliser le <xref:System.Diagnostics.Trace?displayProperty=nameWithType> classe dans des pages Web, vous devez inclure l’espace de noms, par exemple, `System.Diagnostics.Trace.Write("...")`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Un terminateur de ligne suit le deuxième message.  
  
 [!code-cpp[Classic Trace.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Write(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Un nom <see cref="T:System.Object" /> est envoyé à <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit le nom de la catégorie et la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs Trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
> [!NOTE]
>  ASP.NET fournit des fonctionnalités de traçage adaptées aux pages Web. Pour écrire des messages de trace dans les pages ASP.NET, utilisez le <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> propriété.  
  
 Par défaut, dans le code associé à une page Web ASP.NET, l’instruction `Trace.Write("...")` est un appel à la <xref:System.Web.TraceContext.Write%2A> méthode de la <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> propriété. Pour utiliser le <xref:System.Diagnostics.Trace?displayProperty=nameWithType> classe dans des pages Web, vous devez inclure l’espace de noms, par exemple, `System.Diagnostics.Trace.Write("...")`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Verbose`, l’exemple renvoie le nom de la `myObject` et `category` à la <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Error` ou une version ultérieure, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.Write3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write3 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Write(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et un message dans les écouteurs Trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
> [!NOTE]
>  ASP.NET fournit des fonctionnalités de traçage adaptées aux pages Web. Pour écrire des messages de trace dans les pages ASP.NET, utilisez le <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> propriété.  
  
 Par défaut, dans le code associé à une page Web ASP.NET, l’instruction `Trace.Write("...")` est un appel à la <xref:System.Web.TraceContext.Write%2A> méthode de la <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> propriété. Pour utiliser le <xref:System.Diagnostics.Trace?displayProperty=nameWithType> classe dans des pages Web, vous devez inclure l’espace de noms, par exemple, `System.Diagnostics.Trace.Write("...")`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Verbose`, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Error` ou une version ultérieure, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.Write2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des informations sur le traçage vers les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> si une condition a la valeur <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="value">
          <see cref="T:System.Object" /> dont le nom est envoyé au <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Écrit la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier nom du paramètre de valeur pour le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie un message sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" /> vous n’appelez pas <see cref="M:System.Diagnostics.Trace.Write(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 **Premier exemple**  
  
```  
if(mySwitch.TraceError)   
    Trace.Write("aNumber = " + aNumber + " out of range");  
```  
  
 **Deuxième exemple**  
  
```  
Trace.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" /> vous n’appelez pas <see cref="M:System.Diagnostics.Trace.Write(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 **Premier exemple**  
  
```  
if(mySwitch.TraceError)   
    Trace.Write("aNumber = " + aNumber + " out of range");  
```  
  
 **Deuxième exemple**  
  
```  
Trace.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="value">
          <see cref="T:System.Object" /> dont le nom est envoyé au <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />, si une condition a la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Verbose`, l’exemple renvoie le nom de la `myObject` et `category` à la <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Error` ou une version ultérieure, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" /> vous n’appelez pas <see cref="M:System.Diagnostics.Trace.Write(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 **Premier exemple**  
  
```  
if(mySwitch.TraceError)   
    Trace.Write("aNumber = " + aNumber + " out of range");  
```  
  
 **Deuxième exemple**  
  
```  
Trace.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="message">Message à écrire.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et un message dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.Write%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Verbose`, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Error` ou une version ultérieure, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" /> vous n’appelez pas <see cref="M:System.Diagnostics.Trace.Write(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 **Premier exemple**  
  
```  
if(mySwitch.TraceError)   
    Trace.Write("aNumber = " + aNumber + " out of range");  
```  
  
 **Deuxième exemple**  
  
```  
Trace.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des informations sur le traçage vers les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> dont le nom est envoyé au <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Écrit la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le nom de l’objet sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteLine1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLine1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLine1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLine1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLine1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLine1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLine(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> dont le nom est envoyé au <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit le nom de la catégorie et la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs Trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteLine3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLine3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLine3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLine3 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLine3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLine3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à écrire.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur et le `category` sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteLine2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLine2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLine2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLine2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLine2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLine2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLineIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des informations sur le traçage vers les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> si une condition a la valeur <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="value">
          <see cref="T:System.Object" /> dont le nom est envoyé au <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Écrit la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le nom de l’objet sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteLineIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLineIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLineIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" /> vous n’appelez pas <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 **Premier exemple**  
  
```  
if(mySwitch.TraceError)   
    Trace.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 **Deuxième exemple**  
  
```  
Trace.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="message">Message à écrire.</param>
        <summary>Écrit un message dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" /> vous n’appelez pas <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 **Premier exemple**  
  
```  
if(mySwitch.TraceError)   
    Trace.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 **Deuxième exemple**  
  
```  
Trace.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="value">
          <see cref="T:System.Object" /> dont le nom est envoyé au <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et la valeur de la méthode <see cref="M:System.Object.ToString" /> de l’objet dans les écouteurs de suivi de la collection <see cref="P:System.Diagnostics.Trace.Listeners" />, si une condition a la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteLineIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLineIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLineIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" /> vous n’appelez pas <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 **Premier exemple**  
  
```  
if(mySwitch.TraceError)   
    Trace.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 **Deuxième exemple**  
  
```  
Trace.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> pour provoquer l’écriture d’un message ; sinon, <see langword="false" />.</param>
        <param name="message">Message à écrire.</param>
        <param name="category">Nom de catégorie utilisé pour organiser la sortie.</param>
        <summary>Écrit un nom de catégorie et un message dans les écouteurs de la trace de la collection <see cref="P:System.Diagnostics.Trace.Listeners" /> si une condition est <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, la sortie est écrite dans une instance de <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Le `category` paramètre peut être utilisé pour regrouper les messages de sortie.  
  
 Cette méthode appelle la <xref:System.Diagnostics.TraceListener.WriteLine%2A> méthode de l’écouteur de trace.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Diagnostics.TraceSwitch> nommé `generalSwitch`. Ce commutateur est défini en dehors de l’exemple de code.  
  
 Si le commutateur est défini sur le <xref:System.Diagnostics.TraceLevel> `Error` ou une version ultérieure, l’exemple renvoie le premier message d’erreur à le <xref:System.Diagnostics.Trace.Listeners%2A>. Pour plus d’informations sur l’ajout d’un écouteur pour le <xref:System.Diagnostics.Trace.Listeners%2A> collection, consultez la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Ensuite, si le <xref:System.Diagnostics.TraceLevel> a la valeur `Verbose`, l’exemple renvoie le deuxième message d’erreur et le `category` sur la même ligne que le premier message. Le deuxième message est suivi d’un terminateur de ligne.  
  
 [!code-cpp[Classic Trace.WriteLineIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLineIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLineIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez limiter la baisse des performances de l’instrumentation de votre application à l’aide de <see langword="If...Then" /> au lieu d’utiliser les instructions <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" /> instructions. Les exemples suivants de deux fichiers de code envoient le même message de débogage. Toutefois, le premier exemple est beaucoup plus rapide lorsque le traçage est désactivé, car si <c>mySwitch.TraceError</c> prend la valeur de <see langword="false" /> vous n’appelez pas <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)" />. Le deuxième exemple appelle toujours <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />, même quand <c>mySwitch.TraceError</c> est <see langword="false" /> et aucune sortie de traçage n’est généré. Cela peut entraîner l’exécution inutile d’un code arbitrairement complexe.  
  
 **Premier exemple**  
  
```  
if(mySwitch.TraceError)   
    Trace.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 **Deuxième exemple**  
  
```  
Trace.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
  </Members>
</Type>