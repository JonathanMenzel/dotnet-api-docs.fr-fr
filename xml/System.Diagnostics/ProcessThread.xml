<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="088e26e27317339e278a3b3dfe749a6eba53bb72" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36742076" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ProcessThread = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an operating system process thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Diagnostics.ProcessThread> pour obtenir des informations sur un thread en cours d’exécution sur le système. Cela vous permet, par exemple, pour surveiller les caractéristiques de performances du thread.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement. Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.  
  
 Un thread est un chemin d’accès de l’exécution via un programme. Il s’agit de la plus petite unité d’exécution planifiée par Win32. Il se compose d’une pile, l’état des registres du processeur et une entrée dans la liste d’exécution du planificateur système.  
  
 Un processus se compose d’un ou plusieurs threads et le code, données et autres ressources d’un programme en mémoire. Ressources programme standard sont des fichiers ouverts, les sémaphores et la mémoire allouée dynamiquement. Chaque ressource d’un processus est partagée par toutes les threads du processus.  
  
 Un programme s’exécute lorsque le planificateur du système donne le contrôle de l’exécution à un des threads du programme. Le planificateur détermine quels threads doivent s’exécuter et à quel moment. Un thread de priorité inférieure peut être forcé pour attendre que des threads de priorité plus élevée effectuer leurs tâches. Sur les ordinateurs multiprocesseurs, le planificateur peut répartir les threads à des processeurs différents, afin d’équilibrer la charge de l’UC.  
  
 Chaque processus démarre avec un seul thread, qui est connu en tant que le thread principal. N’importe quel thread peut créer des threads supplémentaires. Tous les threads dans un processus de partagent l’espace d’adressage de ce processus.  
  
 Le thread principal n’est pas nécessairement situé sous le premier index dans la collection.  
  
> [!NOTE]
>  À compter de .NET Framework version 2.0, la possibilité de référence des données de compteur de performance sur d’autres ordinateurs a été supprimée pour la plupart des méthodes .NET Framework et des propriétés. Cette modification a été apportée pour améliorer les performances et permettre des non-administrateurs à utiliser le <xref:System.Diagnostics.ProcessThread> classe. Par conséquent, certaines applications qui n’a pas obtenu les exceptions dans les versions antérieures du .NET Framework peuvent maintenant un <xref:System.NotSupportedException>. Les méthodes et propriétés affectées sont trop nombreux pour être répertoriés ici, mais les informations sur l’exception a été ajoutées aux rubriques membre affecté.  
  
 Les threads d’un processus s’exécutent individuellement et ne connaissent pas de l’autre, sauf si les rendre visibles les uns aux autres. Toutefois, les threads qui partagent des ressources communes, doivent coordonner leur travail en utilisant des sémaphores ou une autre méthode de communication entre processus.  
  
 Pour obtenir une collection de tous les le <xref:System.Diagnostics.ProcessThread> obtenir des objets associés au processus en cours, le <xref:System.Diagnostics.Process.Threads%2A> propriété de la <xref:System.Diagnostics.Process> instance.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.ProcessThread.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base priority of the thread.</summary>
        <value>La priorité de base du thread, le système d’exploitation calcule en combinant la classe de priorité de processus avec le niveau de priorité du thread associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.ProcessThread.BasePriority%2A> est la priorité de départ du thread de processus. Vous pouvez afficher des informations sur la priorité de base par le compteur de Base de priorité de l’analyse système.  
  
 Le système d’exploitation calcule la priorité de base d’un thread en combinant la plage au niveau de priorité du thread avec la classe de priorité du processus. Vous pouvez définir le processus <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType> propriété à une des valeurs dans le <xref:System.Diagnostics.ProcessPriorityClass> énumération, qui sont <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Vous pouvez définir du thread <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> propriété à une plage de valeurs qui délimite la priorité de base du thread. Win32 utilise quatre classes de priorités sept niveaux de priorité de base par classe.  
  
 La priorité du thread en cours peut être différente de la priorité de base. Par exemple, le système d’exploitation peut modifier le <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> propriété en fonction du temps écoulé ou autres valorisations lorsqu’un processus doivent être placées devant les autres pour l’accès au processeur. En outre, vous pouvez définir le <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propriété afin que le système afin de renforcer temporairement la priorité d’un thread chaque fois que le processus est extraite de l’état d’attente. La priorité est réinitialisée lorsque le processus retourne à l’état d’attente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPriority : int" Usage="System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current priority of the thread.</summary>
        <value>La priorité actuelle du thread, qui peut être différente de la priorité de base en fonction de la façon dont le système d’exploitation planifie le thread. La priorité peut être temporairement renforcée pour un thread actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La priorité du thread en cours peut être différente de la priorité de base. Par exemple, le système d’exploitation peut modifier le <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> propriété en fonction du temps écoulé ou autres valorisations, lorsqu’un processus doivent être placées devant les autres pour l’accès au processeur. En outre, vous pouvez définir le <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propriété afin que le système afin de renforcer temporairement la priorité d’un thread chaque fois que le processus est extraite de l’état d’attente. La priorité est réinitialisée lorsque le processus retourne à l’état d’attente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.ProcessThread.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique identifier of the thread.</summary>
        <value>L’identificateur unique associé à un thread spécifique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système d’exploitation réutilise les numéros d’identification de thread, qui identifient les threads que pendant leur durée de vie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IdealProcessor : int" Usage="System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the preferred processor for this thread to run on.</summary>
        <value>Processeur préféré pour le thread, utilisé lorsque le système planifie des threads, afin de déterminer le processeur à exécuter le thread.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> valeur est de base zéro.  En d’autres termes, pour définir l’affinité de thread pour le premier processeur, définissez la propriété à zéro.  
  
 Le système planifie les threads sur leur processeur par défaut chaque fois que possible.  
  
 Un thread de processus peut migrer d’un processeur à l’autre, chaque migration entraînant le rechargement du cache du processeur. Spécification d’un processeur d’un thread peut améliorer les performances sous une charge système élevée en réduisant le nombre de fois où que le cache de processeur est rechargé.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> propriété d’une instance du bloc-notes au premier processeur.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The system could not set the thread to start on the specified processor.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the operating system should temporarily boost the priority of the associated thread whenever the main window of the thread's process receives the focus.</summary>
        <value>
          <see langword="true" /> Pour augmenter la priorité du thread lorsque l’utilisateur interagit avec le processus de l’interface ; dans le cas contraire, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> est `true`, le système renforce temporairement la priorité du thread chaque fois que le processus associé est extraite de l’état d’attente. Cette action empêche d’autres processus d’interrompre le traitement du thread actuel. Le <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> paramètre affecte tous les threads existants, ainsi que les threads créés ultérieurement par le processus. Pour rétablir le comportement normal, affectez le <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propriété `false`.  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> a un effet uniquement lorsque le thread s’exécute dans un processus qui a un <xref:System.Diagnostics.Process.PriorityClass%2A> défini sur l’une des valeurs d’énumération priorité dynamique (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>).  
  
> [!NOTE]
>  Renforcement de la priorité trop élevée peut priver de ressources essentielles du système d’exploitation et des fonctions de réseau. Cela peut provoquer des problèmes avec d’autres tâches du système d’exploitation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The priority boost information could not be retrieved.  -or-  The priority boost information could not be set.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityLevel : System.Diagnostics.ThreadPriorityLevel with get, set" Usage="System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the priority level of the thread.</summary>
        <value>Parmi les <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> valeurs, en spécifiant une plage qui limite la priorité du thread.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le niveau de priorité n’est pas une valeur unique, mais plutôt une plage de valeurs. Le système d’exploitation calcule la priorité de base du thread à l’aide du processus <xref:System.Diagnostics.Process.PriorityClass%2A> pour choisir une valeur à partir de la plage spécifiée dans le <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread priority level information could not be retrieved.  -or-  The thread priority level could not be set.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of time that the thread has spent running code inside the operating system core.</summary>
        <value>Un <see cref="T:System.TimeSpan" /> indiquant la quantité de temps que le thread d’exécution du code à l’intérieur du noyau du système d’exploitation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows utilise plusieurs mécanismes de protection différents et à la racine de tous les est la distinction entre en mode utilisateur et mode privilégié. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> correspond à la durée pendant laquelle l’application a passé en mode privilégié, à l’intérieur du noyau du système d’exploitation. Le <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> propriété indique la quantité de temps passé par l’application à exécuter un code en mode utilisateur, en dehors du noyau du système.  
  
 Mode utilisateur limite l’application de deux manières. Tout d’abord, l’application ne peut pas accéder directement aux périphériques, mais il doit appeler à la place du noyau du système d’exploitation pour obtenir ou définir les données du périphérique. Le système d’exploitation peut garantir ainsi qu’une application ne détruit pas les données de périphérique nécessaires à d’autres. En second lieu, l’application ne peut pas lire ou modifier des données qui tient à jour le système d’exploitation lui-même. Cette restriction empêche les applications par inadvertance ou intentionnellement lorsque le noyau. Si l’application doit effectuer une opération du système d’exploitation, elle appelle une des routines du système. La plupart de ces routines passent en mode privilégié, effectuer l’opération et retourner correctement en mode utilisateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread time could not be retrieved.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint" Usage="System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the processors on which the associated thread can run.</summary>
        <value>Un <see cref="T:System.IntPtr" /> qui pointe vers un ensemble de bits, dont chacun représente le thread peut s’exécuter sur un processeur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’affinité du processeur d’un thread est l’ensemble de processeurs, avec qu'il possède une relation. En d’autres termes, ces informatique peut être planifié pour s’exécuter sur.  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> représente chaque processeur par un bit. Le bit 0 représente le premier processeur, le bit 1 processeur deux et ainsi de suite. Le tableau suivant présente un sous-ensemble de ces <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> pour un système à quatre processeurs.  
  
|Valeur de la propriété (en hexadécimal)|Processeurs valides|  
|---------------------------------------|----------------------|  
|0 x 0001|1|  
|0 x 0002|2|  
|0x0003|1 ou 2|  
|0 x 0004|3|  
|0x0005|1 ou 3|  
|0x0007|1, 2 ou 3|  
|0x000F|1, 2, 3 ou 4|  
  
 Vous pouvez également spécifier le seul processeur par défaut d’un thread en définissant le <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> propriété. Un thread de processus peut migrer d’un processeur à l’autre, chaque migration entraînant le rechargement du cache du processeur. Spécification d’un processeur d’un thread peut améliorer les performances sous une charge système élevée en réduisant le nombre de fois où que le cache de processeur est rechargé.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> propriété d’une instance du bloc-notes au premier processeur.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The processor affinity could not be set.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberSignature Language="F#" Value="member this.ResetIdealProcessor : unit -&gt; unit" Usage="processThread.ResetIdealProcessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the ideal processor for this thread to indicate that there is no single ideal processor. In other words, so that any processor is ideal.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The ideal processor could not be reset.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.StartAddress : nativeint" Usage="System.Diagnostics.ProcessThread.StartAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the memory address of the function that the operating system called that started this thread.</summary>
        <value>Adresse de départ du thread, qui pointe vers la fonction définie par l’application qui le thread s’exécute.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque processus démarre avec un seul thread, qui est connu en tant que le thread principal. N’importe quel thread peut créer des threads supplémentaires.  
  
 Un processus possède un espace d’adressage virtuel, code exécutable, données, handles d’objet, variables d’environnement, une priorité de base et au minimum et maximum des tailles de jeu de travail. Tous les threads d’un processus partagent son adresse virtuelle espace et des ressources système. En outre, chaque thread maintient des gestionnaires d’exceptions, une priorité de planification et un ensemble de structures dans lequel le système enregistre le contexte du thread pendant que le thread est en attente d’être planifiée. Le contexte du thread inclut le jeu du thread de registres de l’ordinateur, la pile du noyau, un bloc d’environnement de thread et une pile de l’utilisateur dans l’espace d’adressage de processus du thread.  
  
 Chaque thread Windows commence réellement l’exécution dans une système, pas la fonction fournie par l’application. L’adresse de départ pour le thread principal est, par conséquent, le même (tel qu’il représente l’adresse de la fonction fournie par le système) pour chaque processus Windows dans le système. Toutefois, le <xref:System.Diagnostics.ProcessThread.StartAddress%2A> propriété permet d’obtenir l’adresse de fonction de démarrage qui est spécifique à votre application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.ProcessThread.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the operating system started the thread.</summary>
        <value>A <see cref="T:System.DateTime" /> représentant l’heure sur le système lorsque le système d’exploitation a démarré le thread.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread time could not be retrieved.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Diagnostics.ThreadState" Usage="System.Diagnostics.ProcessThread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current state of this thread.</summary>
        <value>Un <see cref="T:System.Diagnostics.ThreadState" /> qui indique l’exécution du thread, par exemple, en cours d’exécution, en attente ou terminé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.ProcessThread.WaitReason%2A> valeur de propriété est valide uniquement lorsque le <xref:System.Diagnostics.ProcessThread.ThreadState%2A> valeur est <xref:System.Diagnostics.ThreadState.Wait>. Par conséquent, vérifiez la <xref:System.Diagnostics.ProcessThread.ThreadState%2A> valeur avant d’obtenir le <xref:System.Diagnostics.ProcessThread.WaitReason%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total amount of time that this thread has spent using the processor.</summary>
        <value>Un <see cref="T:System.TimeSpan" /> qui indique la durée pendant laquelle le thread contrôlait le processeur de.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> propriété indique la durée totale d’exécution que le système a mis le thread hors de l’état d’attente et il prioritaires sur n’importe quel processeur. Sur un système multiprocesseur, cette valeur comprend le temps passé sur chaque processeur, si le thread utilisé plusieurs processeurs.  
  
 Le <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> propriété est la somme de la <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> et <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> propriétés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread time could not be retrieved.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of time that the associated thread has spent running code inside the application.</summary>
        <value>Un <see cref="T:System.TimeSpan" /> indiquant la quantité de temps passé par le thread à exécuter un code à l’intérieur de l’application, par opposition à l’intérieur du noyau du système d’exploitation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT utilise plusieurs mécanismes de protection différents et à la racine de tous les est la distinction entre en mode utilisateur et mode privilégié. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> correspond à la durée pendant laquelle l’application a passé en mode utilisateur, en dehors du noyau du système d’exploitation. Le <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> correspond à la quantité de temps passé par l’application à exécuter un code en mode privilégié, à l’intérieur du noyau du système.  
  
 Mode utilisateur limite l’application de deux manières. Tout d’abord, l’application ne peut pas accéder directement aux périphériques, mais il doit appeler à la place du noyau du système d’exploitation pour obtenir ou définir les données du périphérique. Le système d’exploitation peut garantir ainsi qu’une application ne détruit pas les données de périphérique nécessaires à d’autres. En second lieu, l’application ne peut pas lire ou modifier des données qui tient à jour le système d’exploitation lui-même. Cette restriction empêche les applications par inadvertance ou intentionnellement lorsque le noyau. Si l’application doit effectuer une opération du système d’exploitation, elle appelle une des routines du système. La plupart de ces routines passent en mode privilégié, effectuer l’opération et retourner correctement en mode utilisateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread time could not be retrieved.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitReason : System.Diagnostics.ThreadWaitReason" Usage="System.Diagnostics.ProcessThread.WaitReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the reason that the thread is waiting.</summary>
        <value>A <see cref="T:System.Diagnostics.ThreadWaitReason" /> représentant la raison pour laquelle le thread est dans l’état d’attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.ProcessThread.WaitReason%2A> propriété est valide uniquement lorsque le <xref:System.Diagnostics.ProcessThread.ThreadState%2A> est <xref:System.Diagnostics.ThreadState.Wait>. Par conséquent, vérifiez la <xref:System.Diagnostics.ProcessThread.ThreadState%2A> valeur avant d’obtenir le <xref:System.Diagnostics.ProcessThread.WaitReason%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The thread is not in the wait state.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>