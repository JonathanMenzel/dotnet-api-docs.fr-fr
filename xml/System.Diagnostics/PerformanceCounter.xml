<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3d980133b1f10b739ff3f429ccb80aef0883db10" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51863421" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type PerformanceCounter = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.PerformanceCounterDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un composant de compteur de performances Windows NT.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.PerformanceCounter> composant peut être utilisé pour la lecture des compteurs personnalisés prédéfinis ou existants et les performances (écriture) de publication les données dans des compteurs personnalisés.  
  
 Il existe de nombreux compteurs prédéfinis répertoriés dans l’Analyseur de performances Windows [boîte de dialogue Ajouter des compteurs](https://go.microsoft.com/fwlink/p/?LinkId=257854). Pour en savoir plus sur les compteurs de performances de .NET Framework, consultez [les compteurs de Performance](~/docs/framework/debug-trace-profile/performance-counters.md).  
  
 Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
> [!IMPORTANT]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette classe exige des appelants immédiats soient entièrement fiables. À compter de .NET Framework version 2.0, cette classe exige <xref:System.Diagnostics.PerformanceCounterPermission> pour des actions spécifiques. Il est fortement recommandé que <xref:System.Diagnostics.PerformanceCounterPermission> ne pas être accordées au code de confiance partiel.  La possibilité de lire et écrire des compteurs de performance permet de code effectuer des actions telles que l’énumération des processus en cours d’exécution et l’obtention d’informations à leur sujet.  
>   
>  En outre, en passant un <xref:System.Diagnostics.PerformanceCounter> objet au code de niveau de confiance moindre peut créer un problème de sécurité. Passez jamais des performances compteur objets, tels qu’un <xref:System.Diagnostics.PerformanceCounterCategory> ou <xref:System.Diagnostics.PerformanceCounter>, au niveau de confiance inférieur code.  
  
 Pour lire à partir d’un compteur de performances, créez une instance de la <xref:System.Diagnostics.PerformanceCounter> classe, définissez la <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>et, éventuellement, le <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> ou <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriétés et appelez ensuite la <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> méthode à prendre de performances lecture du compteur.  
  
 Pour publier les données de compteur de performances, créez un ou plusieurs compteurs personnalisés à l’aide de la <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> (méthode), créez une instance de la <xref:System.Diagnostics.PerformanceCounter> classe, définissez la <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> et, éventuellement, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> ou <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriétés, puis appelez le <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, ou <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> méthodes, ou définir le <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété à modifier la valeur de votre compteur personnalisé.  
  
> [!NOTE]
>  Le <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, et <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> méthodes utilisent des verrouillages internes pour mettre à jour la valeur du compteur. Cela permet de maintenir la valeur du compteur précise dans les scénarios multithread ou multiprocessus, mais également entraîne une baisse des performances. Si vous n’avez pas besoin de la précision à blocage opérations fournissent, vous pouvez mettre à jour le <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété directement pour jusqu'à 5 fois amélioration des performances.  Toutefois, dans les scénarios multithreads, certaines mises à jour à la valeur du compteur peuvent être ignorées, ce qui entraîne des données inexactes.  
  
 Le compteur est le mécanisme par les performances sont collectées. Le Registre stocke les noms de tous les compteurs, chacun d’eux est lié à une zone spécifique des fonctionnalités du système. Exemples : temps d’occupation d’un processeur, utilisation de la mémoire ou le nombre d’octets reçus sur une connexion réseau.  
  
 Chaque compteur est identifié de manière unique par son nom et son emplacement. Dans la même façon qu’un chemin d’accès inclut un lecteur, un répertoire, un ou plusieurs sous-répertoires et un nom de fichier, les informations sur les compteurs se composent de quatre éléments : l’ordinateur, la catégorie, l’instance de catégorie et le nom du compteur.  
  
 Les informations du compteur doivent inclure la catégorie, ou objet de performance, le compteur mesure les données. Catégories d’un ordinateur comprennent les composants physiques, tels que les processeurs, les disques et la mémoire. Il existe également des catégories système, telles que les processus et threads. Chaque catégorie est liée à un élément fonctionnel au sein de l’ordinateur et un ensemble de compteurs standards lui est affectée à ce dernier. Ces objets sont répertoriés dans la liste déroulante objet de Performance de la boîte de dialogue Ajouter des compteurs Moniteur système Windows 2000, et vous devez les inclure dans le chemin de compteur. Les données de performances sont regroupées par la catégorie à laquelle est elles sont liées.  
  
 Dans certains cas, plusieurs copies de la même catégorie peuvent exister. Par exemple, plusieurs processus et threads exécutent simultanément, et certains ordinateurs contiennent plusieurs processeurs. Les copies de catégories sont appelées instances de catégorie, et chaque instance possède un ensemble de compteurs standards qui lui est assignée. Si une catégorie peut avoir plusieurs instances, une spécification de l’instance doit être incluse dans les informations du compteur.  
  
 Pour obtenir des données de performances pour les compteurs nécessitant une valeur initiale ou antérieure pour effectuer les calculs nécessaires, appelez le <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> méthode à deux reprises et utilisez les informations retournées que nécessaire pour votre application.  
  
> [!NOTE]
>  Catégories de compteur de performance installés avec le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] utilisent une mémoire partagée distincte, chaque catégorie de compteur de performance possédant sa propre mémoire. Vous pouvez spécifier la taille de mémoire partagée séparée en créant un DWORD nommé FileMappingSize dans la clé de Registre HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<nom de catégorie >* \ Performances. La valeur FileMappingSize est définie à la taille de mémoire partagée de la catégorie. La taille par défaut est 131072 au format décimal. Si la valeur FileMappingSize n’est pas présente, le `fileMappingSize` attribut de valeur pour le `performanceCounters` élément spécifié dans le fichier Machine.config est utilisé, provoque une surcharge supplémentaire pour le traitement de fichier de configuration. Vous pouvez réaliser une amélioration des performances pour le démarrage de l’application en définissant la taille du mappage de fichier dans le Registre. Pour plus d’informations sur la taille du mappage de fichier, consultez [ &lt;performanceCounters&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Diagnostics.PerformanceCounter> classe pour créer et utiliser un <xref:System.Diagnostics.PerformanceCounterType.AverageCount64> type de compteur. L’exemple crée des catégories, installe des compteurs, collecte les données de compteurs et appelle la <xref:System.Diagnostics.CounterSampleCalculator> classe pour interpréter les données de compteur de performances. Les résultats intermédiaires et finaux sont affichés dans la fenêtre de console. Pour obtenir des exemples supplémentaires d’autres types de compteur de performances, consultez le <xref:System.Diagnostics.PerformanceCounterType> énumération.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.PerformanceCounter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance en lecture seule de la classe <see cref="T:System.Diagnostics.PerformanceCounter" />, sans associer cette instance à un compteur de performance système ou personnalisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge du constructeur définit la <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> propriétés des chaînes vides (« ») et définit le <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriété sur l’ordinateur local, («. »).  
  
 Ce constructeur n’initialise pas le compteur de performances, donc il n’associe pas l’instance à un compteur existant sur l’ordinateur local. Pour désigner un compteur de performance spécifique, définissez la <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>et, éventuellement, le <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> et <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriétés avant de lire d’autres propriétés ou d’une tentative de lecture à partir d’un compteur. Pour écrire dans un compteur de performances, définissez la <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> propriété `false`.  
  
> [!NOTE]
>  Le <xref:System.Security.Permissions.HostProtectionAttribute> attribut appliqué à ce membre a suit <xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A> valeur de propriété : <xref:System.Security.Permissions.HostProtectionResource.Synchronization> &#124; <xref:System.Security.Permissions.HostProtectionResource.SharedState>. <xref:System.Security.Permissions.HostProtectionAttribute> n'affecte pas les applications bureautiques (qui sont généralement démarrées en double-cliquant sur une icône, en tapant une commande ou en entrant une URL dans un navigateur). Pour plus d’informations, consultez le <xref:System.Security.Permissions.HostProtectionAttribute> classe ou [programmation de SQL Server et les attributs de Protection hôte](~/docs/framework/performance/sql-server-programming-and-host-protection-attributes.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance par défaut de la <xref:System.Diagnostics.PerformanceCounter> classe. Une fois que l’instance est créée, le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> les valeurs de propriété sont définies et les résultats d’un appel à la <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> méthode sont affichés.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nom de la catégorie de compteurs de performance (objet de performance) à laquelle ce compteur de performance est associé.</param>
        <param name="counterName">Nom du compteur de performance.</param>
        <summary>Initialise une nouvelle instance en lecture seule de la classe <see cref="T:System.Diagnostics.PerformanceCounter" /> et l'associe au compteur de performance système ou personnalisé spécifié de l'ordinateur local. Ce constructeur exige que la catégorie ait une seule instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les chaînes de paramètres ne respectent pas la casse.  
  
 Utilisez cette surcharge pour accéder à un compteur sur l’ordinateur local qui appartient à une catégorie contenant une instance de catégorie de compteur de performance unique. Si vous essayez d’utiliser ce constructeur pour pointer ce <xref:System.Diagnostics.PerformanceCounter> instance à une catégorie qui contient plusieurs instances, le constructeur lève une exception. Cette surcharge peut accéder à toute en lecture seule ou lecture/écriture de compteur, mais le fait dans un mode en lecture seule. Un <xref:System.Diagnostics.PerformanceCounter> instance créée à l’aide de cette surcharge ne peut pas écrire dans le compteur, même si le compteur lui-même est en lecture/écriture.  
  
 Cette surcharge du constructeur définit le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> et <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> propriétés aux valeurs que vous passez, définit le <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriété sur l’ordinateur local, «. » et définit le <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> propriété sur une chaîne vide (« »).  
  
 Ce constructeur initialise le compteur de performance et associe l’instance à un compteur existant (un système ou un compteur personnalisé) sur l’ordinateur local. Les valeurs que vous passez pour le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> et <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> propriétés doivent pointer vers un compteur de performance existant sur l’ordinateur local.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <paramref name="categoryName" /> est une chaîne vide ("").  
  
- ou - 
 Le <paramref name="counterName" /> est une chaîne vide ("").  
  
- ou - 
La catégorie spécifiée n'existe pas.  
  
- ou - 
La catégorie spécifiée est marquée comme étant à plusieurs instances et requiert la création du compteur de performance avec un nom d'instance.  
  
- ou - 
 <paramref name="categoryName" /> et <paramref name="counterName" /> ont été localisés dans des langages différents.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> ou <paramref name="counterName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nom de la catégorie de compteurs de performance (objet de performance) à laquelle ce compteur de performance est associé.</param>
        <param name="counterName">Nom du compteur de performance.</param>
        <param name="readOnly">
          <see langword="true" /> pour accéder au compteur en mode lecture seule (même si le compteur lui-même peut être en lecture/écriture) ; <see langword="false" /> pour accéder au compteur en mode lecture/écriture.</param>
        <summary>Initialise une nouvelle instance en lecture seule ou en lecture/écriture de la classe <see cref="T:System.Diagnostics.PerformanceCounter" /> et l'associe au compteur de performance système ou personnalisé spécifié de l'ordinateur local. Ce constructeur exige que la catégorie contienne une seule instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les chaînes de paramètres ne respectent pas la casse.  
  
 Utilisez cette surcharge pour accéder en lecture seule ou lecture/écriture compteur sur l’ordinateur local qui appartient à une catégorie contenant une instance de catégorie de compteur de performance unique. Si vous essayez d’utiliser ce constructeur pour pointer ce <xref:System.Diagnostics.PerformanceCounter> instance à une catégorie qui contient plusieurs instances, le constructeur lève une exception.  
  
 Cette surcharge du constructeur définit le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> propriétés aux valeurs que vous passez, définit le <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriété sur l’ordinateur local, «. » et définit le <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> propriété sur une chaîne vide (« »).  
  
 Ce constructeur initialise le compteur de performance et associe l’instance à un compteur existant (un système ou un compteur personnalisé) sur l’ordinateur local. Les valeurs que vous passez pour le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> et <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> propriétés doivent pointer vers un compteur de performance existant sur l’ordinateur local. Si l’instance de compteur de performances que vous pointez vers n’est pas valide, l’appel du constructeur lève une exception.  
  
> [!NOTE]
>  Vous pouvez utiliser cette surcharge pour vous connecter à un compteur système, mais vous ne pouvez pas écrire dans un compteur de système. Par conséquent, la définition `readOnly` à `false` lorsque se connectant à un compteur système entraîne le constructeur lève une exception.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance de la <xref:System.Diagnostics.PerformanceCounter> classe. L’exemple passe dans les noms de catégorie, les noms de compteur et une valeur d’indicateur indiquant que le compteur n’est pas en lecture seule. Cet exemple de code fait partie d’un exemple plus complet pour la <xref:System.Diagnostics.PerformanceCounter> classe.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> est une chaîne vide ("").  
  
- ou - 
<paramref name="counterName" /> est une chaîne vide ("").  
  
- ou - 
La catégorie spécifiée n'existe pas. (si <paramref name="readOnly" /> est <see langword="true" />).  
  
- ou - 
La catégorie spécifiée n'est pas une catégorie personnalisée de .NET Framework (si <paramref name="readOnly" /> est <see langword="false" />).  
  
- ou - 
La catégorie spécifiée est marquée comme étant à plusieurs instances et requiert la création du compteur de performance avec un nom d'instance.  
  
- ou - 
 <paramref name="categoryName" /> et <paramref name="counterName" /> ont été localisés dans des langages différents.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> ou <paramref name="counterName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nom de la catégorie de compteurs de performance (objet de performance) à laquelle ce compteur de performance est associé.</param>
        <param name="counterName">Nom du compteur de performance.</param>
        <param name="instanceName">Nom de l'instance de la catégorie de compteurs de performance, ou chaîne vide ("") si la catégorie contient une seule instance.</param>
        <summary>Initialise une nouvelle instance en lecture seule de la classe <see cref="T:System.Diagnostics.PerformanceCounter" /> et l'associe au compteur de performance système ou personnalisé et à l'instance de la catégorie spécifiés sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les chaînes de paramètres ne respectent pas la casse.  
  
 Cette surcharge du constructeur définit la <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> les valeurs des propriétés vous passez, puis définit la <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriété sur l’ordinateur local, «. ».  
  
 Ce constructeur initialise le compteur de performance et associe l’instance à un compteur existant (un système ou un compteur personnalisé) sur l’ordinateur local. Les valeurs que vous passez pour le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> propriétés doivent pointer vers un compteur de performance existant sur l’ordinateur local. Si l’instance de compteur de performances que vous pointez n’est pas valide, l’appel du constructeur lève une exception.  
  
 Cette surcharge peut accéder à toute en lecture seule ou lecture/écriture de compteur, mais le fait dans un mode en lecture seule. Un <xref:System.Diagnostics.PerformanceCounter> instance créée à l’aide de cette surcharge ne peut pas écrire dans le compteur, même si le compteur lui-même est en lecture/écriture.  
  
 Pour créer une instance de catégorie de performance, spécifiez un `instanceName` sur la <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> constructeur. Si l’instance de la catégorie spécifiée par `instanceName` existe déjà le nouvel objet référencera l’instance existante de la catégorie.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <paramref name="categoryName" /> est une chaîne vide ("").  
  
- ou - 
 Le <paramref name="counterName" /> est une chaîne vide ("").  
  
- ou - 
La valeur spécifiée n'est pas valide.  
  
- ou - 
La catégorie spécifiée est marquée comme étant à plusieurs instances et requiert la création du compteur de performance avec un nom d'instance.  
  
- ou - 
 <paramref name="instanceName" /> dépasse 127 caractères.  
  
- ou - 
 <paramref name="categoryName" /> et <paramref name="counterName" /> ont été localisés dans des langages différents.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> ou <paramref name="counterName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nom de la catégorie de compteurs de performance (objet de performance) à laquelle ce compteur de performance est associé.</param>
        <param name="counterName">Nom du compteur de performance.</param>
        <param name="instanceName">Nom de l'instance de la catégorie de compteurs de performance, ou chaîne vide ("") si la catégorie contient une seule instance.</param>
        <param name="readOnly">
          <see langword="true" /> pour accéder à un compteur en mode lecture seule ; <see langword="false" /> pour accéder à un compteur en mode lecture/écriture.</param>
        <summary>Initialise une nouvelle instance en lecture seule ou en lecture/écriture de la classe <see cref="T:System.Diagnostics.PerformanceCounter" /> et l'associe au compteur de performance système ou personnalisé et à l'instance de la catégorie spécifiés sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les chaînes de paramètres ne respectent pas la casse.  
  
 Utilisez cette surcharge pour accéder à un compteur de performances soit en lecture seule ou en mode lecture/écriture.  
  
 Cette surcharge du constructeur définit la <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> propriétés aux valeurs que vous passez dans, il et définit le <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriété à l’ordinateur local, «. ».  
  
 Ce constructeur initialise le compteur de performance et associe l’instance à un compteur existant (un système ou un compteur personnalisé) sur l’ordinateur local. Les valeurs que vous passez pour le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> propriétés doivent pointer vers un compteur de performance existant sur l’ordinateur local. Si l’instance de compteur de performances que vous pointez vers n’est pas valide, l’appel du constructeur lève une exception.  
  
> [!NOTE]
>  Vous pouvez utiliser cette surcharge pour vous connecter à un compteur système, mais vous ne pouvez pas écrire dans un compteur de système. Par conséquent, la définition `readOnly` à `false` lorsque se connectant à un compteur système entraîne le constructeur lève une exception.  
  
 Pour créer une instance de catégorie de performance, spécifiez un `instanceName` sur la <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> constructeur. Si l’instance de la catégorie spécifiée par `instanceName` existe déjà le nouvel objet référencera l’instance existante de la catégorie.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <paramref name="categoryName" /> est une chaîne vide ("").  
  
- ou - 
 Le <paramref name="counterName" /> est une chaîne vide ("").  
  
- ou - 
Le paramètre d'autorisation de lecture/écriture demandé n'est pas valide pour ce compteur.  
  
- ou - 
La catégorie spécifiée n'existe pas (si <paramref name="readOnly" /> est <see langword="true" />).  
  
- ou - 
La catégorie spécifiée n'est pas une catégorie personnalisée de .NET Framework (si <paramref name="readOnly" /> est <see langword="false" />).  
  
- ou - 
La catégorie spécifiée est marquée comme étant à plusieurs instances et requiert la création du compteur de performance avec un nom d'instance.  
  
- ou - 
 <paramref name="instanceName" /> dépasse 127 caractères.  
  
- ou - 
 <paramref name="categoryName" /> et <paramref name="counterName" /> ont été localisés dans des langages différents.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> ou <paramref name="counterName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nom de la catégorie de compteurs de performance (objet de performance) à laquelle ce compteur de performance est associé.</param>
        <param name="counterName">Nom du compteur de performance.</param>
        <param name="instanceName">Nom de l'instance de la catégorie de compteurs de performance, ou chaîne vide ("") si la catégorie contient une seule instance.</param>
        <param name="machineName">Ordinateur sur lequel se situent le compteur de performance et la catégorie qui lui est associée.</param>
        <summary>Initialise une nouvelle instance en lecture seule de la classe <see cref="T:System.Diagnostics.PerformanceCounter" /> et l'associe au compteur de performance système ou personnalisé et à l'instance de la catégorie spécifiés sur l'ordinateur donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les chaînes de paramètres ne respectent pas la casse.  
  
 Cette surcharge du constructeur définit la <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, et <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriétés pour les valeurs que vous passez.  
  
 Ce constructeur initialise le compteur de performance et associe l’instance à un compteur existant (un système ou un compteur personnalisé) sur l’ordinateur spécifié. Les valeurs que vous passez pour le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> et <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriétés doivent pointer vers un compteur de performance existants. Si l’instance de compteur de performances que vous pointez n’est pas valide, l’appel du constructeur lève une exception. Cette surcharge peut accéder à toute en lecture seule ou lecture/écriture de compteur, mais le fait dans un mode en lecture seule. Un <xref:System.Diagnostics.PerformanceCounter> instance créée à l’aide de cette surcharge ne peut pas écrire dans le compteur, même si le compteur lui-même est en lecture/écriture.  
  
> [!NOTE]
>  Vous ne peut pas écrire dans les compteurs de performances à distance. Aucune surcharge qui vous permet de spécifier une instance en lecture/écriture de la <xref:System.Diagnostics.PerformanceCounter> classe qui se connecte à un ordinateur distant.  
  
 Pour créer une instance de catégorie de performance, spécifiez un `instanceName` sur la <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> constructeur. Si l’instance de la catégorie spécifiée par `instanceName` existe déjà le nouvel objet référencera l’instance existante de la catégorie.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
> [!NOTE]
>  Dans Windows Vista, lorsque l’ordinateur distant est un membre d’un groupe de travail, vous devrez peut-être désactiver l’UAC afin que le compte d’utilisateur local n’est pas filtré et peut être un compte d’administrateur avec élévation de privilèges. Pour des raisons de sécurité, la désactivation du compte d’utilisateur doit être un dernier recours. Pour plus d’informations sur la désactivation de UAC, consultez [contrôle de compte d’utilisateur et WMI](https://go.microsoft.com/fwlink/?LinkId=91617).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <paramref name="categoryName" /> est une chaîne vide ("").  
  
- ou - 
 Le <paramref name="counterName" /> est une chaîne vide ("").  
  
- ou - 
Le paramètre d'autorisation de lecture/écriture demandé n'est pas valide pour ce compteur.  
  
- ou - 
Le compteur n'existe pas sur l'ordinateur spécifié.  
  
- ou - 
La catégorie spécifiée est marquée comme étant à plusieurs instances et requiert la création du compteur de performance avec un nom d'instance.  
  
- ou - 
 <paramref name="instanceName" /> dépasse 127 caractères.  
  
- ou - 
 <paramref name="categoryName" /> et <paramref name="counterName" /> ont été localisés dans des langages différents.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="machineName" /> n’est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> ou <paramref name="counterName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="performanceCounter.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence l'initialisation d'une instance de <see cref="T:System.Diagnostics.PerformanceCounter" /> utilisée dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour démarrer l’initialisation d’un composant qui est utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> et <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> méthodes empêche le composant d’être utilisé avant son initialisation complète.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de la catégorie de compteurs de performance de ce compteur de performance.</summary>
        <value>Nom de la catégorie de compteurs de performance (objet de performance) à laquelle ce compteur de performance est associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> s’affiche dans le `Performance Object` champ du composant logiciel enfichable MMC du Gestionnaire de compteurs Performance in `Add Counter` boîte de dialogue.  
  
 Un compteur de performance surveille le comportement d’une catégorie, ou objet de performance, sur un ordinateur. Catégories incluent les composants physiques (par exemple, les processeurs, les disques et mémoire) et les objets système (tels que les processus et les threads). Compteurs de système qui sont liés au même objet de performance sont regroupés dans une catégorie qui indique leurs points communs. Lorsque vous créez une instance de la <xref:System.Diagnostics.PerformanceCounter> classe, vous indiquez d’abord la catégorie avec laquelle le composant va interagir, puis vous sélectionnez un compteur dans cette catégorie.  
  
 Par exemple, une catégorie de compteur de Windows est la catégorie de la mémoire. Compteurs de système dans cette catégorie suivent les données de mémoire telles que le nombre d’octets disponibles et le nombre d’octets mis en cache. Si vous souhaitez utiliser les octets mis en cache dans votre application, vous créeriez une instance de la <xref:System.Diagnostics.PerformanceCounter> composant, connectez-le à la catégorie mémoire, puis sélectionnez le compteur approprié (dans ce cas, les octets mis en cache) à partir de cette catégorie.  
  
 Bien que votre système met de nombreuses autres catégories disponibles, les catégories que vous allez interagir plus fréquemment sont les catégories du Cache mémoire, objets, PhysicalDisk, processus, processeur, Server, System et Thread.  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance par défaut de la <xref:System.Diagnostics.PerformanceCounter> classe. Une fois que l’instance est créée, le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> les valeurs de propriété sont définies et les résultats d’un appel à la <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> méthode sont affichés.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="performanceCounter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme le compteur de performance et libère toutes les ressources allouées par cette instance du compteur de performance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous associez ce <xref:System.Diagnostics.PerformanceCounter> instance avec un compteur de performance qui réside sur le serveur, le système initialise l’instance et alloue de la mémoire pour qu’il contienne des informations sur les exemples de compteurs. Le <xref:System.Diagnostics.PerformanceCounter.Close%2A> méthode libère les ressources allouées par l’objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberSignature Language="F#" Value="static member CloseSharedResources : unit -&gt; unit" Usage="System.Diagnostics.PerformanceCounter.CloseSharedResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère l'état partagé de la bibliothèque de compteurs de performance alloué par les compteurs.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour la lecture de la catégorie de compteur de performances. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterHelp : string" Usage="System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("A description describing the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterHelp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la description de ce compteur de performance.</summary>
        <value>Description de l'élément ou de la quantité mesuré par ce compteur de performance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La boîte de dialogue Ajouter des compteurs du composant logiciel enfichable MMC de gestionnaire de compteur de performances dans les affichages de la <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> texte lorsqu’un utilisateur sélectionne un compteur dans la liste de compteurs et clique sur le bouton Expliquer.  
  
 Lorsque vous créez un nouveau compteur, utilisez la <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> texte pour décrire ce que surveille le compteur de faire de l’utilisateur peut déterminer s’il faut ajouter le compteur à l’affichage de l’analyse système.  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> propriété est <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> et la catégorie de compteur de performances a été créée avec .NET Framework version 1.0 ou 1.1, un <xref:System.InvalidOperationException> est levée. Catégories de compteur de performances créés avec des versions antérieures utilisent la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'instance de <see cref="T:System.Diagnostics.PerformanceCounter" /> n'est pas associée à un compteur de performance.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> a la valeur <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> lorsqu'elle utilise la mémoire partagée globale.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour la lecture de la catégorie de compteur de performances. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CounterName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du compteur de performance associé à cette instance de <see cref="T:System.Diagnostics.PerformanceCounter" />.</summary>
        <value>Nom du compteur, décrivant généralement la quantité prise en compte. Ce nom est affiché dans la liste des compteurs de la boîte de dialogue Ajouter des compteurs du composant logiciel enfichable MMC du Gestionnaire de compteurs de performance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez obtenir la liste des compteurs préexistants disponibles à partir de Windows Performance du responsable [boîte de dialogue Ajouter des compteurs](https://go.microsoft.com/fwlink/p/?LinkId=257854).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir le <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> propriété à un nom de compteur typique.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounter.CounterName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterType : System.Diagnostics.PerformanceCounterType" Usage="System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The type of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de compteur du compteur de performance associé.</summary>
        <value>
          <see cref="T:System.Diagnostics.PerformanceCounterType" /> décrivant la manière dont le compteur interagit avec une application de surveillance et la nature des valeurs qu'il contient (par exemple, calculées ou non calculées).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.PerformanceCounterType> énumération contient les types de compteurs de performance que vous pouvez interagir avec. Certains des types de compteurs représentent des valeurs calculées, par exemple, la moyenne des mesures des compteurs pris par le système. Autres types représentent des valeurs brutes ou non calculées. Le tableau suivant présente les types de compteurs que vous interagissez avec les plus fréquemment.  
  
|Responsabilité du compteur|Valeur PerformanceCounterType|Exemple|  
|------------------------------|----------------------------------|-------------|  
|Gérer un nombre simple d’éléments ou d’opérations.|`NumberOfItems32`|Suivi du nombre de commandes reçues sous la forme d’un entier 32 bits.|  
|Maintenir un simple décompte de plus grande capacité.|`NumberOfItems64`|Le nombre de commandes pour un site avec un volume très élevé de suivi, stocké comme un entier 64 bits.|  
|Suivre le nombre d’éléments ou d’opérations par seconde.|`RateOfCountsPerSecond32`|Commandes de suivi reçues par seconde sur un site.|  
|Suivre un nombre plus élevé d’éléments ou d’opérations par seconde.|`RateOfCountsPerSecond64`|Suivi des commandes reçues par seconde sur un site avec un volume très élevé.|  
|Calculer le temps moyen pour effectuer un processus ou pour traiter un élément|`AverageTimer32`|Calculer la durée moyenne un ordre de traitement.|  
  
 Lorsque vous créez un compteur dont le type nécessite l’utilisation d’un compteur de base correspondante, vous devez déclarer le compteur et la base dans le <xref:System.Diagnostics.CounterCreationDataCollection> vous passer dans le <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> (méthode).  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> propriété est <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> et la catégorie de compteur de performances a été créée avec .NET Framework version 1.0 ou 1.1, un <xref:System.InvalidOperationException> est levée. Catégories de compteur de performances créés avec des versions antérieures utilisent la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'instance n'est pas correctement associée à un compteur de performance.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> a la valeur <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> lorsqu'elle utilise la mémoire partagée globale.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour la lecture de la catégorie de compteur de performances. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberSignature Language="F#" Value="member this.Decrement : unit -&gt; int64" Usage="performanceCounter.Decrement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Décrémente d'une unité le compteur de performance associé, à l'aide d'une opération atomique efficace.</summary>
        <returns>Valeur décrémentée du compteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez écrire uniquement dans des compteurs personnalisés. Tous les compteurs système sont en lecture seule.  
  
> [!NOTE]
>  Le <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, et <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> méthodes utilisent des verrouillages internes pour mettre à jour la valeur du compteur. Cela permet de maintenir la valeur du compteur précise dans les scénarios multithread ou multiprocessus, mais également entraîne une baisse des performances. Si vous n’avez pas besoin de la précision à blocage opérations fournissent, vous pouvez mettre à jour le <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété directement pour jusqu'à 5 fois amélioration des performances.  Toutefois, dans les scénarios multithreads, certaines mises à jour à la valeur du compteur peuvent être ignorées, ce qui entraîne des données inexactes.  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> propriété est <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> et la catégorie de compteur de performances a été créée avec .NET Framework version 1.0 ou 1.1, un <xref:System.InvalidOperationException> est levée. Catégories de compteur de performances créés avec des versions antérieures utilisent la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le compteur est en lecture seule. L'application ne peut donc pas le décrémenter.  
  
- ou - 
L'instance n'est pas correctement associée à un compteur de performance.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> a la valeur <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> lorsqu'elle utilise la mémoire partagée globale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Cette méthode est thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultFileMappingSize : int" Usage="System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.Obsolete("This field has been deprecated and is not used.  Use machine.config or an application configuration file to set the size of the PerformanceCounter file mapping.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie la taille, en octets, de la mémoire globale partagée par les compteurs de performance. La taille par défaut est 524,288 au format décimal.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="performanceCounter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="performanceCounter.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termine l'initialisation d'une instance de <see cref="T:System.Diagnostics.PerformanceCounter" /> utilisée dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour terminer l’initialisation d’un composant qui est utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> et <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> méthodes empêche le composant d’être utilisé avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberSignature Language="F#" Value="member this.Increment : unit -&gt; int64" Usage="performanceCounter.Increment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Incrémente d'une unité le compteur de performance associé, à l'aide d'une opération atomique efficace.</summary>
        <returns>Valeur incrémentée du compteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez écrire uniquement dans des compteurs personnalisés. Tous les compteurs système sont en lecture seule.  
  
> [!NOTE]
>  Le <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, et <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> méthodes utilisent des verrouillages internes pour mettre à jour la valeur du compteur. Cela permet de maintenir la valeur du compteur précise dans les scénarios multithread ou multiprocessus, mais également entraîne une baisse des performances. Si vous n’avez pas besoin de la précision à blocage opérations fournissent, vous pouvez mettre à jour le <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété directement pour jusqu'à 5 fois amélioration des performances.  Toutefois, dans les scénarios multithreads, certaines mises à jour à la valeur du compteur peuvent être ignorées, ce qui entraîne des données inexactes.  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> propriété est <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> et la catégorie de compteur de performances a été créée avec .NET Framework version 1.0 ou 1.1, un <xref:System.InvalidOperationException> est levée. Catégories de compteur de performances créés avec des versions antérieures utilisent la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le compteur est en lecture seule. L'application ne peut donc pas l'incrémenter.  
  
- ou - 
L'instance n'est pas correctement associée à un compteur de performance.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> a la valeur <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> lorsqu'elle utilise la mémoire partagée globale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Cette méthode est thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberSignature Language="F#" Value="member this.IncrementBy : int64 -&gt; int64" Usage="performanceCounter.IncrementBy value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur d'incrémentation. (Une valeur négative décrémente le compteur).</param>
        <summary>Incrémente ou décrémente d'un nombre d'unités spécifique la valeur du compteur de performance associé, à l'aide d'une opération atomique efficace.</summary>
        <returns>Nouvelle valeur du compteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez écrire uniquement dans des compteurs personnalisés. Tous les compteurs système sont en lecture seule.  
  
> [!NOTE]
>  Le <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, et <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> méthodes utilisent des verrouillages internes pour mettre à jour la valeur du compteur. Cela permet de maintenir la valeur du compteur précise dans les scénarios multithread ou multiprocessus, mais également entraîne une baisse des performances. Si vous n’avez pas besoin de la précision à blocage opérations fournissent, vous pouvez mettre à jour le <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété directement pour jusqu'à 5 fois amélioration des performances.  Toutefois, dans les scénarios multithreads, certaines mises à jour à la valeur du compteur peuvent être ignorées, ce qui entraîne des données inexactes.  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> propriété est <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> et la catégorie de compteur de performances a été créée avec .NET Framework version 1.0 ou 1.1, un <xref:System.InvalidOperationException> est levée. Catégories de compteur de performances créés avec des versions antérieures utilisent la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> pour ajouter des incréments à un compteur. Cet exemple de code fait partie d’un exemple plus complet pour la <xref:System.Diagnostics.PerformanceCounter> classe.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le compteur est en lecture seule. L'application ne peut donc pas l'incrémenter.  
  
- ou - 
L'instance n'est pas correctement associée à un compteur de performance.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> a la valeur <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> lorsqu'elle utilise la mémoire partagée globale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances si le <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> propriété est <see langword="false" />. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Cette méthode est thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceLifetime : System.Diagnostics.PerformanceCounterInstanceLifetime with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée de vie d'un processus.</summary>
        <value>Une des valeurs de <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" />. La valeur par défaut est <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la catégorie de compteur de performance est créée avec le .NET Framework version 1.0 ou 1.1, il utilise la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.CounterType%2A> propriété est <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>, le <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> valeur pour le compteur de performances doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le jeu de valeurs n'est pas un membre de l'énumération <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> est défini une fois <see cref="T:System.Diagnostics.PerformanceCounter" /> initialisé.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un nom d'instance pour ce compteur de performance.</summary>
        <value>Nom de l'instance de la catégorie de compteurs de performance, ou chaîne vide ("") si le compteur possède une seule instance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Les noms d’instance doivent être inférieure à 128 caractères.  
  
 Dans certaines situations, les catégories sont subdivisées en instances, qui assurent le suivi des données sur plusieurs occurrences de l’objet associé à une catégorie. Les instances s’appliquent à la catégorie dans son ensemble, plutôt qu’à des compteurs individuels. Chaque compteur dans une catégorie a chaque instance définie pour la catégorie. Par exemple, la catégorie de processus contient des instances nommées inactif et le système. Chaque compteur au sein de la catégorie de processus contient donc des données pour chaque instance, en affichant des informations sur les processus inactifs ou processus système.  
  
 De nombreuses catégories ne contiennent pas plusieurs instances, vous pouvez donc laisser cette propriété vide pour indiquer qu’aucune instance n’est associé à la catégorie.  
  
 Si cette <xref:System.Diagnostics.PerformanceCounter> instance pointe vers une catégorie non personnalisée, vous pouvez choisir parmi les instances de catégories existantes. Vous pouvez créer de nouvelles instances de catégorie uniquement dans les catégories personnalisées, ce qui vous permet de définir en tant que de nombreux compteurs et catégorie instances que nécessaire.  
  
 Pour créer une instance de catégorie de performance, spécifiez un `instanceName` sur la <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> constructeur. Si l’instance de la catégorie spécifiée par `instanceName` existe déjà le nouvel objet référencera l’instance existante de la catégorie.  
  
> [!NOTE]
>  N’utilisez pas les caractères « («, ») », « # », «\\», ou « / » dans le nom d’instance. Si aucun de ces caractères sont utilisés, la Console de Performance (consultez [profilage d’exécution](~/docs/framework/debug-trace-profile/runtime-profiling.md)) peut ne pas afficher correctement les valeurs d’instance.  
  
 Si le nom d’instance est généré automatiquement et peut contenir les caractères « ( », «) », « # », «\\», ou « / », utilisez le mappage de caractères dans le tableau suivant.  
  
|Caractère|Caractère mappé|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|_|  
|\|_|  
|/|_|  
  
 Le <xref:System.AppDomain.FriendlyName%2A> propriété de la <xref:System.AppDomain> objet obtenu à partir de la <xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType> propriété est une source commune de noms d’instance qui peut contenir des caractères non valides.  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance par défaut de la <xref:System.Diagnostics.PerformanceCounter> classe. Une fois que l’instance est créée, le <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, et <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> les valeurs de propriété sont définies et les résultats d’un appel à la <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> méthode sont affichés.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("What's the machine name format?")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'ordinateur contenant ce compteur de performance.</summary>
        <value>Serveur sur lequel résident le compteur de performance et la catégorie qui lui est associée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez écrire des valeurs uniquement pour les compteurs qui se trouvent sur l’ordinateur local. Toutefois, vous pouvez lire les valeurs de compteur à partir de n’importe quel ordinateur dans l’entreprise pour laquelle vous disposez des privilèges d’accès.  
  
 Lorsque vous définissez la <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> propriété pour pointer vers un ordinateur distant, le <xref:System.Diagnostics.PerformanceCounter> instance tente d’ouvrir le compteur sur cet ordinateur. Si le compteur n’existe pas, la définition de cette propriété lève une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le format <see cref="P:System.Diagnostics.PerformanceCounter.MachineName" /> n'est pas valide.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberSignature Language="F#" Value="member this.NextSample : unit -&gt; System.Diagnostics.CounterSample" Usage="performanceCounter.NextSample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un échantillon de compteur et retourne sa valeur brute ou non calculée.</summary>
        <returns>
          <see cref="T:System.Diagnostics.CounterSample" /> représentant la prochaine valeur brute obtenue par le système pour ce compteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est généralement utilisée pour les compteurs qui contiennent des valeurs non calculées.  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> propriété est <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> et la catégorie de compteur de performances a été créée avec .NET Framework version 1.0 ou 1.1, un <xref:System.InvalidOperationException> est levée. Catégories de compteur de performances créés avec des versions antérieures utilisent la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> méthode pour obtenir la valeur non calculée suivante d’un compteur. Cet exemple de code fait partie d’un exemple plus complet pour la <xref:System.Diagnostics.PerformanceCounter> classe.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'instance n'est pas correctement associée à un compteur de performance.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> a la valeur <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> lorsqu'elle utilise la mémoire partagée globale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour la lecture de la catégorie de compteur de performances. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberSignature Language="F#" Value="member this.NextValue : unit -&gt; single" Usage="performanceCounter.NextValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un échantillon de compteur et retourne sa valeur calculée.</summary>
        <returns>Prochaine valeur calculée obtenue par le système pour ce compteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si la valeur calculée d’un compteur dépend de deux lectures du compteur, la première opération de lecture retourne 0.0. Réinitialiser les propriétés de compteur de performances pour spécifier un autre compteur est équivalent à la création d’un compteur de performances, et la première opération de lecture à l’aide des nouvelles propriétés retourne 0.0. Le délai recommandé entre les appels à la <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> méthode est une seconde, pour permettre au compteur d’effectuer la lecture incrémentielle suivante.  
  
> [!NOTE]
>  Pour lire les compteurs de performances, vous devez disposer des privilèges d’administrateur. Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Diagnostics.PerformanceCounterType.ElapsedTime> compteur et utilise le <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> méthode pour afficher les valeurs du compteur sur une période de temps.  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'instance n'est pas correctement associée à un compteur de performance.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour la lecture de la catégorie de compteur de performances. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.RawValue : int64 with get, set" Usage="System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The raw value of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_RawValue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur brute (ou non calculée) de ce compteur.</summary>
        <value>Valeur brute du compteur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le type de compteur est une taille de 32 bits et que vous tentez de définir cette propriété sur une valeur qui est trop grande pour tenir, la propriété tronque la valeur à 32 bits. Lors de la lecture des compteurs personnalisés sur l’ordinateur local, à l’aide du <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété plutôt qu’une valeur calculée peut produire améliorer considérablement les performances dans les scénarios où la valeur brute est suffisante.  
  
 Si le compteur que vous lisez est en lecture seule, l’obtention du <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété échantillonne le compteur au moment où la propriété est appelée. Cette action est équivalente à un appel initial à la <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> (méthode). Si vous appelez ensuite <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>, vous pouvez effectuer des calculs sur les valeurs retournées par les deux appels.  
  
 Étant donné que les compteurs système sont en lecture seule, vous pouvez obtenir, mais pas définir leurs valeurs brutes.  
  
> [!NOTE]
>  Le <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, et <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> méthodes utilisent des verrouillages internes pour mettre à jour la valeur du compteur. Cela permet de maintenir la valeur du compteur précise dans les scénarios multithread ou multiprocessus, mais également entraîne une baisse des performances. Si vous n’avez pas besoin de la précision à blocage opérations fournissent, vous pouvez mettre à jour le <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété directement pour jusqu'à 5 fois amélioration des performances.  Toutefois, dans les scénarios multithreads, certaines mises à jour à la valeur du compteur peuvent être ignorées, ce qui entraîne des données inexactes.  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> propriété est <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> et la catégorie de compteur de performances a été créée avec .NET Framework version 1.0 ou 1.1, un <xref:System.InvalidOperationException> est levée. Catégories de compteur de performances créés avec des versions antérieures utilisent la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
> [!NOTE]
>  Pour lire les compteurs de performances dans Windows Vista, Windows XP Professionnel x64 64 ou Windows Server 2003, vous devez être membre du groupe utilisateurs de moniteur de performances ou disposer de privilèges administratifs.  
>   
>  Pour éviter d’avoir à élever vos privilèges pour accéder aux compteurs de performances dans Windows Vista, ajoutez-vous au groupe utilisateurs de moniteur de performances.  
>   
>  Dans Windows Vista, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Diagnostics.CounterSample> classe pour afficher la valeur de la <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> propriété pour un compteur.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Vous tentez de définir la valeur brute du compteur, mais il est en lecture seule.  
  
- ou - 
L'instance n'est pas correctement associée à un compteur de performance.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> a la valeur <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> lorsqu'elle utilise la mémoire partagée globale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code s'exécutant sans privilèges d'administrateur, destiné à lire un compteur de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The accessability level of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_ReadOnly")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si cette instance de <see cref="T:System.Diagnostics.PerformanceCounter" /> est en mode lecture seule.</summary>
        <value>
          <see langword="true" /> si l'instance de <see cref="T:System.Diagnostics.PerformanceCounter" /> est en lecture seule (même si le compteur lui-même est un compteur .NET Framework personnalisé) ; <see langword="false" /> si elle est en lecture/écriture. La valeur par défaut est la valeur définie par le constructeur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour un compteur système, <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> doivent toujours `true`. Vous ne pouvez pas écrire dans un compteur de système.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberSignature Language="F#" Value="member this.RemoveInstance : unit -&gt; unit" Usage="performanceCounter.RemoveInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime l'instance de la catégorie spécifiée par la propriété <see cref="T:System.Diagnostics.PerformanceCounter" /> de l'objet <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez supprimer une instance uniquement pour un compteur personnalisé. Tous les compteurs système sont en lecture seule, afin de supprimer un d’eux lève une exception.  
  
> [!NOTE]
>  Pour éviter une condition de concurrence possibles lorsque la mémoire partagée du compteur de performance est libérée, il est recommandé que le <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> méthode être appelée depuis le <xref:System.AppDomain.DomainUnload> Gestionnaire d’événements.  
  
 Pour créer une instance de catégorie de performance, spécifiez un `instanceName` sur la <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> constructeur. Si l’instance de la catégorie spécifiée par `instanceName` existe déjà le nouvel objet référencera l’instance existante de la catégorie.  
  
> [!NOTE]
>  Si la valeur de la <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> propriété est <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> et la catégorie de compteur de performances a été créée avec .NET Framework version 1.0 ou 1.1, un <xref:System.InvalidOperationException> est levée. Catégories de compteur de performances créés avec des versions antérieures utilisent la mémoire partagée globale et la valeur de <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> doit être <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Si la catégorie n’est pas utilisée par les applications qui s’exécutent sur les versions 1.0 ou 1.1 du .NET Framework, supprimez et recréez la catégorie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ce compteur est en lecture seule. Toute instance associée à la catégorie ne peut donc pas être supprimée.  
  
- ou - 
L'instance n'est pas correctement associée à un compteur de performance.  
  
- ou - 
La propriété <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> a la valeur <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> lorsqu'elle utilise la mémoire partagée globale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur s'est produite lors de l'accès à une API système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme est Windows 98 ou Windows Millennium Edition et ne prend pas en charge les compteurs de performance.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">pour l’écriture de la catégorie de compteur de performances. Énumération associée : <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>