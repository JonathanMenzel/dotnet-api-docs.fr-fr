<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9d1d55650794a0dbf45b3b81bb454cf8fbec5629" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36344320" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides interaction with Windows event logs.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> vous permet d’accéder ou de personnaliser les journaux des événements Windows, qui enregistrent des informations sur les événements importants de logiciel ou matériel. À l’aide de <xref:System.Diagnostics.EventLog>, vous pouvez lire les journaux existants, écrire des entrées dans les journaux, créer ou supprimer des sources d’événements, supprimer des journaux et répondre aux entrées de journal. Vous pouvez également créer des nouveaux journaux lors de la création d’une source d’événement.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement. Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.  
  
 En plus de fournir l’accès aux journaux des événements individuels et leurs entrées, la <xref:System.Diagnostics.EventLog> classe vous permet d’accéder à la collection de tous les journaux des événements. Vous pouvez utiliser la `static` membres de <xref:System.Diagnostics.EventLog> pour supprimer les journaux, obtenir les listes de journaux, créer ou supprimer une source ou déterminer si un ordinateur contient déjà une source particulière.  
  
 Il existe trois journaux d’événements par défaut : Application, système et sécurité. Un journal de sécurité est en lecture seule. Autres applications et services que vous installez, tels qu’Active Directory, peuvent avoir des journaux des événements supplémentaires.  
  
 Il existe des considérations sur la sécurité lorsque vous utilisez la <xref:System.Diagnostics.EventLog> classe. <xref:System.Diagnostics.EventLog> requiert <xref:System.Diagnostics.EventLogPermission> des autorisations pour des actions spécifiques dans le .NET Framework 2.0 et versions ultérieures, ou une confiance totale dans le .NET Framework 1.0 et 1.1. Nous vous recommandons <xref:System.Diagnostics.EventLogPermission> ne pas accordée à du code partiellement fiable.  Vous ne devez jamais passer n’importe quel objet de journal des événements, y compris <xref:System.Diagnostics.EventLogEntryCollection> et <xref:System.Diagnostics.EventLogEntry> objets, au code de confiance inférieur. Par exemple, en créant un <xref:System.Diagnostics.EventLog> objet, l’écriture d’une entrée, puis en passant le <xref:System.Diagnostics.EventLog> objet à du code partiellement fiable peut créer un problème de sécurité, étant donné que la possibilité de lire et écrire dans le journal des événements permet d’effectuer des actions telles que l’exécution de code messages du journal des événements dans le nom d’une autre application.  
  
 À compter de Windows Vista, le contrôle de compte d’utilisateur (UAC) détermine les informations d’identification d’un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos informations d’identification d’utilisateur standard à administrateur. Faire cela lorsque vous démarrez une application en ouvrant le menu contextuel de l’application (si vous utilisez une souris, cliquez sur l’icône de l’application) et en indiquant que vous souhaitez exécuter en tant qu’administrateur.  
  
 Vous pouvez utiliser <xref:System.Diagnostics.EventLog> pour créer des journaux des événements personnalisés que vous pouvez afficher via le serveur de l’Observateur d’événements. Utilisez la <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> méthode pour afficher un nom localisé pour votre journal des événements dans l’Observateur d’événements. Utilisez la <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> méthode permettant de configurer le comportement de votre journal des événements lorsqu’il atteint sa taille maximale.  
  
 Pour lire à partir d’un journal des événements, spécifier le nom du journal (<xref:System.Diagnostics.EventLog.Log%2A> propriété) et le nom de l’ordinateur serveur (<xref:System.Diagnostics.EventLog.MachineName%2A> propriété pour le journal des événements. Si vous ne spécifiez pas le nom du serveur, l’ordinateur local, «. », est utilisé. Il n’est pas nécessaire de spécifier la source d’événements (<xref:System.Diagnostics.EventLog.Source%2A> propriété), car une source est requise uniquement pour l’écriture dans les journaux. Le <xref:System.Diagnostics.EventLog.Entries%2A> propriété est automatiquement remplie avec liste du journal des événements des entrées.  
  
 Pour écrire dans un journal des événements, spécifier ou créer une source d’événement (<xref:System.Diagnostics.EventLog.Source%2A> propriété). Vous devez disposer des informations d’identification administratives sur l’ordinateur pour créer une source d’événement. La source d’événements inscrit votre application avec le journal des événements comme source valide d’entrées. Vous pouvez utiliser la source d’événement à écrire dans un journal seul à la fois. Le <xref:System.Diagnostics.EventLog.Source%2A> propriété peut être n’importe quelle chaîne aléatoire, mais le nom doit être distinct des autres sources sur l’ordinateur. La source d’événements est généralement le nom de l’application ou une autre chaîne d’identification. La tentative de création d’un doublon <xref:System.Diagnostics.EventLog.Source%2A> valeur lève une exception. Toutefois, un seul journal des événements peut être associé à plusieurs sources.  
  
 Si la source d’événements pour le journal des événements associé à le <xref:System.Diagnostics.EventLog> instance n’existe pas, une nouvelle source d’événements est créée. Pour créer une source d’événements dans Windows Vista et versions ultérieures ou sur Windows Server 2003, vous devez disposer des informations d’identification administratives.  
  
 Cette exigence est, car tous les journaux des événements, y compris les journaux de sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
  
> [!IMPORTANT]
>  Création ou la suppression d’une source d’événements requiert la synchronisation du code sous-jacent à l’aide d’un mutex nommé. Si une application hautement privilégiée verrouille le mutex nommé, toute tentative de créer ou supprimer une source d’événement provoque l’application cesse de répondre jusqu'à ce que le verrou est libéré. Pour éviter ce problème, jamais accorder <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> autorisation de code non fiable. En outre, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> autorisation permet d’ignorer d’autres autorisations potentiellement et ne doit être accordée au code hautement approuvé.  
  
 Applications et services doivent écrire dans le journal de l’Application ou dans un journal personnalisé. Pilotes de périphérique doivent écrire dans le journal système. Si vous ne définissez pas explicitement la <xref:System.Diagnostics.EventLog.Log%2A> propriété, le journal des événements par défaut le journal des applications.  
  
> [!NOTE]
>  Il n’y a rien pour protéger une application à partir de l’écriture de toute source inscrite.  Si une application est accordée <xref:System.Diagnostics.EventLogPermissionAccess.Write> autorisation, il peut écrire des événements pour n’importe quelle source valide inscrite sur l’ordinateur.  
  
 Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthodes pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous essayez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller> objet ou le <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des informations d’identification administratives sur l’ordinateur pour créer une source d’événement.  
  
 Chaque source peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter des sources multiples configurées pour des journaux des événements ou des fichiers de ressources différents. Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis de le créer avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créez une nouvelle source avec la configuration mise à jour au lieu de supprimer la source existante.  
  
 Vous pouvez inscrire la source d’événements avec des ressources localisées pour vos chaînes de catégorie et le message d’événement. Votre application peut écrire des entrées de journal des événements à l’aide d’identificateurs de ressources au lieu de spécifier les valeurs de chaîne réelle. Reportez-vous à la <xref:System.Diagnostics.EventLogInstaller> et <xref:System.Diagnostics.EventSourceCreationData> classes pour plus d’informations sur la configuration de la source des fichiers de ressources.  
  
 Si votre application écrit les valeurs de chaîne directement dans le journal des événements, il est inutile de paramétrer les propriétés de la source de la ressource. La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Lorsque vous écrivez des événements, vous devez au moins spécifier une chaîne de message ou l’identificateur de ressource pour une chaîne de message. Autres propriétés de l’événement sont facultatifs. Exemples de paramètres d’événements facultatifs sont les suivants :  
  
-   Vous pouvez définir le <xref:System.Diagnostics.EventLogEntryType> pour spécifier l’icône que l’Observateur d’événements affiche pour l’entrée.  
  
-   Vous pouvez spécifier un identificateur de la catégorie de l’événement, si votre application utilise des catégories pour filtrer les événements.  
  
-   Vous pouvez joindre des données binaires à votre entrée d’événement si vous souhaitez associer des informations supplémentaires à un événement donné.  
  
> [!IMPORTANT]
>  Journalisation des événements utilise l’espace disque, de temps processeur et d’autres ressources système. Il est important d’enregistrer uniquement les informations essentielles. Nous vous recommandons de placer des appels du journal des événements dans un chemin d’accès de l’erreur plutôt que dans le chemin d’accès du code principal, par conséquent, ils ne pas nuire aux performances.  
  
 Pour obtenir la liste de valeurs de propriété initiales d’une instance de <xref:System.Diagnostics.EventLog>, consultez la <xref:System.Diagnostics.EventLog.%23ctor%2A> constructeur.  
  
   
  
## Examples  
 L’exemple suivant crée la source d’événements `MySource` si elle n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
> [!NOTE]
>  À compter de Windows Vista, vous devez exécuter cette application en tant qu’administrateur.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventLog" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventLog" /> class. Does not associate the instance with any log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant d’appeler <xref:System.Diagnostics.EventLog.WriteEntry%2A>, spécifiez la <xref:System.Diagnostics.EventLog.Source%2A> propriété de la <xref:System.Diagnostics.EventLog> instance. Si vous lisez uniquement <xref:System.Diagnostics.EventLog.Entries%2A> à partir du journal, vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>.  
  
|Propriété|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Une chaîne vide (« »).|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Une chaîne vide (« »).|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|L’ordinateur local («. »).|  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">The name of the log on the local computer.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventLog" /> class. Associates the instance with a log on the local computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge affecte le <xref:System.Diagnostics.EventLog.Log%2A> propriété le `logName` paramètre. Avant d’appeler <xref:System.Diagnostics.EventLog.WriteEntry%2A>, spécifiez la <xref:System.Diagnostics.EventLog.Source%2A> propriété de la <xref:System.Diagnostics.EventLog> instance. Si vous lisez uniquement <xref:System.Diagnostics.EventLog.Entries%2A> à partir du journal, vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé. Cette surcharge du constructeur spécifie la <xref:System.Diagnostics.EventLog.Log%2A> propriété, mais vous pouvez modifier cela avant de lire le <xref:System.Diagnostics.EventLog.Entries%2A> propriété.  
  
 Si la source que vous spécifiez dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété est unique à partir d’autres sources sur l’ordinateur, un appel ultérieur à <xref:System.Diagnostics.EventLog.WriteEntry%2A> crée un journal avec le nom spécifié, s’il n’existe pas.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>.  
  
|Propriété|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Une chaîne vide (« »).|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Le `logName` paramètre.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|L’ordinateur local («. »).|  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements « myNewLog » sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The log name is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The log name is invalid.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">The name of the log on the specified computer.</param>
        <param name="machineName">The computer on which the log exists.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventLog" /> class. Associates the instance with a log on the specified computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge affecte le <xref:System.Diagnostics.EventLog.Log%2A> propriété le `logName` paramètre et le <xref:System.Diagnostics.EventLog.MachineName%2A> propriété le `machineName` paramètre. Avant d’appeler <xref:System.Diagnostics.EventLog.WriteEntry%2A>, spécifiez la <xref:System.Diagnostics.EventLog.Source%2A> propriété de la <xref:System.Diagnostics.EventLog>. Si vous lisez uniquement <xref:System.Diagnostics.EventLog.Entries%2A> à partir du journal, vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés.  
  
> [!NOTE]
>  Cette surcharge du constructeur spécifie la <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés, mais vous pouvez les modifier avant de lire le <xref:System.Diagnostics.EventLog.Entries%2A> propriété.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>.  
  
|Propriété|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Une chaîne vide (« »).|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Le `logName` paramètre.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Le `machineName` paramètre.|  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements « myNewLog » sur l’ordinateur « myServer ».  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The log name is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The log name is invalid.  -or-  The computer name is invalid.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">The name of the log on the specified computer</param>
        <param name="machineName">The computer on which the log exists.</param>
        <param name="source">The source of event log entries.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventLog" /> class. Associates the instance with a log on the specified computer and creates or assigns the specified source to the <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur définit la <xref:System.Diagnostics.EventLog.Log%2A> propriété le `logName` paramètre, le <xref:System.Diagnostics.EventLog.MachineName%2A> propriété le `machineName` paramètre et le <xref:System.Diagnostics.EventLog.Source%2A> propriété le `source` paramètre. Le <xref:System.Diagnostics.EventLog.Source%2A> propriété est requise lors de l’écriture dans un journal des événements. Toutefois, si vous êtes uniquement la lecture à partir d’un journal des événements, uniquement le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés sont requises (tant que le journal des événements sur le serveur a déjà associé à une source). Si vous êtes uniquement la lecture du journal des événements, une autre surcharge du constructeur peut suffire.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>.  
  
|Propriété|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Le `source` paramètre.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Le `logName` paramètre.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Le `machineName` paramètre.|  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée dans un journal des événements, « MyNewLog », sur l’ordinateur local, à l’aide de la source « Entrées ».  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The log name is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The log name is invalid.  -or-  The computer name is invalid.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the initialization of an <see cref="T:System.Diagnostics.EventLog" /> used on a form or used by another component. The initialization occurs at runtime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour démarrer l’initialisation d’un composant utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Diagnostics.EventLog.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.Diagnostics.EventLog.BeginInit%2A> et <xref:System.Diagnostics.EventLog.EndInit%2A> méthodes empêchent le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> is already initialized.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all entries from the event log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Journaux des événements sont définies avec une taille maximale qui détermine le nombre d’entrées qu’ils peuvent contenir. Lorsqu’un journal des événements est plein, il arrête l’enregistrement de nouvelles informations d’événement ou commence à remplacer les entrées précédentes. Si l’enregistrement d’événements s’arrête, vous pouvez utiliser cette méthode pour effacer le journal des entrées existantes et l’autoriser à nouveau de démarrer l’enregistrement des événements. Vous devez disposer des autorisations d’administrateur sur l’ordinateur sur lequel se trouve le journal pour effacer des entrées de journal des événements.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> ferme le journal des événements, libère les handles d’événement, récupère de nouveaux lire et écrire des handles et rouvre le journal des événements. Les événements reçus après l’appel à la méthode ne sont pas effacés, ainsi que les événements existants.  
  
   
  
## Examples  
 L’exemple suivant efface un journal des événements.  
  
> [!CAUTION]
>  Étant donné que l’Application, système, sécurité et autres journaux non personnalisés peut contenir des informations fondamentales ; Veillez à spécifier un journal personnalisé avant d’exécuter cet exemple de code. Cet exemple supprime le journal personnalisé `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The event log was not cleared successfully.  -or-  The log cannot be opened. A Windows error code is not available.</exception>
        <exception cref="T:System.ArgumentException">A value is not specified for the <see cref="P:System.Diagnostics.EventLog.Log" /> property. Make sure the log name is not an empty string.</exception>
        <exception cref="T:System.InvalidOperationException">The log does not exist.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the event log and releases read and write handles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.EventLog.Close%2A> méthode est appelée par la méthode protégée <xref:System.ComponentModel.Component.Dispose%2A> (méthode). Vous n’avez pas besoin d’appeler <xref:System.Diagnostics.EventLog.Close%2A> avant d’appeler <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The event log's read handle or write handle was not released successfully.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establishes an application as able to write event information to a particular log on the system.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">The configuration properties for the event source and its target event log.</param>
        <summary>Establishes a valid event source for writing localized event messages, using the specified configuration properties for the event source and the corresponding event log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour configurer une nouvelle source pour écrire des entrées dans un journal des événements sur l’ordinateur local ou un ordinateur distant. Il n’est pas nécessaire d’utiliser cette méthode pour lire à partir d’un journal des événements.  
  
 Le <xref:System.Diagnostics.EventLog.CreateEventSource%2A> méthode utilise l’entrée `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> et <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> propriétés afin de créer des valeurs de Registre sur l’ordinateur cible pour la nouvelle source et son journal des événements associé. Un nouveau nom de la source ne peut pas correspondre à un nom de source existant ou un nom de journal des événements existants sur l’ordinateur cible. Si le <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> propriété n’est pas définie, la source est inscrite pour le journal des événements. Si le <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> n’est pas défini, la source est inscrite sur l’ordinateur local.  
  
> [!NOTE]
>  Pour créer une source d’événements dans Windows Vista et versions ultérieures ou sur Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  À compter de Windows Vista, le contrôle de compte d’utilisateur (UAC) détermine les privilèges d’un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 Utilisez <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Vous pouvez créer une source d’événements pour un journal des événements existant ou un journal des événements. Lorsque vous créez une nouvelle source pour un journal des événements, le système inscrit la source de ce journal, mais le journal n’est pas créé tant que l’écriture de la première entrée.  
  
 Le système d’exploitation stocke les journaux des événements sous forme de fichiers. Lorsque vous utilisez <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour créer un nouveau journal des événements, le fichier associé est stocké dans le répertoire %SystemRoot%\System32\Config sur l’ordinateur spécifié. Le nom de fichier est défini en ajoutant les 8 premiers caractères de la <xref:System.Diagnostics.EventLog.Log%2A> propriété avec l’extension de nom de fichier « .evt ».  
  
 Chaque source ne peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter des sources multiples configurées pour des journaux des événements ou des fichiers de ressources différents.  
  
 Vous pouvez inscrire la source d’événements avec les fichiers de ressources localisés pour vos chaînes de catégorie et le message d’événement. Votre application peut écrire des entrées de journal des événements à l’aide d’identificateurs de ressources, au lieu de spécifier la chaîne réelle. L’Observateur d’événements utilise l’identificateur de ressource pour rechercher et afficher la chaîne correspondante à partir du fichier de ressource localisée selon les paramètres de langue actuels. Vous pouvez enregistrer un fichier distinct pour les catégories d’événements, les messages et les chaînes d’insertion de paramètre, ou vous pouvez inscrire le même fichier de ressources pour les trois types de chaînes. Utilisez le <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, et <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> propriétés pour configurer la source pour écrire des entrées localisées dans le journal des événements. Si votre application écrit les valeurs des chaînes directement dans le journal des événements, il est inutile de définir ces propriétés.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis de le créer avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créer une nouvelle source avec la configuration mise à jour, plutôt que de supprimer la source existante.  
  
> [!NOTE]
>  Si une source est configurée pour un journal des événements, et que vous reconfigurez pour un autre journal des événements, vous devez redémarrer l’ordinateur pour que les modifications prennent effet.  
  
   
  
## Examples  
 L’exemple suivant détermine si la source d’événements nommé `SampleApplicationSource` est enregistré sur l’ordinateur local. Si la source d’événements n’existe pas, l’exemple définit le fichier de ressources pour la source de message et crée la nouvelle source d’événements. Enfin, l’exemple définit le nom complet localisé du journal des événements, à l’aide de la valeur d’identificateur de ressource dans `DisplayNameMsgId` et le chemin d’accès du fichier de ressources dans `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 L’exemple utilise le fichier texte du message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir de laquelle le fichier de ressource de message est créé. Le fichier texte de message définit les identificateurs de ressources et le texte de la catégorie, message d’événement et les chaînes d’insertion de paramètre. Plus précisément, l’identificateur de ressource 5001 est défini pour le nom localisé du journal des événements.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The computer name specified in <paramref name="sourceData" /> is not valid.  \- or -  The source name specified in <paramref name="sourceData" /> is <see langword="null" />.  \- or -  The log name specified in <paramref name="sourceData" /> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\'.  \- or -  The log name specified in <paramref name="sourceData" /> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \- or -  The log name matches an existing event source name.  \- or -  The source name specified in <paramref name="sourceData" /> results in a registry key path longer than 254 characters.  \- or -  The first 8 characters of the log name specified in <paramref name="sourceData" /> are not unique.  \- or -  The source name specified in <paramref name="sourceData" /> is already registered.  \- or -  The source name specified in <paramref name="sourceData" /> matches an existing event log name.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">The source name by which the application is registered on the local computer.</param>
        <param name="logName">The name of the log the source's entries are written to. Possible values include Application, System, or a custom event log.</param>
        <summary>Establishes the specified source name as a valid event source for writing entries to a log on the local computer. This method can also create a new custom log on the local computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer un journal personnalisé ou pour créer et inscrire un <xref:System.Diagnostics.EventLog.Source%2A> dans un journal existant sur l’ordinateur local.  
  
 Si `logName` est `null` ou une chaîne vide (" ») lorsque vous appelez <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, le journal par défaut est le journal des applications. Si le journal n’existe pas sur l’ordinateur local, le système crée un journal personnalisé et inscrit votre application comme une <xref:System.Diagnostics.EventLog.Source%2A> de ce journal.  
  
> [!NOTE]
>  Pour créer une source d’événements dans Windows Vista et versions ultérieures ou sur Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  Dans Windows Vista et version ultérieure, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 Vous devez uniquement créer une source d’événements si vous écrivez dans le journal des événements. Avant d’écrire une entrée dans un journal des événements, vous devez inscrire la source d’événements avec le journal des événements comme source valide d’événements. Lorsque vous écrivez une entrée de journal, le système utilise le <xref:System.Diagnostics.EventLog.Source%2A> pour trouver le journal approprié dans lequel placer votre entrée. Si vous lisez le journal des événements, vous pouvez spécifier le <xref:System.Diagnostics.EventLog.Source%2A>, ou un <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Vous n’êtes pas obligé de spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal sur l’ordinateur local. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A> lors de la lecture à partir d’un journal de l’ordinateur local («. ») est supposé.  
  
 Utilisez <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Vous pouvez créer une source d’événements pour un journal des événements existant ou un journal des événements. Lorsque vous créez une nouvelle source pour un journal des événements, le système inscrit la source de ce journal, mais le journal n’est pas créé tant que l’écriture de la première entrée.  
  
 Le système d’exploitation stocke les journaux des événements sous forme de fichiers. Lorsque vous utilisez <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour créer un nouveau journal des événements, le fichier associé est stocké dans le répertoire %SystemRoot%\System32\Config sur l’ordinateur spécifié. Le nom de fichier est défini en ajoutant les 8 premiers caractères de la <xref:System.Diagnostics.EventLog.Log%2A> propriété avec l’extension de nom de fichier « .evt ».  
  
 La source doit être unique sur l’ordinateur local ; un nouveau nom de la source ne peut pas correspondre à un nom de source existant ou un nom de journal des événements existant. Chaque source peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter des sources multiples configurées pour des journaux des événements ou des fichiers de ressources différents.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis de le créer avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créer une nouvelle source avec la configuration mise à jour, plutôt que de supprimer la source existante.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications prennent effet.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> is an empty string ("") or <see langword="null" />.  \- or -  <paramref name="logName" /> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\'.  \- or -  <paramref name="logName" /> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \- or -  The log name matches an existing event source name.  \- or -  The source name results in a registry key path longer than 254 characters.  \- or -  The first 8 characters of <paramref name="logName" /> match the first 8 characters of an existing event log name.  \- or -  The source cannot be registered because it already exists on the local computer.  \- or -  The source name matches an existing event log name.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened on the local computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">The source by which the application is registered on the specified computer.</param>
        <param name="logName">The name of the log the source's entries are written to. Possible values include Application, System, or a custom event log. If you do not specify a value, <c>logName</c> defaults to Application.</param>
        <param name="machineName">The name of the computer to register this event source with, or "." for the local computer.</param>
        <summary>Establishes the specified source name as a valid event source for writing entries to a log on the specified computer. This method can also be used to create a new custom log on the specified computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer un journal personnalisé ou pour créer et inscrire un <xref:System.Diagnostics.EventLog.Source%2A> dans un journal existant sur l’ordinateur spécifié.  
  
 Si `logName` est `null` ou une chaîne vide (" ») lorsque vous appelez <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, le journal par défaut est le journal des applications. Si le journal n’existe pas sur l’ordinateur spécifié, le système crée un journal personnalisé et inscrit votre application comme une <xref:System.Diagnostics.EventLog.Source%2A> de ce journal.  
  
 Vous devez uniquement créer une source d’événements si vous écrivez dans le journal des événements. Avant d’écrire une entrée dans un journal des événements, vous devez inscrire la source d’événements avec le journal des événements comme source valide d’événements. Lorsque vous écrivez une entrée de journal, le système utilise le <xref:System.Diagnostics.EventLog.Source%2A> pour trouver le journal approprié dans lequel placer votre entrée. Si vous lisez le journal des événements, vous pouvez spécifier le <xref:System.Diagnostics.EventLog.Source%2A>, ou un <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Pour créer une source d’événements dans Windows Vista et versions ultérieures ou sur Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. Dans Windows Vista et versions ultérieures, les utilisateurs ne peuvent pas accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  Dans Windows Vista et version ultérieure, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 Utilisez <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Vous pouvez créer une source d’événements pour un journal des événements existant ou un journal des événements. Lorsque vous créez une nouvelle source pour un journal des événements, le système inscrit la source de ce journal, mais le journal n’est pas créé tant que l’écriture de la première entrée.  
  
 Le système d’exploitation stocke les journaux des événements sous forme de fichiers. Lorsque vous utilisez <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour créer un nouveau journal des événements, le fichier associé est stocké dans le répertoire %SystemRoot%\System32\Config sur l’ordinateur spécifié. Le nom de fichier est défini en ajoutant les 8 premiers caractères de la <xref:System.Diagnostics.EventLog.Log%2A> propriété avec l’extension de nom de fichier « .evt ».  
  
 La source doit être unique sur l’ordinateur local ; un nouveau nom de la source ne peut pas correspondre à un nom de source existant ou un nom de journal des événements existant. Chaque source peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter des sources multiples configurées pour des journaux des événements ou des fichiers de ressources différents.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis de le créer avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créer une nouvelle source avec la configuration mise à jour, plutôt que de supprimer la source existante.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications prennent effet.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` sur l’ordinateur `MyServer`et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> is not a valid computer name.  \- or -  <paramref name="source" /> is an empty string ("") or <see langword="null" />.  \- or -  <paramref name="logName" /> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\'.  \- or -  <paramref name="logName" /> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \- or -  The log name matches an existing event source name.  \- or -  The source name results in a registry key path longer than 254 characters.  \- or -  The first 8 characters of <paramref name="logName" /> match the first 8 characters of an existing event log name on the specified computer.  \- or -  The source cannot be registered because it already exists on the specified computer.  \- or -  The source name matches an existing event source name.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened on the specified computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Removes a log resource.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">The name of the log to delete. Possible values include: Application, Security, System, and any custom event logs on the computer.</param>
        <summary>Removes an event log from the local computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque le journal que vous souhaitez supprimer est sur l’ordinateur local. Vous pouvez supprimer n’importe quel journal sur l’ordinateur, si vous disposez des autorisations de Registre appropriées.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Supprime le journal spécifié par `logName` à partir de l’ordinateur local. Si vous souhaitez supprimer uniquement la source inscrite dans un journal, appelez <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Si vous souhaitez uniquement supprimer les entrées de journal, appelez <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> et <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sont `static` méthodes, peuvent donc être appelés sur la classe elle-même. Il n’est pas nécessaire de créer une nouvelle instance de <xref:System.Diagnostics.EventLog> pour appeler une méthode.  
  
 Le <xref:System.Diagnostics.EventLog.Delete%2A> méthode supprime tout d’abord le fichier qui contient le contenu du journal. Ensuite, il accède au Registre et supprime toutes les sources d’événements inscrites pour ce journal. Si vous recréez le journal à un moment ultérieur, vous devez inscrire les sources d’événements, s’ils doivent être réutilisés. Si vous n’enregistrez pas les sources d’événements et d’autres utilisateurs écrivent dans une source d’événement sans spécifier un nom de journal, la source d’événements est créée dans le journal des événements. Par conséquent, les applications qui pouvaient précédemment écrire des entrées dans le journal que vous avez supprimé et recréé écrit dans le journal des applications à la place, car il contient maintenant la source d’événements.  
  
> [!NOTE]
>  Recréation d’un journal des événements peut être difficile. Évitez de supprimer les journaux des événements de créé par le système, telles que le journal des applications.  
  
 Suppression d’un journal par un appel à <xref:System.Diagnostics.EventLog.Delete%2A> supprime automatiquement les sources inscrites dans ce journal. Cela peut rendre d’autres applications à l’aide de ce journal inopérantes.  
  
   
  
## Examples  
 L’exemple suivant supprime un journal de l’ordinateur local. L’exemple détermine le journal à partir de sa source.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’aucune source de l’écriture dans ce journal.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> is an empty string ("") or <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened on the local computer.  \- or -  The log does not exist on the local computer.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The event log was not cleared successfully.  -or-  The log cannot be opened. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">The name of the log to delete. Possible values include: Application, Security, System, and any custom event logs on the specified computer.</param>
        <param name="machineName">The name of the computer to delete the log from, or "." for the local computer.</param>
        <summary>Removes an event log from the specified computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque le journal que vous souhaitez supprimer est sur un ordinateur distant. Vous pouvez supprimer n’importe quel journal sur l’ordinateur, si vous disposez des autorisations de Registre appropriées.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Supprime le journal spécifié par `logName` à partir de l’ordinateur spécifié par `machineName`. Si vous souhaitez supprimer uniquement la source inscrite dans un journal, appelez <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Si vous souhaitez uniquement supprimer les entrées de journal, appelez <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> et <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sont `static` méthodes, peuvent donc être appelés sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler une méthode.  
  
 Cette méthode supprime tout d’abord le fichier qui contient le contenu du journal. Ensuite, il accède au Registre et supprime toutes les sources d’événements inscrites pour ce journal. Si vous recréez le journal à un moment ultérieur, vous devez inscrire les sources d’événements, s’ils doivent être réutilisés. Si vous n’enregistrez pas les sources d’événements et d’autres utilisateurs écrivent dans une source d’événement sans spécifier un nom de journal, la source d’événements est créée dans le journal des événements. Par conséquent, les applications qui pouvaient précédemment écrire des entrées dans le journal que vous avez supprimé et recréé écrit dans le journal des applications à la place, car il contient maintenant la source d’événements.  
  
> [!NOTE]
>  Recréation d’un journal des événements peut être difficile. Évitez de supprimer les journaux des événements de créé par le système, telles que le journal des applications.  
  
 Suppression d’un journal par un appel à <xref:System.Diagnostics.EventLog.Delete%2A> supprime automatiquement les sources inscrites dans ce journal. Cela peut rendre d’autres applications à l’aide de ce journal inopérantes.  
  
   
  
## Examples  
 L’exemple suivant supprime un journal de l’ordinateur spécifié. L’exemple détermine le journal à partir de sa source.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’aucune source de l’écriture dans ce journal.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> is an empty string ("") or <see langword="null" />.  \- or -  <paramref name="machineName" /> is not a valid computer name.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened on the specified computer.  \- or -  The log does not exist on the specified computer.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The event log was not cleared successfully.  -or-  The log cannot be opened. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Removes an application's event source registration from the event log.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">The name by which the application is registered in the event log system.</param>
        <summary>Removes the event source registration from the event log of the local computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour supprimer l’inscription d’un <xref:System.Diagnostics.EventLog.Source%2A> à partir de l’ordinateur local. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> accède au Registre sur l’ordinateur local et supprime l’inscription de votre application en tant que source d’événements valide.  
  
 Si vous n’avez plus besoin d’écrire des entrées dans ce journal, vous pouvez supprimer votre composant comme source d’événements valide. Par exemple, vous pouvez effectuer cela si vous devez modifier votre composant à partir d’un journal à l’autre. Car une source peut uniquement être enregistrée dans un journal à la fois, changez le journal, vous devez supprimer l’enregistrement en cours.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Supprime uniquement la source inscrite dans un journal. Si vous souhaitez supprimer le journal lui-même, appelez <xref:System.Diagnostics.EventLog.Delete%2A>. Si vous souhaitez uniquement supprimer les entrées de journal, appelez <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> et <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sont `static` méthodes, peuvent donc être appelés sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler une méthode.  
  
 Suppression d’un journal par un appel à <xref:System.Diagnostics.EventLog.Delete%2A> supprime automatiquement les sources inscrites dans ce journal. Cela peut rendre d’autres applications à l’aide de ce journal inopérantes.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications prennent effet.  
  
   
  
## Examples  
 L’exemple suivant supprime une source de l’ordinateur local. L’exemple détermine le journal à partir de sa source, puis supprime le journal.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’aucune source de l’écriture dans ce journal.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="source" /> parameter does not exist in the registry of the local computer.  \- or -  You do not have write access on the registry key for the event log.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">The name by which the application is registered in the event log system.</param>
        <param name="machineName">The name of the computer to remove the registration from, or "." for the local computer.</param>
        <summary>Removes the application's event source registration from the specified computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour supprimer l’inscription d’un <xref:System.Diagnostics.EventLog.Source%2A> à partir d’un ordinateur distant. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> accède au Registre sur l’ordinateur spécifié par `machineName` et supprime l’inscription de votre application comme une source valide d’événements.  
  
 Si vous n’avez plus besoin d’écrire des entrées dans ce journal, vous pouvez supprimer votre composant comme source d’événements valide. Par exemple, vous pouvez effectuer cela si vous devez modifier votre composant à partir d’un journal à l’autre. Car une source peut uniquement être enregistrée dans un journal à la fois, changez le journal, vous devez supprimer l’enregistrement en cours.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Supprime uniquement la source inscrite dans un journal. Si vous souhaitez supprimer le journal lui-même, appelez <xref:System.Diagnostics.EventLog.Delete%2A>. Si vous souhaitez uniquement supprimer les entrées de journal, appelez <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> et <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sont `static` méthodes, peuvent donc être appelés sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler une méthode.  
  
 Suppression d’un journal par un appel à <xref:System.Diagnostics.EventLog.Delete%2A> supprime automatiquement les sources inscrites dans ce journal. Cela peut rendre d’autres applications à l’aide de ce journal inopérantes.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications prennent effet.  
  
   
  
## Examples  
 L’exemple suivant supprime une source de l’ordinateur spécifié. L’exemple détermine le journal à partir de sa source, puis supprime le journal.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’aucune source de l’écriture dans ce journal.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter is invalid.  \- or -  The <paramref name="source" /> parameter does not exist in the registry of the specified computer.  \- or -  You do not have write access on the registry key for the event log.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> cannot be deleted because in the registry, the parent registry key for <paramref name="source" /> does not contain a subkey with the same name.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Diagnostics.EventLog" />, and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` la valeur `false`.  
  
 Lorsque le `disposing` paramètre a la valeur true, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Diagnostics.EventLog> références. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d’autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’un Method](~/docs/standard/garbage-collection/implementing-dispose.md) de suppression.  Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [nettoyage de non managé Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the <see cref="T:System.Diagnostics.EventLog" /> receives <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> event notifications.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Diagnostics.EventLog" /> reçoit la notification quand une entrée est écrite dans le journal ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> propriété détermine si le <xref:System.Diagnostics.EventLog> déclenche des événements lorsque les entrées sont écrites dans le journal. Lorsque la propriété est `true`, les composants qui reçoivent le <xref:System.Diagnostics.EventLog.EntryWritten> événement recevront une notification chaque fois qu’une entrée est écrite dans le journal qui est spécifié dans le <xref:System.Diagnostics.EventLog.Log%2A> propriété. Si <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> est `false`, aucun événement est déclenché.  
  
> [!NOTE]
>  Vous pouvez recevoir des notifications d’événements uniquement lorsque les entrées sont écrites sur l’ordinateur local. Vous ne pouvez pas recevoir des notifications pour les entrées écrites sur des ordinateurs distants.  
  
   
  
## Examples  
 L’exemple suivant gère un <xref:System.Diagnostics.EventLog.EntryWritten> événement.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The event log is on a remote computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the initialization of an <see cref="T:System.Diagnostics.EventLog" /> used on a form or by another component. The initialization occurs at runtime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour terminer l’initialisation d’un composant utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Diagnostics.EventLog.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.Diagnostics.EventLog.BeginInit%2A> et <xref:System.Diagnostics.EventLog.EndInit%2A> méthodes empêche le contrôle avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the contents of the event log.</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLogEntryCollection" /> contenant les entrées dans le journal des événements. Chaque entrée est associée à une instance de la classe <see cref="T:System.Diagnostics.EventLogEntry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Diagnostics.EventLog.Entries%2A> membre lors de la lecture du journal des événements.  
  
 Étant donné que la propriété est en lecture seule, vous ne peut pas modifier une entrée ou écrire dans le journal à l’aide de <xref:System.Diagnostics.EventLog.Entries%2A>. Au lieu de cela, spécifiez un <xref:System.Diagnostics.EventLog.Source%2A> et appelez <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire une nouvelle entrée de journal. Vous pouvez utiliser <xref:System.Diagnostics.EventLog.Entries%2A> pour compter le nombre d’entrées dans le journal des événements et afficher chaque <xref:System.Diagnostics.EventLogEntry> dans la collection. Utilisez indexés <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> membre pour récupérer des informations sur une entrée spécifique, tel que <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, ou <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Il n’est pas nécessaire de spécifier un <xref:System.Diagnostics.EventLog.Source%2A> lors de la lecture à partir d’un journal. Vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> nom et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés (nom de l’ordinateur serveur) pour le <xref:System.Diagnostics.EventLog> instance. Dans les deux cas, le <xref:System.Diagnostics.EventLog.Entries%2A> membres est automatiquement rempli avec liste du journal des événements des entrées. Vous pouvez sélectionner l’index approprié pour un élément dans cette liste pour lire les entrées individuelles.  
  
 Une distinction importante entre lecture et écriture des entrées de journal est qu’il n’est pas nécessaire d’appeler explicitement une méthode de lecture. Après le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> sont spécifiés, le <xref:System.Diagnostics.EventLog.Entries%2A> propriété est remplie automatiquement. Si vous modifiez la valeur de la <xref:System.Diagnostics.EventLog.Log%2A> ou <xref:System.Diagnostics.EventLog.MachineName%2A> propriété, le <xref:System.Diagnostics.EventLog.Entries%2A> propriété est rempli à nouveau la prochaine fois que vous les ayez lues.  
  
> [!NOTE]
>  Vous n’êtes pas obligé de spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local, «. », est utilisé.  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements, « MyNewLog », sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an entry is written to an event log on the local computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir des notifications d’événements, vous devez définir <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> à `true`. Vous pouvez uniquement recevoir des notifications d’événements lorsque les entrées sont écrites sur l’ordinateur local. Vous ne pouvez pas recevoir des notifications pour les entrées écrites sur des ordinateurs distants.  
  
 Lorsque vous créez un délégué <xref:System.Diagnostics.EventLog.EntryWritten>, vous identifiez la méthode qui gérera l'événement. Pour associer l'événement au gestionnaire d'événements, ajoutez une instance du délégué à l'événement. Le Gestionnaire d’événements est appelé chaque fois que l’événement se produit, jusqu'à ce que vous supprimez le délégué. Pour plus d’informations sur la gestion des événements avec des délégués, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 Le système répond à <xref:System.Diagnostics.EventLog.WriteEntry%2A> uniquement si le dernier événement d’écriture s’est produite au moins six secondes. Cela implique que vous recevez uniquement un <xref:System.Diagnostics.EventLog.EntryWritten> notification d’événement dans un intervalle de six secondes, même si plusieurs événements journal modification se produit. Si vous insérez un intervalle de mise en veille suffisamment long (environ 10 secondes) entre les appels à <xref:System.Diagnostics.EventLog.WriteEntry%2A>, vous êtes moins enclin à manquer un événement. Toutefois, si les événements d’écriture se produisent plus fréquemment, vous ne pouvez pas recevoir la notification d’événement jusqu’au prochain intervalle. En règle générale, notifications d’événements manquées ne sont pas perdues, mais différées.  
  
   
  
## Examples  
 L’exemple suivant gère un événement EntryWritten.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determines whether the specified log exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">The name of the log to search for. Possible values include: Application, Security, System, other application-specific logs (such as those associated with Active Directory), or any custom log on the computer.</param>
        <summary>Determines whether the log exists on the local computer.</summary>
        <returns>
          <see langword="true" /> if the log exists on the local computer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer si un journal existe sur l’ordinateur local. Si vous souhaitez déterminer si une source existe sur l’ordinateur local, utilisez <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Étant donné que cette méthode accède au Registre, vous devez disposer des autorisations de Registre appropriées sur l’ordinateur local ; Sinon, la requête retourne `false`.  
  
 Étant donné que vous ne pouvez pas donner à un nouveau journal le nom d’un journal existant sur le même ordinateur, utilisez cette méthode avant de créer un nouveau journal pour déterminer si le texte spécifié `logName` existe déjà sur l’ordinateur local. Le `logName` paramètre n’est pas la casse.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> est un `static` (méthode), elle peut donc être appelée sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The logName is <see langword="null" /> or the value is empty.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">The log for which to search. Possible values include: Application, Security, System, other application-specific logs (such as those associated with Active Directory), or any custom log on the computer.</param>
        <param name="machineName">The name of the computer on which to search for the log, or "." for the local computer.</param>
        <summary>Determines whether the log exists on the specified computer.</summary>
        <returns>
          <see langword="true" /> if the log exists on the specified computer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer si un journal existe sur un ordinateur distant. Si vous souhaitez déterminer si une source existe sur un ordinateur distant, utilisez <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Étant donné que cette méthode accède au Registre, vous devez disposer des autorisations de Registre appropriées sur l’ordinateur spécifié ; Sinon, la requête retourne `false`.  
  
 Étant donné que vous ne pouvez pas donner à un nouveau journal le nom d’un journal existant sur le même ordinateur, utilisez cette méthode avant de créer un nouveau journal pour déterminer si un avec l’objet `logName` existe déjà sur le serveur spécifié par le `machineName` paramètre. Le `logName` et `machineName` paramètres ne respectent pas la casse.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> est un `static` (méthode), elle peut donc être appelée sur la classe elle-même. Il n’est pas nécessaire de créer une nouvelle instance de <xref:System.Diagnostics.EventLog> pour appeler <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter is an invalid format. Make sure you have used proper syntax for the computer on which you are searching.  -or-  The <paramref name="logName" /> is <see langword="null" /> or the value is empty.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of the event logs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Searches for all event logs on the local computer and creates an array of <see cref="T:System.Diagnostics.EventLog" /> objects that contain the list.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.EventLog" /> that represents the logs on the local computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau de <xref:System.Diagnostics.EventLog> objets est un instantané de tous les journaux des événements sur l’ordinateur local lors de l’appel à <xref:System.Diagnostics.EventLog.GetEventLogs%2A> est effectuée. Cela n’est pas un regroupement dynamique, afin qu’il ne reflète pas la suppression ou la création de journaux en temps réel. Vous devez vérifier l’existence d’un journal dans le tableau avant de lire ou écrire dessus. Le tableau inclut généralement au moins trois journaux : Application, système et sécurité. Si vous avez créé des journaux personnalisés sur l’ordinateur local, ils s’affichent dans le tableau.  
  
 Pour récupérer la liste des journaux des événements, vous devez disposer des autorisations de Registre appropriées. Ces autorisations sont identiques à celles requises pour appeler <xref:System.Diagnostics.EventLog.Exists%2A> et <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche les détails de configuration pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">You do not have read access to the registry.  -or-  There is no event log service on the computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The computer on which to search for event logs.</param>
        <summary>Searches for all event logs on the given computer and creates an array of <see cref="T:System.Diagnostics.EventLog" /> objects that contain the list.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.EventLog" /> that represents the logs on the given computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau de <xref:System.Diagnostics.EventLog> objets est un instantané de tous les journaux des événements sur l’ordinateur spécifié par le `machineName` paramètre lors de l’appel à <xref:System.Diagnostics.EventLog.GetEventLogs%2A> est effectuée. Cela n’est pas un regroupement dynamique, afin qu’il ne reflète pas la suppression ou la création de journaux en temps réel. Vous devez vérifier l’existence d’un journal dans le tableau avant de lire ou écrire dessus. Le tableau inclut généralement au moins trois journaux : Application, système et sécurité. Si vous avez créé des journaux personnalisés sur l’ordinateur spécifié, ils s’affichent dans le tableau.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> est un `static` (méthode), il peut donc être appelée sur la <xref:System.Diagnostics.EventLog> classe elle-même. Il n’est pas nécessaire de créer une instance d’un <xref:System.Diagnostics.EventLog> objet pour effectuer un appel à la méthode.  
  
 Pour récupérer la liste des journaux des événements, vous devez disposer des autorisations de Registre appropriées. Ces autorisations sont identiques à celles requises pour appeler <xref:System.Diagnostics.EventLog.Exists%2A> et <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 L’exemple suivant obtient une liste des journaux sur l’ordinateur « myServer ». Il génère ensuite le nom de chaque journal.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter is an invalid computer name.</exception>
        <exception cref="T:System.InvalidOperationException">You do not have read access to the registry.  -or-  There is no event log service on the computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the log to read from or write to.</summary>
        <value>Nom du journal. Il peut s'agir d'application, système, sécurité ou d'un nom de journal personnalisé. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trois fichiers journaux existent par défaut sur le serveur : Application, système et sécurité. Applications et services utilisent le fichier de journal d’Application. Pilotes de périphériques utilisent le fichier journal système. Le système génère auditer les événements de réussite et d’échec dans le journal de sécurité lors de l’audit est activé. Si vous avez d’autres applications installées, comme Active Directory sur les serveurs Windows, il peut exister d’autres fichiers de journaux par défaut. En outre, vous pouvez créer des fichiers journaux personnalisés sur un ordinateur local ou distant. Les journaux personnalisés aident à organiser vos entrées de manière plus détaillée que celle autorisée lorsque vos composants écrivent des événements dans le journal des applications par défaut.  
  
> [!NOTE]
>  Les noms de journal sont limités à huit caractères. Selon le système, MyLogSample1 et MyLogSample2 sont le même journal.  
  
 Si vous écrivez dans un journal des événements, il n’est pas suffisant de spécifier la <xref:System.Diagnostics.EventLog.Log%2A> propriété. Vous devez associer un <xref:System.Diagnostics.EventLog.Source%2A> propriété avec votre ressource de journal des événements pour le connecter à un journal particulier. Il n’est pas nécessaire de spécifier un <xref:System.Diagnostics.EventLog.Source%2A> lorsque la lecture à partir d’un journal, mais une source d’événement doit être associée à la ressource de journal des événements dans le Registre du serveur. Vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> nom et <xref:System.Diagnostics.EventLog.MachineName%2A> (nom de l’ordinateur serveur) pour lire à partir de celui-ci.  
  
> [!NOTE]
>  Vous n’êtes pas obligé de spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le <xref:System.Diagnostics.EventLog.Source%2A> propriété n’a pas été spécifiée, un appel à <xref:System.Diagnostics.EventLog.Log%2A> retourne une chaîne vide si <xref:System.Diagnostics.EventLog.Log%2A> n’a pas été explicitement défini (en définissant le <xref:System.Diagnostics.EventLog.Log%2A> propriété, ou par le biais du constructeur). Si le <xref:System.Diagnostics.EventLog.Source%2A> a été spécifié, <xref:System.Diagnostics.EventLog.Log%2A> retourne le nom du journal dans lequel cette source a été inscrite.  
  
 Une source peut uniquement être inscrit dans un journal à la fois. Si le <xref:System.Diagnostics.EventLog.Source%2A> propriété a été définie pour une instance de <xref:System.Diagnostics.EventLog>, vous ne pouvez pas modifier le <xref:System.Diagnostics.EventLog.Log%2A> propriété qui <xref:System.Diagnostics.EventLog> sans modifier la valeur de <xref:System.Diagnostics.EventLog.Source%2A> ou en appelant <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> première. Si vous modifiez le <xref:System.Diagnostics.EventLog.Log%2A> après le <xref:System.Diagnostics.EventLog.Source%2A> propriété a été définie, l’écriture d’une entrée de journal lève une exception.  
  
 Le système d’exploitation stocke les journaux des événements sous forme de fichiers. Lorsque vous utilisez <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour créer un nouveau journal des événements, le fichier associé est stocké dans le répertoire %SystemRoot%\System32\Config sur l’ordinateur spécifié. Le nom de fichier est défini en ajoutant les 8 premiers caractères de la <xref:System.Diagnostics.EventLog.Log%2A> propriété avec l’extension de nom de fichier « .evt ».  
  
 Impossible de créer un nouveau journal à l’aide du <xref:System.Diagnostics.EventLog.Log%2A> propriété seule (sans spécifier de source pour le journal). Vous pouvez appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, en passant un nouveau nom de journal en tant que paramètre, puis appelez <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Toutefois, l’intention est généralement de créer (et écrire des entrées) nouveaux journaux spécifiques à l’application, ou à lire les journaux existants.  
  
 Si le <xref:System.Diagnostics.EventLog.Log%2A> valeur change, le journal des événements est fermé et tous les handles d’événement sont libérés.  
  
> [!CAUTION]
>  Si vous définissez la <xref:System.Diagnostics.EventLog.Log%2A> propriété le nom d’un journal qui n’existe pas, le système attache le <xref:System.Diagnostics.EventLog> dans le journal des applications, mais ne vous avertit pas qu’il utilise un journal autre que celui que vous avez spécifié.  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements, « NewEventLog », sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the event log's friendly name.</summary>
        <value>Nom qui représente le journal des événements dans l'observateur d'événements du système.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans Windows Vista et versions ultérieures, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité. Si vous exécutez Windows Vista ou version ultérieure en tant qu’utilisateur, vous obtenez un <xref:System.Security.SecurityException> lorsque vous essayez d’accéder au nom d’affichage pour un événement dans le journal de sécurité.  
>   
>  Dans Windows Vista et version ultérieure, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche le <xref:System.Diagnostics.EventLog.LogDisplayName%2A> pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <see cref="P:System.Diagnostics.EventLog.Log" /> does not exist in the registry for this computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour avoir la possibilité de lire la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">The name of the event source.</param>
        <param name="machineName">The name of the computer on which to look, or "." for the local computer.</param>
        <summary>Gets the name of the log to which the specified source is registered.</summary>
        <returns>The name of the log associated with the specified source in the registry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La source d’événements indique ce qui consigne l’événement. Il est souvent le nom de l’application ou le nom du sous-composant de l’application, si l’application est importante. Applications et services doivent écrire dans le journal des applications ou dans un journal personnalisé. Pilotes de périphérique doivent écrire dans le journal système.  
  
 Lorsque vous créez une nouvelle source, qui ne peut écrire dans un journal à la fois, le système inscrit votre application avec le journal des événements comme source valide d’entrées. Le <xref:System.Diagnostics.EventLog.Source%2A> propriété peut être n’importe quelle chaîne, mais le nom ne peut pas être utilisé par d’autres sources sur l’ordinateur. Une tentative pour créer un double <xref:System.Diagnostics.EventLog.Source%2A> valeur lève une exception. Toutefois, un seul journal des événements peut avoir de nombreuses sources différentes y écrire.  
  
   
  
## Examples  
 L’exemple suivant supprime une source de l’ordinateur local. L’exemple détermine le journal à partir de sa source, puis supprime le journal.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’aucune source de l’écriture dans ce journal.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the computer on which to read or write events.</summary>
        <value>Nom du serveur sur lequel le journal des événements réside. La valeur par défaut est l'ordinateur local (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous écrivez dans un journal des événements, vous devez associer un <xref:System.Diagnostics.EventLog.Source%2A> à votre objet de journal des événements pour le connecter à un journal particulier. Il n’est pas nécessaire de spécifier le <xref:System.Diagnostics.EventLog.Source%2A> propriété lors de la lecture à partir d’un journal. Vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> nom et <xref:System.Diagnostics.EventLog.MachineName%2A> (nom de l’ordinateur serveur).  
  
> [!NOTE]
>  Vous ne devez pas spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé.  
  
 Une source peut uniquement être inscrit dans un journal à la fois. Si le <xref:System.Diagnostics.EventLog.Source%2A> propriété a été définie pour une instance de <xref:System.Diagnostics.EventLog>, vous ne pouvez pas modifier le <xref:System.Diagnostics.EventLog.MachineName%2A> propriété qui <xref:System.Diagnostics.EventLog> sans modifier la valeur de <xref:System.Diagnostics.EventLog.Source%2A> ou en appelant <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> première. Si vous modifiez le <xref:System.Diagnostics.EventLog.MachineName%2A> propriété, le <xref:System.Diagnostics.EventLog> ferme tous les handles et se rattache au journal et à la source sur le nouvel ordinateur.  
  
 Le <xref:System.Diagnostics.EventLog.MachineName%2A> ne peut pas être une chaîne vide. Si elle n’est pas explicitement définie, la valeur par défaut sur l’ordinateur local («. »).  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements, « NewEventLog », sur un ordinateur spécifié.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The computer name is invalid.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum event log size in kilobytes.</summary>
        <value>Taille maximale du journal des événements en kilo-octets. La valeur par défaut est 512. Elle correspond à une taille de fichier maximale de 512 kilo-octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propriété représente la limite de taille du fichier journal des événements. Lorsque le journal des événements atteint la limite de taille configurée <xref:System.Diagnostics.EventLog.OverflowAction%2A> valeur détermine si les nouvelles entrées sont ignorées, ou si les nouvelles entrées remplacent les entrées plus anciennes.  
  
> [!NOTE]
>  Cette propriété représente un paramètre de configuration pour le journal des événements représenté par cette instance. Lorsque le journal des événements atteint sa taille maximale, cette propriété spécifie la façon dont le système d’exploitation gère les nouvelles entrées écrites par toutes les sources d’événements inscrits pour le journal des événements.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche les détails de configuration pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The specified value is less than 64, or greater than 4194240, or not an even multiple of 64.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.EventLog.Log" /> value is not a valid log name.  \- or -  The registry key for the event log could not be opened on the target computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of days to retain entries in the event log.</summary>
        <value>Durée de conservation en jours des entrées du journal des événements. La valeur par défaut est 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> propriété pour examiner le paramètre actuel d’un journal des événements. Utilisez <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> pour modifier le nombre minimal de jours pendant lesquels chaque entrée dans le journal des événements doit être conservée.  
  
 Le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeur varie selon le comportement de dépassement de capacité configuré du journal des événements. Si le <xref:System.Diagnostics.OverflowAction> pour un journal des événements est définie sur <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, puis le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeur est 0. Si le <xref:System.Diagnostics.OverflowAction> pour un journal des événements est définie sur <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, puis le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeur est -1. Si le <xref:System.Diagnostics.OverflowAction> pour un journal des événements est définie sur <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, puis le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeur est supérieure à zéro et représente le nombre de jours pendant lesquels conserver les entrées de journal des événements lorsque le journal des événements est plein.  
  
 Le comportement de dépassement de capacité se produit uniquement lorsqu’un journal des événements atteint sa limite de taille. Lorsqu’un <xref:System.Diagnostics.EventLog> a son <xref:System.Diagnostics.EventLog.OverflowAction%2A> la valeur <xref:System.Diagnostics.OverflowAction.OverwriteOlder>et le journal des événements atteint sa taille maximale, puis les nouvelles entrées sont écrites uniquement si elles peuvent remplacer des entrées dont âge dépasse le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> période. En conservant les entrées d’événements pendant une période minimale est appropriée lorsque le journal des événements est archivé régulièrement. Sinon, vous risquez de perdre des nouvelles entrées lorsque le journal des événements atteint sa limite. Pour éviter de perdre les nouvelles informations d’événement, définissez la période de conservation minimale des événements en fonction de votre planification d’archivage pour un journal des événements spécifique.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche les détails de configuration pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">The overflow behavior for writing new entries to the event log.</param>
        <param name="retentionDays">The minimum number of days each event log entry is retained. This parameter is used only if <c>action</c> is set to <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Changes the configured behavior for writing new entries when the event log reaches its maximum file size.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement de dépassement de capacité pour un journal des événements indique que se passe-t-il lorsque de nouvelles entrées doivent être écrites dans un journal qui a atteint sa taille maximale de fichier.  
  
> [!NOTE]
>  Le comportement de dépassement de capacité prend effet uniquement quand un journal des événements atteint sa taille maximale. Le comportement de dépassement de capacité n’affecte pas l’écriture d’une nouvelle entrée dans un journal qui peut prendre en charge les entrées de journal des événements supplémentaires.  
  
 Le <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> méthode configure le comportement de dépassement de capacité d’un journal des événements. <xref:System.Diagnostics.EventLog> instance. Après avoir appelé cette méthode pour le journal des événements spécifié par le <xref:System.Diagnostics.EventLog.Log%2A> propriété, le <xref:System.Diagnostics.EventLog.OverflowAction%2A> et <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeurs de propriété reflètent le comportement de dépassement de capacité qui vient d’être configuré.  
  
> [!NOTE]
>  Cette propriété représente un paramètre de configuration pour le journal des événements représenté par cette instance. Lorsque le journal des événements atteint sa taille maximale, cette propriété spécifie la façon dont le système d’exploitation gère les nouvelles entrées écrites par toutes les sources d’événements inscrits pour le journal des événements.  
  
 Définir le `action` paramètre <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> pour indiquer qu’une nouvelle entrée remplace l’entrée la plus ancienne lorsque le <xref:System.Diagnostics.EventLog> atteint sa taille maximale. Si le `action` paramètre est défini sur <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, le `retentionDays` la valeur du paramètre est ignorée.  
  
 Définir le `action` paramètre <xref:System.Diagnostics.OverflowAction.OverwriteOlder> pour indiquer que chaque nouvelle entrée remplace les entrées plus anciennes lorsque le <xref:System.Diagnostics.EventLog> atteint sa taille maximale. Spécifiez le nombre de jours pendant lesquels les événements doivent être conservés dans le journal à l’aide de le `retentionDays` paramètre. Les événements écrits dans la plage de rétention ne sont pas remplacées par les nouvelles entrées.  
  
 Définir le `action` paramètre <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> pour ignorer les nouveaux événements lorsque la taille maximale du journal est atteinte. Si le `action` paramètre est défini sur <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, le `retentionDays` la valeur du paramètre est ignorée.  
  
> [!CAUTION]
>  Définition de la stratégie de dépassement de capacité <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> Spécifie que les nouvelles entrées sont ignorées lorsque le journal des événements est plein. Si vous utilisez ce paramètre, vérifiez le journal des événements est régulièrement archivé et désactivé pour éviter d’atteindre sa limite de taille maximale.  
  
   
  
## Examples  
 L’exemple suivant affiche la stratégie de dépassement de capacité configuré d’un journal des événements spécifié et permet à l’utilisateur de sélectionner un nouveau paramètre de stratégie de dépassement de capacité pour le journal des événements.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> is not a valid <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> value.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> is less than one, or larger than 365.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.EventLog.Log" /> value is not a valid log name.  \- or -  The registry key for the event log could not be opened on the target computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the configured behavior for storing new entries when the event log reaches its maximum log file size.</summary>
        <value>Valeur <see cref="T:System.Diagnostics.OverflowAction" /> qui spécifie le comportement configuré pour le stockage des nouvelles entrées quand le journal des événements atteint sa taille maximale. La valeur par défaut est <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Journaux des événements croître lors de l’écriture pour les nouveaux événements. Chaque journal des événements a une limite de taille maximale configurée ; le <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propriété définit le nombre maximal de kilo-octets autorisé par la taille du fichier journal des événements.  
  
 Utilisez la <xref:System.Diagnostics.EventLog.OverflowAction%2A> valeur de propriété à examiner le comportement de dépassement de capacité configuré d’un journal des événements atteint sa taille maximale. Utilisez la <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> méthode pour modifier le comportement de dépassement de capacité d’un journal des événements.  
  
> [!NOTE]
>  Le comportement de dépassement de capacité prend effet uniquement quand un journal des événements atteint sa taille maximale. Le comportement de dépassement de capacité n’affecte pas l’écriture d’une nouvelle entrée dans un journal qui peut prendre en charge les entrées de journal des événements supplémentaires.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche les détails de configuration pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">The fully specified path to a localized resource file.</param>
        <param name="resourceId">The resource identifier that indexes a localized string within the resource file.</param>
        <summary>Specifies the localized name of the event log, which is displayed in the server Event Viewer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> pour enregistrer et afficher un nom localisé dans l’Observateur d’événements pour les journaux des événements personnalisés.  
  
 L’identificateur de ressource spécifié doit correspondre à une chaîne localisée définie dans le fichier de ressources. L’Observateur d’événements affiche le nom de journal des événements personnalisé à l’aide de la chaîne localisée et les paramètres de culture actuels. Par exemple, vous pouvez définir plusieurs noms de journal des événements localisées pour différentes cultures dans votre fichier de ressources. L’Observateur d’événements affiche la chaîne localisée correspondant aux paramètres de culture de l’utilisateur actuel.  
  
 Si l’Observateur d’événements ne peut pas charger la chaîne localisée du fichier de ressources, ou si aucun nom complet n’a été enregistré pour le journal des événements, l’Observateur d’événements affiche le nom du journal des événements définis dans <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Vous n’avez pas besoin d’inscrire un nom d’affichage pour les journaux des événements prédéfinis. Le système d’exploitation enregistre les noms complets localisés pour les journaux des événements Application, système et sécurité.  
  
   
  
## Examples  
 L’exemple suivant détermine si la source d’événements nommé `SampleApplicationSource` est enregistré sur l’ordinateur local. Si la source d’événements n’existe pas, l’exemple définit le fichier de ressources pour la source de message et crée la nouvelle source d’événements. Enfin, l’exemple définit le nom complet localisé du journal des événements, à l’aide de la valeur d’identificateur de ressource dans `DisplayNameMsgId` et le chemin d’accès du fichier de ressources dans `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 L’exemple utilise le fichier texte du message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir de laquelle le fichier de ressource de message est créé. Le fichier texte de message définit les identificateurs de ressources et le texte de la catégorie, message d’événement et les chaînes d’insertion de paramètre. Plus précisément, l’identificateur de ressource 5001 est défini pour le nom localisé du journal des événements.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.EventLog.Log" /> value is not a valid log name.  \- or -  The registry key for the event log could not be opened on the target computer.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the source name to register and use when writing to the event log.</summary>
        <value>Nom inscrit avec le journal des événements comme source des entrées. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La source d’événements indique ce qui consigne l’événement. Il est souvent le nom de l’application ou le nom du sous-composant de l’application, si l’application est importante. Applications et services doivent écrire dans le journal des applications ou dans un journal personnalisé. Pilotes de périphérique doivent écrire dans le journal système.  
  
 Vous devez uniquement spécifier une source d’événements si vous écrivez dans un journal des événements. Avant d’écrire une entrée dans un journal des événements, vous devez inscrire la source d’événements avec le journal des événements comme source valide d’événements. Lorsque vous écrivez une entrée de journal, le système utilise le <xref:System.Diagnostics.EventLog.Source%2A> propriété à rechercher le journal approprié dans lequel placer votre entrée. Si vous lisez le journal des événements, vous pouvez spécifier le <xref:System.Diagnostics.EventLog.Source%2A>, ou un <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Vous n’êtes pas obligé de spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal sur l’ordinateur local. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé.  
  
 Utilisez <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Vous pouvez créer une source d’événements pour un journal des événements existant ou un journal des événements. Lorsque vous créez une nouvelle source pour un journal des événements, le système inscrit la source de ce journal, mais le journal n’est pas créé tant que l’écriture de la première entrée.  
  
 La source doit être unique sur l’ordinateur local ; un nouveau nom de la source ne peut pas correspondre à un nom de source existant ou un nom de journal des événements existant. Chaque source peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter des sources multiples configurées pour des journaux des événements ou des fichiers de ressources différents.  
  
 Si vous modifiez le <xref:System.Diagnostics.EventLog.Source%2A> valeur, le <xref:System.Diagnostics.EventLog> pour lequel elle est inscrite est fermée et tous les handles d’événement sont libérés.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis de le créer avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créer une nouvelle source avec la configuration mise à jour, plutôt que de supprimer la source existante.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications prennent effet.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The source name results in a registry key path longer than 254 characters.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Searches a computer's registry for a given event source.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">The name of the event source.</param>
        <summary>Determines whether an event source is registered on the local computer.</summary>
        <returns>
          <see langword="true" /> if the event source is registered on the local computer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer si une source d’événements existe sur l’ordinateur local. Si vous souhaitez déterminer si un journal existe sur l’ordinateur local, utilisez <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Étant donné que cette méthode accède au Registre, vous devez disposer des autorisations de Registre appropriées sur l’ordinateur local ; Sinon, un <xref:System.Security.SecurityException> sera levée.  
  
> [!NOTE]
>  Pour rechercher une source d’événements dans Windows Vista et versions ultérieures ou de Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  À compter de Windows Vista, le contrôle de compte d’utilisateur (UAC) détermine les privilèges d’un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez tout d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
> [!NOTE]
>  Un service qui s’exécute sous le <xref:System.ServiceProcess.ServiceAccount.LocalSystem> compte ne dispose pas des privilèges requis pour exécuter cette méthode. La solution consiste à vérifier l’existence de la source d’événements dans le <xref:System.ServiceProcess.ServiceInstaller>, et si elle n’existe pas, pour créer la source dans le programme d’installation.  
  
 Étant donné que vous ne pouvez pas donner une nouvelle source le nom d’une source existante sur le même ordinateur, utilisez cette méthode avant d’essayer d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour vérifier qu’une source avec le nom spécifié par `source` n’existe pas déjà sur l’ordinateur local. Le `source` paramètre n’est pas sensible à la casse.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> was not found, but some or all of the event logs could not be searched.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">The name of the event source.</param>
        <param name="machineName">The name the computer on which to look, or "." for the local computer.</param>
        <summary>Determines whether an event source is registered on a specified computer.</summary>
        <returns>
          <see langword="true" /> if the event source is registered on the given computer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer si une source d’événements existe sur l’ordinateur spécifié par le `machineName` paramètre. Si vous souhaitez déterminer si un journal existe sur l’ordinateur spécifié, utilisez <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Car cette méthode accède au Registre, vous devez disposer des autorisations de Registre appropriées sur le serveur donné ; Sinon, un <xref:System.Security.SecurityException> sera levée.  
  
> [!NOTE]
>  Pour rechercher une source d’événements dans Windows Vista et versions ultérieures ou de Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  À compter de Windows Vista, le contrôle de compte d’utilisateur (UAC) détermine les privilèges d’un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez tout d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
> [!NOTE]
>  Un service qui s’exécute sous le <xref:System.ServiceProcess.ServiceAccount.LocalSystem> compte ne dispose pas des privilèges requis pour exécuter cette méthode. La solution consiste à vérifier l’existence de la source d’événements dans le <xref:System.ServiceProcess.ServiceInstaller>, et si elle n’existe pas, pour créer la source dans le programme d’installation.  
  
 Étant donné que vous ne pouvez pas donner une nouvelle source le nom d’une source existante sur le même ordinateur, utilisez cette méthode avant d’essayer d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour vérifier qu’une source avec le nom spécifié par `source` n’existe pas déjà sur l’ordinateur. Le `source` et `machineName` paramètres ne respectent pas la casse.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> est un `static` (méthode), elle peut donc être appelée sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` sur l’ordinateur `MyServer`et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> is an invalid computer name.</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> was not found, but some or all of the event logs could not be searched.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal the event handler calls issued as a result of an <see cref="T:System.Diagnostics.EventLog" /> entry written event.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> utilisé pour marshaler des appels du gestionnaire d'événements émis à la suite d'un événement <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> dans le journal des événements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> est `null`, méthodes qui gèrent la <xref:System.Diagnostics.EventLog.EntryWritten> événement sont appelées sur un thread du pool de threads système. Pour plus d’informations sur les pools de threads système, consultez <xref:System.Threading.ThreadPool>.  
  
 Lorsque le <xref:System.Diagnostics.EventLog.EntryWritten> événement est géré par un Windows Forms visual composant, tel qu’un bouton, l’accès au composant via le pool de threads système peut ne pas fonctionne ou résulter en une exception. Éviter ce problème en définissant <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> à un composant Windows Forms, ce qui entraîne les méthodes qui gèrent la <xref:System.Diagnostics.EventLog.EntryWritten> événement à être appelé sur le même thread que celui sur lequel le composant a été créé.  
  
 Si le <xref:System.Diagnostics.EventLog> est utilisé à l’intérieur de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] dans un concepteur Windows Forms, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> est automatiquement défini sur le contrôle contenant le <xref:System.Diagnostics.EventLog>. Par exemple, si vous placez un <xref:System.Diagnostics.EventLog> sur un concepteur pour Form1 (qui hérite de <xref:System.Windows.Forms.Form>) le <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> propriété du <xref:System.Diagnostics.EventLog> est définie sur l’instance de Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes an entry in the event log.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">The string to write to the event log.</param>
        <summary>Writes an information type entry, with the given message text, to the event log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée d’informations dans le journal des événements associé à cet <xref:System.Diagnostics.EventLog> instance. Si vous souhaitez spécifier n’importe quel autre <xref:System.Diagnostics.EventLogEntryType>, utilisez une autre surcharge de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appelle <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> avant d’appeler l’instance <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  La plupart des exceptions répertoriées ci-dessus sont générés par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) ne peut pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Diagnostics.EventLog.Source" /> property of the <see cref="T:System.Diagnostics.EventLog" /> has not been set.  -or-  The method attempted to register a new event source, but the computer name in <see cref="P:System.Diagnostics.EventLog.MachineName" /> is not valid.  \- or -  The source is already registered for a different event log.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">The string to write to the event log.</param>
        <param name="type">One of the <see cref="T:System.Diagnostics.EventLogEntryType" /> values.</param>
        <summary>Writes an error, warning, information, success audit, or failure audit entry with the given message text to the event log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée d’un <xref:System.Diagnostics.EventLogEntryType> au journal des événements. Le `type` est indiqué par une icône et le texte de la colonne de Type dans l’Observateur d’événements pour un journal.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appelle <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> avant d’appeler l’instance <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  De nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) ne peut pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée d’avertissement dans un journal des événements, « MyNewLog », sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Diagnostics.EventLog.Source" /> property of the <see cref="T:System.Diagnostics.EventLog" /> has not been set.  -or-  The method attempted to register a new event source, but the computer name in <see cref="P:System.Diagnostics.EventLog.MachineName" /> is not valid.  \- or -  The source is already registered for a different event log.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> is not a valid <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">The source by which the application is registered on the specified computer.</param>
        <param name="message">The string to write to the event log.</param>
        <summary>Writes an information type entry with the given message text to the event log, using the specified registered event source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée d’informations dans le journal des événements, à l’aide d’une source qui est déjà inscrite comme source d’événements pour le journal approprié. Si vous souhaitez spécifier n’importe quel autre <xref:System.Diagnostics.EventLogEntryType>, utilisez une autre surcharge de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
>   
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="source" /> value is an empty string ("").  \- or -  The <paramref name="source" /> value is <see langword="null" />.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">The string to write to the event log.</param>
        <param name="type">One of the <see cref="T:System.Diagnostics.EventLogEntryType" /> values.</param>
        <param name="eventID">The application-specific identifier for the event.</param>
        <summary>Writes an entry with the given message text and application-defined event identifier to the event log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée avec un définies par l’application `eventID` dans le journal des événements. Le `eventID` ainsi que la source identifient un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description à laquelle ils sont mappés. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et suggérer les mesures à prendre.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
 En plus de l’identificateur d’événement, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et le texte de la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, d’audit des succès ou audit des échecs.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appelle <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> avant d’appeler l’instance <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  De nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) ne peut pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Diagnostics.EventLog.Source" /> property of the <see cref="T:System.Diagnostics.EventLog" /> has not been set.  -or-  The method attempted to register a new event source, but the computer name in <see cref="P:System.Diagnostics.EventLog.MachineName" /> is not valid.  \- or -  The source is already registered for a different event log.  \- or -  <paramref name="eventID" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> is not a valid <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">The source by which the application is registered on the specified computer.</param>
        <param name="message">The string to write to the event log.</param>
        <param name="type">One of the <see cref="T:System.Diagnostics.EventLogEntryType" /> values.</param>
        <summary>Writes an error, warning, information, success audit, or failure audit entry with the given message text to the event log, using the specified registered event source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée d’un <xref:System.Diagnostics.EventLogEntryType> dans le journal des événements à l’aide d’une source déjà inscrite comme source d’événements pour le journal approprié. Le `type` est indiqué par une icône et le texte de la colonne de Type dans l’Observateur d’événements pour un journal.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée d’avertissement dans un journal des événements, « MyNewLog », sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="source" /> value is an empty string ("").  \- or -  The <paramref name="source" /> value is <see langword="null" />.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> is not a valid <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">The string to write to the event log.</param>
        <param name="type">One of the <see cref="T:System.Diagnostics.EventLogEntryType" /> values.</param>
        <param name="eventID">The application-specific identifier for the event.</param>
        <param name="category">The application-specific subcategory associated with the message.</param>
        <summary>Writes an entry with the given message text, application-defined event identifier, and application-defined category to the event log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée avec un définies par l’application `category` dans le journal des événements. L’Observateur d’événements utilise la catégorie pour filtrer les événements écrits par une source d’événement. L’Observateur d’événements peut afficher la catégorie en tant que valeur numérique, ou utiliser la catégorie comme identificateur de ressource pour afficher une chaîne de catégorie localisée.  
  
> [!NOTE]
>  Le `category` paramètre doit être une valeur positive. Valeurs de catégorie négatives apparaissent sous la forme d’un nombre positif complémentaire dans l’événement visionneuse. Par exemple, -10 s’affiche sous la forme 65 526 et, une valeur -1 à 65 535.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
 Pour afficher les chaînes de catégorie localisée dans l’Observateur d’événements, vous devez utiliser une source d’événement configuré avec un fichier de ressources de catégorie et définir le `category` à un identificateur de ressource dans le fichier de ressources de catégorie. Si la source d’événements n’a pas un fichier de ressources de catégorie configuré ou spécifié `category` n’indexe pas une chaîne dans le fichier de ressources de catégorie, puis l’Observateur d’événements affiche la valeur de catégorie numérique pour cette entrée. Configurer le fichier de ressources de catégorie, ainsi que le nombre de chaînes de catégorie dans le fichier de ressources, à l’aide de la <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 En plus de la catégorie, vous pouvez spécifier un identificateur d’événement pour l’événement en cours d’écriture dans le journal des événements. Les identificateurs d’événements, ainsi que la source d’événements, identifient de manière unique un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description à laquelle ils sont mappés. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et suggérer les mesures à prendre.  
  
 Enfin, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et le texte de la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, d’audit des succès ou audit des échecs.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appelle <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> avant d’appeler l’instance <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  De nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) ne peut pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Diagnostics.EventLog.Source" /> property of the <see cref="T:System.Diagnostics.EventLog" /> has not been set.  -or-  The method attempted to register a new event source, but the computer name in <see cref="P:System.Diagnostics.EventLog.MachineName" /> is not valid.  \- or -  The source is already registered for a different event log.  \- or -  <paramref name="eventID" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> is not a valid <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">The source by which the application is registered on the specified computer.</param>
        <param name="message">The string to write to the event log.</param>
        <param name="type">One of the <see cref="T:System.Diagnostics.EventLogEntryType" /> values.</param>
        <param name="eventID">The application-specific identifier for the event.</param>
        <summary>Writes an entry with the given message text and application-defined event identifier to the event log, using the specified registered event source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée avec un définies par l’application `eventID` dans le journal des événements à l’aide d’une source déjà inscrite comme source d’événements pour le journal approprié. Le `eventID`, ainsi que la source, identifient un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description à laquelle ils sont mappés. Observateurs d’événements affiche ces chaînes à l’utilisateur pour aider l’utilisateur à comprendre la cause du problème et suggérer les mesures à prendre.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
 En plus de l’identificateur d’événement, cette surcharge de <xref:System.Diagnostics.EventLog.WriteEntry%2A> vous permet de spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et le texte de la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, d’audit des succès ou audit des échecs.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="source" /> value is an empty string ("").  \- or -  The <paramref name="source" /> value is <see langword="null" />.  \- or -  <paramref name="eventID" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> is not a valid <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">The string to write to the event log.</param>
        <param name="type">One of the <see cref="T:System.Diagnostics.EventLogEntryType" /> values.</param>
        <param name="eventID">The application-specific identifier for the event.</param>
        <param name="category">The application-specific subcategory associated with the message.</param>
        <param name="rawData">An array of bytes that holds the binary data associated with the entry.</param>
        <summary>Writes an entry with the given message text, application-defined event identifier, and application-defined category to the event log, and appends binary data to the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour écrire des données de spécifiques à l’événement défini par l’application dans le journal des événements. L’Observateur d’événements n’interprète pas ces données ; Il affiche les données brutes uniquement dans un format combiné hexadécimal et texte. Utiliser avec parcimonie les données spécifiques à l’événement en incluant uniquement si vous êtes sûr qu’il sera utile à une personne déboguer le problème. Vous pouvez également utiliser des données spécifiques à l’événement pour stocker les informations de que l’application peut traiter indépendamment de l’Observateur d’événements. Par exemple, vous pourriez écrire une visionneuse spécifique pour vos événements ou écrire un programme qui analyse le fichier journal et crée des rapports qui incluent des informations à partir des données spécifiques à l’événement.  
  
 En plus des données binaires, vous pouvez spécifier une catégorie définie par l’application et un identificateur d’événement défini par l’application. L’Observateur d’événements utilise la catégorie pour filtrer les événements écrits par une source d’événement. L’Observateur d’événements peut afficher la catégorie en tant que valeur numérique, ou utiliser la catégorie comme identificateur de ressource pour afficher une chaîne de catégorie localisée.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
> [!NOTE]
>  Le `category` paramètre doit être une valeur positive. Valeurs de catégorie négatives apparaissent sous la forme d’un nombre positif complémentaire dans l’événement visionneuse. Par exemple, -10 s’affiche sous la forme 65 526 et, une valeur -1 à 65 535.  
  
 Pour afficher les chaînes de catégorie localisée dans l’Observateur d’événements, vous devez utiliser une source d’événement configuré avec un fichier de ressources de catégorie et définir le `category` à un identificateur de ressource dans le fichier de ressources de catégorie. Si la source d’événements n’a pas un fichier de ressources de catégorie configuré ou spécifié `category` n’indexe pas une chaîne dans le fichier de ressources de catégorie, puis l’Observateur d’événements affiche la valeur de catégorie numérique pour cette entrée. Configurer le fichier de ressources de catégorie, ainsi que le nombre de chaînes de catégorie dans le fichier de ressources, à l’aide de la <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Les identificateurs d’événements, ainsi que la source d’événements, identifient de manière unique un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description à laquelle ils sont mappés. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et suggérer les mesures à prendre.  
  
 Enfin, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et le texte de la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, d’audit des succès ou audit des échecs.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source.  
  
 Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appelle <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> avant d’appeler l’instance <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  De nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) ne peut pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Diagnostics.EventLog.Source" /> property of the <see cref="T:System.Diagnostics.EventLog" /> has not been set.  -or-  The method attempted to register a new event source, but the computer name in <see cref="P:System.Diagnostics.EventLog.MachineName" /> is not valid.  \- or -  The source is already registered for a different event log.  \- or -  <paramref name="eventID" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> is not a valid <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">The source by which the application is registered on the specified computer.</param>
        <param name="message">The string to write to the event log.</param>
        <param name="type">One of the <see cref="T:System.Diagnostics.EventLogEntryType" /> values.</param>
        <param name="eventID">The application-specific identifier for the event.</param>
        <param name="category">The application-specific subcategory associated with the message.</param>
        <summary>Writes an entry with the given message text, application-defined event identifier, and application-defined category to the event log, using the specified registered event source. The <paramref name="category" /> can be used by the Event Viewer to filter events in the log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée avec un définies par l’application `category` dans le journal des événements, à l’aide d’une source qui est déjà inscrite comme source d’événements pour le journal approprié. L’Observateur d’événements utilise la catégorie pour filtrer les événements écrits par une source d’événement. L’Observateur d’événements peut afficher la catégorie en tant que valeur numérique, ou utiliser la catégorie comme identificateur de ressource pour afficher une chaîne de catégorie localisée.  
  
> [!NOTE]
>  Le `category` paramètre doit être une valeur positive. Valeurs de catégorie négatives apparaissent sous la forme d’un nombre positif complémentaire dans l’événement visionneuse. Par exemple, -10 s’affiche sous la forme 65 526 et, une valeur -1 à 65 535.  
  
 Pour afficher les chaînes de catégorie localisée dans l’Observateur d’événements, vous devez utiliser une source d’événement configuré avec un fichier de ressources de catégorie et définir le `category` à un identificateur de ressource dans le fichier de ressources de catégorie. Si la source d’événements n’a pas un fichier de ressources de catégorie configuré ou spécifié `category` n’indexe pas une chaîne dans le fichier de ressources de catégorie, puis l’Observateur d’événements affiche la valeur de catégorie numérique pour cette entrée. Configurer le fichier de ressources de catégorie, ainsi que le nombre de chaînes de catégorie dans le fichier de ressources, à l’aide de la <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 En plus de la catégorie, vous pouvez spécifier un identificateur d’événement pour l’événement en cours d’écriture dans le journal des événements. Les identificateurs d’événements, ainsi que la source d’événements, identifient de manière unique un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description à laquelle ils sont mappés. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et suggérer les mesures à prendre.  
  
 Enfin, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et le texte de la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, d’audit des succès ou audit des échecs.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
>   
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="source" /> value is an empty string ("").  \- or -  The <paramref name="source" /> value is <see langword="null" />.  \- or -  <paramref name="eventID" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> is not a valid <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">The source by which the application is registered on the specified computer.</param>
        <param name="message">The string to write to the event log.</param>
        <param name="type">One of the <see cref="T:System.Diagnostics.EventLogEntryType" /> values.</param>
        <param name="eventID">The application-specific identifier for the event.</param>
        <param name="category">The application-specific subcategory associated with the message.</param>
        <param name="rawData">An array of bytes that holds the binary data associated with the entry.</param>
        <summary>Writes an entry with the given message text, application-defined event identifier, and application-defined category to the event log (using the specified registered event source) and appends binary data to the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire des données de spécifiques à l’événement défini par l’application dans le journal des événements, à l’aide d’une source déjà inscrite en tant que source d’événements pour le journal approprié. L’Observateur d’événements n’interprète pas ces données ; Il affiche les données brutes uniquement dans un format combiné hexadécimal et texte. Utiliser des données spécifiques à l’événement. inclure uniquement si vous êtes sûr qu’il sera utile. Vous pouvez également utiliser des données spécifiques à l’événement pour stocker les informations de que l’application peut traiter indépendamment de l’Observateur d’événements. Par exemple, vous pourriez écrire une visionneuse spécifique pour vos événements ou écrire un programme qui analyse le fichier journal et crée des rapports qui incluent des informations à partir des données spécifiques à l’événement.  
  
 En plus des données binaires, vous pouvez spécifier une catégorie définie par l’application et un identificateur d’événement défini par l’application. L’Observateur d’événements utilise la catégorie pour filtrer les événements écrits par une source d’événement. L’Observateur d’événements peut afficher la catégorie en tant que valeur numérique, ou utiliser la catégorie comme identificateur de ressource pour afficher une chaîne de catégorie localisée.  
  
> [!NOTE]
>  Le `category` paramètre doit être une valeur positive. Valeurs de catégorie négatives apparaissent sous la forme d’un nombre positif complémentaire dans l’événement visionneuse. Par exemple, -10 s’affiche sous la forme 65 526 et, une valeur -1 à 65 535.  
  
 Pour afficher les chaînes de catégorie localisée dans l’Observateur d’événements, vous devez utiliser une source d’événement configuré avec un fichier de ressources de catégorie et définir le `category` à un identificateur de ressource dans le fichier de ressources de catégorie. Si la source d’événements n’a pas un fichier de ressources de catégorie configuré ou spécifié `category` n’indexe pas une chaîne dans le fichier de ressources de catégorie, puis l’Observateur d’événements affiche la valeur de catégorie numérique pour cette entrée. Configurer le fichier de ressources de catégorie, ainsi que le nombre de chaînes de catégorie dans le fichier de ressources, à l’aide de la <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Les identificateurs d’événements, ainsi que la source d’événements, identifient de manière unique un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description à laquelle ils sont mappés. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et suggérer les mesures à prendre.  
  
 Enfin, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et le texte de la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, d’audit des succès ou audit des échecs.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
>   
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="source" /> value is an empty string ("").  \- or -  The <paramref name="source" /> value is <see langword="null" />.  \- or -  <paramref name="eventID" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> is not a valid <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes a localized event entry to the event log.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">An <see cref="T:System.Diagnostics.EventInstance" /> instance that represents a localized event log entry.</param>
        <param name="values">An array of strings to merge into the message text of the event log entry.</param>
        <summary>Writes a localized entry to the event log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée localisée dans le journal des événements. Vous spécifiez les propriétés d’événement avec les identificateurs de ressources au lieu des valeurs de chaîne. L’Observateur d’événements utilise les identificateurs de ressource pour afficher les chaînes correspondants à partir du fichier de ressources localisé pour le <xref:System.Diagnostics.EventLog.Source%2A>. Vous devez inscrire la source avec le fichier de ressources correspondant avant d’écrire des événements à l’aide d’identificateurs de ressources.  
  
 L’entrée `instance` instance spécifie les propriétés et le message d’événement. Définir le <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` d’entrée pour le message défini dans le fichier de ressources du message source. Vous pouvez éventuellement définir le <xref:System.Diagnostics.EventInstance.CategoryId%2A> et <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrée pour définir le type de catégorie et les événements de votre entrée d’événement. Vous pouvez également spécifier un tableau de chaînes indépendant du langage à insérer dans le texte du message localisé. Définissez `values` à `null` si le message d’événement ne contient pas de mise en forme des espaces réservés pour les chaînes de remplacement.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant d’utiliser <xref:System.Diagnostics.EventLog.WriteEvent%2A>. La source spécifiée doit être configurée pour écrire des entrées localisées dans le journal ; la source doit au moins avoir un fichier de ressources de message défini.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Utilisez la <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode si votre application écrit les valeurs de chaîne directement dans le journal des événements.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur de la `message` chaîne ne peut pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework. En outre, le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
   
  
## Examples  
 L’exemple suivant écrit deux entrées d’audit dans le journal des événements `myNewLog`. L’exemple crée une nouvelle source d’événement et un journal des événements s’ils n’existent pas sur l’ordinateur local. Le texte de message d’événement est spécifié à l’aide d’un identificateur de ressource dans un fichier de ressources.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 L’exemple utilise le fichier texte du message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir de laquelle le fichier de ressource de message est créé. Le fichier texte de message définit les identificateurs de ressources et le texte de la catégorie, message d’événement et les chaînes d’insertion de paramètre.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Diagnostics.EventLog.Source" /> property of the <see cref="T:System.Diagnostics.EventLog" /> has not been set.  -or-  The method attempted to register a new event source, but the computer name in <see cref="P:System.Diagnostics.EventLog.MachineName" /> is not valid.  \- or -  The source is already registered for a different event log.  \- or -  <paramref name="instance.InstanceId" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  <paramref name="values" /> has more than 256 elements.  \- or -  One of the <paramref name="values" /> elements is longer than 32766 bytes.  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">An <see cref="T:System.Diagnostics.EventInstance" /> instance that represents a localized event log entry.</param>
        <param name="data">An array of bytes that holds the binary data associated with the entry.</param>
        <param name="values">An array of strings to merge into the message text of the event log entry.</param>
        <summary>Writes an event log entry with the given event data, message replacement strings, and associated binary data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée localisée avec d’autres données spécifiques à l’événement dans le journal des événements. Vous spécifiez les propriétés d’événement avec les identificateurs de ressources au lieu des valeurs de chaîne. L’Observateur d’événements utilise les identificateurs de ressource pour afficher les chaînes correspondants à partir du fichier de ressources localisé pour le <xref:System.Diagnostics.EventLog.Source%2A>. Vous devez inscrire la source avec le fichier de ressources correspondant avant d’écrire des événements à l’aide d’identificateurs de ressources.  
  
 L’entrée `instance` instance spécifie les propriétés et le message d’événement. Définir le <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` d’entrée pour le message défini dans le fichier de ressources du message source. Vous pouvez éventuellement définir le <xref:System.Diagnostics.EventInstance.CategoryId%2A> et <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrée pour définir le type de catégorie et les événements de votre entrée d’événement. Vous pouvez également spécifier un tableau de chaînes indépendant du langage à insérer dans le texte du message localisé. Définissez `values` à `null` si le message d’événement ne contient pas de mise en forme des espaces réservés pour les chaînes de remplacement.  
  
 Spécifiez les données binaires avec un événement lorsqu’il est nécessaire de fournir des détails supplémentaires pour l’événement. Par exemple, utiliser le `data` paramètre pour inclure des informations sur une erreur spécifique. L’Observateur d’événements n’interprète pas les données d’événement associées ; Il affiche les données dans un format combiné hexadécimal et texte. Utiliser des données spécifiques à l’événement. inclure uniquement si vous êtes sûr qu’il sera utile. Vous pouvez également utiliser des données spécifiques à l’événement pour stocker les informations de que l’application peut traiter indépendamment de l’Observateur d’événements. Par exemple, vous pourriez écrire une visionneuse spécifique pour vos événements ou écrire un programme qui analyse le journal des événements et crée des rapports qui incluent des informations à partir des données spécifiques à l’événement.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant le composant avant d’utiliser <xref:System.Diagnostics.EventLog.WriteEvent%2A>. La source spécifiée doit être configurée pour écrire des entrées localisées dans le journal ; la source doit au moins avoir un fichier de ressources de message défini.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> avant d’appeler l’instance <xref:System.Diagnostics.EventLog.WriteEvent%2A>, l’ordinateur local («. ») est supposé.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Utilisez la <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode si votre application écrit les valeurs de chaîne directement dans le journal des événements.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur de la `message` chaîne ne peut pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework. En outre, le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Étant donné que le protocole d’Internet, version 6 (IPv6) adresse peut contenir cette séquence de caractères, un message d’événement qui contient une adresse IPv6 ne peut pas se connecter.  
  
   
  
## Examples  
 L’exemple suivant écrit deux entrées d’audit dans le journal des événements `myNewLog`. L’exemple crée une nouvelle source d’événement et un journal des événements s’ils n’existent pas sur l’ordinateur local. Le texte de message d’événement est spécifié à l’aide d’un identificateur de ressource dans un fichier de ressources.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 L’exemple utilise le fichier texte du message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir de laquelle le fichier de ressource de message est créé. Le fichier texte de message définit les identificateurs de ressources et le texte de la catégorie, message d’événement et les chaînes d’insertion de paramètre.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Diagnostics.EventLog.Source" /> property of the <see cref="T:System.Diagnostics.EventLog" /> has not been set.  -or-  The method attempted to register a new event source, but the computer name in <see cref="P:System.Diagnostics.EventLog.MachineName" /> is not valid.  \- or -  The source is already registered for a different event log.  \- or -  <paramref name="instance.InstanceId" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  <paramref name="values" /> has more than 256 elements.  \- or -  One of the <paramref name="values" /> elements is longer than 32766 bytes.  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">The name of the event source registered for the application on the specified computer.</param>
        <param name="instance">An <see cref="T:System.Diagnostics.EventInstance" /> instance that represents a localized event log entry.</param>
        <param name="values">An array of strings to merge into the message text of the event log entry.</param>
        <summary>Writes an event log entry with the given event data and message replacement strings, using the specified registered event source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée localisée dans le journal des événements à l’aide d’une source déjà inscrite en tant que source d’événements pour le journal approprié. Vous spécifiez les propriétés d’événement avec les identificateurs de ressources au lieu des valeurs de chaîne. L’Observateur d’événements utilise les identificateurs de ressource pour afficher les chaînes correspondants à partir du fichier de ressources localisé pour la source. Vous devez inscrire la source avec le fichier de ressources correspondant avant d’écrire des événements à l’aide d’identificateurs de ressources.  
  
 L’entrée `instance` instance spécifie les propriétés et le message d’événement. Définir le <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` d’entrée pour le message défini dans le fichier de ressources du message source. Vous pouvez éventuellement définir le <xref:System.Diagnostics.EventInstance.CategoryId%2A> et <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrée pour définir le type de catégorie et les événements de votre entrée d’événement. Vous pouvez également spécifier un tableau de chaînes indépendant du langage à insérer dans le texte du message localisé. Définissez `values` à `null` si le message d’événement ne contient pas de mise en forme des espaces réservés pour les chaînes de remplacement.  
  
 La source spécifiée doit être enregistrée pour un journal des événements avant d’utiliser <xref:System.Diagnostics.EventLog.WriteEvent%2A>. La source spécifiée doit être configurée pour écrire des entrées localisées dans le journal ; la source doit au moins avoir un fichier de ressources de message défini.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Utilisez la <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode si votre application écrit les valeurs de chaîne directement dans le journal des événements.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée d’événement d’information et d’une entrée d’événement avertissement dans un journal des événements existant. Le texte de message d’événement est spécifié à l’aide d’un identificateur de ressource dans un fichier de ressources. L’exemple suppose que le fichier de ressources correspondant a été enregistré pour la source.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 L’exemple utilise le fichier texte du message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir de laquelle le fichier de ressource de message est créé. Le fichier texte de message définit les identificateurs de ressources et le texte de la catégorie, message d’événement et les chaînes d’insertion de paramètre.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="source" /> value is an empty string ("").  \- or -  The <paramref name="source" /> value is <see langword="null" />.  \- or -  <paramref name="instance.InstanceId" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  <paramref name="values" /> has more than 256 elements.  \- or -  One of the <paramref name="values" /> elements is longer than 32766 bytes.  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">The name of the event source registered for the application on the specified computer.</param>
        <param name="instance">An <see cref="T:System.Diagnostics.EventInstance" /> instance that represents a localized event log entry.</param>
        <param name="data">An array of bytes that holds the binary data associated with the entry.</param>
        <param name="values">An array of strings to merge into the message text of the event log entry.</param>
        <summary>Writes an event log entry with the given event data, message replacement strings, and associated binary data, and using the specified registered event source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée localisée avec d’autres données spécifiques à l’événement dans le journal des événements, à l’aide d’une source déjà inscrite en tant que source d’événements pour le journal approprié. Vous spécifiez les propriétés d’événement avec les identificateurs de ressources au lieu des valeurs de chaîne. L’Observateur d’événements utilise les identificateurs de ressource pour afficher les chaînes correspondants à partir du fichier de ressources localisé pour la source. Vous devez inscrire la source avec le fichier de ressources correspondant avant d’écrire des événements à l’aide d’identificateurs de ressources.  
  
 L’entrée `instance` instance spécifie les propriétés et le message d’événement. Définir le <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` d’entrée pour le message défini dans le fichier de ressources du message source. Vous pouvez éventuellement définir le <xref:System.Diagnostics.EventInstance.CategoryId%2A> et <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrée pour définir le type de catégorie et les événements de votre entrée d’événement. Vous pouvez également spécifier un tableau de chaînes indépendant du langage à insérer dans le texte du message localisé. Définissez `values` à `null` si le message d’événement ne contient pas de mise en forme des espaces réservés pour les chaînes de remplacement.  
  
 Spécifiez les données binaires avec un événement lorsqu’il est nécessaire de fournir des détails supplémentaires pour l’événement. Par exemple, utiliser le `data` paramètre pour inclure des informations sur une erreur spécifique. L’Observateur d’événements n’interprète pas les données d’événement associées ; Il affiche les données dans un format combiné hexadécimal et texte. Utiliser des données spécifiques à l’événement. inclure uniquement si vous êtes sûr qu’il sera utile. Vous pouvez également utiliser des données spécifiques à l’événement pour stocker les informations de que l’application peut traiter indépendamment de l’Observateur d’événements. Par exemple, vous pourriez écrire une visionneuse spécifique pour vos événements ou écrire un programme qui analyse le journal des événements et crée des rapports qui incluent des informations à partir des données spécifiques à l’événement.  
  
 La source spécifiée doit être enregistrée pour un journal des événements avant d’utiliser <xref:System.Diagnostics.EventLog.WriteEvent%2A>. La source spécifiée doit être configurée pour écrire des entrées localisées dans le journal ; la source doit au moins avoir un fichier de ressources de message défini.  
  
 Vous devez créer et configurer la source d’événements avant d’écrire la première entrée avec la source. Créer la source d’événements pendant l’installation de votre application. Ainsi, le temps nécessaire au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou l’écriture de chaînes directes. Utilisez la <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode si votre application écrit les valeurs de chaîne directement dans le journal des événements.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressources et les valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source des fichiers de ressources, puis utilisez cette source dans la <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Créez une autre source, sans fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée d’événement d’information et d’une entrée d’événement avertissement dans un journal des événements existant. Le texte de message d’événement est spécifié à l’aide d’un identificateur de ressource dans un fichier de ressources. L’exemple suppose que le fichier de ressources correspondant a été enregistré pour la source.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 L’exemple utilise le fichier texte du message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir de laquelle le fichier de ressource de message est créé. Le fichier texte de message définit les identificateurs de ressources et le texte de la catégorie, message d’événement et les chaînes d’insertion de paramètre.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="source" /> value is an empty string ("").  \- or -  The <paramref name="source" /> value is <see langword="null" />.  \- or -  <paramref name="instance.InstanceId" /> is less than zero or greater than <see cref="F:System.UInt16.MaxValue" />.  \- or -  <paramref name="values" /> has more than 256 elements.  \- or -  One of the <paramref name="values" /> elements is longer than 32766 bytes.  \- or -  The source name results in a registry key path longer than 254 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The registry key for the event log could not be opened.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The operating system reported an error when writing the event entry to the event log. A Windows error code is not available.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>