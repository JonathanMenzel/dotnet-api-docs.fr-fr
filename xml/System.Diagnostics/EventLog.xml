<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d2f3fe5ebc54812cb603cd9fb1b1a12d5ed97a7" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52913896" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une interaction avec les journaux des événements Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> vous permet d’accéder ou de personnaliser les journaux des événements Windows, qui enregistrent des informations sur les événements importants de logiciel ou matériel. À l’aide de <xref:System.Diagnostics.EventLog>, vous pouvez lire à partir de journaux existants, écrire des entrées dans les journaux, créer ou supprimer des sources d’événements, supprimer des journaux et répondre aux entrées de journal. Vous pouvez également créer des nouveaux journaux lors de la création d’une source d’événement.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 Outre l’accès aux journaux des événements individuels et leurs entrées, la <xref:System.Diagnostics.EventLog> classe vous permet d’accéder à la collection de tous les journaux des événements. Vous pouvez utiliser la `static` membres de <xref:System.Diagnostics.EventLog> pour supprimer les journaux, obtenir les listes de journaux, créer ou supprimer une source ou déterminer si un ordinateur contient déjà une source particulière.  
  
 Il existe trois journaux d’événements par défaut : Application, système et sécurité. Un journal de sécurité est en lecture seule. Autres applications et services que vous installez, tels qu’Active Directory, peuvent avoir des journaux des événements supplémentaires.  
  
 Il existe des considérations sur la sécurité lorsque vous utilisez la <xref:System.Diagnostics.EventLog> classe. <xref:System.Diagnostics.EventLog> requiert <xref:System.Diagnostics.EventLogPermission> autorisations pour des actions spécifiques dans le .NET Framework 2.0 et versions ultérieures, ou une confiance totale dans le .NET Framework 1.0 et 1.1. Nous vous recommandons <xref:System.Diagnostics.EventLogPermission> ne pas accordée à du code partiellement fiable.  Vous ne devez jamais passer n’importe quel objet de journal des événements, y compris <xref:System.Diagnostics.EventLogEntryCollection> et <xref:System.Diagnostics.EventLogEntry> objets, au code de confiance inférieur. Par exemple, créez un <xref:System.Diagnostics.EventLog> , écriture d’une entrée et de transmettre le <xref:System.Diagnostics.EventLog> objet code partiellement approuvé peut créer un problème de sécurité, étant donné que la possibilité de lire et écrire dans le journal des événements permet d’effectuer des actions telles que l’exécution de code messages du journal des événements dans le nom d’une autre application.  
  
 À compter de Windows Vista, le contrôle de compte utilisateur (UAC) détermine les informations d’identification d’un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos informations d’identification d’utilisateur standard à administrateur. Vous pouvez le faire lorsque vous démarrez une application en ouvrant le menu contextuel de l’application (si vous utilisez une souris, cliquez sur l’icône d’application) et en indiquant que vous souhaitez exécuter en tant qu’administrateur.  
  
 Vous pouvez utiliser <xref:System.Diagnostics.EventLog> pour créer des journaux des événements personnalisés que vous pouvez afficher via le serveur de l’Observateur d’événements. Utilisez le <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> méthode pour afficher un nom localisé pour votre journal des événements dans l’Observateur d’événements. Utilisez le <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> méthode pour configurer le comportement de votre journal des événements lorsqu’il atteint sa taille maximale du journal.  
  
 Pour lire à partir d’un journal des événements, spécifiez le nom du journal (<xref:System.Diagnostics.EventLog.Log%2A> propriété) et le nom de l’ordinateur serveur (<xref:System.Diagnostics.EventLog.MachineName%2A> propriété pour le journal des événements. Si vous ne spécifiez pas le nom du serveur, l’ordinateur local, «. », est supposé. Il n’est pas nécessaire de spécifier la source d’événements (<xref:System.Diagnostics.EventLog.Source%2A> propriété), car une source est obligatoire uniquement pour les opérations d’écriture. Le <xref:System.Diagnostics.EventLog.Entries%2A> propriété est automatiquement remplie avec liste du journal des événements d’entrées.  
  
 Pour écrire dans un journal des événements, spécifiez ou créez une source d’événement (<xref:System.Diagnostics.EventLog.Source%2A> propriété). Vous devez disposer des informations d’identification administratives sur l’ordinateur pour créer une source d’événement. La source d’événements inscrit votre application avec le journal des événements comme source valide d’entrées. Vous pouvez utiliser la source d’événement pour écrire dans le journal qu’une seule à la fois. Le <xref:System.Diagnostics.EventLog.Source%2A> propriété peut être n’importe quelle chaîne aléatoire, mais le nom doit être différent des autres sources sur l’ordinateur. La source d’événements est généralement le nom de l’application ou une autre chaîne d’identification. Essaie de créer un doublon <xref:System.Diagnostics.EventLog.Source%2A> valeur lève une exception. Toutefois, un seul journal des événements peuvent être associé à plusieurs sources.  
  
 Si la source d’événements du journal des événements associé à la <xref:System.Diagnostics.EventLog> instance n’existe pas, une nouvelle source d’événements est créée. Pour créer une source d’événements dans Windows Vista et versions ultérieures ou sur Windows Server 2003, vous devez disposer des informations d’identification administratives.  
  
 Cette exigence est, car tous les journaux des événements, y compris les journaux de sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
  
> [!IMPORTANT]
>  Création ou la suppression d’une source d’événements requiert la synchronisation du code sous-jacent à l’aide d’un mutex nommé. Si une application à privilèges élevés verrouille le mutex nommé, toute tentative de créer ou supprimer une source d’événement provoque l’application cesse de répondre jusqu'à ce que le verrou est libéré. Pour éviter ce problème, n’accordez jamais <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> autorisation au code non fiable. En outre, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> autorisation permet d’ignorer d’autres autorisations potentiellement et doit uniquement être accordée à du code hautement fiable.  
  
 Applications et services doivent écrire dans le journal des applications ou dans un journal personnalisé. Pilotes de périphérique doivent écrire dans le journal système. Si vous ne définissez pas explicitement la <xref:System.Diagnostics.EventLog.Log%2A> propriété, le journal des événements par défaut dans le journal des applications.  
  
> [!NOTE]
>  Il n’y a rien pour protéger une application à partir de l’écriture en tant que n’importe quelle source inscrite.  Si une application est accordée <xref:System.Diagnostics.EventLogPermissionAccess.Write> autorisation, il peut écrire des événements pour n’importe quelle source valide inscrite sur l’ordinateur.  
  
 Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthodes pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous essayez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une nouvelle source à l’aide un <xref:System.Diagnostics.EventLogInstaller> objet ou le <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des informations d’identification administratives sur l’ordinateur pour créer une source d’événement.  
  
 Chaque source peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter plusieurs sources configurés pour des journaux des événements ou des fichiers de ressources différents. Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis créez-le avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créez une nouvelle source avec la configuration mise à jour au lieu de supprimer la source existante.  
  
 Vous pouvez inscrire la source d’événements avec des ressources localisées pour vos chaînes de catégorie et le message d’événement. Votre application peut écrire des entrées de journal des événements à l’aide d’identificateurs de ressource au lieu de spécifier les valeurs de chaîne réelle. Reportez-vous à la <xref:System.Diagnostics.EventLogInstaller> et <xref:System.Diagnostics.EventSourceCreationData> classes pour plus d’informations sur la configuration de votre source des fichiers de ressources.  
  
 Si votre application écrit les valeurs de chaîne directement dans le journal des événements, il est inutile de paramétrer les propriétés de la source de la ressource. La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Lorsque vous écrivez des événements, vous devez spécifier au moins une chaîne de message ou l’identificateur de ressource pour une chaîne de message. Autres propriétés de l’événement sont facultatifs. Exemples de paramètres d’événements facultatifs sont les suivants :  
  
-   Vous pouvez définir le <xref:System.Diagnostics.EventLogEntryType> pour spécifier l’icône que l’Observateur d’événements affiche pour l’entrée.  
  
-   Vous pouvez spécifier un identificateur de catégorie pour l’événement, si votre application utilise des catégories pour filtrer les événements.  
  
-   Vous pouvez joindre des données binaires à votre entrée d’événement si vous souhaitez associer des informations supplémentaires à un événement donné.  
  
> [!IMPORTANT]
>  Journalisation des événements utilise l’espace disque, de temps processeur et d’autres ressources système. Il est important de consigner uniquement les informations essentielles. Nous recommandons que vous placez les appels de journal des événements dans un chemin d’accès de l’erreur, plutôt que dans le chemin d’accès du code principal, par conséquent, ils ne pas nuire aux performances.  
  
 Pour obtenir la liste des valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>, consultez le <xref:System.Diagnostics.EventLog.%23ctor%2A> constructeur.  
  
   
  
## Examples  
 L’exemple suivant crée la source d’événements `MySource` si elle n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
> [!NOTE]
>  À compter de Windows Vista, vous devez exécuter cette application en tant qu’administrateur.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.EventLog" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.EventLog" />. N'associe pas l'instance à un journal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant d’appeler <xref:System.Diagnostics.EventLog.WriteEntry%2A>, spécifiez la <xref:System.Diagnostics.EventLog.Source%2A> propriété de la <xref:System.Diagnostics.EventLog> instance. Si vous lisez uniquement une <xref:System.Diagnostics.EventLog.Entries%2A> à partir du journal, vous pouvez également spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>.  
  
|Propriété|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Une chaîne vide ( » »).|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Une chaîne vide ( » »).|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|L’ordinateur local («. »).|  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nom du journal sur l'ordinateur local.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.EventLog" />. Associe l'instance à un journal sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge affecte le <xref:System.Diagnostics.EventLog.Log%2A> propriété le `logName` paramètre. Avant d’appeler <xref:System.Diagnostics.EventLog.WriteEntry%2A>, spécifiez la <xref:System.Diagnostics.EventLog.Source%2A> propriété de la <xref:System.Diagnostics.EventLog> instance. Si vous lisez uniquement une <xref:System.Diagnostics.EventLog.Entries%2A> à partir du journal, vous pouvez également spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé. Cette surcharge du constructeur spécifie le <xref:System.Diagnostics.EventLog.Log%2A> propriété, mais vous pouvez modifier cela avant de lire le <xref:System.Diagnostics.EventLog.Entries%2A> propriété.  
  
 Si la source que vous spécifiez dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété est unique à partir d’autres sources sur l’ordinateur, un appel ultérieur à <xref:System.Diagnostics.EventLog.WriteEntry%2A> crée un journal avec le nom spécifié, si elle n’existe pas déjà.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>.  
  
|Propriété|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Une chaîne vide ( » »).|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Le `logName` paramètre.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|L’ordinateur local («. »).|  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements, « myNewLog » sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le nom du journal est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom du journal n’est pas valide.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nom du journal sur l'ordinateur spécifié.</param>
        <param name="machineName">Ordinateur sur lequel se trouve le journal.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.EventLog" />. Associe l'instance à un journal sur l'ordinateur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge définit le <xref:System.Diagnostics.EventLog.Log%2A> propriété le `logName` paramètre et le <xref:System.Diagnostics.EventLog.MachineName%2A> propriété le `machineName` paramètre. Avant d’appeler <xref:System.Diagnostics.EventLog.WriteEntry%2A>, spécifiez la <xref:System.Diagnostics.EventLog.Source%2A> propriété de la <xref:System.Diagnostics.EventLog>. Si vous lisez uniquement une <xref:System.Diagnostics.EventLog.Entries%2A> à partir du journal, vous pouvez également spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés.  
  
> [!NOTE]
>  Cette surcharge du constructeur spécifie le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés, mais vous pouvez modifier avant de lire le <xref:System.Diagnostics.EventLog.Entries%2A> propriété.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>.  
  
|Propriété|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Une chaîne vide ( » »).|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Le `logName` paramètre.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Le `machineName` paramètre.|  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements, « myNewLog » sur l’ordinateur « myServer ».  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le nom du journal est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom du journal n’est pas valide.  
  
- ou - 
Le nom d’ordinateur n’est pas valide.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nom du journal sur l'ordinateur spécifié.</param>
        <param name="machineName">Ordinateur sur lequel se trouve le journal.</param>
        <param name="source">Source des entrées du journal des événements.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.EventLog" />. Associe l'instance à un journal sur l'ordinateur spécifié et crée ou assigne la source spécifiée à <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur affecte la <xref:System.Diagnostics.EventLog.Log%2A> propriété le `logName` paramètre, le <xref:System.Diagnostics.EventLog.MachineName%2A> propriété le `machineName` paramètre et le <xref:System.Diagnostics.EventLog.Source%2A> propriété le `source` paramètre. Le <xref:System.Diagnostics.EventLog.Source%2A> propriété est requise lors de l’écriture dans un journal des événements. Toutefois, si vous effectuez uniquement une lecture à partir d’un journal des événements uniquement le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés sont requises (tant que le journal des événements sur le serveur a déjà associé à une source). Si vous effectuez uniquement une lecture du journal des événements, une autre surcharge du constructeur peut suffire.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Diagnostics.EventLog>.  
  
|Propriété|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Le `source` paramètre.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Le `logName` paramètre.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Le `machineName` paramètre.|  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée dans un journal des événements, « MyNewLog », sur l’ordinateur local, à l’aide de la source « Entrées ».  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le nom du journal est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom du journal n’est pas valide.  
  
- ou - 
Le nom d’ordinateur n’est pas valide.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence l'initialisation d'un <see cref="T:System.Diagnostics.EventLog" /> utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour démarrer l’initialisation d’un composant utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Diagnostics.EventLog.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.Diagnostics.EventLog.BeginInit%2A> et <xref:System.Diagnostics.EventLog.EndInit%2A> méthodes empêchent le contrôle d’être utilisés avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> est déjà initialisé.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime toutes les entrées du journal des événements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Journaux des événements sont définis avec une taille maximale qui détermine le nombre d’entrées qu’ils peuvent contenir. Lorsqu’un journal des événements est plein, il arrête l’enregistrement de nouvelles informations d’événement ou commence à remplacer les entrées précédentes. Si l’enregistrement des événements s’arrête, vous pouvez utiliser cette méthode pour effacer le journal des entrées existantes et de lui permettre de démarrer l’enregistrement des événements à nouveau. Vous devez disposer des autorisations d’administrateur sur l’ordinateur sur lequel réside le journal pour effacer les entrées de journal des événements.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> ferme le journal des événements, libère les identificateurs d’événements, récupère de nouveaux lire et écrire des handles et rouvre le journal des événements. Événements reçus après l’appel à la méthode ne sont pas effacés, ainsi que les événements existants.  
  
   
  
## Examples  
 L’exemple suivant efface un journal des événements.  
  
> [!CAUTION]
>  Étant donné que l’Application, système, sécurité et autres journaux non personnalisés permettre contenir des informations cruciales ; Veillez à spécifier un journal personnalisé avant d’exécuter cet exemple de code. Cet exemple supprime le journal personnalisé `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Le journal des événements a été effacé pas correctement.  
  
- ou - 
Impossible d’ouvrir le journal. Un code d’erreur Windows n’est pas disponible.</exception>
        <exception cref="T:System.ArgumentException">Une valeur n’est pas spécifiée pour le <see cref="P:System.Diagnostics.EventLog.Log" /> propriété. Assurez-vous que le nom du journal n’est pas une chaîne vide.</exception>
        <exception cref="T:System.InvalidOperationException">Le journal n’existe pas.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme le journal des événements et libère les handles de lecture et d’écriture.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.EventLog.Close%2A> méthode est appelée par l’élément protégé <xref:System.ComponentModel.Component.Dispose%2A> (méthode). Vous n’avez pas besoin d’appeler <xref:System.Diagnostics.EventLog.Close%2A> avant d’appeler <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Handle de lecture du journal des événements ou d’écriture qui n’a pas été libéré avec succès.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit une application comme capable d'écrire des événements dans un fichier journal spécifique sur le système.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">Propriétés de configuration pour la source d'événements et son journal des événements cible.</param>
        <summary>Définit une source d'événements valide pour l'écriture de messages d'événements localisés, à l'aide des propriétés de configuration spécifiées pour la source d'événements et le journal des événements correspondant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour configurer une nouvelle source pour écrire des entrées dans un journal des événements sur l’ordinateur local ou un ordinateur distant. Il n’est pas nécessaire d’utiliser cette méthode pour lire à partir d’un journal des événements.  
  
 Le <xref:System.Diagnostics.EventLog.CreateEventSource%2A> méthode utilise l’entrée `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> et <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> propriétés pour créer des valeurs de Registre sur l’ordinateur cible pour la nouvelle source et son journal des événements associé. Un nouveau nom de source ne peut pas correspondre à un nom de source existant ou un nom de journal des événements existant sur l’ordinateur cible. Si le <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> propriété n’est pas définie, la source est inscrite pour le journal des événements Application. Si le <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> n’est pas défini, la source est inscrite sur l’ordinateur local.  
  
> [!NOTE]
>  Pour créer une source d’événements dans Windows Vista et versions ultérieures ou sur Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  À compter de Windows Vista, le contrôle de compte utilisateur (UAC) détermine les privilèges d’un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 Utilisez <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Vous pouvez créer une source d’événement pour un journal des événements existant ou un journal des événements. Lorsque vous créez une nouvelle source pour un journal des événements, le système inscrit la source de ce journal, mais le journal n’est pas créé jusqu'à ce que la première entrée est écrites.  
  
 Le système d’exploitation stocke les journaux des événements sous forme de fichiers. Lorsque vous utilisez <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour créer un nouveau journal des événements, le fichier associé est stocké dans le répertoire %SystemRoot%\System32\Config sur l’ordinateur spécifié. Le nom de fichier est défini en ajoutant les 8 premiers caractères de la <xref:System.Diagnostics.EventLog.Log%2A> propriété avec l’extension de nom de fichier « .evt ».  
  
 Chaque source peut uniquement écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter plusieurs sources configurés pour des journaux des événements ou des fichiers de ressources différents.  
  
 Vous pouvez inscrire la source d’événements avec les fichiers de ressources localisés pour vos chaînes de catégorie et le message d’événement. Votre application peut écrire des entrées de journal des événements à l’aide d’identificateurs de ressources, plutôt que de spécifier la chaîne réelle. L’Observateur d’événements utilise l’identificateur de ressource pour rechercher et afficher la chaîne correspondante à partir du fichier de ressource localisée selon les paramètres de langue actuels. Vous pouvez enregistrer un fichier distinct pour les catégories d’événements, les messages et les chaînes d’insertion de paramètre, ou vous pouvez inscrire le même fichier de ressources pour les trois types de chaînes. Utilisez le <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, et <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> propriétés pour configurer la source pour écrire des entrées localisées dans le journal des événements. Si votre application écrit les valeurs de chaînes directement dans le journal des événements, il est inutile de définir ces propriétés.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis créez-le avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créez une nouvelle source avec la configuration mise à jour, plutôt que de supprimer la source existante.  
  
> [!NOTE]
>  Si une source est configurée pour un journal des événements, et que vous reconfigurez pour un autre journal des événements, vous devez redémarrer l’ordinateur pour que les modifications entrent en vigueur.  
  
   
  
## Examples  
 L’exemple suivant détermine si la source d’événements nommée `SampleApplicationSource` est inscrite sur l’ordinateur local. Si la source d’événements n’existe pas, l’exemple définit le fichier de ressources de message pour la source et crée la nouvelle source d’événements. Enfin, l’exemple définit le nom complet localisé du journal des événements, à l’aide de la valeur d’identificateur de ressource dans `DisplayNameMsgId` et le chemin d’accès du fichier de ressources dans `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 L’exemple utilise le fichier de texte de message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir duquel le fichier de ressource de message est créé. Le fichier de texte de message définit les identificateurs de ressource et le texte pour la catégorie, message d’événement et chaînes d’insertion de paramètre. Plus précisément, l’identificateur de ressource 5001 est défini pour le nom localisé du journal des événements.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom d’ordinateur spécifié dans <paramref name="sourceData" /> n’est pas valide.  
  
\- ou - 
Le nom de source spécifié dans <paramref name="sourceData" /> est <see langword="null" />.  
  
\- ou - 
Le nom du journal spécifié dans <paramref name="sourceData" /> n’est pas valide. Les noms des journaux d’événements doivent comporter des caractères imprimables et ne peuvent pas inclure les caractères « * », « ? » ou « \\ ».  
  
\- ou - 
Le nom du journal spécifié dans <paramref name="sourceData" /> n’est pas valide pour la création du journal utilisateur. Les noms de journal des événements AppEvent, SysEvent et SecEvent sont réservés pour une utilisation système.  
  
\- ou - 
Le nom du journal correspond à un nom de source d’événements existant.  
  
\- ou - 
Le nom de source spécifié dans <paramref name="sourceData" /> entraîne un chemin de clé de Registre dépassant 254 caractères.  
  
\- ou - 
Les 8 premiers caractères du nom du journal spécifié dans <paramref name="sourceData" /> ne sont pas uniques.  
  
\- ou - 
Le nom de source spécifié dans <paramref name="sourceData" /> est déjà inscrit.  
  
\- ou - 
Le nom de source spécifié dans <paramref name="sourceData" /> correspond à un nom de journal des événements existant.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nom de la source grâce à laquelle l'application est inscrite sur l'ordinateur local.</param>
        <param name="logName">Nom du journal dans lequel les entrées de la source sont écrites. Les valeurs possibles sont notamment : journal d'événements d'applications, système ou personnalisé.</param>
        <summary>Établit le nom de source spécifié comme étant une source d'événement valide pour enregistrer des entrées dans un journal sur l'ordinateur local. Cette méthode peut également créer un nouveau journal personnalisé sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer un journal personnalisé ou pour créer et inscrire un <xref:System.Diagnostics.EventLog.Source%2A> dans un journal existant sur l’ordinateur local.  
  
 Si `logName` est `null` ou une chaîne vide (" ») lorsque vous appelez <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, le journal par défaut est le journal des applications. Si le journal n’existe pas sur l’ordinateur local, le système crée un journal personnalisé et inscrit votre application comme un <xref:System.Diagnostics.EventLog.Source%2A> pour ce journal.  
  
> [!NOTE]
>  Pour créer une source d’événements dans Windows Vista et versions ultérieures ou sur Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  Dans Windows Vista et version ultérieure, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 Vous devez uniquement créer une source d’événements si vous écrivez dans le journal des événements. Avant d’écrire une entrée dans un journal des événements, vous devez inscrire la source d’événements avec le journal des événements comme source valide d’événements. Lorsque vous écrivez une entrée de journal, le système utilise le <xref:System.Diagnostics.EventLog.Source%2A> pour trouver le journal approprié dans lequel placer votre entrée. Si vous lisez le journal des événements, vous pouvez spécifier le <xref:System.Diagnostics.EventLog.Source%2A>, ou un <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Vous n’êtes pas obligé de spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal sur l’ordinateur local. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A> lors de la lecture à partir d’un journal, l’ordinateur local («. ») est supposé.  
  
 Utilisez <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Vous pouvez créer une source d’événement pour un journal des événements existant ou un journal des événements. Lorsque vous créez une nouvelle source pour un journal des événements, le système inscrit la source de ce journal, mais le journal n’est pas créé jusqu'à ce que la première entrée est écrites.  
  
 Le système d’exploitation stocke les journaux des événements sous forme de fichiers. Lorsque vous utilisez <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour créer un nouveau journal des événements, le fichier associé est stocké dans le répertoire %SystemRoot%\System32\Config sur l’ordinateur spécifié. Le nom de fichier est défini en ajoutant les 8 premiers caractères de la <xref:System.Diagnostics.EventLog.Log%2A> propriété avec l’extension de nom de fichier « .evt ».  
  
 La source doit être unique sur l’ordinateur local ; un nouveau nom de source ne peut pas correspondre à un nom de source existant ou un nom de journal des événements existant. Chaque source peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter plusieurs sources configurés pour des journaux des événements ou des fichiers de ressources différents.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis créez-le avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créez une nouvelle source avec la configuration mise à jour, plutôt que de supprimer la source existante.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications entrent en vigueur.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> est une chaîne vide (" ») ou <see langword="null" />.  
  
\- ou - 
 <paramref name="logName" /> n’est pas un nom de journal des événements valide. Les noms des journaux d’événements doivent comporter des caractères imprimables et ne peuvent pas inclure les caractères « * », « ? » ou « \\ ».  
  
\- ou - 
 <paramref name="logName" /> n’est pas valide pour la création du journal utilisateur. Les noms de journal des événements AppEvent, SysEvent et SecEvent sont réservés pour une utilisation système.  
  
\- ou - 
Le nom du journal correspond à un nom de source d’événements existant.  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.  
  
\- ou - 
Les 8 premiers caractères de <paramref name="logName" /> correspondre les 8 premiers caractères d’un nom de journal des événements existant.  
  
\- ou - 
La source ne peut pas être inscrite, car il existe déjà sur l’ordinateur local.  
  
\- ou - 
Le nom de la source correspond à un nom de journal des événements existant.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert sur l’ordinateur local.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Source grâce à laquelle l'application est inscrite sur l'ordinateur spécifié.</param>
        <param name="logName">Nom du journal dans lequel les entrées de la source sont écrites. Les valeurs possibles sont notamment : journal d'événements d'applications, système ou personnalisé. Si vous ne spécifiez pas de valeur, le paramètre <paramref name="logName" /> est défini par défaut sur Application.</param>
        <param name="machineName">Nom de l'ordinateur avec lequel inscrire cette source d'événements ou "." pour l'ordinateur local.</param>
        <summary>Établit le nom de source spécifié comme étant une source d'événement valide pour enregistrer des entrées dans un journal sur l'ordinateur spécifié. Cette méthode peut également être utilisée pour créer un nouveau journal personnalisé sur l'ordinateur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer un journal personnalisé ou pour créer et inscrire un <xref:System.Diagnostics.EventLog.Source%2A> dans un journal existant sur l’ordinateur spécifié.  
  
 Si `logName` est `null` ou une chaîne vide (" ») lorsque vous appelez <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, le journal par défaut est le journal des applications. Si le journal n’existe pas sur l’ordinateur spécifié, le système crée un journal personnalisé et inscrit votre application comme un <xref:System.Diagnostics.EventLog.Source%2A> pour ce journal.  
  
 Vous devez uniquement créer une source d’événements si vous écrivez dans le journal des événements. Avant d’écrire une entrée dans un journal des événements, vous devez inscrire la source d’événements avec le journal des événements comme source valide d’événements. Lorsque vous écrivez une entrée de journal, le système utilise le <xref:System.Diagnostics.EventLog.Source%2A> pour trouver le journal approprié dans lequel placer votre entrée. Si vous lisez le journal des événements, vous pouvez spécifier le <xref:System.Diagnostics.EventLog.Source%2A>, ou un <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Pour créer une source d’événements dans Windows Vista et versions ultérieures ou sur Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. Dans Windows Vista et versions ultérieures, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  Dans Windows Vista et version ultérieure, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
 Utilisez <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Vous pouvez créer une source d’événement pour un journal des événements existant ou un journal des événements. Lorsque vous créez une nouvelle source pour un journal des événements, le système inscrit la source de ce journal, mais le journal n’est pas créé jusqu'à ce que la première entrée est écrites.  
  
 Le système d’exploitation stocke les journaux des événements sous forme de fichiers. Lorsque vous utilisez <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour créer un nouveau journal des événements, le fichier associé est stocké dans le répertoire %SystemRoot%\System32\Config sur l’ordinateur spécifié. Le nom de fichier est défini en ajoutant les 8 premiers caractères de la <xref:System.Diagnostics.EventLog.Log%2A> propriété avec l’extension de nom de fichier « .evt ».  
  
 La source doit être unique sur l’ordinateur local ; un nouveau nom de source ne peut pas correspondre à un nom de source existant ou un nom de journal des événements existant. Chaque source peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter plusieurs sources configurés pour des journaux des événements ou des fichiers de ressources différents.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis créez-le avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créez une nouvelle source avec la configuration mise à jour, plutôt que de supprimer la source existante.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications entrent en vigueur.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` sur l’ordinateur `MyServer`et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="machineName" /> n’est pas un nom d’ordinateur valide.  
  
\- ou - 
 <paramref name="source" /> est une chaîne vide (" ») ou <see langword="null" />.  
  
\- ou - 
 <paramref name="logName" /> n’est pas un nom de journal des événements valide. Les noms des journaux d’événements doivent comporter des caractères imprimables et ne peuvent pas inclure les caractères « * », « ? » ou « \\ ».  
  
\- ou - 
 <paramref name="logName" /> n’est pas valide pour la création du journal utilisateur. Les noms de journal des événements AppEvent, SysEvent et SecEvent sont réservés pour une utilisation système.  
  
\- ou - 
Le nom du journal correspond à un nom de source d’événements existant.  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.  
  
\- ou - 
Les 8 premiers caractères de <paramref name="logName" /> correspondance les 8 premiers caractères d’un journal des événements existant nom sur l’ordinateur spécifié.  
  
\- ou - 
La source ne peut pas être inscrite, car il existe déjà sur l’ordinateur spécifié.  
  
\- ou - 
Le nom de la source correspond à un nom de source d’événements existant.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert sur l’ordinateur spécifié.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime une ressource du journal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nom du journal à supprimer. Les valeurs possibles sont notamment : application, sécurité, système et n'importe quel journal des événements personnalisé se trouvant sur l'ordinateur.</param>
        <summary>Supprime un journal des événements de l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque le journal que vous souhaitez supprimer est sur l’ordinateur local. Vous pouvez supprimer n’importe quel journal sur l’ordinateur, condition que vous ayez les autorisations de Registre appropriées.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Supprime le journal spécifié par `logName` à partir de l’ordinateur local. Si vous souhaitez supprimer uniquement la source inscrite dans un journal, appelez <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Si vous souhaitez uniquement supprimer les entrées de journal, appelez <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> et <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sont `static` méthodes, il peuvent donc être appelées sur la classe elle-même. Il n’est pas nécessaire de créer une nouvelle instance de <xref:System.Diagnostics.EventLog> pour appeler soit la méthode.  
  
 Le <xref:System.Diagnostics.EventLog.Delete%2A> méthode supprime tout d’abord le fichier qui contient le contenu du journal. Ensuite, il accède au Registre et supprime toutes les sources d’événements inscrits pour ce journal. Si vous recréez le journal à un moment ultérieur, vous devez inscrire les sources d’événements là encore, s’ils doivent être réutilisés. Si vous n’enregistrez pas les sources d’événements et d’autres utilisateurs écrivent dans une source d’événement sans spécifier un nom de journal, la source d’événements sera créée dans le journal des événements Application. Par conséquent, les applications qui ont été précédemment en mesure d’écrire des entrées dans le journal que vous avez supprimé et recréé écrira dans le journal des applications à la place, car il contient désormais la source d’événements.  
  
> [!NOTE]
>  Recréation d’un journal des événements peut être un processus difficile. Évitez de supprimer les journaux des événements de créé par le système, telles que le journal des applications.  
  
 Suppression d’un journal par un appel à <xref:System.Diagnostics.EventLog.Delete%2A> supprime automatiquement les sources inscrites dans ce journal. Cela peut rendre d’autres applications à l’aide de ce journal inopérantes.  
  
   
  
## Examples  
 L’exemple suivant supprime un journal de l’ordinateur local. L’exemple détermine le journal à partir de sa source.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’il n’existe aucune autre source écrit dans ce journal.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> est une chaîne vide (" ») ou <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert sur l’ordinateur local.  
  
\- ou - 
Le journal n’existe pas sur l’ordinateur local.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le journal des événements a été effacé pas correctement.  
  
- ou - 
Impossible d’ouvrir le journal. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nom du journal à supprimer. Les valeurs possibles sont notamment : application, sécurité, système et n'importe quel journal des événements personnalisé se trouvant sur l'ordinateur spécifié.</param>
        <param name="machineName">Nom de l'ordinateur d'où le journal doit être supprimé ou "." pour l'ordinateur local.</param>
        <summary>Supprime un journal des événements de l'ordinateur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque le journal que vous souhaitez supprimer est sur un ordinateur distant. Vous pouvez supprimer n’importe quel journal sur l’ordinateur, condition que vous ayez les autorisations de Registre appropriées.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Supprime le journal spécifié par `logName` à partir de l’ordinateur spécifié par `machineName`. Si vous souhaitez supprimer uniquement la source inscrite dans un journal, appelez <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Si vous souhaitez uniquement supprimer les entrées de journal, appelez <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> et <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sont `static` méthodes, il peuvent donc être appelées sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler soit la méthode.  
  
 Cette méthode supprime tout d’abord le fichier qui contient le contenu du journal. Ensuite, il accède au Registre et supprime toutes les sources d’événements inscrits pour ce journal. Si vous recréez le journal à un moment ultérieur, vous devez inscrire les sources d’événements là encore, s’ils doivent être réutilisés. Si vous n’enregistrez pas les sources d’événements et d’autres utilisateurs écrivent dans une source d’événement sans spécifier un nom de journal, la source d’événements sera créée dans le journal des événements Application. Par conséquent, les applications qui ont été précédemment en mesure d’écrire des entrées dans le journal que vous avez supprimé et recréé écrira dans le journal des applications à la place, car il contient désormais la source d’événements.  
  
> [!NOTE]
>  Recréation d’un journal des événements peut être un processus difficile. Évitez de supprimer les journaux des événements de créé par le système, telles que le journal des applications.  
  
 Suppression d’un journal par un appel à <xref:System.Diagnostics.EventLog.Delete%2A> supprime automatiquement les sources inscrites dans ce journal. Cela peut rendre d’autres applications à l’aide de ce journal inopérantes.  
  
   
  
## Examples  
 L’exemple suivant supprime un journal de l’ordinateur spécifié. L’exemple détermine le journal à partir de sa source.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’il n’existe aucune autre source écrit dans ce journal.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> est une chaîne vide (" ») ou <see langword="null" />.  
  
\- ou - 
 <paramref name="machineName" /> n’est pas un nom d’ordinateur valide.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert sur l’ordinateur spécifié.  
  
\- ou - 
Le journal n’existe pas sur l’ordinateur spécifié.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le journal des événements a été effacé pas correctement.  
  
- ou - 
Impossible d’ouvrir le journal. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime l'inscription de la source des événements d'une application du journal des événements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nom d'inscription de l'application dans le système de journal des événements.</param>
        <summary>Supprime l'inscription de la source d'événements du journal des événements de l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour supprimer l’inscription d’un <xref:System.Diagnostics.EventLog.Source%2A> à partir de l’ordinateur local. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> accède au Registre sur l’ordinateur local et supprime l’inscription de votre application en tant que source d’événements valide.  
  
 Si vous n’avez plus besoin d’écrire des entrées dans ce journal, vous pouvez supprimer votre composant comme source d’événements valide. Par exemple, vous êtes susceptible d’effectuer cela si vous devez modifier votre composant de journal vers un autre. Car une source peut uniquement être enregistrée dans un journal à la fois, le journal de la modification nécessite vous permet de supprimer l’enregistrement actuel.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Supprime uniquement la source inscrite dans un journal. Si vous souhaitez supprimer le journal lui-même, appelez <xref:System.Diagnostics.EventLog.Delete%2A>. Si vous souhaitez uniquement supprimer les entrées de journal, appelez <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> et <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sont `static` méthodes, il peuvent donc être appelées sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler soit la méthode.  
  
 Suppression d’un journal par un appel à <xref:System.Diagnostics.EventLog.Delete%2A> supprime automatiquement les sources inscrites dans ce journal. Cela peut rendre d’autres applications à l’aide de ce journal inopérantes.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications entrent en vigueur.  
  
   
  
## Examples  
 L’exemple suivant supprime une source de l’ordinateur local. L’exemple détermine le journal à partir de sa source, puis supprime le journal.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’il n’existe aucune autre source écrit dans ce journal.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="source" /> paramètre n’existe pas dans le Registre de l’ordinateur local.  
  
\- ou - 
Il est inutile l’accès en écriture sur la clé de Registre du journal des événements.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nom d'inscription de l'application dans le système de journal des événements.</param>
        <param name="machineName">Nom de l'ordinateur d'où l'inscription doit être supprimée ou "." pour l'ordinateur local.</param>
        <summary>Supprime l'inscription de la source d'événements de l'application sur l'ordinateur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour supprimer l’inscription d’un <xref:System.Diagnostics.EventLog.Source%2A> à partir d’un ordinateur distant. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> accède au Registre sur l’ordinateur spécifié par `machineName` et supprime l’inscription de votre application en tant que source d’événements valide.  
  
 Si vous n’avez plus besoin d’écrire des entrées dans ce journal, vous pouvez supprimer votre composant comme source d’événements valide. Par exemple, vous êtes susceptible d’effectuer cela si vous devez modifier votre composant de journal vers un autre. Car une source peut uniquement être enregistrée dans un journal à la fois, le journal de la modification nécessite vous permet de supprimer l’enregistrement actuel.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Supprime uniquement la source inscrite dans un journal. Si vous souhaitez supprimer le journal lui-même, appelez <xref:System.Diagnostics.EventLog.Delete%2A>. Si vous souhaitez uniquement supprimer les entrées de journal, appelez <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> et <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sont `static` méthodes, il peuvent donc être appelées sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler soit la méthode.  
  
 Suppression d’un journal par un appel à <xref:System.Diagnostics.EventLog.Delete%2A> supprime automatiquement les sources inscrites dans ce journal. Cela peut rendre d’autres applications à l’aide de ce journal inopérantes.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications entrent en vigueur.  
  
   
  
## Examples  
 L’exemple suivant supprime une source de l’ordinateur spécifié. L’exemple détermine le journal à partir de sa source, puis supprime le journal.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’il n’existe aucune autre source écrit dans ce journal.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="machineName" /> n'est pas valide.  
  
\- ou - 
Le <paramref name="source" /> paramètre n’existe pas dans le Registre de l’ordinateur spécifié.  
  
\- ou - 
Il est inutile l’accès en écriture sur la clé de Registre du journal des événements.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> ne peut pas être supprimé, car dans le Registre, la clé de Registre parente pour <paramref name="source" /> ne contient pas une sous-clé portant le même nom.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par le <see cref="T:System.Diagnostics.EventLog" />, et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Lorsque le `disposing` paramètre est true, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Diagnostics.EventLog> références. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see cref="T:System.Diagnostics.EventLog" /> reçoit les notifications d'un événement <see cref="E:System.Diagnostics.EventLog.EntryWritten" />.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Diagnostics.EventLog" /> reçoit la notification quand une entrée est écrite dans le journal ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> propriété détermine si le <xref:System.Diagnostics.EventLog> déclenche des événements lorsque les entrées sont écrites dans le journal. Lorsque la propriété est `true`, composants qui reçoivent le <xref:System.Diagnostics.EventLog.EntryWritten> événement recevront une notification chaque fois qu’une entrée est écrite dans le journal est spécifié dans le <xref:System.Diagnostics.EventLog.Log%2A> propriété. Si <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> est `false`, aucun événement est déclenché.  
  
> [!NOTE]
>  Vous pouvez recevoir des notifications d’événements uniquement lorsque les entrées sont écrites sur l’ordinateur local. Vous ne pouvez pas recevoir des notifications pour les entrées écrites sur des ordinateurs distants.  
  
   
  
## Examples  
 L’exemple suivant gère un <xref:System.Diagnostics.EventLog.EntryWritten> événement.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le journal des événements se trouve sur un ordinateur distant.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termine l'initialisation d'un <see cref="T:System.Diagnostics.EventLog" /> utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour terminer l’initialisation d’un composant utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Diagnostics.EventLog.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.Diagnostics.EventLog.BeginInit%2A> et <xref:System.Diagnostics.EventLog.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le contenu du journal des événements.</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLogEntryCollection" /> contenant les entrées dans le journal des événements. Chaque entrée est associée à une instance de la classe <see cref="T:System.Diagnostics.EventLogEntry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Diagnostics.EventLog.Entries%2A> membre lors de la lecture du journal des événements.  
  
 Étant donné que la propriété est en lecture seule, vous ne pouvez pas modifier une entrée ou écrire dans le journal à l’aide <xref:System.Diagnostics.EventLog.Entries%2A>. Au lieu de cela, spécifiez un <xref:System.Diagnostics.EventLog.Source%2A> et appelez <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire une nouvelle entrée de journal. Vous pouvez utiliser <xref:System.Diagnostics.EventLog.Entries%2A> pour compter le nombre d’entrées dans le journal des événements et afficher chaque <xref:System.Diagnostics.EventLogEntry> dans la collection. Utilisez indexés <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> membre pour récupérer des informations sur une entrée spécifique, tel que <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, ou <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Il n’est pas nécessaire de spécifier un <xref:System.Diagnostics.EventLog.Source%2A> lors de la lecture à partir d’un journal. Vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> nom et <xref:System.Diagnostics.EventLog.MachineName%2A> propriétés (nom de l’ordinateur serveur) pour le <xref:System.Diagnostics.EventLog> instance. Dans les deux cas, le <xref:System.Diagnostics.EventLog.Entries%2A> membre est automatiquement rempli avec liste du journal des événements d’entrées. Vous pouvez sélectionner l’index approprié pour un élément dans cette liste pour lire les entrées individuelles.  
  
 Une différence importante entre lecture et écriture des entrées de journal est qu’il n’est pas nécessaire d’appeler explicitement une méthode de lecture. Après le <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A> sont spécifiés, le <xref:System.Diagnostics.EventLog.Entries%2A> propriété est remplie automatiquement. Si vous modifiez la valeur de la <xref:System.Diagnostics.EventLog.Log%2A> ou <xref:System.Diagnostics.EventLog.MachineName%2A> propriété, le <xref:System.Diagnostics.EventLog.Entries%2A> propriété est rempli à nouveau la prochaine fois que vous lire.  
  
> [!NOTE]
>  Vous n’êtes pas obligé de spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local, «. », est supposé.  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements « MyNewLog », sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand une entrée est écrite dans un journal des événements sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir des notifications d’événements, vous devez définir <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> à `true`. Vous pouvez uniquement recevoir des notifications d’événements lorsque les entrées sont écrites sur l’ordinateur local. Vous ne pouvez pas recevoir des notifications pour les entrées écrites sur des ordinateurs distants.  
  
 Lorsque vous créez un délégué <xref:System.Diagnostics.EventLog.EntryWritten>, vous identifiez la méthode qui gérera l'événement. Pour associer l'événement au gestionnaire d'événements, ajoutez une instance du délégué à l'événement. Le Gestionnaire d’événements est appelé chaque fois que l’événement se produit, jusqu'à ce que vous supprimiez le délégué. Pour plus d’informations sur la gestion des événements avec des délégués, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 Le système répond à <xref:System.Diagnostics.EventLog.WriteEntry%2A> uniquement si le dernier événement d’écriture s’est produite au moins six secondes. Cela implique que vous recevez uniquement un <xref:System.Diagnostics.EventLog.EntryWritten> notification d’événement dans un intervalle de six secondes, même si plusieurs événements journal modification se produit. Si vous insérez un intervalle de mise en veille suffisamment longue (environ 10 secondes) entre les appels à <xref:System.Diagnostics.EventLog.WriteEntry%2A>, vous êtes moins enclin à avez manqué un événement. Toutefois, si les événements d’écriture se produisent plus fréquemment, vous ne pouvez pas recevoir la notification d’événement jusqu’au prochain intervalle. En règle générale, notifications d’événements manquées ne sont pas perdues, mais retardées.  
  
   
  
## Examples  
 L’exemple suivant gère un événement entry written.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si le journal spécifié existe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nom du journal à rechercher. Les valeurs possibles sont notamment : application, sécurité, système, autres journaux spécifiques à l'application (tels que ceux associés à Active Directory) ou n'importe quel journal personnalisé se trouvant sur l'ordinateur.</param>
        <summary>Détermine si le journal existe sur l'ordinateur local.</summary>
        <returns>
          <see langword="true" /> si le journal existe sur l'ordinateur local ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer si un journal existe sur l’ordinateur local. Si vous souhaitez déterminer si une source existe sur l’ordinateur local, utilisez <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Étant donné que cette méthode accède au Registre, vous devez disposer des autorisations de Registre appropriées sur l’ordinateur local ; Sinon, la requête retourne `false`.  
  
 Étant donné que vous ne pouvez pas donner un nouveau journal le nom d’un journal existant sur le même ordinateur, utilisez cette méthode avant de créer un nouveau journal pour déterminer si le texte spécifié `logName` existe déjà sur l’ordinateur local. Le `logName` paramètre n’est pas sensible à la casse.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> est un `static` (méthode), il peut donc être appelée sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le logName est <see langword="null" /> ou la valeur est vide.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Journal à rechercher. Les valeurs possibles sont notamment : application, sécurité, système, autres journaux spécifiques à l'application (tels que ceux associés à Active Directory) ou n'importe quel journal personnalisé se trouvant sur l'ordinateur.</param>
        <param name="machineName">Nom de l'ordinateur dans lequel rechercher le journal ou "." pour l'ordinateur local.</param>
        <summary>Détermine si le journal existe sur l'ordinateur spécifié.</summary>
        <returns>
          <see langword="true" /> si le journal existe sur l'ordinateur spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer si un journal existe sur un ordinateur distant. Si vous souhaitez déterminer si une source existe sur un ordinateur distant, utilisez <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Étant donné que cette méthode accède au Registre, vous devez disposer des autorisations de Registre appropriées sur l’ordinateur spécifié ; Sinon, la requête retourne `false`.  
  
 Étant donné que vous ne pouvez pas donner un nouveau journal le nom d’un journal existant sur le même ordinateur, utilisez cette méthode avant de créer un nouveau journal pour déterminer si un avec la valeur `logName` existe déjà sur le serveur spécifié par le `machineName` paramètre. Le `logName` et `machineName` paramètres ne respectent pas la casse.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> est un `static` (méthode), il peut donc être appelée sur la classe elle-même. Il n’est pas nécessaire de créer une nouvelle instance de <xref:System.Diagnostics.EventLog> pour appeler <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="machineName" /> paramètre est un format non valide. Assurez-vous que vous avez utilisé la syntaxe correcte pour l’ordinateur sur lequel vous effectuez la recherche.  
  
- ou - 
Le <paramref name="logName" /> est <see langword="null" /> ou la valeur est vide.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un tableau des journaux des événements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recherche tous les journaux des événements sur l'ordinateur local et crée un tableau des objets <see cref="T:System.Diagnostics.EventLog" /> qui contiennent la liste.</summary>
        <returns>Tableau de type <see cref="T:System.Diagnostics.EventLog" /> représentant les journaux sur l'ordinateur local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau de <xref:System.Diagnostics.EventLog> objets est un instantané de tous les journaux des événements sur l’ordinateur local lors de l’appel à <xref:System.Diagnostics.EventLog.GetEventLogs%2A> est effectuée. Cela n’est pas un regroupement dynamique, donc il ne reflète pas la suppression ou la création de journaux en temps réel. Vous devez vérifier l’existence d’un journal dans le tableau avant que vous lire ou écrivez dedans. Le tableau inclut généralement au moins trois journaux : Application, système et sécurité. Si vous avez créé des journaux personnalisés sur l’ordinateur local, ils apparaîtront dans le tableau.  
  
 Pour récupérer la liste des journaux des événements, vous devez disposer des autorisations de Registre appropriées. Ces autorisations sont identiques à ceux requis pour appeler <xref:System.Diagnostics.EventLog.Exists%2A> et <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche les détails de configuration pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Il est inutile l’accès en lecture au Registre.  
  
- ou - 
Il n’existe aucun service de journal des événements sur l’ordinateur.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Ordinateur sur lequel rechercher les journaux des événements.</param>
        <summary>Recherche tous les journaux des événements sur l'ordinateur spécifié et crée un tableau des objets <see cref="T:System.Diagnostics.EventLog" /> qui contiennent la liste.</summary>
        <returns>Tableau de type <see cref="T:System.Diagnostics.EventLog" /> représentant les journaux sur l'ordinateur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau de <xref:System.Diagnostics.EventLog> objets est un instantané de tous les journaux des événements sur l’ordinateur spécifié par le `machineName` paramètre lors de l’appel à <xref:System.Diagnostics.EventLog.GetEventLogs%2A> est effectuée. Cela n’est pas un regroupement dynamique, donc il ne reflète pas la suppression ou la création de journaux en temps réel. Vous devez vérifier l’existence d’un journal dans le tableau avant que vous lire ou écrivez dedans. Le tableau inclut généralement au moins trois journaux : Application, système et sécurité. Si vous avez créé des journaux personnalisés sur l’ordinateur spécifié, ils apparaîtront dans le tableau.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> est un `static` (méthode), il peut donc être appelée sur le <xref:System.Diagnostics.EventLog> classe lui-même. Il n’est pas nécessaire de créer une instance d’un <xref:System.Diagnostics.EventLog> objet pour effectuer un appel à la méthode.  
  
 Pour récupérer la liste des journaux des événements, vous devez disposer des autorisations de Registre appropriées. Ces autorisations sont identiques à ceux requis pour appeler <xref:System.Diagnostics.EventLog.Exists%2A> et <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 L’exemple suivant obtient une liste des journaux sur l’ordinateur « myServer ». Il renvoie ensuite le nom de chaque journal.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="machineName" /> paramètre est un nom d’ordinateur non valide.</exception>
        <exception cref="T:System.InvalidOperationException">Il est inutile l’accès en lecture au Registre.  
  
- ou - 
Il n’existe aucun service de journal des événements sur l’ordinateur.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du journal à utiliser en lecture ou en écriture.</summary>
        <value>Nom du journal. Il peut s'agir d'application, système, sécurité ou d'un nom de journal personnalisé. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trois fichiers journaux existent par défaut sur le serveur : Application, système et sécurité. Applications et services utilisent le fichier de journal d’applications. Pilotes de périphériques utilisent le fichier journal système. Le système génère des événements d’audit de réussite et d’échec dans le journal de sécurité lors de l’audit est activé. Si vous avez d’autres applications installées, comme Active Directory sur les serveurs Windows, il existe peut-être d’autres fichiers de journaux par défaut. En outre, vous pouvez créer des fichiers journaux personnalisés sur un ordinateur local ou distant. Journaux personnalisés aident à organiser vos entrées de manière plus détaillée que celle autorisée lorsque vos composants écrivent des événements dans le journal des applications par défaut.  
  
> [!NOTE]
>  Les noms de journal sont limités à huit caractères. Selon le système, MyLogSample1 et MyLogSample2 sont le même journal.  
  
 Si vous écrivez dans un journal des événements, il ne suffit pas à spécifier le <xref:System.Diagnostics.EventLog.Log%2A> propriété. Vous devez associer un <xref:System.Diagnostics.EventLog.Source%2A> propriété avec votre ressource de journal des événements pour vous connecter à un journal particulier. Il n’est pas nécessaire de spécifier un <xref:System.Diagnostics.EventLog.Source%2A> lorsque la lecture à partir d’un journal, mais une source d’événement doit être associée à la ressource de journal des événements dans le Registre du serveur. Vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> nom et <xref:System.Diagnostics.EventLog.MachineName%2A> (nom de l’ordinateur serveur) pour lire à partir de celui-ci.  
  
> [!NOTE]
>  Vous n’êtes pas obligé de spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le <xref:System.Diagnostics.EventLog.Source%2A> propriété n’a pas été spécifiée, un appel à <xref:System.Diagnostics.EventLog.Log%2A> retourne une chaîne vide si <xref:System.Diagnostics.EventLog.Log%2A> n’a pas été explicitement défini (en définissant le <xref:System.Diagnostics.EventLog.Log%2A> propriété, ou via le constructeur). Si le <xref:System.Diagnostics.EventLog.Source%2A> a été spécifié, <xref:System.Diagnostics.EventLog.Log%2A> retourne le nom du journal dans lequel cette source a été inscrite.  
  
 Une source peut uniquement être inscrit dans un journal à la fois. Si le <xref:System.Diagnostics.EventLog.Source%2A> propriété a été définie pour une instance de <xref:System.Diagnostics.EventLog>, vous ne pouvez pas modifier le <xref:System.Diagnostics.EventLog.Log%2A> propriété pour que <xref:System.Diagnostics.EventLog> sans modifier la valeur de <xref:System.Diagnostics.EventLog.Source%2A> ou en appelant <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> première. Si vous modifiez le <xref:System.Diagnostics.EventLog.Log%2A> propriété après la <xref:System.Diagnostics.EventLog.Source%2A> propriété a été définie, l’écriture d’une entrée de journal lève une exception.  
  
 Le système d’exploitation stocke les journaux des événements sous forme de fichiers. Lorsque vous utilisez <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour créer un nouveau journal des événements, le fichier associé est stocké dans le répertoire %SystemRoot%\System32\Config sur l’ordinateur spécifié. Le nom de fichier est défini en ajoutant les 8 premiers caractères de la <xref:System.Diagnostics.EventLog.Log%2A> propriété avec l’extension de nom de fichier « .evt ».  
  
 Impossible de créer un nouveau journal à l’aide du <xref:System.Diagnostics.EventLog.Log%2A> propriété autonome (sans spécification d’une source pour le journal). Vous pouvez appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, en passant un nouveau nom de journal en tant que paramètre, puis appelez <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Toutefois, l’intention est généralement de créer (et écrire des entrées dans) nouveaux journaux spécifiques à l’application, ou pour lire à partir de journaux existants.  
  
 Si le <xref:System.Diagnostics.EventLog.Log%2A> valeur change, le journal des événements est fermé et tous les descripteurs d’événement sont libérés.  
  
> [!CAUTION]
>  Si vous définissez la <xref:System.Diagnostics.EventLog.Log%2A> propriété le nom d’un journal qui n’existe pas, le système attache le <xref:System.Diagnostics.EventLog> dans le journal des applications, mais ne vous avertit pas qu’il utilise un journal autre que celui que vous avez spécifié.  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements, « NewEventLog », sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom convivial du journal des événements.</summary>
        <value>Nom qui représente le journal des événements dans l'observateur d'événements du système.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans Windows Vista et versions ultérieures, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité. Si vous exécutez Windows Vista ou version ultérieure en tant qu’utilisateur, vous obtiendrez un <xref:System.Security.SecurityException> lorsque vous tentez d’accéder au nom d’affichage pour un événement dans le journal de sécurité.  
>   
>  Dans Windows Vista et version ultérieure, le contrôle de compte d'utilisateur détermine les privilèges d'un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède au journal de sécurité, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche le <xref:System.Diagnostics.EventLog.LogDisplayName%2A> pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Spécifié <see cref="P:System.Diagnostics.EventLog.Log" /> n’existe pas dans le Registre pour cet ordinateur.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nom de la source d'événements.</param>
        <param name="machineName">Nom de l'ordinateur sur lequel la recherche doit être effectuée ou "." pour l'ordinateur local.</param>
        <summary>Obtient le nom du journal dans lequel la source spécifiée est inscrite.</summary>
        <returns>Nom du journal associé à la source spécifiée dans le Registre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La source d’événements indique ce qui consigne l’événement. Il est souvent le nom de l’application ou le nom d’un sous-composant de l’application, si l’application est volumineuse. Applications et services doivent écrire dans le journal des applications ou d’un journal personnalisé. Pilotes de périphérique doivent écrire dans le journal système.  
  
 Lorsque vous créez une nouvelle source, qui ne peut écrire dans un journal à la fois, le système inscrit votre application avec le journal des événements comme source valide d’entrées. Le <xref:System.Diagnostics.EventLog.Source%2A> propriété peut être n’importe quelle chaîne, mais le nom ne peut pas être utilisé par d’autres sources sur l’ordinateur. Une tentative de création dupliqué <xref:System.Diagnostics.EventLog.Source%2A> valeur lève une exception. Toutefois, un seul journal des événements peut avoir de nombreuses sources différentes, l’écriture dans celle-ci.  
  
   
  
## Examples  
 L’exemple suivant supprime une source de l’ordinateur local. L’exemple détermine le journal à partir de sa source, puis supprime le journal.  
  
> [!NOTE]
>  Plusieurs sources peuvent écrire dans un journal des événements. Avant de supprimer un journal personnalisé, assurez-vous qu’il n’existe aucune autre source écrit dans ce journal.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'ordinateur à utiliser pour lire ou écrire les événements.</summary>
        <value>Nom du serveur sur lequel le journal des événements réside. La valeur par défaut est l'ordinateur local (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous écrivez dans un journal des événements, vous devez associer un <xref:System.Diagnostics.EventLog.Source%2A> avec votre objet de journal des événements pour vous connecter à un journal particulier. Il n’est pas nécessaire de spécifier le <xref:System.Diagnostics.EventLog.Source%2A> propriété lors de la lecture à partir d’un journal. Vous pouvez spécifier uniquement le <xref:System.Diagnostics.EventLog.Log%2A> nom et <xref:System.Diagnostics.EventLog.MachineName%2A> (nom de l’ordinateur serveur).  
  
> [!NOTE]
>  Vous ne devez pas spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé.  
  
 Une source peut uniquement être inscrit dans un journal à la fois. Si le <xref:System.Diagnostics.EventLog.Source%2A> propriété a été définie pour une instance de <xref:System.Diagnostics.EventLog>, vous ne pouvez pas modifier le <xref:System.Diagnostics.EventLog.MachineName%2A> propriété pour que <xref:System.Diagnostics.EventLog> sans modifier la valeur de <xref:System.Diagnostics.EventLog.Source%2A> ou en appelant <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> première. Si vous modifiez le <xref:System.Diagnostics.EventLog.MachineName%2A> propriété, le <xref:System.Diagnostics.EventLog> ferme tous les handles et se rattache dans le journal et de la source sur le nouvel ordinateur.  
  
 Le <xref:System.Diagnostics.EventLog.MachineName%2A> valeur ne peut pas être une chaîne vide. Si elle n’est pas explicitement définie, par défaut sur l’ordinateur local («. »).  
  
   
  
## Examples  
 L’exemple suivant lit les entrées dans le journal des événements, « NewEventLog », sur un ordinateur spécifié.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom d’ordinateur n’est pas valide.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille maximale du journal des événements en kilo-octets.</summary>
        <value>Taille maximale du journal des événements en kilo-octets. La valeur par défaut est 512. Elle correspond à une taille de fichier maximale de 512 kilo-octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propriété représente la limite de taille du fichier journal des événements. Lorsque le journal des événements atteint la limite de taille configurée <xref:System.Diagnostics.EventLog.OverflowAction%2A> valeur détermine si les nouvelles entrées sont ignorées, ou si les nouvelles entrées remplacent les entrées plus anciennes.  
  
> [!NOTE]
>  Cette propriété représente un paramètre de configuration du journal des événements représenté par cette instance. Lorsque le journal des événements atteint sa taille maximale, cette propriété spécifie la façon dont le système d’exploitation gère les nouvelles entrées écrites par toutes les sources d’événements inscrits pour le journal des événements.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche les détails de configuration pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée est inférieure à 64, supérieure à 4 194 240 ou pas un multiple pair de 64.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="P:System.Diagnostics.EventLog.Log" /> valeur n’est pas un nom de journal valide.  
  
\- ou - 
La clé de Registre du journal des événements n’a pas pu être ouvert sur l’ordinateur cible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique la durée de conservation en jours des entrées du journal des événements.</summary>
        <value>Durée de conservation en jours des entrées du journal des événements. La valeur par défaut est 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> propriété à examiner le paramètre actuel d’un journal des événements. Utilisez <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> pour modifier le nombre minimal de jours pendant lesquels chaque entrée dans le journal des événements doit être conservée.  
  
 Le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeur varie selon le comportement de dépassement de capacité configuré du journal des événements. Si le <xref:System.Diagnostics.OverflowAction> propriété pour un journal des événements est définie sur <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, puis le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeur est 0. Si le <xref:System.Diagnostics.OverflowAction> propriété pour un journal des événements est définie sur <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, puis le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeur est -1. Si le <xref:System.Diagnostics.OverflowAction> propriété pour un journal des événements est définie sur <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, puis le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valeur est supérieure à zéro et représente le nombre de jours pendant lesquels conserver les entrées de journal des événements lorsque le journal des événements est plein.  
  
 Le comportement de dépassement de capacité se produit uniquement lorsqu’un journal des événements atteint sa limite de taille. Quand un <xref:System.Diagnostics.EventLog> a son <xref:System.Diagnostics.EventLog.OverflowAction%2A> défini sur <xref:System.Diagnostics.OverflowAction.OverwriteOlder>et le journal des événements atteint sa taille maximale, puis les nouvelles entrées sont écrites uniquement si elles peuvent remplacer les entrées dont âge dépasse le <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> période. En conservant les entrées d’événements pendant une période minimale est appropriée lorsque le journal des événements est archivé régulièrement. Sinon, vous risquez de perdre des nouvelles entrées lorsque le journal des événements atteint sa limite. Pour éviter de perdre les nouvelles informations d’événement, définissez les jours de rétention minimale pour les événements en fonction de votre planification d’archivage pour le journal des événements spécifique.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche les détails de configuration pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">Comportement de dépassement de capacité pour l'écriture de nouvelles entrées dans le journal des événements.</param>
        <param name="retentionDays">Durée minimale exprimée en jours de conservation de chaque entrée du journal des événements. Ce paramètre n'est utilisé que si <paramref name="action" /> a la valeur <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Modifie le comportement configuré pour l'écriture de nouvelles entrées quand le journal des événements atteint sa taille de fichier maximale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement de dépassement de capacité pour un journal des événements indique que se passe-t-il lorsque de nouvelles entrées doivent être écrites dans un journal qui a atteint sa taille maximale de fichier.  
  
> [!NOTE]
>  Le comportement de dépassement de capacité prend effet uniquement quand un journal des événements atteint sa taille maximale de fichier. Le comportement de dépassement de capacité n’affecte pas l’écriture d’une nouvelle entrée dans un journal qui peut prendre en charge les entrées de journal des événements supplémentaires.  
  
 Le <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> méthode configure le comportement de dépassement de capacité d’un journal des événements. <xref:System.Diagnostics.EventLog> instance. Après avoir appelé cette méthode pour le journal des événements spécifié par le <xref:System.Diagnostics.EventLog.Log%2A> propriété, le <xref:System.Diagnostics.EventLog.OverflowAction%2A> et <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> les valeurs de propriété reflètent le comportement de dépassement de capacité qui vient d’être configuré.  
  
> [!NOTE]
>  Cette propriété représente un paramètre de configuration du journal des événements représenté par cette instance. Lorsque le journal des événements atteint sa taille maximale, cette propriété spécifie la façon dont le système d’exploitation gère les nouvelles entrées écrites par toutes les sources d’événements inscrits pour le journal des événements.  
  
 Définir le `action` paramètre <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> pour indiquer qu’une nouvelle entrée remplace l’entrée la plus ancienne lorsque le <xref:System.Diagnostics.EventLog> atteint sa taille maximale. Si le `action` paramètre est défini sur <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, le `retentionDays` valeur du paramètre est ignorée.  
  
 Définir le `action` paramètre <xref:System.Diagnostics.OverflowAction.OverwriteOlder> pour indiquer que chaque nouvelle entrée remplace les entrées plus anciennes lorsque le <xref:System.Diagnostics.EventLog> atteint sa taille maximale. Spécifiez le nombre de jours pendant lesquels les événements doivent être conservées dans le journal à l’aide de le `retentionDays` paramètre. Les événements écrits dans la plage de rétention ne sont pas remplacées par les nouvelles entrées.  
  
 Définir le `action` paramètre <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> pour ignorer les nouveaux événements lorsque la taille maximale du journal est atteinte. Si le `action` paramètre est défini sur <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, le `retentionDays` valeur du paramètre est ignorée.  
  
> [!CAUTION]
>  Définition de la stratégie de dépassement de capacité <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> Spécifie que les nouvelles entrées sont ignorées lorsque le journal des événements est plein. Si vous utilisez ce paramètre, vérifiez le journal des événements est régulièrement archivé et désactivé pour éviter d’atteindre sa limite de taille maximale.  
  
   
  
## Examples  
 L’exemple suivant affiche la stratégie de dépassement de capacité configuré pour un journal des événements spécifié et permet à l’utilisateur sélectionner un nouveau paramètre de stratégie de dépassement de capacité du journal des événements.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> n’est pas une valeur de <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> est inférieur à 1, ou supérieur à 365.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="P:System.Diagnostics.EventLog.Log" /> valeur n’est pas un nom de journal valide.  
  
\- ou - 
La clé de Registre du journal des événements n’a pas pu être ouvert sur l’ordinateur cible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le comportement configuré pour le stockage des nouvelles entrées quand le journal des événements atteint sa taille de fichier maximale.</summary>
        <value>Valeur <see cref="T:System.Diagnostics.OverflowAction" /> qui spécifie le comportement configuré pour le stockage des nouvelles entrées quand le journal des événements atteint sa taille maximale. La valeur par défaut est <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Taille augmente les journaux des événements comme l’écriture de nouveaux événements. Chaque journal des événements a une limite de taille maximale configurée ; le <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propriété définit le nombre maximal de kilo-octets autorisés pour la taille du fichier journal des événements.  
  
 Utilisez le <xref:System.Diagnostics.EventLog.OverflowAction%2A> valeur de propriété à examiner le comportement de dépassement de capacité configuré pour un journal des événements atteint sa taille maximale. Utilisez le <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> méthode pour modifier le comportement de dépassement de capacité pour un journal des événements.  
  
> [!NOTE]
>  Le comportement de dépassement de capacité prend effet uniquement quand un journal des événements atteint sa taille maximale de fichier. Le comportement de dépassement de capacité n’affecte pas l’écriture d’une nouvelle entrée dans un journal qui peut prendre en charge les entrées de journal des événements supplémentaires.  
  
   
  
## Examples  
 L’exemple suivant énumère les journaux des événements définis sur l’ordinateur local et affiche les détails de configuration pour chaque journal des événements.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Chemin d’accès spécifié complet d’un fichier de ressources localisé.</param>
        <param name="resourceId">Identificateur de ressource qui indexe une chaîne localisée dans le fichier de ressources.</param>
        <summary>Spécifie le nom localisé du journal des événements qui est affiché sur l'Observateur d'événements du serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> pour enregistrer et afficher un nom localisé dans l’Observateur d’événements pour les journaux des événements personnalisés.  
  
 L’identificateur de ressource spécifié doit correspondre à une chaîne localisée définie dans le fichier de ressources. L’Observateur d’événements affiche le nom de journal des événements personnalisé à l’aide de la chaîne localisée et les paramètres de culture actuels. Par exemple, vous pouvez définir plusieurs noms de journal des événements localisées pour différentes cultures dans votre fichier de ressources. L’Observateur d’événements affiche la chaîne localisée correspondant aux paramètres de culture de l’utilisateur actuel.  
  
 Si l’Observateur d’événements ne peut pas charger la chaîne localisée du fichier de ressources, ou si aucun nom d’affichage a été enregistré pour le journal des événements, l’Observateur d’événements affiche le nom du journal des événements défini dans <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Vous n’avez pas besoin d’inscrire un nom d’affichage pour les journaux des événements prédéfinis. Le système d’exploitation inscrit les noms d’affichage localisé pour les journaux des événements Application, système et sécurité.  
  
   
  
## Examples  
 L’exemple suivant détermine si la source d’événements nommée `SampleApplicationSource` est inscrite sur l’ordinateur local. Si la source d’événements n’existe pas, l’exemple définit le fichier de ressources de message pour la source et crée la nouvelle source d’événements. Enfin, l’exemple définit le nom complet localisé du journal des événements, à l’aide de la valeur d’identificateur de ressource dans `DisplayNameMsgId` et le chemin d’accès du fichier de ressources dans `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 L’exemple utilise le fichier de texte de message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir duquel le fichier de ressource de message est créé. Le fichier de texte de message définit les identificateurs de ressource et le texte pour la catégorie, message d’événement et chaînes d’insertion de paramètre. Plus précisément, l’identificateur de ressource 5001 est défini pour le nom localisé du journal des événements.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="P:System.Diagnostics.EventLog.Log" /> valeur n’est pas un nom de journal valide.  
  
\- ou - 
La clé de Registre du journal des événements n’a pas pu être ouvert sur l’ordinateur cible.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour administrer les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de la source à inscrire et à utiliser pendant l'écriture d'entrées dans le journal des événements.</summary>
        <value>Nom inscrit avec le journal des événements comme source des entrées. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La source d’événements indique ce qui consigne l’événement. Il est souvent le nom de l’application ou le nom d’un sous-composant de l’application, si l’application est volumineuse. Applications et services doivent écrire dans le journal des applications ou d’un journal personnalisé. Pilotes de périphérique doivent écrire dans le journal système.  
  
 Vous devez uniquement spécifier une source d’événement, si vous écrivez dans un journal des événements. Avant d’écrire une entrée dans un journal des événements, vous devez inscrire la source d’événements avec le journal des événements comme source valide d’événements. Lorsque vous écrivez une entrée de journal, le système utilise le <xref:System.Diagnostics.EventLog.Source%2A> propriété à rechercher le journal approprié dans lequel placer votre entrée. Si vous lisez le journal des événements, vous pouvez spécifier le <xref:System.Diagnostics.EventLog.Source%2A>, ou un <xref:System.Diagnostics.EventLog.Log%2A> et <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Vous n’êtes pas obligé de spécifier le <xref:System.Diagnostics.EventLog.MachineName%2A> si vous vous connectez à un journal sur l’ordinateur local. Si vous ne spécifiez pas le <xref:System.Diagnostics.EventLog.MachineName%2A>, l’ordinateur local («. ») est supposé.  
  
 Utilisez <xref:System.Diagnostics.EventLog.WriteEvent%2A> et <xref:System.Diagnostics.EventLog.WriteEntry%2A> pour écrire des événements dans un journal des événements. Vous devez spécifier une source d’événement pour écrire des événements ; Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Vous pouvez créer une source d’événement pour un journal des événements existant ou un journal des événements. Lorsque vous créez une nouvelle source pour un journal des événements, le système inscrit la source de ce journal, mais le journal n’est pas créé jusqu'à ce que la première entrée est écrites.  
  
 La source doit être unique sur l’ordinateur local ; un nouveau nom de source ne peut pas correspondre à un nom de source existant ou un nom de journal des événements existant. Chaque source peut écrire qu’un seul journal des événements à la fois. Toutefois, votre application peut utiliser plusieurs sources pour écrire dans plusieurs journaux des événements. Par exemple, votre application peut nécessiter plusieurs sources configurés pour des journaux des événements ou des fichiers de ressources différents.  
  
 Si vous modifiez le <xref:System.Diagnostics.EventLog.Source%2A> valeur, le <xref:System.Diagnostics.EventLog> pour lequel elle est inscrite est fermée et tous les descripteurs d’événement sont libérés.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
 Pour modifier les détails de configuration d’une source existante, vous devez supprimer la source et puis créez-le avec la nouvelle configuration. Si d’autres applications ou composants utilisent la source existante, créez une nouvelle source avec la configuration mise à jour, plutôt que de supprimer la source existante.  
  
> [!NOTE]
>  Si une source a déjà été mappée à un journal et vous remappez à un nouveau journal, vous devez redémarrer l’ordinateur pour que les modifications entrent en vigueur.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche un Registre de l'ordinateur pour une source d'événements donnée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nom de la source d'événements.</param>
        <summary>Détermine si une source d'événements est inscrite dans l'ordinateur local.</summary>
        <returns>
          <see langword="true" /> si la source d'événements est inscrite sur l'ordinateur local ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer si une source d’événements existe sur l’ordinateur local. Si vous souhaitez déterminer si un journal existe sur l’ordinateur local, utilisez <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Étant donné que cette méthode accède au Registre, vous devez disposer des autorisations de Registre appropriées sur l’ordinateur local ; Sinon, un <xref:System.Security.SecurityException> sera levée.  
  
> [!NOTE]
>  Pour rechercher une source d’événements dans Windows Vista et versions ultérieures ou de Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  À compter de Windows Vista, le contrôle de compte utilisateur (UAC) détermine les privilèges d’un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
> [!NOTE]
>  Un service qui s’exécute sous le <xref:System.ServiceProcess.ServiceAccount.LocalSystem> compte ne dispose pas des privilèges requis pour exécuter cette méthode. La solution consiste à vérifier si la source d’événements existe dans le <xref:System.ServiceProcess.ServiceInstaller>, et si elle n’existe pas, pour créer la source dans le programme d’installation.  
  
 Étant donné que vous ne pouvez pas donner une nouvelle source le nom d’une source existante sur le même ordinateur, utilisez cette méthode avant d’essayer d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour vérifier qu’une source avec le nom spécifié par `source` n’existe pas déjà sur l’ordinateur local. Le `source` paramètre ne respecte pas la casse.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> n’a été trouvée, mais certains ou tous les journaux des événements ne peuvent pas rechercher.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nom de la source d'événements.</param>
        <param name="machineName">Nom de l'ordinateur sur lequel la recherche doit être effectuée ou "." pour l'ordinateur local.</param>
        <summary>Détermine si une source d'événements est inscrite dans un ordinateur spécifié.</summary>
        <returns>
          <see langword="true" /> si la source d'événements est inscrite sur l'ordinateur spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer si une source d’événements existe sur l’ordinateur spécifié par le `machineName` paramètre. Si vous souhaitez déterminer si un journal existe sur l’ordinateur spécifié, utilisez <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Étant donné que cette méthode accède au Registre, vous devez disposer des autorisations de Registre appropriées sur le serveur donné ; Sinon, un <xref:System.Security.SecurityException> sera levée.  
  
> [!NOTE]
>  Pour rechercher une source d’événements dans Windows Vista et versions ultérieures ou de Windows Server 2003, vous devez disposer des privilèges d’administrateur.  
>   
>  La raison de cette exigence est que tous les journaux des événements, y compris la sécurité, doivent être recherchés pour déterminer si la source d’événements est unique. À compter de Windows Vista, les utilisateurs n’êtes pas autorisé à accéder au journal de sécurité ; Par conséquent, un <xref:System.Security.SecurityException> est levée.  
>   
>  À compter de Windows Vista, le contrôle de compte utilisateur (UAC) détermine les privilèges d’un utilisateur. Si vous êtes membre du groupe Administrateurs intégrés, deux jetons d'accès au moment de l'exécution vous sont assignés : un jeton d'accès utilisateur standard et un jeton d'accès administrateur. Par défaut, vous êtes dans le rôle d'utilisateur standard. Pour exécuter le code qui accède aux compteurs de performances, vous devez d’abord élever vos privilèges d’utilisateur standard à administrateur. Vous pouvez effectuer cela au démarrage d'une application en cliquant avec le bouton droit sur l'icône de l'application et en indiquant que vous voulez l'exécuter en tant qu'administrateur.  
  
> [!NOTE]
>  Un service qui s’exécute sous le <xref:System.ServiceProcess.ServiceAccount.LocalSystem> compte ne dispose pas des privilèges requis pour exécuter cette méthode. La solution consiste à vérifier si la source d’événements existe dans le <xref:System.ServiceProcess.ServiceInstaller>, et si elle n’existe pas, pour créer la source dans le programme d’installation.  
  
 Étant donné que vous ne pouvez pas donner une nouvelle source le nom d’une source existante sur le même ordinateur, utilisez cette méthode avant d’essayer d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> pour vérifier qu’une source avec le nom spécifié par `source` n’existe pas déjà sur l’ordinateur. Le `source` et `machineName` paramètres ne respectent pas la casse.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> est un `static` (méthode), il peut donc être appelée sur la classe elle-même. Il n’est pas nécessaire de créer une instance de <xref:System.Diagnostics.EventLog> pour appeler <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` sur l’ordinateur `MyServer`et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> est un nom d’ordinateur non valide.</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> n’a été trouvée, mais certains ou tous les journaux des événements ne peuvent pas rechercher.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’objet utilisé pour marshaler des appels du gestionnaire d’événements consécutifs à un événement EntryWritten de <see cref="T:System.Diagnostics.EventLog" /></summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> utilisé pour marshaler des appels du gestionnaire d'événements émis à la suite d'un événement <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> dans le journal des événements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> est `null`, méthodes gérant le <xref:System.Diagnostics.EventLog.EntryWritten> événement sont appelées sur un thread du pool de threads système. Pour plus d’informations sur les pools de threads système, consultez <xref:System.Threading.ThreadPool>.  
  
 Lorsque le <xref:System.Diagnostics.EventLog.EntryWritten> événement est géré par un formulaire Windows visual composant, tel qu’un bouton, l’accès au composant via le pool de threads système peut ne pas fonctionne, ou peut entraîner une exception. Éviter ce problème en définissant <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> à un composant Windows Forms, ce qui provoque les méthodes gérant le <xref:System.Diagnostics.EventLog.EntryWritten> événement à appeler sur le même thread que celui sur lequel le composant a été créé.  
  
 Si le <xref:System.Diagnostics.EventLog> est utilisé à l’intérieur de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] dans un concepteur Windows Forms, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> est automatiquement défini sur le contrôle contenant le <xref:System.Diagnostics.EventLog>. Par exemple, si vous placez un <xref:System.Diagnostics.EventLog> sur un concepteur pour Form1 (qui hérite <xref:System.Windows.Forms.Form>) le <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> propriété du <xref:System.Diagnostics.EventLog> est définie sur l’instance de Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit une entrée dans le journal des événements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <summary>Écrit une entrée de type information, avec le texte de message donné, dans le journal des événements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée d’informations dans le journal des événements associé à cet <xref:System.Diagnostics.EventLog> instance. Si vous souhaitez spécifier n’importe quel autre <xref:System.Diagnostics.EventLogEntryType>, utilisez une autre surcharge de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appels <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> instance avant d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  Nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) peut-être pas ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Diagnostics.EventLog.Source" /> propriété de la <see cref="T:System.Diagnostics.EventLog" /> n’a pas été définie.  
  
- ou - 
La méthode a tenté d’inscrire une source d’événement, mais le nom d’ordinateur dans <see cref="P:System.Diagnostics.EventLog.MachineName" /> n’est pas valide.  
  
\- ou - 
La source est déjà inscrite pour un journal des événements différent.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <param name="type">Une des valeurs de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Écrit une entrée d'erreur, d'avertissement, d'information, d'audit des succès ou des échecs avec le texte de message donné, dans le journal des événements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée d’une certaine <xref:System.Diagnostics.EventLogEntryType> dans le journal des événements. Le `type` est indiqué par une icône et du texte dans la colonne de Type dans l’Observateur d’événements pour un journal.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appels <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> instance avant d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  De nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) peut-être pas ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée d’avertissement dans un journal des événements, « MyNewLog », sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Diagnostics.EventLog.Source" /> propriété de la <see cref="T:System.Diagnostics.EventLog" /> n’a pas été définie.  
  
- ou - 
La méthode a tenté d’inscrire une source d’événement, mais le nom d’ordinateur dans <see cref="P:System.Diagnostics.EventLog.MachineName" /> n’est pas valide.  
  
\- ou - 
La source est déjà inscrite pour un journal des événements différent.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> n’est pas un <see cref="T:System.Diagnostics.EventLogEntryType" /> valide.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Source grâce à laquelle l'application est inscrite sur l'ordinateur spécifié.</param>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <summary>Écrit une entrée de type information, avec le texte de message donné, dans le journal des événements, à l'aide de la source d'événements inscrite spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée d’informations dans le journal des événements à l’aide d’une source qui est déjà inscrit en tant que source d’événements pour le journal approprié. Si vous souhaitez spécifier n’importe quel autre <xref:System.Diagnostics.EventLogEntryType>, utilisez une autre surcharge de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
>   
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
   
  
## Examples  
 L’exemple suivant crée la source de `MySource` s’il n’existe pas déjà et écrit une entrée dans le journal des événements `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="source" /> valeur est une chaîne vide ( » »).  
  
\- ou - 
<paramref name="source" /> a la valeur <see langword="null" />.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <param name="type">Une des valeurs de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificateur spécifique à l'application pour l'événement.</param>
        <summary>Écrit une entrée avec le texte de message donné et l'identificateur d'événements défini par l'application, dans le journal des événements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée avec un défini par l’application `eventID` dans le journal des événements. Le `eventID` ainsi que la source identifient un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description auxquelles elles sont mappées. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et de suggérer les actions à entreprendre.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
 Outre l’identificateur d’événement, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et du texte dans la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, audit de réussite ou audit des échecs.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appels <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> instance avant d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  De nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) peut-être pas ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Diagnostics.EventLog.Source" /> propriété de la <see cref="T:System.Diagnostics.EventLog" /> n’a pas été définie.  
  
- ou - 
La méthode a tenté d’inscrire une source d’événement, mais le nom d’ordinateur dans <see cref="P:System.Diagnostics.EventLog.MachineName" /> n’est pas valide.  
  
\- ou - 
La source est déjà inscrite pour un journal des événements différent.  
  
\- ou - 
 <paramref name="eventID" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> n’est pas un <see cref="T:System.Diagnostics.EventLogEntryType" /> valide.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Source grâce à laquelle l'application est inscrite sur l'ordinateur spécifié.</param>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <param name="type">Une des valeurs de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Écrit une entrée d'erreur, d'avertissement, d'information, d'audit des succès ou des échecs avec le texte de message donné, dans le journal des événements, à l'aide de la source d'événements inscrite spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée d’une certaine <xref:System.Diagnostics.EventLogEntryType> dans le journal des événements, à l’aide d’une source déjà inscrite en tant que source d’événements pour le journal approprié. Le `type` est indiqué par une icône et du texte dans la colonne de Type dans l’Observateur d’événements pour un journal.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée d’avertissement dans un journal des événements, « MyNewLog », sur l’ordinateur local.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="source" /> valeur est une chaîne vide ( » »).  
  
\- ou - 
<paramref name="source" /> a la valeur <see langword="null" />.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> n’est pas un <see cref="T:System.Diagnostics.EventLogEntryType" /> valide.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <param name="type">Une des valeurs de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificateur spécifique à l'application pour l'événement.</param>
        <param name="category">Sous-catégorie spécifique à l'application associée au message.</param>
        <summary>Écrit une entrée avec le texte de message donné, l'identificateur de l'événement défini par l'application et la catégorie définie par l'application, dans le journal des événements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée avec un défini par l’application `category` dans le journal des événements. L’Observateur d’événements utilise la catégorie pour filtrer les événements écrits par une source d’événement. L’Observateur d’événements peut afficher la catégorie en tant que valeur numérique, ou il peut utiliser la catégorie comme identificateur de ressource pour afficher une chaîne de catégorie localisée.  
  
> [!NOTE]
>  Le `category` paramètre doit être une valeur positive. Les valeurs de catégorie négative s’affichent en tant qu’un nombre positif complémentaire de l’événement Observateur. Par exemple, -10 s’affiche en tant que forme 65 526 et, une valeur -1 à 65 535.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
 Pour afficher les chaînes de catégorie localisée dans l’Observateur d’événements, vous devez utiliser une source d’événement configuré avec un fichier de ressources de catégorie et définissez le `category` à un identificateur de ressource dans le fichier de ressources de catégorie. Si la source d’événements n’a pas un fichier de ressources de catégorie configuré ou spécifié `category` n’indexe pas une chaîne dans le fichier de ressources de catégorie, puis l’Observateur d’événements affiche la valeur de catégorie numérique pour cette entrée. Configurer le fichier de ressources de catégorie, ainsi que le nombre de chaînes de catégorie dans le fichier de ressources, à l’aide de la <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 En plus de la catégorie, vous pouvez spécifier un identificateur d’événement pour l’événement en cours d’écriture dans le journal des événements. Les identificateurs d’événements, ainsi que la source d’événements, identifient un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description auxquelles elles sont mappées. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et de suggérer les actions à entreprendre.  
  
 Enfin, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et du texte dans la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, audit de réussite ou audit des échecs.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appels <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> instance avant d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  De nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) peut-être pas ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Diagnostics.EventLog.Source" /> propriété de la <see cref="T:System.Diagnostics.EventLog" /> n’a pas été définie.  
  
- ou - 
La méthode a tenté d’inscrire une source d’événement, mais le nom d’ordinateur dans <see cref="P:System.Diagnostics.EventLog.MachineName" /> n’est pas valide.  
  
\- ou - 
La source est déjà inscrite pour un journal des événements différent.  
  
\- ou - 
 <paramref name="eventID" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> n’est pas un <see cref="T:System.Diagnostics.EventLogEntryType" /> valide.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Source grâce à laquelle l'application est inscrite sur l'ordinateur spécifié.</param>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <param name="type">Une des valeurs de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificateur spécifique à l'application pour l'événement.</param>
        <summary>Écrit une entrée avec le texte de message donné et l'identificateur d'événements défini par l'application, dans le journal des événements, à l'aide de la source d'événements inscrite spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée avec un défini par l’application `eventID` au journal des événements, à l’aide d’une source déjà inscrite en tant que source d’événements pour le journal approprié. Le `eventID`, ainsi que la source, identifient un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description auxquelles elles sont mappées. Observateurs d’événements présentent ces chaînes à l’utilisateur pour aider l’utilisateur à comprendre la cause du problème et de suggérer les actions à entreprendre.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
 En plus de l’identificateur d’événement, cette surcharge de <xref:System.Diagnostics.EventLog.WriteEntry%2A> vous permet de spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et du texte dans la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, audit de réussite ou audit des échecs.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="source" /> valeur est une chaîne vide ( » »).  
  
\- ou - 
<paramref name="source" /> a la valeur <see langword="null" />.  
  
\- ou - 
 <paramref name="eventID" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> n’est pas un <see cref="T:System.Diagnostics.EventLogEntryType" /> valide.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <param name="type">Une des valeurs de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificateur spécifique à l'application pour l'événement.</param>
        <param name="category">Sous-catégorie spécifique à l'application associée au message.</param>
        <param name="rawData">Tableau d'octets contenant les données binaires associées à l'entrée.</param>
        <summary>Écrit une entrée avec le texte de message donné, l'identificateur de l'événement défini par l'application et la catégorie définie par l'application, dans le journal des événements, et ajoute des données binaires au message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour écrire des données de spécifiques à l’événement défini par l’application dans le journal des événements. L’Observateur d’événements n’interprète pas ces données ; Il affiche les données brutes uniquement dans un format hexadécimal et texte combiné. Utiliser les données propres aux événements avec parcimonie, en incluant uniquement si vous êtes sûr qu’il sera utile à une personne déboguer le problème. Vous pouvez également utiliser des données propres aux événements pour stocker les informations de que l’application peut traiter indépendamment de l’Observateur d’événements. Par exemple, vous pourrez écrire une visionneuse spécifique pour vos événements, ou écrire un programme qui analyse le fichier journal et crée des rapports qui incluent des informations à partir des données spécifiques à l’événement.  
  
 Outre les données binaires, vous pouvez spécifier une catégorie définie par l’application et un identificateur d’événement défini par l’application. L’Observateur d’événements utilise la catégorie pour filtrer les événements écrits par une source d’événement. L’Observateur d’événements peut afficher la catégorie en tant que valeur numérique, ou il peut utiliser la catégorie comme identificateur de ressource pour afficher une chaîne de catégorie localisée.  
  
> [!NOTE]
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
> [!NOTE]
>  Le `category` paramètre doit être une valeur positive. Les valeurs de catégorie négative s’affichent en tant qu’un nombre positif complémentaire de l’événement Observateur. Par exemple, -10 s’affiche en tant que forme 65 526 et, une valeur -1 à 65 535.  
  
 Pour afficher les chaînes de catégorie localisée dans l’Observateur d’événements, vous devez utiliser une source d’événement configuré avec un fichier de ressources de catégorie et définissez le `category` à un identificateur de ressource dans le fichier de ressources de catégorie. Si la source d’événements n’a pas un fichier de ressources de catégorie configuré ou spécifié `category` n’indexe pas une chaîne dans le fichier de ressources de catégorie, puis l’Observateur d’événements affiche la valeur de catégorie numérique pour cette entrée. Configurer le fichier de ressources de catégorie, ainsi que le nombre de chaînes de catégorie dans le fichier de ressources, à l’aide de la <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Les identificateurs d’événements, ainsi que la source d’événements, identifient un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description auxquelles elles sont mappées. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et de suggérer les actions à entreprendre.  
  
 Enfin, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et du texte dans la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, audit de réussite ou audit des échecs.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant de pouvoir écrire des entrées dans le journal. Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source.  
  
 Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 Si la source spécifiée dans le <xref:System.Diagnostics.EventLog.Source%2A> propriété de ce <xref:System.Diagnostics.EventLog> instance n’est pas inscrit sur l’ordinateur sur lequel votre composant est écrit, <xref:System.Diagnostics.EventLog.WriteEntry%2A> appels <xref:System.Diagnostics.EventLog.CreateEventSource%2A> et inscrit la source.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> instance avant d’appeler <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, l’ordinateur local («. ») est supposé.  
  
 Si le système doit enregistrer le <xref:System.Diagnostics.EventLog.Source%2A> via un appel à <xref:System.Diagnostics.EventLog.WriteEntry%2A> et <xref:System.Diagnostics.EventLog.Log%2A> propriété n’a pas été définie sur votre <xref:System.Diagnostics.EventLog> instance, le journal par défaut est le journal des applications.  
  
> [!NOTE]
>  De nombreuses exceptions répertoriées ci-dessus sont générées par des erreurs déclenchées au cours du processus d’inscription de le <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur du message (la chaîne de texte) peut-être pas ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Diagnostics.EventLog.Source" /> propriété de la <see cref="T:System.Diagnostics.EventLog" /> n’a pas été définie.  
  
- ou - 
La méthode a tenté d’inscrire une source d’événement, mais le nom d’ordinateur dans <see cref="P:System.Diagnostics.EventLog.MachineName" /> n’est pas valide.  
  
\- ou - 
La source est déjà inscrite pour un journal des événements différent.  
  
\- ou - 
 <paramref name="eventID" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> n’est pas un <see cref="T:System.Diagnostics.EventLogEntryType" /> valide.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Source grâce à laquelle l'application est inscrite sur l'ordinateur spécifié.</param>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <param name="type">Une des valeurs de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificateur spécifique à l'application pour l'événement.</param>
        <param name="category">Sous-catégorie spécifique à l'application associée au message.</param>
        <summary>Écrit une entrée avec le texte de message donné, l'identificateur de l'événement défini par l'application et la catégorie définie par l'application, dans le journal des événements, à l'aide de la source d'événements inscrite spécifiée. L'Observateur d'événements peut utiliser <paramref name="category" /> pour le filtrage des événements du journal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée avec un défini par l’application `category` au journal des événements, à l’aide d’une source qui est déjà inscrit en tant que source d’événements pour le journal approprié. L’Observateur d’événements utilise la catégorie pour filtrer les événements écrits par une source d’événement. L’Observateur d’événements peut afficher la catégorie en tant que valeur numérique, ou il peut utiliser la catégorie comme identificateur de ressource pour afficher une chaîne de catégorie localisée.  
  
> [!NOTE]
>  Le `category` paramètre doit être une valeur positive. Les valeurs de catégorie négative s’affichent en tant qu’un nombre positif complémentaire de l’événement Observateur. Par exemple, -10 s’affiche en tant que forme 65 526 et, une valeur -1 à 65 535.  
  
 Pour afficher les chaînes de catégorie localisée dans l’Observateur d’événements, vous devez utiliser une source d’événement configuré avec un fichier de ressources de catégorie et définissez le `category` à un identificateur de ressource dans le fichier de ressources de catégorie. Si la source d’événements n’a pas un fichier de ressources de catégorie configuré ou spécifié `category` n’indexe pas une chaîne dans le fichier de ressources de catégorie, puis l’Observateur d’événements affiche la valeur de catégorie numérique pour cette entrée. Configurer le fichier de ressources de catégorie, ainsi que le nombre de chaînes de catégorie dans le fichier de ressources, à l’aide de la <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 En plus de la catégorie, vous pouvez spécifier un identificateur d’événement pour l’événement en cours d’écriture dans le journal des événements. Les identificateurs d’événements, ainsi que la source d’événements, identifient un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description auxquelles elles sont mappées. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et de suggérer les actions à entreprendre.  
  
 Enfin, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et du texte dans la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, audit de réussite ou audit des échecs.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
>   
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="source" /> valeur est une chaîne vide ( » »).  
  
\- ou - 
<paramref name="source" /> a la valeur <see langword="null" />.  
  
\- ou - 
 <paramref name="eventID" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> n’est pas un <see cref="T:System.Diagnostics.EventLogEntryType" /> valide.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Source grâce à laquelle l'application est inscrite sur l'ordinateur spécifié.</param>
        <param name="message">Chaîne à écrire dans le journal des événements.</param>
        <param name="type">Une des valeurs de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificateur spécifique à l'application pour l'événement.</param>
        <param name="category">Sous-catégorie spécifique à l'application associée au message.</param>
        <param name="rawData">Tableau d'octets contenant les données binaires associées à l'entrée.</param>
        <summary>Écrit une entrée avec le texte de message donné, l'identificateur de l'événement défini par l'application et la catégorie définie par l'application, dans le journal des événements (à l'aide de la source d'événements inscrite spécifiée), et ajoute des données binaires au message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire des données de spécifiques à l’événement défini par l’application dans le journal des événements, à l’aide d’une source déjà inscrite en tant que source d’événements pour le journal approprié. L’Observateur d’événements n’interprète pas ces données ; Il affiche les données brutes uniquement dans un format hexadécimal et texte combiné. Utilisez les données propres aux événements avec parcimonie ; inclure uniquement si vous êtes sûr qu’il sera utile. Vous pouvez également utiliser des données propres aux événements pour stocker les informations de que l’application peut traiter indépendamment de l’Observateur d’événements. Par exemple, vous pourrez écrire une visionneuse spécifique pour vos événements, ou écrire un programme qui analyse le fichier journal et crée des rapports qui incluent des informations à partir des données spécifiques à l’événement.  
  
 Outre les données binaires, vous pouvez spécifier une catégorie définie par l’application et un identificateur d’événement défini par l’application. L’Observateur d’événements utilise la catégorie pour filtrer les événements écrits par une source d’événement. L’Observateur d’événements peut afficher la catégorie en tant que valeur numérique, ou il peut utiliser la catégorie comme identificateur de ressource pour afficher une chaîne de catégorie localisée.  
  
> [!NOTE]
>  Le `category` paramètre doit être une valeur positive. Les valeurs de catégorie négative s’affichent en tant qu’un nombre positif complémentaire de l’événement Observateur. Par exemple, -10 s’affiche en tant que forme 65 526 et, une valeur -1 à 65 535.  
  
 Pour afficher les chaînes de catégorie localisée dans l’Observateur d’événements, vous devez utiliser une source d’événement configuré avec un fichier de ressources de catégorie et définissez le `category` à un identificateur de ressource dans le fichier de ressources de catégorie. Si la source d’événements n’a pas un fichier de ressources de catégorie configuré ou spécifié `category` n’indexe pas une chaîne dans le fichier de ressources de catégorie, puis l’Observateur d’événements affiche la valeur de catégorie numérique pour cette entrée. Configurer le fichier de ressources de catégorie, ainsi que le nombre de chaînes de catégorie dans le fichier de ressources, à l’aide de la <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Les identificateurs d’événements, ainsi que la source d’événements, identifient un événement. Chaque application peut définir ses propres événements numérotés et les chaînes de description auxquelles elles sont mappées. Observateurs d’événements affichent ces valeurs de chaîne pour aider l’utilisateur à comprendre la cause du problème et de suggérer les actions à entreprendre.  
  
 Enfin, vous pouvez spécifier un <xref:System.Diagnostics.EventLogEntryType> pour l’événement en cours d’écriture dans le journal des événements. Le `type` est indiqué par une icône et du texte dans la colonne de Type dans l’Observateur d’événements pour un journal. Ce paramètre indique si le type d’événement est erreur, avertissement, information, audit de réussite ou audit des échecs.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode écrit la chaîne donnée directement dans le journal des événements ; elle n’utilise pas un fichier de ressources du message localisable. Utilisez le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des événements à l’aide d’un fichier de ressources du message localisé.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si le `message` paramètre contient un caractère NUL, le message dans le journal des événements est arrêté au caractère NUL.  
>   
>  Le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="source" /> valeur est une chaîne vide ( » »).  
  
\- ou - 
<paramref name="source" /> a la valeur <see langword="null" />.  
  
\- ou - 
 <paramref name="eventID" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
La chaîne de message est supérieure à 31 839 octets (32 766 octets sur les systèmes d’exploitation Windows avant Windows Vista).  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> n’est pas un <see cref="T:System.Diagnostics.EventLogEntryType" /> valide.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit une entrée d'événement localisée dans le journal des événements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Instance de <see cref="T:System.Diagnostics.EventInstance" /> qui représente une entrée localisée dans le journal des événements.</param>
        <param name="values">Tableau de chaînes à fusionner dans le texte du message de l’entrée de journal des événements.</param>
        <summary>Écrit une entrée localisée dans le journal des événements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée localisée dans le journal des événements. Vous spécifiez les propriétés d’événements avec les identificateurs de ressource au lieu des valeurs de chaîne. L’Observateur d’événements utilise les identificateurs de ressource pour afficher les chaînes correspondantes à partir du fichier de ressource localisée pour le <xref:System.Diagnostics.EventLog.Source%2A>. Vous devez inscrire la source avec le fichier de ressources correspondant avant d’écrire des événements à l’aide d’identificateurs de ressource.  
  
 L’entrée `instance` instance spécifie les propriétés et le message d’événement. Définir le <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` d’entrée pour le message défini dans le fichier de ressources du message source. Vous pouvez éventuellement définir le <xref:System.Diagnostics.EventInstance.CategoryId%2A> et <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrée pour définir la catégorie et type d’événement de votre entrée d’événement. Vous pouvez également spécifier un tableau de chaînes indépendants du langage à insérer dans le texte du message localisé. Définissez `values` à `null` si le message d’événement ne contient pas de mise en forme des espaces réservés pour les chaînes de remplacement.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant d’utiliser <xref:System.Diagnostics.EventLog.WriteEvent%2A>. La source spécifiée doit être configurée pour écrire des entrées localisées dans le journal ; la source doit au moins avoir un fichier de ressources de message défini.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Utilisez le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode si votre application écrit les valeurs de chaîne directement dans le journal des événements.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur de la `message` chaîne peut ne pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework. En outre, le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
   
  
## Examples  
 L’exemple suivant écrit deux entrées d’audit dans le journal des événements `myNewLog`. L’exemple crée une nouvelle source d’événements et un journal des événements si elles n’existent pas sur l’ordinateur local. Le texte de message d’événement est spécifié à l’aide d’un identificateur de ressource dans un fichier de ressources.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 L’exemple utilise le fichier de texte de message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir duquel le fichier de ressource de message est créé. Le fichier de texte de message définit les identificateurs de ressource et le texte pour la catégorie, message d’événement et chaînes d’insertion de paramètre.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Diagnostics.EventLog.Source" /> propriété de la <see cref="T:System.Diagnostics.EventLog" /> n’a pas été définie.  
  
- ou - 
La méthode a tenté d’inscrire une source d’événement, mais le nom d’ordinateur dans <see cref="P:System.Diagnostics.EventLog.MachineName" /> n’est pas valide.  
  
\- ou - 
La source est déjà inscrite pour un journal des événements différent.  
  
\- ou - 
 <paramref name="instance.InstanceId" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
 <paramref name="values" /> comporte plus de 256 éléments.  
  
\- ou - 
Parmi les <paramref name="values" /> éléments est dépasse 32 766 octets.  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Instance de <see cref="T:System.Diagnostics.EventInstance" /> qui représente une entrée localisée dans le journal des événements.</param>
        <param name="data">Tableau d'octets contenant les données binaires associées à l'entrée.</param>
        <param name="values">Tableau de chaînes à fusionner dans le texte du message de l’entrée de journal des événements.</param>
        <summary>Écrit une entrée dans un journal des événements avec les données d'événement, les chaînes de remplacement de message et les données binaires associées données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée localisée avec d’autres données spécifiques à l’événement dans le journal des événements. Vous spécifiez les propriétés d’événements avec les identificateurs de ressource au lieu des valeurs de chaîne. L’Observateur d’événements utilise les identificateurs de ressource pour afficher les chaînes correspondantes à partir du fichier de ressource localisée pour le <xref:System.Diagnostics.EventLog.Source%2A>. Vous devez inscrire la source avec le fichier de ressources correspondant avant d’écrire des événements à l’aide d’identificateurs de ressource.  
  
 L’entrée `instance` instance spécifie les propriétés et le message d’événement. Définir le <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` d’entrée pour le message défini dans le fichier de ressources du message source. Vous pouvez éventuellement définir le <xref:System.Diagnostics.EventInstance.CategoryId%2A> et <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrée pour définir la catégorie et type d’événement de votre entrée d’événement. Vous pouvez également spécifier un tableau de chaînes indépendants du langage à insérer dans le texte du message localisé. Définissez `values` à `null` si le message d’événement ne contient pas de mise en forme des espaces réservés pour les chaînes de remplacement.  
  
 Spécifiez les données binaires avec un événement lorsqu’il est nécessaire de fournir des détails supplémentaires pour l’événement. Par exemple, utiliser le `data` paramètre pour inclure des informations sur une erreur spécifique. L’Observateur d’événements n’interprète pas les données d’événement associées ; Il affiche les données dans un format hexadécimal et texte combiné. Utilisez les données propres aux événements avec parcimonie ; inclure uniquement si vous êtes sûr qu’il sera utile. Vous pouvez également utiliser des données propres aux événements pour stocker les informations de que l’application peut traiter indépendamment de l’Observateur d’événements. Par exemple, vous pourrez écrire une visionneuse spécifique pour vos événements, ou écrire un programme qui analyse le journal des événements et crée des rapports qui incluent des informations à partir des données spécifiques à l’événement.  
  
 Vous devez définir le <xref:System.Diagnostics.EventLog.Source%2A> propriété sur votre <xref:System.Diagnostics.EventLog> composant avant le composant avant d’utiliser <xref:System.Diagnostics.EventLog.WriteEvent%2A>. La source spécifiée doit être configurée pour écrire des entrées localisées dans le journal ; la source doit au moins avoir un fichier de ressources de message défini.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
> [!NOTE]
>  Si vous ne spécifiez pas un <xref:System.Diagnostics.EventLog.MachineName%2A> pour votre <xref:System.Diagnostics.EventLog> instance avant d’appeler <xref:System.Diagnostics.EventLog.WriteEvent%2A>, l’ordinateur local («. ») est supposé.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Utilisez le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode si votre application écrit les valeurs de chaîne directement dans le journal des événements.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
> [!NOTE]
>  Si vous écrivez une entrée à un ordinateur distant, la valeur de la `message` chaîne peut ne pas être ce que vous attendez si l’ordinateur distant ne fonctionne pas le .NET Framework. En outre, le `message` chaîne ne peut pas contenir %*n*, où *n* est une valeur entière (par exemple, %1), car l’Observateur d’événements traite comme une chaîne d’insertion. Car un Internet Protocol version 6 (IPv6) adresse peut contenir cette séquence de caractères, vous ne pouvez pas vous connecter un message d’événement qui contient une adresse IPv6.  
  
   
  
## Examples  
 L’exemple suivant écrit deux entrées d’audit dans le journal des événements `myNewLog`. L’exemple crée une nouvelle source d’événements et un journal des événements si elles n’existent pas sur l’ordinateur local. Le texte de message d’événement est spécifié à l’aide d’un identificateur de ressource dans un fichier de ressources.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 L’exemple utilise le fichier de texte de message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir duquel le fichier de ressource de message est créé. Le fichier de texte de message définit les identificateurs de ressource et le texte pour la catégorie, message d’événement et chaînes d’insertion de paramètre.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Diagnostics.EventLog.Source" /> propriété de la <see cref="T:System.Diagnostics.EventLog" /> n’a pas été définie.  
  
- ou - 
La méthode a tenté d’inscrire une source d’événement, mais le nom d’ordinateur dans <see cref="P:System.Diagnostics.EventLog.MachineName" /> n’est pas valide.  
  
\- ou - 
La source est déjà inscrite pour un journal des événements différent.  
  
\- ou - 
 <paramref name="instance.InstanceId" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
 <paramref name="values" /> comporte plus de 256 éléments.  
  
\- ou - 
Parmi les <paramref name="values" /> éléments est dépasse 32 766 octets.  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nom de la source d'événement inscrite pour l'application sur l'ordinateur spécifié.</param>
        <param name="instance">Instance de <see cref="T:System.Diagnostics.EventInstance" /> qui représente une entrée localisée dans le journal des événements.</param>
        <param name="values">Tableau de chaînes à fusionner dans le texte du message de l’entrée de journal des événements.</param>
        <summary>Écrit une entrée dans un journal des événements avec les données d'événement et les chaînes de remplacement de message à l'aide de la source d'événement inscrite spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée localisée dans le journal des événements à l’aide d’une source déjà inscrite en tant que source d’événements pour le journal approprié. Vous spécifiez les propriétés d’événements avec les identificateurs de ressource au lieu des valeurs de chaîne. L’Observateur d’événements utilise les identificateurs de ressource pour afficher les chaînes correspondantes à partir du fichier de ressource localisée pour la source. Vous devez inscrire la source avec le fichier de ressources correspondant avant d’écrire des événements à l’aide d’identificateurs de ressource.  
  
 L’entrée `instance` instance spécifie les propriétés et le message d’événement. Définir le <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` d’entrée pour le message défini dans le fichier de ressources du message source. Vous pouvez éventuellement définir le <xref:System.Diagnostics.EventInstance.CategoryId%2A> et <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrée pour définir la catégorie et type d’événement de votre entrée d’événement. Vous pouvez également spécifier un tableau de chaînes indépendants du langage à insérer dans le texte du message localisé. Définissez `values` à `null` si le message d’événement ne contient pas de mise en forme des espaces réservés pour les chaînes de remplacement.  
  
 La source spécifiée doit être inscrit pour un journal des événements avant d’utiliser <xref:System.Diagnostics.EventLog.WriteEvent%2A>. La source spécifiée doit être configurée pour écrire des entrées localisées dans le journal ; la source doit au moins avoir un fichier de ressources de message défini.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Utilisez le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode si votre application écrit les valeurs de chaîne directement dans le journal des événements.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée d’événement d’information et d’une entrée d’événement avertissement dans un journal des événements existant. Le texte de message d’événement est spécifié à l’aide d’un identificateur de ressource dans un fichier de ressources. L’exemple suppose que le fichier de ressources correspondant a été inscrit pour la source.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 L’exemple utilise le fichier de texte de message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir duquel le fichier de ressource de message est créé. Le fichier de texte de message définit les identificateurs de ressource et le texte pour la catégorie, message d’événement et chaînes d’insertion de paramètre.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="source" /> valeur est une chaîne vide ( » »).  
  
\- ou - 
<paramref name="source" /> a la valeur <see langword="null" />.  
  
\- ou - 
 <paramref name="instance.InstanceId" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
 <paramref name="values" /> comporte plus de 256 éléments.  
  
\- ou - 
Parmi les <paramref name="values" /> éléments est dépasse 32 766 octets.  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nom de la source d'événement inscrite pour l'application sur l'ordinateur spécifié.</param>
        <param name="instance">Instance de <see cref="T:System.Diagnostics.EventInstance" /> qui représente une entrée localisée dans le journal des événements.</param>
        <param name="data">Tableau d'octets contenant les données binaires associées à l'entrée.</param>
        <param name="values">Tableau de chaînes à fusionner dans le texte du message de l’entrée de journal des événements.</param>
        <summary>Écrit une entrée dans un journal des événements avec les données d'événement, les chaînes de remplacement de message et les données binaires associées données et à l'aide de la source d'événement inscrite spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour écrire une entrée localisée avec d’autres données spécifiques à l’événement dans le journal des événements à l’aide d’une source déjà inscrite en tant que source d’événements pour le journal approprié. Vous spécifiez les propriétés d’événements avec les identificateurs de ressource au lieu des valeurs de chaîne. L’Observateur d’événements utilise les identificateurs de ressource pour afficher les chaînes correspondantes à partir du fichier de ressource localisée pour la source. Vous devez inscrire la source avec le fichier de ressources correspondant avant d’écrire des événements à l’aide d’identificateurs de ressource.  
  
 L’entrée `instance` instance spécifie les propriétés et le message d’événement. Définir le <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` d’entrée pour le message défini dans le fichier de ressources du message source. Vous pouvez éventuellement définir le <xref:System.Diagnostics.EventInstance.CategoryId%2A> et <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrée pour définir la catégorie et type d’événement de votre entrée d’événement. Vous pouvez également spécifier un tableau de chaînes indépendants du langage à insérer dans le texte du message localisé. Définissez `values` à `null` si le message d’événement ne contient pas de mise en forme des espaces réservés pour les chaînes de remplacement.  
  
 Spécifiez les données binaires avec un événement lorsqu’il est nécessaire de fournir des détails supplémentaires pour l’événement. Par exemple, utiliser le `data` paramètre pour inclure des informations sur une erreur spécifique. L’Observateur d’événements n’interprète pas les données d’événement associées ; Il affiche les données dans un format hexadécimal et texte combiné. Utilisez les données propres aux événements avec parcimonie ; inclure uniquement si vous êtes sûr qu’il sera utile. Vous pouvez également utiliser des données propres aux événements pour stocker les informations de que l’application peut traiter indépendamment de l’Observateur d’événements. Par exemple, vous pourrez écrire une visionneuse spécifique pour vos événements, ou écrire un programme qui analyse le journal des événements et crée des rapports qui incluent des informations à partir des données spécifiques à l’événement.  
  
 La source spécifiée doit être inscrit pour un journal des événements avant d’utiliser <xref:System.Diagnostics.EventLog.WriteEvent%2A>. La source spécifiée doit être configurée pour écrire des entrées localisées dans le journal ; la source doit au moins avoir un fichier de ressources de message défini.  
  
 Vous devez créer et configurer la source d’événement avant l’écriture de la première entrée avec la source. Créer la nouvelle source d’événements pendant l’installation de votre application. Cela laisse le temps au système d’exploitation à actualiser sa liste de sources d’événements inscrites et leur configuration. Si le système d’exploitation n’a pas actualisé sa liste de sources d’événements, et que vous tentez d’écrire un événement avec la nouvelle source, que l’opération d’écriture échouera. Vous pouvez configurer une source en utilisant un <xref:System.Diagnostics.EventLogInstaller>, ou à l’aide de la <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (méthode). Vous devez disposer des droits d’administration sur l’ordinateur pour créer une source d’événement.  
  
 La source doit être configurée pour écrire des entrées localisées ou pour l’écriture de chaînes directes. Utilisez le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode si votre application écrit les valeurs de chaîne directement dans le journal des événements.  
  
 Si votre application écrit des entrées à l’aide d’identificateurs de ressource et de valeurs de chaîne, vous devez inscrire deux sources distinctes. Par exemple, configurez une source de fichiers de ressources et ensuite utiliser cette source dans le <xref:System.Diagnostics.EventLog.WriteEvent%2A> méthode pour écrire des entrées à l’aide d’identificateurs de ressource dans le journal des événements. Puis, créez une autre source sans les fichiers de ressources et utilisez-la dans le <xref:System.Diagnostics.EventLog.WriteEntry%2A> méthode pour écrire des chaînes directement dans le journal des événements à l’aide de cette source.  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée d’événement d’information et d’une entrée d’événement avertissement dans un journal des événements existant. Le texte de message d’événement est spécifié à l’aide d’un identificateur de ressource dans un fichier de ressources. L’exemple suppose que le fichier de ressources correspondant a été inscrit pour la source.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 L’exemple utilise le fichier de texte de message suivant, incorporé dans la bibliothèque de ressources EventLogMsgs.dll. Un fichier texte du message est la source à partir duquel le fichier de ressource de message est créé. Le fichier de texte de message définit les identificateurs de ressource et le texte pour la catégorie, message d’événement et chaînes d’insertion de paramètre.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <paramref name="source" /> valeur est une chaîne vide ( » »).  
  
\- ou - 
<paramref name="source" /> a la valeur <see langword="null" />.  
  
\- ou - 
 <paramref name="instance.InstanceId" /> est inférieur à 0 ou supérieur à <see cref="F:System.UInt16.MaxValue" />.  
  
\- ou - 
 <paramref name="values" /> comporte plus de 256 éléments.  
  
\- ou - 
Parmi les <paramref name="values" /> éléments est dépasse 32 766 octets.  
  
\- ou - 
Le nom de la source entraîne un chemin de clé de Registre dépassant 254 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La clé de Registre du journal des événements n’a pas pu être ouvert.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Le système d’exploitation a signalé une erreur lors de l’écriture de l’entrée d’événement dans le journal des événements. Un code d’erreur Windows n’est pas disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">pour écrire les informations du journal des événements sur l’ordinateur. Énumération associée : <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>