<Type Name="FileTracker" FullName="Microsoft.Build.Utilities.FileTracker">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e9f0b2b44271566e687ddc0b147ec2b873406511" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39956070" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class FileTracker" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed FileTracker extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Utilities.FileTracker" />
  <TypeSignature Language="VB.NET" Value="Public Class FileTracker" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileTracker abstract sealed" />
  <TypeSignature Language="F#" Value="type FileTracker = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Cette classe contient des fonctions utilitaires pour encapsuler le lancement et l'enregistrement du dispositif de suivi.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateRootingMarkerResponseFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un fichier réponse temporaire contenant le marqueur racine.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRootingMarkerResponseFile">
      <MemberSignature Language="C#" Value="public static string CreateRootingMarkerResponseFile (Microsoft.Build.Framework.ITaskItem[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateRootingMarkerResponseFile(class Microsoft.Build.Framework.ITaskItem[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile(Microsoft.Build.Framework.ITaskItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateRootingMarkerResponseFile (sources As ITaskItem()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateRootingMarkerResponseFile(cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="static member CreateRootingMarkerResponseFile : Microsoft.Build.Framework.ITaskItem[] -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile sources" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sources" Type="Microsoft.Build.Framework.ITaskItem[]" />
      </Parameters>
      <Docs>
        <param name="sources">Ensemble de fichiers sources.</param>
        <summary>À l'aide d'un ensemble de fichiers sources sous la forme d'ITaskItem, crée un fichier réponse temporaire contenant le marqueur de racine qui correspond à ces sources.</summary>
        <returns>Chemin d'accès au fichier réponse.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRootingMarkerResponseFile">
      <MemberSignature Language="C#" Value="public static string CreateRootingMarkerResponseFile (string rootMarker);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateRootingMarkerResponseFile(string rootMarker) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateRootingMarkerResponseFile (rootMarker As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateRootingMarkerResponseFile(System::String ^ rootMarker);" />
      <MemberSignature Language="F#" Value="static member CreateRootingMarkerResponseFile : string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile rootMarker" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootMarker" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rootMarker">Marqueur de racine à insérer dans le fichier réponse.</param>
        <summary>À l'aide d'un marqueur de racine, crée un fichier réponse temporaire contenant ce marqueur de racine.</summary>
        <returns>Chemin d'accès au fichier réponse.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTrackingContext">
      <MemberSignature Language="C#" Value="public static void EndTrackingContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndTrackingContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.EndTrackingContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndTrackingContext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndTrackingContext();" />
      <MemberSignature Language="F#" Value="static member EndTrackingContext : unit -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.EndTrackingContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête d'assurer le suivi des accès au fichier.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsureFileTrackerOnPath">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute le chemin d'accès à l'assembly FileTracker approprié à la variable d'environnement PATH.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsureFileTrackerOnPath">
      <MemberSignature Language="C#" Value="public static string EnsureFileTrackerOnPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureFileTrackerOnPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureFileTrackerOnPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EnsureFileTrackerOnPath();" />
      <MemberSignature Language="F#" Value="static member EnsureFileTrackerOnPath : unit -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ajoute le chemin d'accès à l'assembly FileTracker approprié à la variable d'environnement PATH. Utilisé pour le suivi d'inproc.</summary>
        <returns>Ancienne valeur de la variable d'environnement PATH.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureFileTrackerOnPath">
      <MemberSignature Language="C#" Value="public static string EnsureFileTrackerOnPath (string rootPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureFileTrackerOnPath(string rootPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureFileTrackerOnPath (rootPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EnsureFileTrackerOnPath(System::String ^ rootPath);" />
      <MemberSignature Language="F#" Value="static member EnsureFileTrackerOnPath : string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath rootPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rootPath">Chemin d'accès racine de FileTracker.dll. Remplace le toolType si spécifié.</param>
        <summary>Ajoute le chemin d'accès à l'assembly FileTracker approprié à la variable d'environnement PATH. Utilisé pour le suivi Inproc, ou lorsque .NET Framework ne peut pas se trouver sur le chemin d'accès.</summary>
        <returns>Ancienne valeur de PATH.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FileIsExcludedFromDependencies">
      <MemberSignature Language="C#" Value="public static bool FileIsExcludedFromDependencies (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FileIsExcludedFromDependencies(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.FileIsExcludedFromDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileIsExcludedFromDependencies (fileName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileIsExcludedFromDependencies(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member FileIsExcludedFromDependencies : string -&gt; bool" Usage="Microsoft.Build.Utilities.FileTracker.FileIsExcludedFromDependencies fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Chemin d'accès complet au fichier à tester</param>
        <summary>Vérifie si le fichier spécifié est exclu des dépendances faisant l'objet d'un suivi</summary>
        <returns>Retourne la valeur true si le fichier est exclu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FileIsUnderPath">
      <MemberSignature Language="C#" Value="public static bool FileIsUnderPath (string fileName, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FileIsUnderPath(string fileName, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.FileIsUnderPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileIsUnderPath (fileName As String, path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileIsUnderPath(System::String ^ fileName, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member FileIsUnderPath : string * string -&gt; bool" Usage="Microsoft.Build.Utilities.FileTracker.FileIsUnderPath (fileName, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Chemin d'accès complet au fichier à tester</param>
        <param name="path">Chemin d'accès qui peut contenir le fichier.</param>
        <summary>Vérifie si le fichier spécifié se trouve sous le chemin d'accès indiqué.</summary>
        <returns>Retourne la valeur true si le fichier est sous le chemin d'accès.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindTrackerOnPath">
      <MemberSignature Language="C#" Value="public static string FindTrackerOnPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string FindTrackerOnPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.FindTrackerOnPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindTrackerOnPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ FindTrackerOnPath();" />
      <MemberSignature Language="F#" Value="static member FindTrackerOnPath : unit -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.FindTrackerOnPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recherche %PATH% pour l'emplacement de Tracker.exe et retourne le premier chemin d'accès qui correspond. Chemin d'accès complet correspondant à Tracker.exe ou null, si aucun chemin d'accès correspondant n'est trouvé.</summary>
        <returns>Retourne le chemin d'accès à Tracker.exe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForceOutOfProcTracking">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si nous devons suivre en mode out-of-process ou si le suivi en mode in process fonctionnera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForceOutOfProcTracking">
      <MemberSignature Language="C#" Value="public static bool ForceOutOfProcTracking (Microsoft.Build.Utilities.ExecutableType toolType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForceOutOfProcTracking(valuetype Microsoft.Build.Utilities.ExecutableType toolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForceOutOfProcTracking (toolType As ExecutableType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForceOutOfProcTracking(Microsoft::Build::Utilities::ExecutableType toolType);" />
      <MemberSignature Language="F#" Value="static member ForceOutOfProcTracking : Microsoft.Build.Utilities.ExecutableType -&gt; bool" Usage="Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking toolType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
      </Parameters>
      <Docs>
        <param name="toolType">Type exécutable pour l'outil faisant l'objet d'un suivi</param>
        <summary>Détermine si nous devons suivre out-of-proc ou si le suivi d'inproc fonctionnera.</summary>
        <returns>True si nous devons effectuer un suivi out-of-proc. False si le suivi d'inproc convient.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceOutOfProcTracking">
      <MemberSignature Language="C#" Value="public static bool ForceOutOfProcTracking (Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string cancelEventName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForceOutOfProcTracking(valuetype Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string cancelEventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForceOutOfProcTracking (toolType As ExecutableType, dllName As String, cancelEventName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForceOutOfProcTracking(Microsoft::Build::Utilities::ExecutableType toolType, System::String ^ dllName, System::String ^ cancelEventName);" />
      <MemberSignature Language="F#" Value="static member ForceOutOfProcTracking : Microsoft.Build.Utilities.ExecutableType * string * string -&gt; bool" Usage="Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking (toolType, dllName, cancelEventName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="cancelEventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="toolType">Type exécutable pour l'outil faisant l'objet d'un suivi</param>
        <param name="dllName">Outil faisant l'objet d'un suivi.</param>
        <param name="cancelEventName">Nom de l'événement d'annulation que le dispositif de suivi doit écouter ou valeur null s'il n'en existe aucun.</param>
        <summary>Détermine si nous devons suivre out-of-proc ou si le suivi d'inproc fonctionnera.</summary>
        <returns>True si nous devons effectuer un suivi out-of-proc. False si le suivi d'inproc convient.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FormatRootingMarker">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Construit une chaîne de marqueur de racine à partir du tableau ITaskItem de sources principales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FormatRootingMarker">
      <MemberSignature Language="C#" Value="public static string FormatRootingMarker (Microsoft.Build.Framework.ITaskItem source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string FormatRootingMarker(class Microsoft.Build.Framework.ITaskItem source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FormatRootingMarker (source As ITaskItem) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ FormatRootingMarker(Microsoft::Build::Framework::ITaskItem ^ source);" />
      <MemberSignature Language="F#" Value="static member FormatRootingMarker : Microsoft.Build.Framework.ITaskItem -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.FormatRootingMarker source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.Build.Framework.ITaskItem" />
      </Parameters>
      <Docs>
        <param name="source">Sources principales.</param>
        <summary>Construit une chaîne de marqueur de racine à partir du tableau ITaskItem de sources principales.</summary>
        <returns>Retourne la chaîne du marqueur.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormatRootingMarker">
      <MemberSignature Language="C#" Value="public static string FormatRootingMarker (Microsoft.Build.Framework.ITaskItem[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string FormatRootingMarker(class Microsoft.Build.Framework.ITaskItem[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FormatRootingMarker (sources As ITaskItem()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ FormatRootingMarker(cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="static member FormatRootingMarker : Microsoft.Build.Framework.ITaskItem[] -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.FormatRootingMarker sources" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sources" Type="Microsoft.Build.Framework.ITaskItem[]" />
      </Parameters>
      <Docs>
        <param name="sources">Tableau ITaskItem de sources principales.</param>
        <summary>Construit une chaîne de marqueur de racine à partir du tableau ITaskItem de sources principales.</summary>
        <returns>Retourne la chaîne du marqueur.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormatRootingMarker">
      <MemberSignature Language="C#" Value="public static string FormatRootingMarker (Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string FormatRootingMarker(class Microsoft.Build.Framework.ITaskItem source, class Microsoft.Build.Framework.ITaskItem output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem,Microsoft.Build.Framework.ITaskItem)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FormatRootingMarker (source As ITaskItem, output As ITaskItem) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ FormatRootingMarker(Microsoft::Build::Framework::ITaskItem ^ source, Microsoft::Build::Framework::ITaskItem ^ output);" />
      <MemberSignature Language="F#" Value="static member FormatRootingMarker : Microsoft.Build.Framework.ITaskItem * Microsoft.Build.Framework.ITaskItem -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.FormatRootingMarker (source, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.Build.Framework.ITaskItem" />
        <Parameter Name="output" Type="Microsoft.Build.Framework.ITaskItem" />
      </Parameters>
      <Docs>
        <param name="source">Sources principales.</param>
        <param name="output">Fichiers de sortie.</param>
        <summary>Construit une chaîne de marqueur de racine à partir du tableau ITaskItem de sources principales.</summary>
        <returns>Retourne la chaîne du marqueur.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormatRootingMarker">
      <MemberSignature Language="C#" Value="public static string FormatRootingMarker (Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem[] outputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string FormatRootingMarker(class Microsoft.Build.Framework.ITaskItem[] sources, class Microsoft.Build.Framework.ITaskItem[] outputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[],Microsoft.Build.Framework.ITaskItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FormatRootingMarker (sources As ITaskItem(), outputs As ITaskItem()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ FormatRootingMarker(cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ sources, cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ outputs);" />
      <MemberSignature Language="F#" Value="static member FormatRootingMarker : Microsoft.Build.Framework.ITaskItem[] * Microsoft.Build.Framework.ITaskItem[] -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.FormatRootingMarker (sources, outputs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sources" Type="Microsoft.Build.Framework.ITaskItem[]" />
        <Parameter Name="outputs" Type="Microsoft.Build.Framework.ITaskItem[]" />
      </Parameters>
      <Docs>
        <param name="sources">Tableau ITaskItem de sources principales.</param>
        <param name="outputs">Fichiers de sortie.</param>
        <summary>Construit une chaîne de marqueur de racine à partir du tableau ITaskItem de sources principales.</summary>
        <returns>Retourne la chaîne du marqueur.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileTrackerPath">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine et retourne le chemin d'accès au FileTracker.dll correct.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileTrackerPath">
      <MemberSignature Language="C#" Value="public static string GetFileTrackerPath (Microsoft.Build.Utilities.ExecutableType toolType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileTrackerPath(valuetype Microsoft.Build.Utilities.ExecutableType toolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileTrackerPath (toolType As ExecutableType) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileTrackerPath(Microsoft::Build::Utilities::ExecutableType toolType);" />
      <MemberSignature Language="F#" Value="static member GetFileTrackerPath : Microsoft.Build.Utilities.ExecutableType -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath toolType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
      </Parameters>
      <Docs>
        <param name="toolType">ExecutableType de l'outil inclus dans un wrapper.</param>
        <summary>Détermine et retourne, à l'aide du ExecutableType de l'outil inclus dans un wrapper et des informations connues relatives au nombre de bits actuel, le chemin d'accès au fichier FileTracker.dll correct.</summary>
        <returns>Retourne le chemin d'accès de l'outil.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileTrackerPath">
      <MemberSignature Language="C#" Value="public static string GetFileTrackerPath (Microsoft.Build.Utilities.ExecutableType toolType, string rootPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileTrackerPath(valuetype Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileTrackerPath (toolType As ExecutableType, rootPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileTrackerPath(Microsoft::Build::Utilities::ExecutableType toolType, System::String ^ rootPath);" />
      <MemberSignature Language="F#" Value="static member GetFileTrackerPath : Microsoft.Build.Utilities.ExecutableType * string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath (toolType, rootPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
        <Parameter Name="rootPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="toolType">ToolType.</param>
        <param name="rootPath">Chemin d'accès racine de FileTracker.dll. Remplace le toolType si spécifié.</param>
        <summary>Détermine et retourne, à l'aide du ExecutableType de l'outil inclus dans un wrapper et des informations connues relatives au nombre de bits actuel, le chemin d'accès au fichier FileTracker.dll correct.</summary>
        <returns>Retourne <see cref="T:System.String" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTrackerPath">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine et retourne le chemin d'accès au Tracker.exe correct.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTrackerPath">
      <MemberSignature Language="C#" Value="public static string GetTrackerPath (Microsoft.Build.Utilities.ExecutableType toolType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTrackerPath(valuetype Microsoft.Build.Utilities.ExecutableType toolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.GetTrackerPath(Microsoft.Build.Utilities.ExecutableType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTrackerPath (toolType As ExecutableType) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTrackerPath(Microsoft::Build::Utilities::ExecutableType toolType);" />
      <MemberSignature Language="F#" Value="static member GetTrackerPath : Microsoft.Build.Utilities.ExecutableType -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.GetTrackerPath toolType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
      </Parameters>
      <Docs>
        <param name="toolType">ExecutableType de l'outil inclus dans un wrapper.</param>
        <summary>Détermine et retourne, à l'aide du ExecutableType de l'outil inclus dans un wrapper et des informations connues relatives au nombre de bits actuel, le chemin d'accès au fichier Tracker.exe correct.</summary>
        <returns>Retourne le chemin d'accès du dispositif de suivi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTrackerPath">
      <MemberSignature Language="C#" Value="public static string GetTrackerPath (Microsoft.Build.Utilities.ExecutableType toolType, string rootPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTrackerPath(valuetype Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.GetTrackerPath(Microsoft.Build.Utilities.ExecutableType,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTrackerPath (toolType As ExecutableType, rootPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTrackerPath(Microsoft::Build::Utilities::ExecutableType toolType, System::String ^ rootPath);" />
      <MemberSignature Language="F#" Value="static member GetTrackerPath : Microsoft.Build.Utilities.ExecutableType * string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.GetTrackerPath (toolType, rootPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
        <Parameter Name="rootPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="toolType">ToolType.</param>
        <param name="rootPath">Chemin d'accès racine de Tracker.exe. Remplace le toolType si spécifié.</param>
        <summary>Détermine et retourne, à l'aide du ExecutableType de l'outil inclus dans un wrapper et des informations connues relatives au nombre de bits actuel, le chemin d'accès au fichier Tracker.exe correct.</summary>
        <returns>Retourne <see cref="T:System.String" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeTracking">
      <MemberSignature Language="C#" Value="public static void ResumeTracking ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResumeTracking() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.ResumeTracking" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResumeTracking ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResumeTracking();" />
      <MemberSignature Language="F#" Value="static member ResumeTracking : unit -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.ResumeTracking " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reprend le suivi des accès au fichier dans le contexte de suivi actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetThreadCount">
      <MemberSignature Language="C#" Value="public static void SetThreadCount (int threadCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetThreadCount(int32 threadCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.SetThreadCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetThreadCount (threadCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetThreadCount(int threadCount);" />
      <MemberSignature Language="F#" Value="static member SetThreadCount : int -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.SetThreadCount threadCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="threadCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="threadCount">Nombre de threads.</param>
        <summary>Définit le nombre de threads global et assigne ce nombre au thread actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartProcess">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre le processus ; avec suivi de la commande.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process StartProcess (string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process StartProcess(string command, string arguments, valuetype Microsoft.Build.Utilities.ExecutableType toolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.StartProcess(System.String,System.String,Microsoft.Build.Utilities.ExecutableType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartProcess (command As String, arguments As String, toolType As ExecutableType) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ StartProcess(System::String ^ command, System::String ^ arguments, Microsoft::Build::Utilities::ExecutableType toolType);" />
      <MemberSignature Language="F#" Value="static member StartProcess : string * string * Microsoft.Build.Utilities.ExecutableType -&gt; System.Diagnostics.Process" Usage="Microsoft.Build.Utilities.FileTracker.StartProcess (command, arguments, toolType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
      </Parameters>
      <Docs>
        <param name="command">Commande dont effectuer le suivi</param>
        <param name="arguments">Arguments de la commande dont effectuer le suivi</param>
        <param name="toolType">Type d'exécutable de l'outil inclus dans un wrapper</param>
        <summary>Démarre le processus ; avec suivi de la commande.</summary>
        <returns>Retourne l'instance du processus.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process StartProcess (string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string rootFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process StartProcess(string command, string arguments, valuetype Microsoft.Build.Utilities.ExecutableType toolType, string rootFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.StartProcess(System.String,System.String,Microsoft.Build.Utilities.ExecutableType,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartProcess (command As String, arguments As String, toolType As ExecutableType, rootFiles As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ StartProcess(System::String ^ command, System::String ^ arguments, Microsoft::Build::Utilities::ExecutableType toolType, System::String ^ rootFiles);" />
      <MemberSignature Language="F#" Value="static member StartProcess : string * string * Microsoft.Build.Utilities.ExecutableType * string -&gt; System.Diagnostics.Process" Usage="Microsoft.Build.Utilities.FileTracker.StartProcess (command, arguments, toolType, rootFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
        <Parameter Name="rootFiles" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="command">Commande dont effectuer le suivi</param>
        <param name="arguments">Arguments de commande.</param>
        <param name="toolType">Type d'exécutable de l'outil inclus dans un wrapper</param>
        <param name="rootFiles">Marqueur de racine</param>
        <summary>Démarre le processus ; avec suivi de la commande.</summary>
        <returns>Retourne l'instance du processus.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process StartProcess (string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string intermediateDirectory, string rootFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process StartProcess(string command, string arguments, valuetype Microsoft.Build.Utilities.ExecutableType toolType, string intermediateDirectory, string rootFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.StartProcess(System.String,System.String,Microsoft.Build.Utilities.ExecutableType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartProcess (command As String, arguments As String, toolType As ExecutableType, intermediateDirectory As String, rootFiles As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ StartProcess(System::String ^ command, System::String ^ arguments, Microsoft::Build::Utilities::ExecutableType toolType, System::String ^ intermediateDirectory, System::String ^ rootFiles);" />
      <MemberSignature Language="F#" Value="static member StartProcess : string * string * Microsoft.Build.Utilities.ExecutableType * string * string -&gt; System.Diagnostics.Process" Usage="Microsoft.Build.Utilities.FileTracker.StartProcess (command, arguments, toolType, intermediateDirectory, rootFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="rootFiles" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="command">Commande dont effectuer le suivi</param>
        <param name="arguments">Arguments de la commande dont effectuer le suivi</param>
        <param name="toolType">Type d'exécutable de l'outil inclus dans un wrapper</param>
        <param name="intermediateDirectory">Répertoire intermédiaire où les journaux de suivi seront écrits</param>
        <param name="rootFiles">Marqueur de racine</param>
        <summary>Démarre le processus ; avec suivi de la commande.</summary>
        <returns>Retourne l'instance du processus.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process StartProcess (string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process StartProcess(string command, string arguments, valuetype Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.StartProcess(System.String,System.String,Microsoft.Build.Utilities.ExecutableType,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartProcess (command As String, arguments As String, toolType As ExecutableType, dllName As String, intermediateDirectory As String, rootFiles As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ StartProcess(System::String ^ command, System::String ^ arguments, Microsoft::Build::Utilities::ExecutableType toolType, System::String ^ dllName, System::String ^ intermediateDirectory, System::String ^ rootFiles);" />
      <MemberSignature Language="F#" Value="static member StartProcess : string * string * Microsoft.Build.Utilities.ExecutableType * string * string * string -&gt; System.Diagnostics.Process" Usage="Microsoft.Build.Utilities.FileTracker.StartProcess (command, arguments, toolType, dllName, intermediateDirectory, rootFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="rootFiles" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="command">Commande dont effectuer le suivi</param>
        <param name="arguments">Arguments de la commande dont effectuer le suivi</param>
        <param name="toolType">Type d'exécutable de l'outil inclus dans un wrapper</param>
        <param name="dllName">Nom de la dll qui effectuera le suivi.</param>
        <param name="intermediateDirectory">Répertoire intermédiaire où les journaux de suivi seront écrits</param>
        <param name="rootFiles">Marqueur de racine</param>
        <summary>Démarre le processus ; avec suivi de la commande.</summary>
        <returns>Instance de processus</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process StartProcess (string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process StartProcess(string command, string arguments, valuetype Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.StartProcess(System.String,System.String,Microsoft.Build.Utilities.ExecutableType,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartProcess (command As String, arguments As String, toolType As ExecutableType, dllName As String, intermediateDirectory As String, rootFiles As String, cancelEventName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ StartProcess(System::String ^ command, System::String ^ arguments, Microsoft::Build::Utilities::ExecutableType toolType, System::String ^ dllName, System::String ^ intermediateDirectory, System::String ^ rootFiles, System::String ^ cancelEventName);" />
      <MemberSignature Language="F#" Value="static member StartProcess : string * string * Microsoft.Build.Utilities.ExecutableType * string * string * string * string -&gt; System.Diagnostics.Process" Usage="Microsoft.Build.Utilities.FileTracker.StartProcess (command, arguments, toolType, dllName, intermediateDirectory, rootFiles, cancelEventName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="toolType" Type="Microsoft.Build.Utilities.ExecutableType" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="rootFiles" Type="System.String" />
        <Parameter Name="cancelEventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="command">Commande dont effectuer le suivi</param>
        <param name="arguments">Arguments de la commande dont effectuer le suivi</param>
        <param name="toolType">Type d'exécutable de l'outil inclus dans un wrapper</param>
        <param name="dllName">Nom de la dll qui effectuera le suivi.</param>
        <param name="intermediateDirectory">Répertoire intermédiaire où les journaux de suivi seront écrits</param>
        <param name="rootFiles">Marqueur de racine</param>
        <param name="cancelEventName">Si le dispositif de suivi doit rechercher un événement particulier en vue d'une annulation, passez son nom ici.</param>
        <summary>Démarre le processus ; avec suivi de la commande.</summary>
        <returns>Instance de processus</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartTrackingContext">
      <MemberSignature Language="C#" Value="public static void StartTrackingContext (string intermediateDirectory, string taskName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StartTrackingContext(string intermediateDirectory, string taskName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.StartTrackingContext(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StartTrackingContext (intermediateDirectory As String, taskName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StartTrackingContext(System::String ^ intermediateDirectory, System::String ^ taskName);" />
      <MemberSignature Language="F#" Value="static member StartTrackingContext : string * string -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.StartTrackingContext (intermediateDirectory, taskName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="taskName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="intermediateDirectory">Répertoire dans lequel écrire les fichiers journaux de suivi</param>
        <param name="taskName">Nom de la tâche qui appelle cette fonction, utilisé pour déterminer les noms des fichiers journaux de suivi</param>
        <summary>Démarre le suivi des accès au fichier.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartTrackingContextWithRoot">
      <MemberSignature Language="C#" Value="public static void StartTrackingContextWithRoot (string intermediateDirectory, string taskName, string rootMarkerResponseFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarkerResponseFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.StartTrackingContextWithRoot(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StartTrackingContextWithRoot (intermediateDirectory As String, taskName As String, rootMarkerResponseFile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StartTrackingContextWithRoot(System::String ^ intermediateDirectory, System::String ^ taskName, System::String ^ rootMarkerResponseFile);" />
      <MemberSignature Language="F#" Value="static member StartTrackingContextWithRoot : string * string * string -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.StartTrackingContextWithRoot (intermediateDirectory, taskName, rootMarkerResponseFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="taskName" Type="System.String" />
        <Parameter Name="rootMarkerResponseFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="intermediateDirectory">Répertoire dans lequel écrire les fichiers journaux de suivi</param>
        <param name="taskName">Nom de la tâche qui appelle cette fonction, utilisé pour déterminer les noms des fichiers journaux de suivi</param>
        <param name="rootMarkerResponseFile">Marqueur de racine du fichier réponse.</param>
        <summary>Démarre le suivi des accès au fichier, à l'aide du marqueur de racine du fichier réponse fourni. Pour générer automatiquement un fichier réponse à l'aide d'un marqueur de racine, appelez FileTracker.CreateRootingMarkerResponseFile.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopTrackingAndCleanup">
      <MemberSignature Language="C#" Value="public static void StopTrackingAndCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StopTrackingAndCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.StopTrackingAndCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StopTrackingAndCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StopTrackingAndCleanup();" />
      <MemberSignature Language="F#" Value="static member StopTrackingAndCleanup : unit -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.StopTrackingAndCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête d'assurer le suivi des accès au fichier et supprime les contextes de suivi actuels.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendTracking">
      <MemberSignature Language="C#" Value="public static void SuspendTracking ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuspendTracking() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.SuspendTracking" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuspendTracking ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuspendTracking();" />
      <MemberSignature Language="F#" Value="static member SuspendTracking : unit -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.SuspendTracking " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspend temporairement le suivi des accès au fichier dans le contexte de suivi actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TrackerArguments">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cette méthode génère les arguments Tracker.exe corrects à partir de ses paramètres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TrackerArguments">
      <MemberSignature Language="C#" Value="public static string TrackerArguments (string command, string arguments, string dllName, string intermediateDirectory, string rootFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.TrackerArguments(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrackerArguments (command As String, arguments As String, dllName As String, intermediateDirectory As String, rootFiles As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrackerArguments(System::String ^ command, System::String ^ arguments, System::String ^ dllName, System::String ^ intermediateDirectory, System::String ^ rootFiles);" />
      <MemberSignature Language="F#" Value="static member TrackerArguments : string * string * string * string * string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.TrackerArguments (command, arguments, dllName, intermediateDirectory, rootFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="rootFiles" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="command">Commande dont effectuer le suivi</param>
        <param name="arguments">Arguments de la commande dont effectuer le suivi</param>
        <param name="dllName">Nom de la dll qui effectuera le suivi.</param>
        <param name="intermediateDirectory">Répertoire intermédiaire où les journaux de suivi seront écrits</param>
        <param name="rootFiles">Marqueur de racine</param>
        <summary>Cette méthode génère les arguments Tracker.exe corrects à partir de ses paramètres.</summary>
        <returns>Arguments sous forme de chaîne</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrackerArguments">
      <MemberSignature Language="C#" Value="public static string TrackerArguments (string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.TrackerArguments(System.String,System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrackerArguments (command As String, arguments As String, dllName As String, intermediateDirectory As String, rootFiles As String, cancelEventName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrackerArguments(System::String ^ command, System::String ^ arguments, System::String ^ dllName, System::String ^ intermediateDirectory, System::String ^ rootFiles, System::String ^ cancelEventName);" />
      <MemberSignature Language="F#" Value="static member TrackerArguments : string * string * string * string * string * string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.TrackerArguments (command, arguments, dllName, intermediateDirectory, rootFiles, cancelEventName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="rootFiles" Type="System.String" />
        <Parameter Name="cancelEventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="command">Commande dont effectuer le suivi</param>
        <param name="arguments">Arguments de la commande dont effectuer le suivi</param>
        <param name="dllName">Nom de la dll qui effectuera le suivi.</param>
        <param name="intermediateDirectory">Répertoire intermédiaire où les journaux de suivi seront écrits</param>
        <param name="rootFiles">Marqueur de racine</param>
        <param name="cancelEventName">Si un événement d'annulation a été créé et que le dispositif de suivi doit le surveiller, son nom est passé ici.</param>
        <summary>Cette méthode génère les arguments Tracker.exe corrects à partir de ses paramètres.</summary>
        <returns>Arguments sous forme de chaîne</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrackerCommandArguments">
      <MemberSignature Language="C#" Value="public static string TrackerCommandArguments (string command, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrackerCommandArguments(string command, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.TrackerCommandArguments(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrackerCommandArguments (command As String, arguments As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrackerCommandArguments(System::String ^ command, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member TrackerCommandArguments : string * string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.TrackerCommandArguments (command, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="command">Commande dont effectuer le suivi</param>
        <param name="arguments">Arguments de la commande dont effectuer le suivi</param>
        <summary>Cette méthode génère les arguments de commande Tracker.exe corrects à partir de ses paramètres.</summary>
        <returns>Arguments sous forme de chaîne</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TrackerResponseFileArguments">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cette méthode génère les arguments de fichier de réponse Tracker.exe corrects à partir de ses paramètres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TrackerResponseFileArguments">
      <MemberSignature Language="C#" Value="public static string TrackerResponseFileArguments (string dllName, string intermediateDirectory, string rootFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrackerResponseFileArguments (dllName As String, intermediateDirectory As String, rootFiles As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrackerResponseFileArguments(System::String ^ dllName, System::String ^ intermediateDirectory, System::String ^ rootFiles);" />
      <MemberSignature Language="F#" Value="static member TrackerResponseFileArguments : string * string * string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments (dllName, intermediateDirectory, rootFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="rootFiles" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nom de la dll qui effectuera le suivi.</param>
        <param name="intermediateDirectory">Répertoire intermédiaire où les journaux de suivi seront écrits</param>
        <param name="rootFiles">Marqueur de racine</param>
        <summary>Cette méthode génère les arguments de fichier de réponse Tracker.exe corrects à partir de ses paramètres.</summary>
        <returns>Arguments sous forme de chaîne</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrackerResponseFileArguments">
      <MemberSignature Language="C#" Value="public static string TrackerResponseFileArguments (string dllName, string intermediateDirectory, string rootFiles, string cancelEventName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrackerResponseFileArguments (dllName As String, intermediateDirectory As String, rootFiles As String, cancelEventName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrackerResponseFileArguments(System::String ^ dllName, System::String ^ intermediateDirectory, System::String ^ rootFiles, System::String ^ cancelEventName);" />
      <MemberSignature Language="F#" Value="static member TrackerResponseFileArguments : string * string * string * string -&gt; string" Usage="Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments (dllName, intermediateDirectory, rootFiles, cancelEventName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="rootFiles" Type="System.String" />
        <Parameter Name="cancelEventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nom de la dll qui effectuera le suivi.</param>
        <param name="intermediateDirectory">Répertoire intermédiaire où les journaux de suivi seront écrits</param>
        <param name="rootFiles">Marqueur de racine</param>
        <param name="cancelEventName">Si un événement d'annulation a été créé et que le dispositif de suivi doit le surveiller, son nom est passé ici.</param>
        <summary>Cette méthode génère les arguments de fichier de réponse Tracker.exe corrects à partir de ses paramètres.</summary>
        <returns>Arguments sous forme de chaîne</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTLogs">
      <MemberSignature Language="C#" Value="public static void WriteAllTLogs (string intermediateDirectory, string taskName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllTLogs(string intermediateDirectory, string taskName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.WriteAllTLogs(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllTLogs (intermediateDirectory As String, taskName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllTLogs(System::String ^ intermediateDirectory, System::String ^ taskName);" />
      <MemberSignature Language="F#" Value="static member WriteAllTLogs : string * string -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.WriteAllTLogs (intermediateDirectory, taskName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="taskName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="intermediateDirectory">Répertoire dans lequel écrire les fichiers journaux de suivi</param>
        <param name="taskName">Nom de la tâche qui appelle cette fonction, utilisé pour déterminer les noms des fichiers journaux de suivi</param>
        <summary>Écrit des journaux de suivi pour tous les contextes et threads.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteContextTLogs">
      <MemberSignature Language="C#" Value="public static void WriteContextTLogs (string intermediateDirectory, string taskName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteContextTLogs(string intermediateDirectory, string taskName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Utilities.FileTracker.WriteContextTLogs(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteContextTLogs (intermediateDirectory As String, taskName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteContextTLogs(System::String ^ intermediateDirectory, System::String ^ taskName);" />
      <MemberSignature Language="F#" Value="static member WriteContextTLogs : string * string -&gt; unit" Usage="Microsoft.Build.Utilities.FileTracker.WriteContextTLogs (intermediateDirectory, taskName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Utilities.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intermediateDirectory" Type="System.String" />
        <Parameter Name="taskName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="intermediateDirectory">Répertoire dans lequel écrire les fichiers journaux de suivi</param>
        <param name="taskName">Nom de la tâche qui appelle cette fonction, utilisé pour déterminer les noms des fichiers journaux de suivi</param>
        <summary>Écrit des journaux de suivi correspondant au contexte de suivi actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>