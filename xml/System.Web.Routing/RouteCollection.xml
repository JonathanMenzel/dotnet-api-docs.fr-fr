<Type Name="RouteCollection" FullName="System.Web.Routing.RouteCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f7a56076e84a4a4a1b8779b51e10321651f3424f" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39850627" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RouteCollection : System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RouteCollection extends System.Collections.ObjectModel.Collection`1&lt;class System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Web.Routing.RouteCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class RouteCollection&#xA;Inherits Collection(Of RouteBase)" />
  <TypeSignature Language="C++ CLI" Value="public ref class RouteCollection : System::Collections::ObjectModel::Collection&lt;System::Web::Routing::RouteBase ^&gt;" />
  <TypeSignature Language="F#" Value="type RouteCollection = class&#xA;    inherit Collection&lt;RouteBase&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Web.Routing</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Web.Routing.RouteBase</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web.Routing, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une collection d’itinéraires pour le routage ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.Routing.RouteCollection> classe fournit des méthodes qui vous permettent de gérer une collection d’objets dérivés de la <xref:System.Web.Routing.RouteBase> classe.  
  
 En règle générale, vous utiliserez le `static` <xref:System.Web.Routing.RouteTable.Routes%2A> propriété de la <xref:System.Web.Routing.RouteTable> classe à récupérer un <xref:System.Web.Routing.RouteCollection> objet. Le <xref:System.Web.Routing.RouteTable.Routes%2A> propriété stocke tous les itinéraires pour une application ASP.NET. Routage ASP.NET effectue une itération dans les itinéraires dans le <xref:System.Web.Routing.RouteTable.Routes%2A> propriété à rechercher l’itinéraire qui correspond à une URL.  
  
 Pour construire une URL, vous appelez le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> (méthode) et passez une collection de valeurs. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> méthode recherche le premier itinéraire avec des paramètres qui correspondent aux valeurs que vous avez transmis, retourne un <xref:System.Web.Routing.VirtualPathData> objet qui contient des informations sur l’itinéraire correspondant. Vous récupérez l’URL via le <xref:System.Web.Routing.VirtualPathData.VirtualPath%2A> propriété de la <xref:System.Web.Routing.VirtualPathData> objet.  
  
 Vous pouvez ajouter un itinéraire avec un nom ou sans nom. Y compris un nom vous permet de faire la distinction entre des routes similaires lorsque les URL sont construites. Si vous ne spécifiez pas un nom, le routage ASP.NET utilise le premier itinéraire correspondant dans la collection pour construire une URL.  
  
 Lorsque vous ajoutez un itinéraire sans nom à la <xref:System.Web.Routing.RouteCollection> de l’objet, vous ne pouvez pas ajouter un itinéraire qui se trouve déjà dans la collection. Lorsque vous ajoutez un itinéraire nommé, vous ne pouvez pas utiliser un nom qui identifie déjà un itinéraire dans la collection.  
  
 Vous utilisez le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> (méthode) et le <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode pour vous assurer que vous interagissez avec la collection sans conflits provenant d’autres processus.  
  
 Pour plus d’informations sur comment ajouter un itinéraire à une collection d’itinéraires, consultez [routage ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.Routing.RouteCollection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.Routing.RouteCollection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection (System.Web.Hosting.VirtualPathProvider virtualPathProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.Hosting.VirtualPathProvider virtualPathProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor(System.Web.Hosting.VirtualPathProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection(System::Web::Hosting::VirtualPathProvider ^ virtualPathProvider);" />
      <MemberSignature Language="F#" Value="new System.Web.Routing.RouteCollection : System.Web.Hosting.VirtualPathProvider -&gt; System.Web.Routing.RouteCollection" Usage="new System.Web.Routing.RouteCollection virtualPathProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="virtualPathProvider" Type="System.Web.Hosting.VirtualPathProvider" />
      </Parameters>
      <Docs>
        <param name="virtualPathProvider">Fournisseur pour récupérer des ressources à partir d’un système de fichiers virtuel.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.Routing.RouteCollection" /> en utilisant le fournisseur de chemins d'accès virtuels spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string name, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string name, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Add(System.String,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (name As String, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ name, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.Add : string * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.Add (name, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="name">Valeur qui identifie l’itinéraire. La valeur peut être <see langword="null" /> ou une chaîne vide.</param>
        <param name="item">Itinéraire à ajouter à la fin de la collection.</param>
        <summary>Ajoute un itinéraire à la fin de l’objet <see cref="T:System.Web.Routing.RouteCollection" /> et assigne le nom spécifié à l’itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.Routing.RouteCollection.Add%2A> méthode vous permet de définir un nom pour un itinéraire lorsque vous l’ajoutez à la collection d’itinéraires. En définissant un nom pour l’itinéraire, vous pouvez spécifier un itinéraire particulier à utiliser lorsque vous utilisez le routage pour construire une URL. Spécification d’un itinéraire particulier est importante lorsque plusieurs itinéraires correspondent aux valeurs que vous passez à la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> (méthode). Si vous ne spécifiez pas un itinéraire nommé, le routage ASP.NET utilisera le premier itinéraire dans la collection qui correspond aux valeurs. Pour plus d’informations, consultez [Comment : construire une URL d’itinéraires](http://msdn.microsoft.com/library/1ffd4085-71f6-4822-be8f-f682ca638650).  
  
 Un nom peut être utilisé qu’une seule fois dans le <xref:System.Web.Routing.RouteCollection> objet.  
  
 Si vous n’êtes pas obligé de spécifier un nom pour l’itinéraire, vous pouvez ajouter l’itinéraire en appelant le <xref:System.Collections.ObjectModel.Collection%601.Add%2A> (méthode).  
  
 Utilisez le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> (méthode) et le <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode pour vous assurer que vous interagissez avec la collection sans conflits provenant d’autres processus.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter un itinéraire vers un <xref:System.Web.Routing.RouteCollection> de l’objet et attribuer un nom à l’itinéraire.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#1)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est déjà utilisé dans la collection.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendTrailingSlash">
      <MemberSignature Language="C#" Value="public bool AppendTrailingSlash { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AppendTrailingSlash" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberSignature Language="VB.NET" Value="Public Property AppendTrailingSlash As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AppendTrailingSlash { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AppendTrailingSlash : bool with get, set" Usage="System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les barres obliques de fin sont ajoutées lorsque les chemins d'accès virtuels sont normalisés.</summary>
        <value>
          <see langword="true" /> si des barres obliques finales sont ajoutées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="routeCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments de l’objet <see cref="T:System.Web.Routing.RouteCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> (méthode) et le <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode pour vous assurer que vous interagissez avec la collection sans conflits provenant d’autres processus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReadLock">
      <MemberSignature Language="C#" Value="public IDisposable GetReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReadLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetReadLock();" />
      <MemberSignature Language="F#" Value="member this.GetReadLock : unit -&gt; IDisposable" Usage="routeCollection.GetReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit un objet pour gérer la sécurité des threads quand vous récupérez un objet de la collection.</summary>
        <returns>Objet qui gère la sécurité des threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.Routing.RouteCollection> objet n’est disponible pour plusieurs processus dans l’application. Par conséquent, si vous devez récupérer un itinéraire lorsque l’application est en cours d’exécution, utilisez la <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> méthode afin de garantir la sécurité des threads. En obtenant un verrou de lecture sur la collection d’itinéraires, vous vous assurer que la collection ne sera pas modifiée lorsque vous essayez de le récupérer.  
  
 Le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> méthode arrête le thread de se poursuivre jusqu'à ce que le verrou peut être acquis. Si un verrou d’écriture est en place, le thread attend jusqu'à ce que la mise à jour est terminée et que le verrou d’écriture est libéré. Le verrou en lecture sur la collection d’itinéraires est libéré lorsque la <xref:System.IDisposable> objet qui est retourné par cette méthode est supprimé.  
  
 Si vous n’utilisez pas <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>, vous pouvez obtenir une erreur pendant la lecture le <xref:System.Web.Routing.RouteCollection> collection. Par exemple, supposons que vous parcourez les objets dans le <xref:System.Web.Routing.RouteCollection> collection pour les lire, sans appeler <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>. Pendant que vous faites cela, un autre thread à partir d’une autre demande peut appeler <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> et ajouter un itinéraire à la collection. Le premier thread échouera ensuite avec une erreur.  
  
 Il existe deux scénarios dans lesquels vous n’avez pas à appeler <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>:  
  
-   Les méthodes publiques de la <xref:System.Web.Routing.RouteCollection> classe telle que <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> et <xref:System.Web.Routing.RouteCollection.GetRouteData%2A> appeler <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> en interne. Par conséquent, il est inutile d’appeler explicitement <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> lorsque vous appelez une méthode publique de la <xref:System.Web.Routing.RouteCollection> classe à récupérer des données à partir de la collection.  
  
-   Lorsque l’application démarre et ne traite pas encore de demandes, comme dans le `Application_Start` Gestionnaire d’événements, un seul thread est en cours d’exécution. Comme il n’y a pas d’autres threads qui peuvent mettre à jour la collection pendant que vous la lisez, vous n’avez pas à appeler <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> méthode lorsque vous récupérez un itinéraire pendant l’exécution de l’application. Le `Using` instruction garantit que ce qui se passe au moment de l’exécution lorsque vous lisez à partir de la collection (que le code s’exécute normalement ou une exception est levée), le verrou sera libéré en toute sécurité à la fin de la `Using` bloc de code.  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData GetRouteData (System.Web.HttpContextBase httpContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.RouteData GetRouteData(class System.Web.HttpContextBase httpContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetRouteData(System.Web.HttpContextBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteData (httpContext As HttpContextBase) As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::RouteData ^ GetRouteData(System::Web::HttpContextBase ^ httpContext);" />
      <MemberSignature Language="F#" Value="member this.GetRouteData : System.Web.HttpContextBase -&gt; System.Web.Routing.RouteData" Usage="routeCollection.GetRouteData httpContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpContext" Type="System.Web.HttpContextBase" />
      </Parameters>
      <Docs>
        <param name="httpContext">Objet qui encapsule des informations sur la requête HTTP.</param>
        <summary>Retourne des informations sur l’itinéraire dans la collection qui correspond aux valeurs spécifiées.</summary>
        <returns>Objet qui contient les valeurs de la définition d’itinéraire.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Web.HttpContextBase.Request" /> de l'objet dans le paramètre <paramref name="context" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetVirtualPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne des informations sur le chemin d'accès d'URL associé à l'itinéraire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Objet qui encapsule des informations sur l’itinéraire demandé.</param>
        <param name="values">Objet qui contient les paramètres d’un itinéraire.</param>
        <summary>Retourne des informations sur le chemin de l’URL associé à l’itinéraire, selon les valeurs de contexte et de paramètre spécifiées.</summary>
        <returns>Objet qui contient des informations sur le chemin d’URL associé à l’itinéraire.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, string name, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, string name, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::String ^ name, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * string * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, name, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Objet qui encapsule des informations sur l’itinéraire demandé.</param>
        <param name="name">Nom de l’itinéraire à utiliser au moment de récupérer des informations sur le chemin d’URL.</param>
        <param name="values">Objet qui contient les paramètres d’un itinéraire.</param>
        <summary>Retourne des informations sur le chemin d’URL associé à l’itinéraire nommé, selon le contexte, le nom d’itinéraire et les valeurs de paramètres spécifiés.</summary>
        <returns>Objet qui contient des informations sur le chemin d’URL associé à l’itinéraire.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Aucun itinéraire avec le nom spécifié dans le paramètre <paramref name="name" /> n'a été trouvé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWriteLock">
      <MemberSignature Language="C#" Value="public IDisposable GetWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWriteLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetWriteLock();" />
      <MemberSignature Language="F#" Value="member this.GetWriteLock : unit -&gt; IDisposable" Usage="routeCollection.GetWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit un objet pour gérer la sécurité des threads quand vous ajoutez ou supprimez des éléments dans la collection.</summary>
        <returns>Objet qui gère la sécurité des threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’approche recommandée pour définir des itinéraires dans une application ASP.NET consiste à ajouter les itinéraires vers le <xref:System.Web.Routing.RouteTable.Routes%2A> propriété dans un gestionnaire d’événements pour le `Application_Start` événement dans le fichier Global.asax. Pour plus d'informations, consultez <xref:System.Web.Routing.RouteCollection>.  
  
 Si vous devez ajouter un itinéraire lorsque l’application est en cours d’exécution, vous utilisez la <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode pour garantir la sécurité des threads. Le verrou d’écriture sur la collection d’itinéraires est libéré lorsque la <xref:System.IDisposable> objet qui est retourné par cette méthode est supprimé.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode lorsque vous ajoutez un itinéraire pendant l’exécution de l’application.  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ignore">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit un modèle d'URL dont les correspondances par rapport à des itinéraires ne doivent pas être vérifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée un itinéraire qui est mappé à la <xref:System.Web.Routing.StopRoutingHandler> Gestionnaire d’itinéraire. Après avoir appelé cette méthode, les demandes qui correspondent au modèle d’URL spécifié ne seront pas traitées comme acheminer les demandes.  
  
 Routage ASP.NET ignore automatiquement les demandes lorsque l’URL correspond à un fichier physique, tel qu’un fichier image. Dans certains cas, vous pourriez également le routage pour ignorer les demandes quand il n’existe aucun fichier physique. Par exemple, les demandes qu’ASP.NET fait automatiquement pour les fichiers .axd ne doivent pas être considérés comme acheminer les demandes même s’il n’existe aucun fichier physique qui correspond à l’extension de nom de fichier .axd.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string -&gt; unit" Usage="routeCollection.Ignore url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Modèle d'URL à ignorer.</param>
        <summary>Définit un modèle d'URL dont les correspondances par rapport à des itinéraires ne doivent pas être vérifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée un itinéraire qui est mappé à la <xref:System.Web.Routing.StopRoutingHandler> Gestionnaire d’itinéraire. Après avoir appelé cette méthode, les demandes qui correspondent au modèle d’URL spécifié ne seront pas traitées comme acheminer les demandes.  
  
 Routage ASP.NET ignore automatiquement les demandes lorsque l’URL correspond à un fichier physique, tel qu’un fichier image. Dans certains cas, vous pourriez également le routage pour ignorer les demandes quand il n’existe aucun fichier physique. Par exemple, les demandes qu’ASP.NET fait automatiquement pour les fichiers .axd ne doivent pas être considérés comme acheminer les demandes même s’il n’existe aucun fichier physique qui correspond à l’extension de nom de fichier .axd.  
  
   
  
## Examples  
 Le modèle par défaut pour les projets MVC utilise cette méthode pour exclure des fichiers .axd du routage, comme indiqué dans l’exemple suivant :  
  
 [!code-csharp[MvcDefaultApp#2](~/samples/snippets/csharp/VS_Snippets_WebNet/mvcdefaultapp/cs/global.asax.cs#2)]
 [!code-vb[MvcDefaultApp#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/mvcdefaultapp/vb/global.asax.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url, object constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url, object constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String, constraints As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url, System::Object ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string * obj -&gt; unit" Usage="routeCollection.Ignore (url, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="constraints" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="url">Modèle d'URL à ignorer.</param>
        <param name="constraints">Critère supplémentaire qui détermine si une demande qui correspond au modèle d'URL sera ignorée.</param>
        <summary>Définit un modèle d'URL qui ne doit pas être vérifié pour les correspondances par rapport à des itinéraires si une URL de requête satisfait les contraintes spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée un itinéraire qui est mappé à la <xref:System.Web.Routing.StopRoutingHandler> Gestionnaire d’itinéraire. Après avoir appelé cette méthode, les demandes qui correspondent au modèle d’URL spécifié ne seront pas traitées comme acheminer les demandes.  
  
 Routage ASP.NET ignore automatiquement les demandes lorsque l’URL correspond à un fichier physique, tel qu’un fichier image. Dans certains cas, vous pourriez également le routage pour ignorer les demandes quand il n’existe aucun fichier physique. Par exemple, les demandes qu’ASP.NET fait automatiquement pour les fichiers .axd ne doivent pas être considérés comme acheminer les demandes même s’il n’existe aucun fichier physique qui correspond à l’extension de nom de fichier .axd.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser cette méthode pour ignorer toutes les URL qui ont une extension .aspx. Vous souhaiterez peut-être le faire si vous inscrivez un gestionnaire HTTP personnalisé pour gérer toutes les URL pour les fichiers ayant l’extension « .aspx ». Un modèle d’URL unique qui correspondrait à toutes les demandes .aspx requerrait deux paramètres catchall tels que `{*path}.aspx/{*pathinfo}`. (Ce modèle correspondrait à n’importe quelle URL qui se termine par .aspx, y compris ceux qui ont des paramètres de chaîne de requête.) Toutefois, le routage n'autorise qu’un seul paramètre fourre-tout à la fin. Comme alternative, vous pouvez spécifier un modèle d’URL qui a un paramètre catchall unique qui correspond à toutes les URL et puis spécifier des contraintes qui excluent tout ce qui n’a pas l’extension .aspx, comme illustré dans l’exemple suivant :  
  
```vb  
routes.Ignore("{*allaspx}", new With {.allaspx = ".*\.aspx(/.*)?"})  
```  
  
```csharp  
routes.Ignore("{*allaspx}", new {allaspx=@".*\.aspx(/.*)?"});  
```  
  
 La ligne de code précédente est généralement ajoutée à une méthode qui est appelée à partir de la `Application_Start` méthode dans Global.asax, comme indiqué dans l’exemple pour la <xref:System.Web.Routing.RouteCollection.Ignore%28System.String%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="url" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.InsertItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro au niveau duquel <c>item</c> est inséré.</param>
        <param name="item">Itinéraire à insérer.</param>
        <summary>Insère l'itinéraire spécifié dans l'objet <see cref="T:System.Web.Routing.RouteCollection" /> à l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous ajoutez un itinéraire sans nom à la <xref:System.Web.Routing.RouteCollection> de l’objet, vous ne pouvez pas ajouter un itinéraire qui se trouve déjà dans la collection.  
  
 Utilisez le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> (méthode) et le <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode pour vous assurer que vous interagissez avec la collection sans conflits provenant d’autres processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> existe déjà dans la collection.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteBase this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteBase Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(name As String) As RouteBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteBase ^ default[System::String ^] { System::Web::Routing::RouteBase ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Web.Routing.RouteBase" Usage="System.Web.Routing.RouteCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Valeur qui identifie l’itinéraire à obtenir.</param>
        <summary>Obtient l’itinéraire dans la collection qui porte le nom spécifié.</summary>
        <value>Un objet portant le nom spécifié, ou <see langword="null" /> si <paramref name="name" /> est <see langword="null" />, est une chaîne vide ou ne correspond pas à un itinéraire dans la collection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> (méthode) et le <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode pour vous assurer que vous interagissez avec la collection sans conflits provenant d’autres processus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowercaseUrls">
      <MemberSignature Language="C#" Value="public bool LowercaseUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LowercaseUrls" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property LowercaseUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LowercaseUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LowercaseUrls : bool with get, set" Usage="System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les URL sont converties en minuscules lorsque les chemins d'accès virtuels sont normalisés.</summary>
        <value>
          <see langword="true" /> pour convertir les caractères des URL en minuscules ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une chaîne de requête est incluse dans l’URL, cette partie de l’URL n’est pas convertie en minuscules.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPageRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Offre un moyen de définir des itinéraires pour les applications Web Forms.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.Add%2A> (méthode) et en passant un <xref:System.Web.Routing.Route> objet qui est créé à l’aide de la <xref:System.Web.Routing.PageRouteHandler> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir des itinéraires pour une application Web Forms à l’aide de cette méthode. L’exemple montre une méthode nommée `RegisterRoutes` qui est appelée à partir de `Application_Start` dans le fichier Global.asax. La méthode utilise chaque surcharge de <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> pour ajouter un itinéraire à l’application. Pour plus d’informations sur la façon de définir des itinéraires pour les applications Web Forms, consultez [Comment : définir des itinéraires pour les Applications Web Forms](http://msdn.microsoft.com/library/200fe812-d0a6-4531-b9b4-cfc4ee83a678).  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#122)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#122)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeUrl">Modèle d’URL pour l’itinéraire.</param>
        <param name="physicalFile">URL physique de l'itinéraire.</param>
        <summary>Offre un moyen de définir des itinéraires pour les applications Web Forms.</summary>
        <returns>Itinéraire ajouté à la collection d'itinéraires.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.Add%2A> (méthode) et en passant un <xref:System.Web.Routing.Route> objet qui est créé à l’aide de la <xref:System.Web.Routing.PageRouteHandler> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir un itinéraire à l’aide de cette méthode. La première instruction définit un itinéraire qui n’a pas de nom. La deuxième instruction définit un itinéraire nommé. Cet exemple fait partie d’un exemple plus complet qui est disponible dans le <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> vue d’ensemble de la méthode.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#140)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#140)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeUrl">Modèle d’URL pour l’itinéraire.</param>
        <param name="physicalFile">URL physique de l'itinéraire.</param>
        <param name="checkPhysicalUrlAccess">Valeur qui indique si ASP.NET doit valider que l'utilisateur a autorité pour accéder à l'URL physique (l'URL de routage est toujours vérifiée). Ce paramètre définit la propriété <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />.</param>
        <summary>Offre un moyen de définir des itinéraires pour les applications Web Forms.</summary>
        <returns>Itinéraire ajouté à la collection d'itinéraires.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.Add%2A> (méthode) et en passant un <xref:System.Web.Routing.Route> objet qui est créé à l’aide de la <xref:System.Web.Routing.PageRouteHandler> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir un itinéraire à l’aide de cette méthode. Cet exemple fait partie d’un exemple plus complet qui est disponible dans le <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> vue d’ensemble de la méthode.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#145)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#145)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeUrl">Modèle d’URL pour l’itinéraire.</param>
        <param name="physicalFile">URL physique de l'itinéraire.</param>
        <param name="checkPhysicalUrlAccess">Valeur qui indique si ASP.NET doit valider que l'utilisateur a autorité pour accéder à l'URL physique (l'URL de routage est toujours vérifiée). Ce paramètre définit la propriété <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />.</param>
        <param name="defaults">Valeurs par défaut pour les paramètres d'itinéraire.</param>
        <summary>Offre un moyen de définir des itinéraires pour les applications Web Forms.</summary>
        <returns>Itinéraire ajouté à la collection d'itinéraires.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.Add%2A> (méthode) et en passant un <xref:System.Web.Routing.Route> objet qui est créé à l’aide de la <xref:System.Web.Routing.PageRouteHandler> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir un itinéraire à l’aide de cette méthode. Cet exemple fait partie d’un exemple plus complet qui est disponible dans le <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> vue d’ensemble de la méthode.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#150)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeUrl">Modèle d’URL pour l’itinéraire.</param>
        <param name="physicalFile">URL physique de l'itinéraire.</param>
        <param name="checkPhysicalUrlAccess">Valeur qui indique si ASP.NET doit valider que l'utilisateur a autorité pour accéder à l'URL physique (l'URL de routage est toujours vérifiée). Ce paramètre définit la propriété <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />.</param>
        <param name="defaults">Valeurs par défaut de l'itinéraire.</param>
        <param name="constraints">Contraintes qu'une requête d'URL doit satisfaire pour qu'elles soient traitées en tant qu'itinéraire.</param>
        <summary>Offre un moyen de définir des itinéraires pour les applications Web Forms.</summary>
        <returns>Itinéraire ajouté à la collection d'itinéraires.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.Add%2A> (méthode) et en passant un <xref:System.Web.Routing.Route> objet qui est créé à l’aide de la <xref:System.Web.Routing.PageRouteHandler> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir un itinéraire à l’aide de cette méthode. Cet exemple fait partie d’un exemple plus complet qui est disponible dans le <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> vue d’ensemble de la méthode.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#155)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints, System.Web.Routing.RouteValueDictionary dataTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints, class System.Web.Routing.RouteValueDictionary dataTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary, dataTokens As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints, System::Web::Routing::RouteValueDictionary ^ dataTokens);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints, dataTokens)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="dataTokens" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeUrl">Modèle d’URL pour l’itinéraire.</param>
        <param name="physicalFile">URL physique de l'itinéraire.</param>
        <param name="checkPhysicalUrlAccess">Valeur qui indique si ASP.NET doit valider que l'utilisateur a autorité pour accéder à l'URL physique (l'URL de routage est toujours vérifiée). Ce paramètre définit la propriété <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />.</param>
        <param name="defaults">Valeurs par défaut pour les paramètres d'itinéraire.</param>
        <param name="constraints">Contraintes qu'une requête d'URL doit satisfaire pour qu'elles soient traitées en tant qu'itinéraire.</param>
        <param name="dataTokens">Valeurs associées à l'itinéraire et non utilisées pour déterminer si un itinéraire correspond à un modèle d'URL.</param>
        <summary>Offre un moyen de définir des itinéraires pour les applications Web Forms.</summary>
        <returns>Itinéraire ajouté à la collection d'itinéraires.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.Add%2A> (méthode) et en passant un <xref:System.Web.Routing.Route> objet qui est créé à l’aide de la <xref:System.Web.Routing.PageRouteHandler> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir un itinéraire à l’aide de cette méthode. Cet exemple fait partie d’un exemple plus complet qui est disponible dans le <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> vue d’ensemble de la méthode.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#160)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#160)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="routeUrl" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="routeCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l’itinéraire à supprimer.</param>
        <summary>Supprime l'itinéraire de l'objet <see cref="T:System.Web.Routing.RouteCollection" /> à l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> (méthode) et le <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode pour vous assurer que vous interagissez avec la collection sans conflits provenant d’autres processus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteExistingFiles">
      <MemberSignature Language="C#" Value="public bool RouteExistingFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteExistingFiles" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteExistingFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteExistingFiles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RouteExistingFiles : bool with get, set" Usage="System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le routage ASP.NET doit gérer des URL qui correspondent à un fichier existant.</summary>
        <value>
          <see langword="true" /> si le routage ASP.NET gère toutes les requêtes, y compris celles qui correspondent à un fichier existant ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que cette valeur peut être modifiée dynamiquement, toute modification apportée après l’activation d’un service sera ignorée lors de l’utilisation de l’intégration de routage ASP.NET. Pour plus d’informations, consultez [intégration de routage ASP.NET](http://go.microsoft.com/fwlink/?LinkId=195235).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.SetItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l’itinéraire à remplacer.</param>
        <param name="item">Itinéraire à ajouter à l’index spécifié.</param>
        <summary>Remplace l’itinéraire à l’index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous ajoutez un itinéraire sans nom à la <xref:System.Web.Routing.RouteCollection> de l’objet, vous ne pouvez pas ajouter un itinéraire qui se trouve déjà dans la collection.  
  
 Utilisez le <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> (méthode) et le <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> méthode pour vous assurer que vous interagissez avec la collection sans conflits provenant d’autres processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> existe déjà dans la collection.</exception>
      </Docs>
    </Member>
  </Members>
</Type>