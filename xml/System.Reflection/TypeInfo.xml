<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeInfo.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac51b83aad3fe8f6a61474824a2428045a9cb69f48d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1b83aad3fe8f6a61474824a2428045a9cb69f48d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeInfo">
          <source>Represents type declarations for class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</source>
          <target state="translated">Représente les déclarations de type pour les types de classe, d'interface, de tableau, de valeur, d'énumération, les paramètres de type, les définitions de type générique et les types génériques construits ouverts ou fermés.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> class is included in the <ph id="ph3">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> subset for use in creating Windows Store apps.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, le <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> classe est incluse dans le <ph id="ph3">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> sous-ensemble à utiliser pour créer des applications du Windows Store.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> is available in the full .NET Framework as well.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> est disponible dans le .NET Framework complet ainsi.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>For more information about reflection for Windows Store apps, see <bpt id="p1">[</bpt>System.Reflection namespaces<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/hh441595\(v=vs.110\).aspx)</ept> in the Windows Dev Center and <bpt id="p2">[</bpt>Reflection in the .NET Framework for Windows Store Apps<ept id="p2">](~/docs/framework/reflection-and-codedom/reflection-for-windows-store-apps.md)</ept> in the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur la réflexion pour les applications du Windows Store, consultez <bpt id="p1">[</bpt>espaces de noms System.Reflection<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/hh441595\(v=vs.110\).aspx)</ept> dans le centre de développement Windows et <bpt id="p2">[</bpt>réflexion dans le .NET Framework pour les applications du Windows Store<ept id="p2">](~/docs/framework/reflection-and-codedom/reflection-for-windows-store-apps.md)</ept> sur le site MSDN Bibliothèque.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> contains many of the members available in the <ph id="ph2">&lt;xref:System.Type&gt;</ph> class, and many of the reflection properties in the <ph id="ph3">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> return collections of <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> contient de nombreux membres disponibles dans le <ph id="ph2">&lt;xref:System.Type&gt;</ph> classe et nombreuses propriétés de réflexion dans le <ph id="ph3">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> retournent des collections de <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>To get a <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object from a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, use the <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%28System.Type%29?displayProperty=nameWithType&gt;</ph> extension method.</source>
          <target state="translated">Pour obtenir un <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> à partir de l’objet un <ph id="ph2">&lt;xref:System.Type&gt;</ph> de l’objet, utilisez la <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%28System.Type%29?displayProperty=nameWithType&gt;</ph> méthode d’extension.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object represents the type definition itself, whereas a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents a reference to the type definition.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objet représente la définition de ce type, alors qu’un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objet représente une référence à la définition de type.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>Getting a <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object forces the assembly that contains that type to load.</source>
          <target state="translated">Obtention d’un <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objet force l’assembly qui contient ce type à charger.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>In comparison, you can manipulate <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects without necessarily requiring the runtime to load the assembly they reference.</source>
          <target state="translated">En comparaison, vous pouvez manipuler <ph id="ph1">&lt;xref:System.Type&gt;</ph> objets sans obliger le runtime pour charger l’assembly qu’ils référencent.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>In the <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph>, you use the reflection properties of <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> that return <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collections instead of methods that return arrays.</source>
          <target state="translated">Dans le <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph>, vous utilisez les propriétés de réflexion de <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> qui retournent <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collections au lieu de méthodes qui retournent des tableaux.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>For example, use the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredMembers%2A&gt;</ph> property to get all declared members, or the <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.DeclaredProperties%2A&gt;</ph> property to get all declared properties.</source>
          <target state="translated">Par exemple, utiliser le <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredMembers%2A&gt;</ph> propriété à obtenir tous les membres déclarés, ou le <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.DeclaredProperties%2A&gt;</ph> propriété à obtenir toutes les propriétés déclarées.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>Reflection contexts can implement lazy traversal of these collections for large assemblies or types.</source>
          <target state="translated">Les contextes de réflexion peuvent implémenter le parcours différé de ces collections pour de grands assemblys ou types.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>To get specific members, use methods such as <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GetDeclaredMethod%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.GetDeclaredProperty%2A&gt;</ph>, and pass the name of the method or property you would like to retrieve.</source>
          <target state="translated">Pour obtenir des membres spécifiques, utilisez les méthodes telles que <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GetDeclaredMethod%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.GetDeclaredProperty%2A&gt;</ph>et passez le nom de la méthode ou propriété que vous souhaitez récupérer.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>To filter the results of <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> properties, use LINQ queries.</source>
          <target state="translated">Pour filtrer les résultats de <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> , utilisez les requêtes LINQ.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>For reflection objects that originate with the runtime (for example, as the result of <ph id="ph1">`typeof(Object)`</ph>), you can traverse the inheritance tree by using the methods in the <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> class.</source>
          <target state="translated">Pour les objets réflexion provenant du runtime (par exemple, à la suite de <ph id="ph1">`typeof(Object)`</ph>), vous pouvez parcourir l’arborescence d’héritage en utilisant les méthodes dans la <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>Consumers of objects from customized reflection contexts cannot use these methods and must traverse the inheritance tree themselves.</source>
          <target state="translated">Les consommateurs des objets à partir de contextes de réflexion personnalisés ne peuvent pas utiliser ces méthodes et doivent parcourir l’arborescence d’héritage eux-mêmes.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>This example uses the reflection types and members in the <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> subset to retrieve the methods and properties of the <ph id="ph2">&lt;xref:System.Globalization.Calendar&gt;</ph> type, including inherited methods and properties.</source>
          <target state="translated">Cet exemple utilise la réflexion types et membres dans le <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> sous-ensemble pour récupérer les méthodes et propriétés de la <ph id="ph2">&lt;xref:System.Globalization.Calendar&gt;</ph> type, y compris les méthodes et propriétés héritées.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeInfo">
          <source>To run this code, paste it into the code file for a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> XAML app that contains a <bpt id="p1">[</bpt>Windows.UI.Xaml.Controls.Textblock<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textblock.aspx)</ept> control named <ph id="ph2">`textblock1`</ph>.</source>
          <target state="translated">Pour exécuter ce code, collez-le dans le fichier de code pour un <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> application XAML qui contienne un <bpt id="p1">[</bpt>Windows.UI.Xaml.Controls.Textblock<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textblock.aspx)</ept> contrôle nommé <ph id="ph2">`textblock1`</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.AsType">
          <source>Returns the current type as a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object.</source>
          <target state="translated">Retourne le type actuel sous forme d'objet <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.AsType">
          <source>The current type.</source>
          <target state="translated">Type actuel.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.DeclaredConstructors">
          <source>Gets a collection of the constructors declared by the current type.</source>
          <target state="translated">Obtient une collection des constructeurs déclarés par le type actuel.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredConstructors">
          <source>A collection of the constructors declared by the current type.</source>
          <target state="translated">Collection des constructeurs déclarés par le type actuel.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredConstructors">
          <source>To filter the results of the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredConstructors%2A&gt;</ph> property, use LINQ queries.</source>
          <target state="translated">Pour filtrer les résultats de la <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredConstructors%2A&gt;</ph> propriété, utilisez des requêtes LINQ.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredConstructors">
          <source>For reflection objects that originate with the runtime (for example, as the result of <ph id="ph1">`typeof(Object)`</ph>), you can traverse the inheritance tree by using the methods in the <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> class.</source>
          <target state="translated">Pour les objets réflexion provenant du runtime (par exemple, à la suite de <ph id="ph1">`typeof(Object)`</ph>), vous pouvez parcourir l’arborescence d’héritage en utilisant les méthodes dans la <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredConstructors">
          <source>Consumers of objects from customized reflection contexts cannot use these methods and must traverse the inheritance tree themselves.</source>
          <target state="translated">Les consommateurs des objets à partir de contextes de réflexion personnalisés ne peuvent pas utiliser ces méthodes et doivent parcourir l’arborescence d’héritage eux-mêmes.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.DeclaredEvents">
          <source>Gets a collection of the events defined by the current type.</source>
          <target state="translated">Obtient une collection des événements définis par le type actuel.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredEvents">
          <source>A collection of the events defined by the current type.</source>
          <target state="translated">Collection des événements définis par le type actuel.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredEvents">
          <source>To filter the results of the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredEvents%2A&gt;</ph> property, use LINQ queries.</source>
          <target state="translated">Pour filtrer les résultats de la <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredEvents%2A&gt;</ph> propriété, utilisez des requêtes LINQ.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredEvents">
          <source>For reflection objects that originate with the runtime (for example, as the result of <ph id="ph1">`typeof(Object)`</ph>), you can traverse the inheritance tree by using the methods in the <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> class.</source>
          <target state="translated">Pour les objets réflexion provenant du runtime (par exemple, à la suite de <ph id="ph1">`typeof(Object)`</ph>), vous pouvez parcourir l’arborescence d’héritage en utilisant les méthodes dans la <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredEvents">
          <source>Consumers of objects from customized reflection contexts cannot use these methods and must traverse the inheritance tree themselves.</source>
          <target state="translated">Les consommateurs des objets à partir de contextes de réflexion personnalisés ne peuvent pas utiliser ces méthodes et doivent parcourir l’arborescence d’héritage eux-mêmes.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.DeclaredFields">
          <source>Gets a collection of the fields defined by the current type.</source>
          <target state="translated">Obtient une collection des champs définis par le type actuel.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredFields">
          <source>A collection of the fields defined by the current type.</source>
          <target state="translated">Collection des champs définis par le type actuel.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredFields">
          <source>To filter the results of the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredFields%2A&gt;</ph> property, use LINQ queries.</source>
          <target state="translated">Pour filtrer les résultats de la <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredFields%2A&gt;</ph> propriété, utilisez des requêtes LINQ.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredFields">
          <source>For reflection objects that originate with the runtime (for example, as the result of <ph id="ph1">`typeof(Object)`</ph>), you can traverse the inheritance tree by using the methods in the <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> class.</source>
          <target state="translated">Pour les objets réflexion provenant du runtime (par exemple, à la suite de <ph id="ph1">`typeof(Object)`</ph>), vous pouvez parcourir l’arborescence d’héritage en utilisant les méthodes dans la <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredFields">
          <source>Consumers of objects from customized reflection contexts cannot use these methods and must traverse the inheritance tree themselves.</source>
          <target state="translated">Les consommateurs des objets à partir de contextes de réflexion personnalisés ne peuvent pas utiliser ces méthodes et doivent parcourir l’arborescence d’héritage eux-mêmes.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.DeclaredMembers">
          <source>Gets a collection of the members defined by the current type.</source>
          <target state="translated">Obtient une collection du membre défini par le type actuel.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMembers">
          <source>A collection of the members defined by the current type.</source>
          <target state="translated">Collection des membres définis par le type actuel.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMembers">
          <source>To filter the results of the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredMembers%2A&gt;</ph> property, use LINQ queries.</source>
          <target state="translated">Pour filtrer les résultats de la <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredMembers%2A&gt;</ph> propriété, utilisez des requêtes LINQ.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMembers">
          <source>For reflection objects that originate with the runtime (for example, as the result of <ph id="ph1">`typeof(Object)`</ph>), you can traverse the inheritance tree by using the methods in the <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> class.</source>
          <target state="translated">Pour les objets réflexion provenant du runtime (par exemple, à la suite de <ph id="ph1">`typeof(Object)`</ph>), vous pouvez parcourir l’arborescence d’héritage en utilisant les méthodes dans la <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMembers">
          <source>Consumers of objects from customized reflection contexts cannot use these methods and must traverse the inheritance tree themselves.</source>
          <target state="translated">Les consommateurs des objets à partir de contextes de réflexion personnalisés ne peuvent pas utiliser ces méthodes et doivent parcourir l’arborescence d’héritage eux-mêmes.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.DeclaredMethods">
          <source>Gets a collection of the methods defined by the current type.</source>
          <target state="translated">Obtient une collection des méthodes définies par le type actuel.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMethods">
          <source>A collection of the methods defined by the current type.</source>
          <target state="translated">Collection des méthodes définies par le type actuel.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMethods">
          <source>To filter the results of the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredMethods%2A&gt;</ph> property, use LINQ queries.</source>
          <target state="translated">Pour filtrer les résultats de la <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredMethods%2A&gt;</ph> propriété, utilisez des requêtes LINQ.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMethods">
          <source>For reflection objects that originate with the runtime (for example, as the result of <ph id="ph1">`typeof(Object)`</ph>), you can traverse the inheritance tree by using the methods in the <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> class.</source>
          <target state="translated">Pour les objets réflexion provenant du runtime (par exemple, à la suite de <ph id="ph1">`typeof(Object)`</ph>), vous pouvez parcourir l’arborescence d’héritage en utilisant les méthodes dans la <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMethods">
          <source>Consumers of objects from customized reflection contexts cannot use these methods and must traverse the inheritance tree themselves.</source>
          <target state="translated">Les consommateurs des objets à partir de contextes de réflexion personnalisés ne peuvent pas utiliser ces méthodes et doivent parcourir l’arborescence d’héritage eux-mêmes.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMethods">
          <source>This example uses the reflection types and members in the <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> subset to retrieve the methods and properties of the <ph id="ph2">&lt;xref:System.Globalization.Calendar&gt;</ph> type, including inherited methods and properties.</source>
          <target state="translated">Cet exemple utilise la réflexion types et membres dans le <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> sous-ensemble pour récupérer les méthodes et propriétés de la <ph id="ph2">&lt;xref:System.Globalization.Calendar&gt;</ph> type, y compris les méthodes et propriétés héritées.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredMethods">
          <source>To run this code, paste it into the code file for a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> XAML app that contains a <bpt id="p1">[</bpt>Windows.UI.Xaml.Controls.Textblock<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textblock.aspx)</ept> control named <ph id="ph2">`textblock1`</ph>.</source>
          <target state="translated">Pour exécuter ce code, collez-le dans le fichier de code pour un <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> application XAML qui contienne un <bpt id="p1">[</bpt>Windows.UI.Xaml.Controls.Textblock<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textblock.aspx)</ept> contrôle nommé <ph id="ph2">`textblock1`</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.DeclaredNestedTypes">
          <source>Gets a collection of the nested types defined by the current type.</source>
          <target state="translated">Obtient une collection des types imbriqués définis par le type actuel.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredNestedTypes">
          <source>A collection of nested types defined by the current type.</source>
          <target state="translated">Collection de types imbriqués définis par le type actuel.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredNestedTypes">
          <source>To filter the results of the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredNestedTypes%2A&gt;</ph> property, use LINQ queries.</source>
          <target state="translated">Pour filtrer les résultats de la <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.DeclaredNestedTypes%2A&gt;</ph> propriété, utilisez des requêtes LINQ.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredNestedTypes">
          <source>For reflection objects that originate with the runtime (for example, as the result of <ph id="ph1">`typeof(Object)`</ph>), you can traverse the inheritance tree by using the methods in the <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> class.</source>
          <target state="translated">Pour les objets réflexion provenant du runtime (par exemple, à la suite de <ph id="ph1">`typeof(Object)`</ph>), vous pouvez parcourir l’arborescence d’héritage en utilisant les méthodes dans la <ph id="ph2">&lt;xref:System.Reflection.RuntimeReflectionExtensions&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredNestedTypes">
          <source>Consumers of objects from customized reflection contexts cannot use these methods and must traverse the inheritance tree themselves.</source>
          <target state="translated">Les consommateurs des objets à partir de contextes de réflexion personnalisés ne peuvent pas utiliser ces méthodes et doivent parcourir l’arborescence d’héritage eux-mêmes.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.DeclaredProperties">
          <source>Gets a collection of the properties defined by the current type.</source>
          <target state="translated">Obtient la collection des propriétés définies par le type actuel.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredProperties">
          <source>A collection of the properties defined by the current type.</source>
          <target state="translated">Collection des propriétés définies par le type actuel.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredProperties">
          <source>This example uses the reflection types and members in the <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> subset to retrieve the methods and properties of the <ph id="ph2">&lt;xref:System.Globalization.Calendar&gt;</ph> type, including inherited methods and properties.</source>
          <target state="translated">Cet exemple utilise la réflexion types et membres dans le <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> sous-ensemble pour récupérer les méthodes et propriétés de la <ph id="ph2">&lt;xref:System.Globalization.Calendar&gt;</ph> type, y compris les méthodes et propriétés héritées.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.DeclaredProperties">
          <source>To run this code, paste it into the code file for a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> XAML app that contains a <bpt id="p1">[</bpt>Windows.UI.Xaml.Controls.Textblock<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textblock.aspx)</ept> control named <ph id="ph2">`textblock1`</ph>.</source>
          <target state="translated">Pour exécuter ce code, collez-le dans le fichier de code pour un <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> application XAML qui contienne un <bpt id="p1">[</bpt>Windows.UI.Xaml.Controls.Textblock<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textblock.aspx)</ept> contrôle nommé <ph id="ph2">`textblock1`</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.GenericTypeParameters">
          <source>Gets an array of the generic type parameters of the current instance.</source>
          <target state="translated">Obtient un tableau des paramètres de type génériques de l’instance actuelle.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.GenericTypeParameters">
          <source>An array that contains the current instance's generic type parameters, or an array of <ph id="ph1">&lt;see cref="P:System.Array.Length" /&gt;</ph> zero if the current instance has no generic type parameters.</source>
          <target state="translated">Tableau qui contient les paramètres de type génériques de l'instance actuelle ou tableau de <ph id="ph1">&lt;see cref="P:System.Array.Length" /&gt;</ph> zéro si l'instance actuelle n'a aucun paramètre de type générique.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredEvent(System.String)">
          <source>The name of the event.</source>
          <target state="translated">Nom de l'événement.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredEvent(System.String)">
          <source>Returns an object that represents the specified public event declared by the current type.</source>
          <target state="translated">Retourne un objet qui représente l'événement public spécifié déclaré par le type actuel.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredEvent(System.String)">
          <source>An object that represents the specified event, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet qui représente l'événement spécifié, s'il est trouvé ; sinon, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredEvent(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredField(System.String)">
          <source>The name of the field.</source>
          <target state="translated">Nom du champ.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredField(System.String)">
          <source>Returns an object that represents the specified public field declared by the current type.</source>
          <target state="translated">Retourne un objet qui représente le champ public spécifié déclaré par le type actuel.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredField(System.String)">
          <source>An object that represents the specified field, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet qui représente le champ spécifié, s'il est trouvé ; sinon, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredField(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredMethod(System.String)">
          <source>The name of the method.</source>
          <target state="translated">Nom de la méthode.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredMethod(System.String)">
          <source>Returns an object that represents the specified public method declared by the current type.</source>
          <target state="translated">Retourne un objet qui représente la méthode publique spécifiée déclarée par le type actuel.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredMethod(System.String)">
          <source>An object that represents the specified method, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet qui représente la méthode spécifiée, si elle est trouvée ; sinon, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredMethods(System.String)">
          <source>The method name to search for.</source>
          <target state="translated">Nom de la méthode à rechercher.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredMethods(System.String)">
          <source>Returns a collection that contains all public methods declared on the current type that match the specified name.</source>
          <target state="translated">Retourne une collection qui contient toutes les méthodes publiques déclarées sur le type actuel qui correspondent au nom spécifié.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredMethods(System.String)">
          <source>A collection that contains methods that match <ph id="ph1">&lt;paramref name="name" /&gt;</ph>.</source>
          <target state="translated">Collection qui contient des méthodes qui correspondent à <ph id="ph1">&lt;paramref name="name" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredMethods(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredNestedType(System.String)">
          <source>The name of the nested type.</source>
          <target state="translated">Nom du type imbriqué.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredNestedType(System.String)">
          <source>Returns an object that represents the specified public nested type declared by the current type.</source>
          <target state="translated">Retourne un objet qui représente le type imbriqué public spécifié déclaré par le type actuel.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredNestedType(System.String)">
          <source>An object that represents the specified nested type, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet qui représente le type imbriqué spécifié, s'il est trouvé ; sinon, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredProperty(System.String)">
          <source>The name of the property.</source>
          <target state="translated">Nom de la propriété.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredProperty(System.String)">
          <source>Returns an object that represents the specified public property declared by the current type.</source>
          <target state="translated">Retourne un objet qui représente la propriété publique spécifiée déclarée par le type actuel.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredProperty(System.String)">
          <source>An object that represents the specified property, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet qui représente la propriété spécifiée, si elle est trouvée ; sinon, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.GetDeclaredProperty(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeInfo.ImplementedInterfaces">
          <source>Gets a collection of the interfaces implemented by the current type.</source>
          <target state="translated">Obtient une collection d’interfaces implémentée par le type actuel.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeInfo.ImplementedInterfaces">
          <source>A collection of the interfaces implemented by the current type.</source>
          <target state="translated">Collection d’interfaces implémentée par le type actuel.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The type to check.</source>
          <target state="translated">Type à vérifier.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Returns a value that indicates whether the specified type can be assigned to the current type.</source>
          <target state="translated">Retourne une valeur qui indique si le type spécifié peut être affecté au type actuel.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified type can be assigned to this type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le type spécifié peut être assigné à ce type ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.System#Reflection#IReflectableType#GetTypeInfo">
          <source>Returns a representation of the current type as a <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object.</source>
          <target state="translated">Retourne une représentation du type actuel en tant qu'objet <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeInfo.System#Reflection#IReflectableType#GetTypeInfo">
          <source>A reference to the current type.</source>
          <target state="translated">Référence au type actuel.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeInfo.System#Reflection#IReflectableType#GetTypeInfo">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeInfo.System#Reflection#IReflectableType#GetTypeInfo">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Reflection.IReflectableType&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Reflection.IReflectableType&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>