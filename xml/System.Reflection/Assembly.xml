<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Assembly.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d3d5877ccfca1ad46bc974cf9102a85adaba2a32.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3d5877ccfca1ad46bc974cf9102a85adaba2a32</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</source>
          <target state="translated">Représente un assembly, qui est un bloc de construction réutilisable, avec un numéro de version et autodescriptif d'une application du Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe pour charger des assemblys, pour Explorer les parties constituant et les métadonnées d’assemblys, pour découvrir les types contenus dans des assemblys et pour créer des instances de ces types.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To get an array of <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour obtenir un tableau de <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objets représentant les assemblys actuellement chargés dans un domaine d’application (par exemple, la valeur par défaut domaine d’application d’un projet simple), utilisez le <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To load assemblies dynamically, the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class provides the following static methods (<ph id="ph2">`Shared`</ph> methods in Visual Basic).</source>
          <target state="translated">Pour charger les assemblys dynamiquement, le <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe fournit les méthodes statiques suivantes (<ph id="ph2">`Shared`</ph> méthodes en Visual Basic).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Assemblies are loaded into the application domain where the load operation occurs.</source>
          <target state="translated">Les assemblys sont chargés dans le domaine d’application où l’opération de chargement se produit.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The recommended way to load assemblies is to use the <ph id="ph1">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</source>
          <target state="translated">La méthode recommandée pour charger des assemblys consiste à utiliser le <ph id="ph1">&lt;xref:System.AppDomain.Load%2A&gt;</ph> (méthode), qui identifie l’assembly à charger par son nom complet (par exemple, « System.Windows.Forms, Version = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089 »).</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The search for the assembly follows the rules described in <bpt id="p1">[</bpt>How the Runtime Locates Assemblies<ept id="p1">](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)</ept>.</source>
          <target state="translated">La recherche de l’assembly suit les règles décrites dans <bpt id="p1">[</bpt>méthode de localisation des assemblys par le Runtime<ept id="p1">](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods enable you to load an assembly for reflection, but not for execution.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> méthodes permettent de charger un assembly pour la réflexion, mais pas pour l’exécution.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</source>
          <target state="translated">Par exemple, un assembly qui cible une plateforme 64 bits peut être examiné par le code qui s’exécute sur une plateforme 32 bits.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> methods are provided for rare scenarios in which an assembly must be identified by path.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthodes sont fournies pour les rares scénarios dans lesquels un assembly doit être identifié par le chemin d’accès.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To get an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object for the currently executing assembly, use the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> method.</source>
          <target state="translated">Pour obtenir un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objet pour l’assembly en cours d’exécution, utilisez la <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Many members of the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class provide information about an assembly.</source>
          <target state="translated">De nombreux membres de la <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe fournissent des informations sur un assembly.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For example:</source>
          <target state="translated">Exemple :</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> method returns an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that provides access to the parts of the assembly display name.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> méthode retourne un <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objet qui fournit l’accès aux parties du nom complet d’assembly.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> method lists the attributes applied to the assembly.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> méthode répertorie les attributs appliqués à l’assembly.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%2A&gt;</ph> method provides access to the files in the assembly manifest.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%2A&gt;</ph> méthode fournit l’accès aux fichiers dans le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceNames%2A&gt;</ph> method provides the names of the resources in the assembly manifest.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceNames%2A&gt;</ph> méthode fournit les noms des ressources dans le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method lists all the types in the assembly.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> méthode répertorie tous les types dans l’assembly.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> method lists the types that are visible to callers outside the assembly.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> méthode répertorie les types qui sont visibles par les appelants à l’extérieur de l’assembly.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> method can be used to search for a particular type in the assembly.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> méthode peut être utilisée pour rechercher un type particulier dans l’assembly.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%2A&gt;</ph> method can be used to search for and create instances of types in the assembly.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%2A&gt;</ph> méthode peut être utilisée pour rechercher et créer des instances de types dans l’assembly.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For more information on assemblies, see the "Application Domains and Assemblies" section in the <bpt id="p1">[</bpt>Application Domains<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept> topic.</source>
          <target state="translated">Pour plus d’informations sur les assemblys, consultez la section « Domaines d’Application et assemblys » dans le <bpt id="p1">[</bpt>domaines d’Application<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</source>
          <target state="translated">L’exemple de code suivant montre comment obtenir l’assembly en cours d’exécution, créez une instance d’un type contenu dans cet assembly et appeler une des méthodes du type avec une liaison tardive.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For this purpose, the code example defines a class named <ph id="ph1">`Example`</ph>, with a method named <ph id="ph2">`SampleMethod`</ph>.</source>
          <target state="translated">Pour cela, l’exemple de code définit une classe nommée <ph id="ph1">`Example`</ph>, avec une méthode nommée <ph id="ph2">`SampleMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The constructor of the class accepts an integer, which is used to compute the return value of the method.</source>
          <target state="translated">Le constructeur de la classe accepte un entier, qui est utilisé pour calculer la valeur de retour de la méthode.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The code example also demonstrates the use of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that can be used to parse the full name of the assembly.</source>
          <target state="translated">L’exemple de code illustre également l’utilisation de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> méthode pour obtenir un <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objet qui peut être utilisé pour analyser le nom complet de l’assembly.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The example displays the version number of the assembly, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property, and the <ph id="ph2">&lt;xref:System.Reflection.Assembly.EntryPoint%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple affiche le numéro de version de l’assembly, le <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> propriété et le <ph id="ph2">&lt;xref:System.Reflection.Assembly.EntryPoint%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>for full trust for inheritors.</source>
          <target state="translated">pour la confiance totale pour les héritiers de.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Cette classe ne peut pas être héritée par du code partiellement fiable.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.#ctor">
          <source>This constructor is invoked by derived classes during the construction of <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objects.</source>
          <target state="translated">Ce constructeur est appelé par les classes dérivées lors de la construction de <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.CodeBase">
          <source>Gets the location of the assembly as specified originally, for example, in an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">Obtient l'emplacement de l'assembly tel qu'il a été spécifié à l'origine, par exemple dans un objet <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>The location of the assembly as specified originally.</source>
          <target state="translated">Emplacement de l'assembly tel qu'il a été spécifié à l'origine.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>To get the absolute path to the loaded manifest-containing file, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Pour obtenir le chemin d’accès absolu du fichier chargé qui contient le manifeste, utilisez le <ph id="ph1">&lt;xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType&gt;</ph> propriété à la place.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>If the assembly was loaded as a byte array, using an overload of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</source>
          <target state="translated">Si l’assembly a été chargé comme un tableau d’octets, à l’aide d’une surcharge de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode qui prend un tableau d’octets, cette propriété retourne l’emplacement de l’appelant de la méthode, et non l’emplacement de l’assembly chargé.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>for access to the path.</source>
          <target state="translated">Pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Locates a type from this assembly and creates an instance of it using the system activator.</source>
          <target state="translated">Recherche un type dans cet assembly et en crée une instance à l'aide de l'activateur système.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated">Propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> du type à rechercher.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</source>
          <target state="translated">Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche respectant la casse.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>An instance of the specified type created with the default constructor; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Une instance du type spécifié créée avec le constructeur par défaut, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The type is resolved using the default binder, without specifying culture or activation attributes, and with <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> set to <ph id="ph2">&lt;see langword="Public" /&gt;</ph> or <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</source>
          <target state="translated">Le type est résolu à l'aide du binder par défaut, sans spécifier d'attributs de culture ou d'activation, et avec <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> défini sur <ph id="ph2">&lt;see langword="Public" /&gt;</ph> ou <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>If the runtime is unable to find <ph id="ph1">`typeName`</ph> in the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> instance, it returns <ph id="ph3">`null`</ph> instead of throwing an exception.</source>
          <target state="translated">Si le runtime ne peut pas trouver <ph id="ph1">`typeName`</ph> dans les <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> de l’instance, elle retourne <ph id="ph3">`null`</ph> au lieu de lever une exception.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>This might happen because:</source>
          <target state="translated">Cela peut se produire si :</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>You haven't specified the fully qualified name of the type.</source>
          <target state="translated">Vous n’avez pas spécifié le nom qualifié complet du type.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>You've specified the fully qualified type name, but its case doesn’t match the case of the type's <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Vous avez spécifié le nom de type qualifié complet, mais sa casse ne correspond pas à la casse de du type <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>For a case-insensitive comparison of <ph id="ph1">`typeName`</ph> with the type's full name, call the <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> overload and specify <ph id="ph3">`true`</ph> for the <ph id="ph4">`ignoreCase`</ph> argument.</source>
          <target state="translated">Pour une comparaison respectant la casse de <ph id="ph1">`typeName`</ph> avec le nom du type complet, appelez le <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> de surcharge et spécifiez <ph id="ph3">`true`</ph> pour la <ph id="ph4">`ignoreCase`</ph> argument.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The type doesn’t exist in the current <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> instance.</source>
          <target state="translated">Le type n’existe pas en cours <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The following example defines a <ph id="ph1">`Person`</ph> class and calls the <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> method to instantiate it.</source>
          <target state="translated">L’exemple suivant définit un <ph id="ph1">`Person`</ph> classe et appelle le <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> méthode à instancier.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est une chaîne vide ("") ou une chaîne commençant par un caractère Null.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>No matching constructor was found.</source>
          <target state="translated">Aucun constructeur correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requiert un assembly dépendant qui est introuvable.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui n’a pas été préchargé.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated">Propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> du type à rechercher.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour ignorer la casse du nom de type ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</source>
          <target state="translated">Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche facultative respectant la casse.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>An instance of the specified type created with the default constructor; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Une instance du type spécifié créée avec le constructeur par défaut, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The type is resolved using the default binder, without specifying culture or activation attributes, and with <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> set to <ph id="ph2">&lt;see langword="Public" /&gt;</ph> or <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</source>
          <target state="translated">Le type est résolu à l'aide du binder par défaut, sans spécifier d'attributs de culture ou d'activation, et avec <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> défini sur <ph id="ph2">&lt;see langword="Public" /&gt;</ph> ou <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>If the runtime is unable to find <ph id="ph1">`typeName`</ph> in the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> instance, it returns <ph id="ph3">`null`</ph> instead of throwing an exception.</source>
          <target state="translated">Si le runtime ne peut pas trouver <ph id="ph1">`typeName`</ph> dans les <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> de l’instance, elle retourne <ph id="ph3">`null`</ph> au lieu de lever une exception.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>This might happen because:</source>
          <target state="translated">Cela peut se produire si :</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>You haven't specified the fully qualified name of the type.</source>
          <target state="translated">Vous n’avez pas spécifié le nom qualifié complet du type.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The type doesn’t exist in the current <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> instance.</source>
          <target state="translated">Le type n’existe pas en cours <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The following example defines a <ph id="ph1">`Person`</ph> class.</source>
          <target state="translated">L’exemple suivant définit un <ph id="ph1">`Person`</ph> classe.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> method to instantiate it, but because the casing of the <ph id="ph2">`typeName`</ph> argument doesn’t match that of the type's <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph> property, the method returns <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> méthode instancier, mais étant donné que la casse de la <ph id="ph2">`typeName`</ph> argument ne correspond pas à celui du type <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph> propriété, la méthode retourne <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>When the example passes the same string to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> overload and specifies that the comparison should be case-insensitive, the <ph id="ph2">`Person`</ph> class is found, and a <ph id="ph3">`Person`</ph> object is successfully instantiated.</source>
          <target state="translated">Lorsque l’exemple passe la même chaîne à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> de surcharge et indique que la comparaison doit être pas la casse, le <ph id="ph2">`Person`</ph> classe est trouvée et une <ph id="ph3">`Person`</ph> objet est instancié avec succès.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est une chaîne vide ("") ou une chaîne commençant par un caractère Null.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>No matching constructor was found.</source>
          <target state="translated">Aucun constructeur correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui est introuvable.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui n’a pas été préchargé.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated">Propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> du type à rechercher.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour ignorer la casse du nom de type ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The value is a combination of bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de bits indicateurs de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array that contains the arguments to be passed to the constructor.</source>
          <target state="translated">Tableau qui contient les arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombres, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is desired, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si vous souhaitez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Instance de <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> utilisée pour régir la contrainte des types.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si la valeur est <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>(This is necessary to convert a <ph id="ph1">&lt;see langword="String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see langword="Double" /&gt;</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Par exemple, cela est nécessaire pour convertir un <ph id="ph1">&lt;see langword="String" /&gt;</ph> représentant 1000 en valeur <ph id="ph2">&lt;see langword="Double" /&gt;</ph>, car 1000 est représenté de différentes manières selon la culture.)</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Ce paramètre est lié aux objets activés par le client.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</source>
          <target state="translated">Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche facultative respectant la casse et possédant la culture, les arguments, ainsi que les attributs de liaison et d'activation spécifiés.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of the specified type, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Une instance du type spécifié ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</source>
          <target state="translated">Les arguments fournis sont utilisés pour résoudre le type, et lier le constructeur utilisé pour créer l'instance.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est une chaîne vide ("") ou une chaîne commençant par un caractère null.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">Aucun constructeur correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A non-empty activation attributes array is passed to a type that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Un tableau d’attributs d’activation non vides est passé à un type qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requiert un assembly dépendant qui est introuvable.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui n’a pas été préchargé.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>to create an instance of a delegate.</source>
          <target state="translated">Pour créer une instance d’un délégué.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The display name of an assembly.</source>
          <target state="translated">Nom complet d'un assembly.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The full name of a type.</source>
          <target state="translated">Nom complet d'un type.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>Creates the name of a type qualified by the display name of its assembly.</source>
          <target state="translated">Crée le nom d'un type qualifié par le nom complet de son assembly.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The full name of the type qualified by the display name of the assembly.</source>
          <target state="translated">Nom complet du type complet par le nom d'affichage de l'assembly.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The format of the returned string is:</source>
          <target state="translated">Le format de la chaîne retournée est :</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source><ph id="ph1">\&lt;</ph>FullTypeName&gt;, <ph id="ph2">\&lt;</ph>AssemblyDisplayName&gt;</source>
          <target state="translated"><ph id="ph1">\&lt;</ph>FullTypeName&gt;, <ph id="ph2">\&lt;</ph>AssemblyDisplayName&gt;</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour obtenir une description du format du nom d’affichage d’un assembly.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</source>
          <target state="translated">Pour prendre en compte les modifications dans les versions du common language runtime, utilisez cette méthode, plutôt que de construire le nom qualifié vous-même.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>For information about qualified assembly names, see <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les noms d’assemblys qualifiés, consultez <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.CustomAttributes">
          <source>Gets a collection that contains this assembly's custom attributes.</source>
          <target state="translated">Obtient une collection qui contient les attributs personnalisés de cet assembly.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CustomAttributes">
          <source>A collection that contains this assembly's custom attributes.</source>
          <target state="translated">Collection qui contient les attributs personnalisés de cet assembly.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>Gets a collection of the types defined in this assembly.</source>
          <target state="translated">Obtient une collection des types définis dans cet assembly.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>A collection of the types defined in this assembly.</source>
          <target state="translated">Collection des types définis dans cet assembly.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> property is comparable to the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> method, except that the <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> property returns a collection of <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objects, and the <ph id="ph5">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> method returns an array of <ph id="ph6">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> propriété est comparable à la <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> (méthode), à ceci près que le <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> propriété retourne une collection de <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objets et le <ph id="ph5">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> méthode retourne un tableau de <ph id="ph6">&lt;xref:System.Type&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>The returned array includes nested types.</source>
          <target state="translated">Le tableau retourné inclut des types imbriqués.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>Gets the entry point of this assembly.</source>
          <target state="translated">Obtient le point d'entrée de cet assembly.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>An object that represents the entry point of this assembly.</source>
          <target state="translated">Objet qui représente le point d'entrée de cet assembly.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>If no entry point is found (for example, the assembly is a DLL), <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Si aucun point d'entrée n'est détecté (par exemple, si l'assembly est une DLL), <ph id="ph1">&lt;see langword="null" /&gt;</ph> est retourné.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>The object to compare with this instance.</source>
          <target state="translated">Objet à comparer avec cette instance.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>Determines whether this assembly and the specified object are equal.</source>
          <target state="translated">Détermine si cet assembly et l'objet spécifié sont égaux.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is equal to this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="o" /&gt;</ph> est égal à cette instance ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.Equals%2A&gt;</ph> method performs a test for reference equality to determine whether the current instance and <ph id="ph2">`o`</ph> are equal.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.Equals%2A&gt;</ph> méthode effectue un test d’égalité de référence déterminer si l’instance actuelle et <ph id="ph2">`o`</ph> sont égales.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>Gets the URI, including escape characters, that represents the codebase.</source>
          <target state="translated">Obtient l'URI, y compris les caractères d'espacement, qui représente le code base.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>A URI with escape characters.</source>
          <target state="translated">Un URI avec des caractères d'espacement.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>for access to the path.</source>
          <target state="translated">Pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Evidence">
          <source>Gets the evidence for this assembly.</source>
          <target state="translated">Obtient la preuve pour cet assembly.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>The evidence for this assembly.</source>
          <target state="translated">Preuve pour cet assembly.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</source>
          <target state="translated">La preuve est le jeu d'informations qui alimente les décisions de stratégie de sécurité, telles que les autorisations qui peuvent être accordées au code.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ExportedTypes">
          <source>Gets a collection of the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">Obtient une collection des types publics définis dans cet assembly qui sont visibles à l’extérieur de l’assembly.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ExportedTypes">
          <source>A collection of the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">Collection des types publics définis dans cet assembly qui sont visibles à l’extérieur de l’assembly.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.FullName">
          <source>Gets the display name of the assembly.</source>
          <target state="translated">Obtient le nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour obtenir une description du format du nom d’affichage d’un assembly.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>Writing your own code to parse display names is not recommended.</source>
          <target state="translated">L’écriture de votre propre code pour analyser les noms d’affichage n’est pas recommandée.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>Instead, pass the display name to the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.%23ctor%2A&gt;</ph> constructor, which parses it and populates the appropriate fields of the new <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>.</source>
          <target state="translated">Au lieu de cela, passez le nom complet à la <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.%23ctor%2A&gt;</ph> constructeur, qui analyse et remplit les champs appropriés du nouveau <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Toutefois, il n’est pas inclus dans la chaîne retournée par la <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> propriété, pour des raisons de compatibilité.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type (<ph id="ph2">`int`</ph> in C#, <ph id="ph3">`Integer`</ph> in Visual Basic).</source>
          <target state="translated">L’exemple suivant récupère le nom complet de l’assembly en cours d’exécution et le nom complet de l’assembly qui contient le <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type (<ph id="ph2">`int`</ph> en c#, <ph id="ph3">`Integer`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>An object representing a type in the assembly that will be returned.</source>
          <target state="translated">Objet représentant un type de l’assembly retourné.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Gets the currently loaded assembly in which the specified type is defined.</source>
          <target state="translated">Obtient l’assembly actuellement chargé dans lequel le type spécifié est défini.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>The assembly in which the specified type is defined.</source>
          <target state="translated">Assembly dans lequel le type spécifié est défini.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Calling this method is equivalent to retrieving the value of the  <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Appel de cette méthode est équivalente à la récupération de la valeur de la <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> property typically offers superior performance.</source>
          <target state="translated">Toutefois, le <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> propriété offre généralement de meilleures performances.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>In order to call this method, you must have a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object, which means that the assembly in which the class is defined must already be loaded.</source>
          <target state="translated">Afin d’appeler cette méthode, vous devez avoir un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objet, ce qui signifie que l’assembly dans lequel la classe est définie doit déjà être chargé.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>The following example retrieves the assembly that contains the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type and displays its name and file location.</source>
          <target state="translated">L’exemple suivant récupère l’assembly qui contient le <ph id="ph1">&lt;xref:System.Int32&gt;</ph> de type et affiche son nom et chaque emplacement.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> of the method that invoked the currently executing method.</source>
          <target state="translated">Retourne le <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> de la méthode ayant appelé la méthode en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>The <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> object of the method that invoked the currently executing method.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> de la méthode ayant appelé la méthode en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>If the method that calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> may differ unexpectedly.</source>
          <target state="translated">Si la méthode qui appelle le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> méthode est développée inline par le compilateur juste-à-temps (JIT), ou si son appelant est développé inline, l’assembly qui est retourné par <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> peut différer de façon inattendue.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>For example, consider the following methods and assemblies:</source>
          <target state="translated">Par exemple, considérez les méthodes et les assemblys suivants :</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M1`</ph> in assembly <ph id="ph2">`A1`</ph> calls <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</source>
          <target state="translated">Méthode <ph id="ph1">`M1`</ph> dans l’assembly <ph id="ph2">`A1`</ph> appelle <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M2`</ph> in assembly <ph id="ph2">`A2`</ph> calls <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">Méthode <ph id="ph1">`M2`</ph> dans l’assembly <ph id="ph2">`A2`</ph> appelle <ph id="ph3">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M3`</ph> in assembly <ph id="ph2">`A3`</ph> calls <ph id="ph3">`M2`</ph>.</source>
          <target state="translated">Méthode <ph id="ph1">`M3`</ph> dans l’assembly <ph id="ph2">`A3`</ph> appelle <ph id="ph3">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M1`</ph> is not inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A2`</ph>.</source>
          <target state="translated">Lorsque <ph id="ph1">`M1`</ph> n’est pas mise inline, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> retourne <ph id="ph3">`A2`</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M1`</ph> is inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A3`</ph>.</source>
          <target state="translated">Lorsque <ph id="ph1">`M1`</ph> est inline, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> retourne <ph id="ph3">`A3`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Similarly, when <ph id="ph1">`M2`</ph> is not inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A2`</ph>.</source>
          <target state="translated">De même, lorsque <ph id="ph1">`M2`</ph> n’est pas mise inline, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> retourne <ph id="ph3">`A2`</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M2`</ph> is inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A3`</ph>.</source>
          <target state="translated">Lorsque <ph id="ph1">`M2`</ph> est inline, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> retourne <ph id="ph3">`A3`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>This effect also occurs when <ph id="ph1">`M1`</ph> executes as a tail call from <ph id="ph2">`M2`</ph>, or when <ph id="ph3">`M2`</ph> executes as a tail call from <ph id="ph4">`M3`</ph>.</source>
          <target state="translated">Cela se produit également lorsque <ph id="ph1">`M1`</ph> s’exécute comme un appel tail de <ph id="ph2">`M2`</ph>, ou lorsque <ph id="ph3">`M2`</ph> s’exécute comme un appel tail de <ph id="ph4">`M3`</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>You can prevent the JIT compiler from inlining the method that calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>, by applying the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph> attribute with the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType&gt;</ph> flag, but there is no similar mechanism for preventing tail calls.</source>
          <target state="translated">Vous pouvez empêcher le compilateur JIT d’incorporation (inlining) la méthode qui appelle <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>, en appliquant le <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph> attribut avec le <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType&gt;</ph> indicateur, mais il n’existe aucun mécanisme similaire pour empêcher les appels tail.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>The following example gets the calling assembly of the current method.</source>
          <target state="translated">L’exemple suivant obtient l’assembly appelant de la méthode actuelle.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the custom attributes for this assembly.</source>
          <target state="translated">Obtient les attributs personnalisés pour cet assembly.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Cet argument est ignoré pour les objets de type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Gets all the custom attributes for this assembly.</source>
          <target state="translated">Obtient tous les attributs personnalisés pour cet assembly.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>An array that contains the custom attributes for this assembly.</source>
          <target state="translated">Tableau qui contient les attributs personnalisés pour cet assembly.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>This method implements the corresponding <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> interface method.</source>
          <target state="translated">Cette méthode implémente correspondant <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> méthode d’interface.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Therefore, the <ph id="ph1">`inherit`</ph> parameter must be specified even though it is ignored.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`inherit`</ph> paramètre doit être spécifié même s’il est ignoré.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</source>
          <target state="translated">Un attribut pseudo-aléatoire indique les bits des métadonnées de base qui doit être définie lorsque l’attribut est présent.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</source>
          <target state="translated">Contrairement à un attribut personnalisé qui étend les métadonnées d’un type et est enregistré avec le type, un attribut pseudo-aléatoire modifie les métadonnées pour le type et qu’elle est ensuite ignoré.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Some of the resulting bits cannot be accessed using existing reflection APIs.</source>
          <target state="translated">Certains bits obtenus ne sont pas accessibles à l’aide des API de réflexion existantes.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</source>
          <target state="translated">Le tableau suivant résume les différents attributs de pseudo et les accesseurs pour les bits qui sont disponibles dans la réflexion.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Pseudo-Attribute</source>
          <target state="translated">Pseudo-Attribute</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Metadata Bits</source>
          <target state="translated">Bits de métadonnées</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Reflection Accessor</source>
          <target state="translated">Accesseur de réflexion</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>DllImportAttribute</source>
          <target state="translated">DllImportAttribute</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorPInvokeMap</source>
          <target state="translated">CorPInvokeMap</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>DLL name</source>
          <target state="translated">Nom de la DLL</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor for PInvokeMap for ordinary method/global method attributes.</source>
          <target state="translated">Aucun accesseur pour PInvokeMap pour les attributs de méthode méthode/globale ordinaires.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor for DLL name.</source>
          <target state="translated">Aucun accesseur pour le nom de la DLL.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>GuidAttribute</source>
          <target state="translated">GuidAttribute</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Stored as a real custom attribute.</source>
          <target state="translated">Stocké comme un attribut personnalisé réel.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Accessed as a real custom attribute.</source>
          <target state="translated">Accessible en tant qu’un attribut personnalisé réel.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ComImportAttribute</source>
          <target state="translated">ComImportAttribute</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdImport</source>
          <target state="translated">CorTypeAttr.tdImport</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.Import</source>
          <target state="translated">Type.Attributes.Import</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>SerializableAttribute</source>
          <target state="translated">SerializableAttribute</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdSerializable</source>
          <target state="translated">CorTypeAttr.tdSerializable</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.Serializable</source>
          <target state="translated">Type.Attributes.Serializable</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>NonSerializedAttribute</source>
          <target state="translated">NonSerializedAttribute</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorFieldAttr.fdNotSerialized</source>
          <target state="translated">CorFieldAttr.fdNotSerialized</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>FieldInfo.Attributes.NotSerialized</source>
          <target state="translated">FieldInfo.Attributes.NotSerialized</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodImplAttribute</source>
          <target state="translated">MethodImplAttribute</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorMethodImpl</source>
          <target state="translated">CorMethodImpl</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags()</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags()</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MarshalAsAttribute</source>
          <target state="translated">MarshalAsAttribute</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Various bits.</source>
          <target state="translated">Divers bits.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Pas d’accesseur.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>PreserveSigAttribute</source>
          <target state="translated">PreserveSigAttribute</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorMethodImpl.miOLE</source>
          <target state="translated">CorMethodImpl.miOLE</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>InAttribute</source>
          <target state="translated">InAttribute</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorParamAttr.pdIn</source>
          <target state="translated">CorParamAttr.pdIn</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ParameterInfo.Attributes.In</source>
          <target state="translated">ParameterInfo.Attributes.In</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>OutAttribute</source>
          <target state="translated">OutAttribute</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorParamAttr.pdOut</source>
          <target state="translated">CorParamAttr.pdOut</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ParameterInfo.Attributes.Out</source>
          <target state="translated">ParameterInfo.Attributes.Out</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>StructLayoutAttribute</source>
          <target state="translated">StructLayoutAttribute</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdLayoutSequential</source>
          <target state="translated">CorTypeAttr.tdLayoutSequential</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdExplicitLayout</source>
          <target state="translated">CorTypeAttr.tdExplicitLayout</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdAnsiClass</source>
          <target state="translated">CorTypeAttr.tdAnsiClass</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdUnicodeClass</source>
          <target state="translated">CorTypeAttr.tdUnicodeClass</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdAutoClass</source>
          <target state="translated">CorTypeAttr.tdAutoClass</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Class packing.</source>
          <target state="translated">Compression de la classe.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.LayoutSequential</source>
          <target state="translated">Type.Attributes.LayoutSequential</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.ExplicitLayout</source>
          <target state="translated">Type.Attributes.ExplicitLayout</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.AnsiClass</source>
          <target state="translated">Type.Attributes.AnsiClass</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.UnicodeClass</source>
          <target state="translated">Type.Attributes.UnicodeClass</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.AutoClass</source>
          <target state="translated">Type.Attributes.AutoClass</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Pas d’accesseur.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>FieldOffsetAttribute</source>
          <target state="translated">FieldOffsetAttribute</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Field offset.</source>
          <target state="translated">Offset de champ.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Pas d’accesseur.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>AssemblyLoadAttribute</source>
          <target state="translated">AssemblyLoadAttribute</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorAssemblyFlags</source>
          <target state="translated">CorAssemblyFlags</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor or enumerator.</source>
          <target state="translated">Aucun accesseur ou l’énumérateur.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type for which the custom attributes are to be returned.</source>
          <target state="translated">Type pour lequel les attributs personnalisés doivent être retournés.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Cet argument est ignoré pour les objets de type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Gets the custom attributes for this assembly as specified by type.</source>
          <target state="translated">Obtient les attributs personnalisés pour cet assembly, tels qu'ils sont spécifiés par le type.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array that contains the custom attributes for this assembly as specified by <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated">Tableau qui contient les attributs personnalisés pour cet assembly, tels qu'ils sont spécifiés par <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method implements the corresponding <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> interface method.</source>
          <target state="translated">Cette méthode implémente correspondant <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> méthode d’interface.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Therefore, the <ph id="ph1">`inherit`</ph> parameter must be specified even though it is ignored.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`inherit`</ph> paramètre doit être spécifié même s’il est ignoré.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</source>
          <target state="translated">Un attribut pseudo-aléatoire indique les bits des métadonnées de base qui doit être définie lorsque l’attribut est présent.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</source>
          <target state="translated">Contrairement à un attribut personnalisé qui étend les métadonnées d’un type et est enregistré avec le type, un attribut pseudo-aléatoire modifie les métadonnées pour le type et qu’elle est ensuite ignoré.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Some of the resulting bits cannot be accessed using existing reflection APIs.</source>
          <target state="translated">Certains bits obtenus ne sont pas accessibles à l’aide des API de réflexion existantes.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</source>
          <target state="translated">Le tableau suivant résume les différents attributs de pseudo et les accesseurs pour les bits qui sont disponibles dans la réflexion.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Pseudo-Attribute</source>
          <target state="translated">Pseudo-Attribute</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Metadata Bits</source>
          <target state="translated">Bits de métadonnées</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Reflection Accessor</source>
          <target state="translated">Accesseur de réflexion</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>DllImportAttribute</source>
          <target state="translated">DllImportAttribute</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorPInvokeMap</source>
          <target state="translated">CorPInvokeMap</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>DLL name</source>
          <target state="translated">Nom de la DLL</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor for PInvokeMap for ordinary method/global method attributes.</source>
          <target state="translated">Aucun accesseur pour PInvokeMap pour les attributs de méthode méthode/globale ordinaires.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor for DLL name.</source>
          <target state="translated">Aucun accesseur pour le nom de la DLL.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>GuidAttribute</source>
          <target state="translated">GuidAttribute</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Stored as a real custom attribute.</source>
          <target state="translated">Stocké comme un attribut personnalisé réel.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Accessed as a real custom attribute.</source>
          <target state="translated">Accessible en tant qu’un attribut personnalisé réel.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ComImportAttribute</source>
          <target state="translated">ComImportAttribute</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdImport</source>
          <target state="translated">CorTypeAttr.tdImport</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.Import</source>
          <target state="translated">Type.Attributes.Import</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>SerializableAttribute</source>
          <target state="translated">SerializableAttribute</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdSerializable</source>
          <target state="translated">CorTypeAttr.tdSerializable</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.Serializable</source>
          <target state="translated">Type.Attributes.Serializable</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>NonSerializedAttribute</source>
          <target state="translated">NonSerializedAttribute</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorFieldAttr.fdNotSerialized</source>
          <target state="translated">CorFieldAttr.fdNotSerialized</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>FieldInfo.Attributes.NotSerialized</source>
          <target state="translated">FieldInfo.Attributes.NotSerialized</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodImplAttribute</source>
          <target state="translated">MethodImplAttribute</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorMethodImpl</source>
          <target state="translated">CorMethodImpl</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags()</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags()</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MarshalAsAttribute</source>
          <target state="translated">MarshalAsAttribute</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Various bits.</source>
          <target state="translated">Divers bits.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Pas d’accesseur.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>PreserveSigAttribute</source>
          <target state="translated">PreserveSigAttribute</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorMethodImpl.miOLE</source>
          <target state="translated">CorMethodImpl.miOLE</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>InAttribute</source>
          <target state="translated">InAttribute</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorParamAttr.pdIn</source>
          <target state="translated">CorParamAttr.pdIn</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ParameterInfo.Attributes.In</source>
          <target state="translated">ParameterInfo.Attributes.In</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>OutAttribute</source>
          <target state="translated">OutAttribute</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorParamAttr.pdOut</source>
          <target state="translated">CorParamAttr.pdOut</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ParameterInfo.Attributes.Out</source>
          <target state="translated">ParameterInfo.Attributes.Out</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>StructLayoutAttribute</source>
          <target state="translated">StructLayoutAttribute</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdLayoutSequential</source>
          <target state="translated">CorTypeAttr.tdLayoutSequential</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdExplicitLayout</source>
          <target state="translated">CorTypeAttr.tdExplicitLayout</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdAnsiClass</source>
          <target state="translated">CorTypeAttr.tdAnsiClass</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdUnicodeClass</source>
          <target state="translated">CorTypeAttr.tdUnicodeClass</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdAutoClass</source>
          <target state="translated">CorTypeAttr.tdAutoClass</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Class packing.</source>
          <target state="translated">Compression de la classe.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.LayoutSequential</source>
          <target state="translated">Type.Attributes.LayoutSequential</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.ExplicitLayout</source>
          <target state="translated">Type.Attributes.ExplicitLayout</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.AnsiClass</source>
          <target state="translated">Type.Attributes.AnsiClass</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.UnicodeClass</source>
          <target state="translated">Type.Attributes.UnicodeClass</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.AutoClass</source>
          <target state="translated">Type.Attributes.AutoClass</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Pas d’accesseur.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>FieldOffsetAttribute</source>
          <target state="translated">FieldOffsetAttribute</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Field offset.</source>
          <target state="translated">Offset de champ.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Pas d’accesseur.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>AssemblyLoadAttribute</source>
          <target state="translated">AssemblyLoadAttribute</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorAssemblyFlags</source>
          <target state="translated">CorAssemblyFlags</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor or enumerator.</source>
          <target state="translated">Aucun accesseur ou l’énumérateur.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a runtime type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> n'est pas un type au moment de l'exécution.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Returns information about the attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, expressed as <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects.</source>
          <target state="translated">Retourne des informations sur les attributs appliqués au <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> actuel, en tant qu'objets <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current assembly.</source>
          <target state="translated">Liste générique d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> représentant des données relatives aux attributs qui ont été appliqués à l'assembly actuel.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Utilisez cette méthode pour examiner les attributs personnalisés du code dans le contexte de réflexion uniquement, dans les cas où les attributs personnalisés eux-mêmes sont définis dans le code qui est chargé dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Methods like <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Méthodes, telles que <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> ne peut pas être utilisé dans ce cas, parce qu’elles créent des instances des attributs.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">Impossible d’exécuter le code dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>For more information and for example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Pour plus d’informations et un par exemple de code, consultez la <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>Gets the process executable in the default application domain.</source>
          <target state="translated">Obtient l'exécutable du processus dans le domaine d'application par défaut.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>In other application domains, this is the first executable that was executed by <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</source>
          <target state="translated">Dans les autres domaines d'application, il s'agit du premier exécutable exécuté par <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>The assembly that is the process executable in the default application domain, or the first executable that was executed by <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</source>
          <target state="translated">Assembly qui est l'exécutable du processus dans le domaine d'application par défaut, ou le premier exécutable exécuté par <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>Can return <ph id="ph1">&lt;see langword="null" /&gt;</ph> when called from unmanaged code.</source>
          <target state="translated">Peut retourner <ph id="ph1">&lt;see langword="null" /&gt;</ph> quand il est appelé à partir de code non managé.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> method can return <ph id="ph2">`null`</ph> when a managed assembly has been loaded from an unmanaged application.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> méthode peut retourner <ph id="ph2">`null`</ph> lorsqu’un assembly managé a été chargé à partir d’une application non managée.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</source>
          <target state="translated">Par exemple, si une application non managée crée une instance d’un composant COM écrit en c#, un appel à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> méthode à partir du composant c# retourne la valeur null, car le point d’entrée pour le processus était du code non managé plutôt qu’un assembly managé.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>Gets the assembly that contains the code that is currently executing.</source>
          <target state="translated">Obtient l'assembly qui contient le code en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The assembly that contains the code that is currently executing.</source>
          <target state="translated">Assembly qui contient le code en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</source>
          <target state="translated">Pour des raisons de performances, vous devez appeler cette méthode uniquement lorsque vous ne connaissez pas au moment du design l’assembly en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The recommended way to retrieve an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents the current assembly is to use the <ph id="ph2">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property of a type found in the assembly, as the following example illustrates.</source>
          <target state="translated">La méthode recommandée pour récupérer un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objet qui représente l’assembly actuel est d’utiliser le <ph id="ph2">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> propriété d’un type trouvé dans l’assembly, comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>To get the assembly that contains the method that called the currently executing code, use <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</source>
          <target state="translated">Pour obtenir l’assembly qui contient la méthode qui a appelé le code en cours d’exécution, utilisez <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property to get the currently executing assembly based on a type contained in that assembly.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> propriété à obtenir l’assembly en cours d’exécution basé sur un type de contenu dans cet assembly.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>It also calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> method to show that it returns an <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents the same assembly.</source>
          <target state="translated">Il appelle également la <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> méthode pour montrer qu’il retourne un <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> objet qui représente le même assembly.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>Gets the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">Obtient les types publics définis dans cet assembly qui sont visibles à l'extérieur de l'assembly.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>An array that represents the types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">Tableau qui représente les types définis dans cet assembly qui sont visibles à l'extérieur de l'assembly.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The only types visible outside an assembly are public types and public types nested within other public types.</source>
          <target state="translated">Les seuls types visibles en dehors d’un assembly sont les types publics et les types publics imbriqués dans d’autres types publics.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The following code sample defines a number of classes with various access levels, and calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> to display the ones that are visible from outside the assembly.</source>
          <target state="translated">L’exemple de code suivant définit plusieurs classes avec différents niveaux d’accès et appelle <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> pour afficher celles qui sont visibles à l’extérieur de l’assembly.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The assembly is a dynamic assembly.</source>
          <target state="translated">L’assembly est un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>Unable to load a dependent assembly.</source>
          <target state="translated">Impossible de charger un assembly dépendant.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The name of the specified file.</source>
          <target state="translated">Nom du fichier spécifié.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Do not include the path to the file.</source>
          <target state="translated">N’incluez pas le chemin d’accès au fichier.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> for the specified file in the file table of the manifest of this assembly.</source>
          <target state="translated">Obtient un <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> pour le fichier spécifié dans la table de fichiers du manifeste de cet assembly.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>A stream that contains the specified file, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the file is not found.</source>
          <target state="translated">Flux qui contient le fichier spécifié, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si le fichier est introuvable.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>This method works on both public and private resource files.</source>
          <target state="translated">Cette méthode fonctionne sur les deux fichiers de ressources publics et privés.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">`name`</ph> should not include the path to the file.</source>
          <target state="translated">Le <ph id="ph1">`name`</ph> ne doit pas inclure le chemin d’accès au fichier.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>for access to the path and for reading the specified file.</source>
          <target state="translated">Pour accéder au chemin d’accès et pour lire le fichier spécifié.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph> et <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the files in the file table of an assembly manifest.</source>
          <target state="translated">Obtient les fichiers de la table de fichiers d'un manifeste d'assembly.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>Gets the files in the file table of an assembly manifest.</source>
          <target state="translated">Obtient les fichiers de la table de fichiers d'un manifeste d'assembly.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>An array of streams that contain the files.</source>
          <target state="translated">Tableau des flux de données qui contiennent les fichiers.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles">
          <source>This method works on public and private resource files.</source>
          <target state="translated">Cette méthode fonctionne sur les fichiers de ressources publics et privés.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles">
          <source>This overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Cette surcharge revient à appeler la <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29&gt;</ph> surcharge et en spécifiant <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file was not found.</source>
          <target state="translated">Un fichier est introuvable.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file was not a valid assembly.</source>
          <target state="translated">Un fichier n’était pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour inclure des modules de ressources ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</source>
          <target state="translated">Obtient les fichiers de la table de fichiers d'un manifeste d'assembly, en spécifiant si des modules de ressources doivent être inclus.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>An array of streams that contain the files.</source>
          <target state="translated">Tableau des flux de données qui contiennent les fichiers.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>This method works on public and private resource files.</source>
          <target state="translated">Cette méthode fonctionne sur les fichiers de ressources publics et privés.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file was not found.</source>
          <target state="translated">Un fichier est introuvable.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file was not a valid assembly.</source>
          <target state="translated">Un fichier n’était pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retourne le code de hachage de cette instance.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Code de hachage d'un entier signé 32 bits.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets all the loaded modules that are part of this assembly.</source>
          <target state="translated">Obtient tous les modules chargés qui appartiennent à cet assembly.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules">
          <source>Gets all the loaded modules that are part of this assembly.</source>
          <target state="translated">Obtient tous les modules chargés qui appartiennent à cet assembly.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules">
          <source>An array of modules.</source>
          <target state="translated">Tableau de modules.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour inclure des modules de ressources ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source>Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</source>
          <target state="translated">Obtient tous les modules chargés qui appartiennent à cet assembly, en spécifiant si des modules de ressources doivent être inclus.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source>An array of modules.</source>
          <target state="translated">Tableau de modules.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>The case-sensitive name of the resource.</source>
          <target state="translated">Nom de la ressource respectant la casse.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Returns information about how the given resource has been persisted.</source>
          <target state="translated">Retourne des informations sur la manière dont la ressource donnée a été persistante.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>An object that is populated with information about the resource's topology, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the resource is not found.</source>
          <target state="translated">Objet qui est rempli par des informations sur la topologie de la ressource, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si la ressource est introuvable.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant, ou l’appelant a <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Returns the names of all the resources in this assembly.</source>
          <target state="translated">Retourne les noms de toutes les ressources de cet assembly.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>An array that contains the names of all the resources.</source>
          <target state="translated">Tableau qui contient les noms de toutes les ressources.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can use each resource name in the array returned by this method as follows:</source>
          <target state="translated">Vous pouvez utiliser le nom de chaque ressource dans le tableau retourné par cette méthode comme suit :</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceInfo%2A&gt;</ph> method to get additional information about the resource.</source>
          <target state="translated">Vous pouvez passer le nom de ressource pour le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceInfo%2A&gt;</ph> méthode pour obtenir des informations supplémentaires sur la ressource.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <ph id="ph1">&lt;xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate the resource manager.</source>
          <target state="translated">Si le nom identifie un fichier .resources binaire, vous pouvez supprimer son extension de fichier .resources et passer à la <ph id="ph1">&lt;xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType&gt;</ph> constructeur pour instancier le Gestionnaire de ressources.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object that you can then pass to the <ph id="ph3">&lt;xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Vous pouvez passer le nom de ressource pour le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> méthode pour récupérer un <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> objet que vous pouvez ensuite passer le <ph id="ph3">&lt;xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object that you can then pass to the <ph id="ph3">&lt;xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Vous pouvez passer le nom de ressource pour le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> méthode pour récupérer un <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> objet que vous pouvez ensuite passer le <ph id="ph3">&lt;xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant, ou l’appelant a <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">Charge la ressource de manifeste spécifiée à partir de cet assembly.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The case-sensitive name of the manifest resource being requested.</source>
          <target state="translated">Nom de la ressource de manifeste demandée respectant la casse.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">Charge la ressource de manifeste spécifiée à partir de cet assembly.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The manifest resource; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no resources were specified during compilation or if the resource is not visible to the caller.</source>
          <target state="translated">La ressource de manifeste ; ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si aucune ressource n'a été spécifiée pendant la compilation, ou si la ressource n'est pas visible par l'appelant.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</source>
          <target state="translated">Une ressource de manifeste est une ressource (par exemple, un fichier image) qui est incorporée dans l’assembly au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>For more information about manifest resources, see <bpt id="p1">[</bpt>Microsoft .NET Framework Resource Basics<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> in the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur les ressources de manifeste, consultez <bpt id="p1">[</bpt>Microsoft .NET Framework Resource Basics<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> dans MSDN Library.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant, ou l’appelant a <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>This method returns <ph id="ph1">`null`</ph> if a private resource in another assembly is accessed and the caller does not have <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Cette méthode retourne <ph id="ph1">`null`</ph> si une ressource privée dans un autre assembly est accessible et que l’appelant n’a pas <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>If the assembly manifest lists a resource file, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object even if the resource file cannot be found on disk at the time.</source>
          <target state="translated">Si le manifeste d’assembly répertorie un fichier de ressources <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> retourne un <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> même si le fichier de ressources est introuvable sur le disque au moment de l’objet.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>If the resource file is not found, passing the resulting <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> constructor causes an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Si le fichier de ressources est introuvable, le passage résultant <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> de l’objet à la <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> constructeur entraîne une <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Dans <bpt id="p1">[</bpt>.NET pour les applications du Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou la <bpt id="p2">[</bpt>Bibliothèque de classes portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, interceptez l’exception de la classe de base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, à la place.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Resource length is greater than <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La longueur de la ressource est supérieure à <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The type whose namespace is used to scope the manifest resource name.</source>
          <target state="translated">Type dont l'espace de noms définit la portée du nom de la ressource de manifeste.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The case-sensitive name of the manifest resource being requested.</source>
          <target state="translated">Nom de la ressource de manifeste demandée respectant la casse.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</source>
          <target state="translated">Charge la ressource de manifeste spécifiée, dont la portée est définie par l'espace de noms du type déterminé, à partir de cet assembly.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The manifest resource; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no resources were specified during compilation or if the resource is not visible to the caller.</source>
          <target state="translated">La ressource de manifeste ; ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si aucune ressource n'a été spécifiée pendant la compilation, ou si la ressource n'est pas visible par l'appelant.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>For example, if the full name specified for <ph id="ph1">`type`</ph> is "MyNameSpace.MyClasses" and <ph id="ph2">`name`</ph> is "Net", this method overload searches for a resource named "MyNameSpace.Net".</source>
          <target state="translated">Par exemple, si le nom complet spécifié pour <ph id="ph1">`type`</ph> est « MyNameSpace.MyClasses » et <ph id="ph2">`name`</ph> est « Net », cette méthode recherche une ressource nommée « MyNameSpace.Net » de surcharge.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</source>
          <target state="translated">Une ressource de manifeste est une ressource (par exemple, un fichier image) qui est incorporée dans l’assembly au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>For more information about manifest resources, see <bpt id="p1">[</bpt>Microsoft .NET Framework Resource Basics<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> in the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur les ressources de manifeste, consultez <bpt id="p1">[</bpt>Microsoft .NET Framework Resource Basics<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> dans MSDN Library.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant, ou l’appelant a <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>This method returns <ph id="ph1">`null`</ph> if a private resource in another assembly is accessed and the caller does not have <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Cette méthode retourne <ph id="ph1">`null`</ph> si une ressource privée dans un autre assembly est accessible et que l’appelant n’a pas <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>If the assembly manifest lists a resource file, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object even if the resource file cannot be found on disk at the time.</source>
          <target state="translated">Si le manifeste d’assembly répertorie un fichier de ressources <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> retourne un <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> même si le fichier de ressources est introuvable sur le disque au moment de l’objet.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>If the resource file is not found, passing the resulting <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> constructor causes an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Si le fichier de ressources est introuvable, le passage résultant <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> de l’objet à la <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> constructeur entraîne une <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Resource length is greater than <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La longueur de la ressource est supérieure à <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The name of the module being requested.</source>
          <target state="translated">Nom du module demandé.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Gets the specified module in this assembly.</source>
          <target state="translated">Obtient le module spécifié dans cet assembly.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The module being requested, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the module is not found.</source>
          <target state="translated">Module demandé, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si le module est introuvable.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>This method works on file names.</source>
          <target state="translated">Cette méthode fonctionne sur les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Classes in the <ph id="ph1">`Reflection.Emit`</ph> namespace emit the scope name for a dynamic module.</source>
          <target state="translated">Classes de la <ph id="ph1">`Reflection.Emit`</ph> espace de noms émettent le nom de la portée d’un module dynamique.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The scope name can be determined by the <ph id="ph1">&lt;xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Nom de l’étendue peut être déterminé par le <ph id="ph1">&lt;xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Pass the kind of module you want to <ph id="ph1">`Assembly.GetModule`</ph>.</source>
          <target state="translated">Passez le type de module que vous souhaitez <ph id="ph1">`Assembly.GetModule`</ph>.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>For example, if you want the module that contains the assembly manifest, pass the scope name of the module to <ph id="ph1">`GetModule`</ph>.</source>
          <target state="translated">Par exemple, si vous souhaitez que le module qui contient le manifeste d’assembly, passez le nom de l’étendue du module à <ph id="ph1">`GetModule`</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Otherwise, pass the file name of the module.</source>
          <target state="translated">Sinon, passez le nom de fichier du module.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Assemblies loaded by one of the <ph id="ph1">`Load`</ph> methods that have a byte[] parameter have only one module, and that is the manifest module.</source>
          <target state="translated">Les assemblys chargés par un de le <ph id="ph1">`Load`</ph> méthodes qui possèdent un paramètre byte [] disposent uniquement d’un module, et qui est le module du manifeste.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Always seek these modules using the scope name.</source>
          <target state="translated">Toujours demander ces modules à l’aide du nom de l’étendue.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Un type peut être récupéré à partir d’un module spécifique à l’aide de <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Calling <ph id="ph1">`Module.GetType`</ph> on the module containing the manifest will not initiate a search of the entire assembly.</source>
          <target state="translated">Appel de <ph id="ph1">`Module.GetType`</ph> sur le module contenant le manifeste ne sera pas lancer une recherche dans la totalité de l’assembly.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets all the modules that are part of this assembly.</source>
          <target state="translated">Obtient tous les modules qui appartiennent à cet assembly.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>Gets all the modules that are part of this assembly.</source>
          <target state="translated">Obtient tous les modules qui appartiennent à cet assembly.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>An array of modules.</source>
          <target state="translated">Tableau de modules.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>This method works on public and private resource files.</source>
          <target state="translated">Cette méthode fonctionne sur les fichiers de ressources publics et privés.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>Modules must be emitted with file name extensions.</source>
          <target state="translated">Les modules doivent être émises avec les extensions de nom de fichier.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>The following example displays the name of the module in the returned array that contains the assembly manifest.</source>
          <target state="translated">L’exemple suivant affiche le nom du module dans le tableau retourné qui contient le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>The module to be loaded does not specify a file name extension.</source>
          <target state="translated">Le module à charger ne spécifie pas une extension de nom de fichier.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour inclure des modules de ressources ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>Gets all the modules that are part of this assembly, specifying whether to include resource modules.</source>
          <target state="translated">Obtient tous les modules qui appartiennent à cet assembly, en spécifiant si des modules de ressources doivent être inclus.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>An array of modules.</source>
          <target state="translated">Tableau de modules.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>This method works on public and private resource files.</source>
          <target state="translated">Cette méthode fonctionne sur les fichiers de ressources publics et privés.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>Modules must be emitted with file name extensions.</source>
          <target state="translated">Les modules doivent être émises avec les extensions de nom de fichier.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly.</source>
          <target state="translated">Obtient <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> pour cet assembly.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly.</source>
          <target state="translated">Obtient <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> pour cet assembly.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName">
          <source>An object that contains the fully parsed display name for this assembly.</source>
          <target state="translated">Objet qui contient le nom complet analysé correspondant à cet assembly.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName">
          <source>for access to the path of the assembly.</source>
          <target state="translated">Pour accéder au chemin de l’assembly.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the <ph id="ph2">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> to the location of the assembly after it was shadow copied; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to set <ph id="ph4">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> to the original location.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour affecter à <ph id="ph2">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> l'emplacement de l'assembly une fois qu'il est devenu un cliché instantané ; <ph id="ph3">&lt;see langword="false" /&gt;</ph> pour affecter un emplacement d'origine à <ph id="ph4">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly, setting the codebase as specified by <ph id="ph2">&lt;paramref name="copiedName" /&gt;</ph>.</source>
          <target state="translated">Obtient un <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> pour cet assembly, en définissant le code base de la manière spécifiée par <ph id="ph2">&lt;paramref name="copiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>An object that contains the fully parsed display name for this assembly.</source>
          <target state="translated">Objet qui contient le nom complet analysé correspondant à cet assembly.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>for access to the path of the assembly.</source>
          <target state="translated">Pour accéder au chemin de l’assembly.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object to be populated with serialization information.</source>
          <target state="translated">Objet à remplir à l'aide des informations de sérialisation.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination context of the serialization.</source>
          <target state="translated">Contexte de destination de la sérialisation.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Gets serialization information with all of the data needed to reinstantiate this assembly.</source>
          <target state="translated">Obtient les informations de sérialisation avec toutes les données nécessaires pour réinstancier cet assembly.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> objects for all the assemblies referenced by this assembly.</source>
          <target state="translated">Obtient les objets <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> pour tous les assemblys référencés par cet assembly.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</source>
          <target state="translated">Tableau qui contient les noms complets analysés de tous les assemblys référencés par cet assembly.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> property of an <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that is returned by this method is <ph id="ph4">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType&gt;</ph> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <ph id="ph5">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, le <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> propriété d’un <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objet qui est retourné par cette méthode est <ph id="ph4">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType&gt;</ph> s’il n’existe aucun algorithme de hachage pour l’assembly référencé, ou si l’algorithme de hachage de l’assembly référencé n’est pas identifié par le <ph id="ph5">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>In previous versions of the .NET Framework, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> property returned <ph id="ph2">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType&gt;</ph> in this situation.</source>
          <target state="translated">Dans les versions précédentes du .NET Framework, le <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> propriété retournée <ph id="ph2">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType&gt;</ph> dans cette situation.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>The following code example demonstrates calling the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetReferencedAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre l’appel du <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetReferencedAssemblies%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the satellite assembly.</source>
          <target state="translated">Obtient l'assembly satellite.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The specified culture.</source>
          <target state="translated">Culture spécifiée.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Gets the satellite assembly for the specified culture.</source>
          <target state="translated">Obtient l'assembly satellite pour la culture spécifiée.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The specified satellite assembly.</source>
          <target state="translated">Assembly satellite spécifié.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</source>
          <target state="translated">Les assemblys satellites contiennent des ressources localisées, comme les assemblys d’application principaux qui contiennent du code exécutable non localisables et des ressources pour une culture unique utilisée comme culture neutre ou par défaut.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Call this method to use your current assembly version.</source>
          <target state="translated">Appelez cette méthode pour utiliser votre version actuelle de l’assembly.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The assembly cannot be found.</source>
          <target state="translated">L’assembly est introuvable.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The satellite assembly with a matching file name was found, but the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> did not match the one specified.</source>
          <target state="translated">L'assembly satellite avec un nom de fichier correspondant a été trouvé, mais <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> ne correspondait pas à celui spécifié.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The satellite assembly is not a valid assembly.</source>
          <target state="translated">L’assembly satellite n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The specified culture.</source>
          <target state="translated">Culture spécifiée.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The version of the satellite assembly.</source>
          <target state="translated">Version de l'assembly satellite.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Gets the specified version of the satellite assembly for the specified culture.</source>
          <target state="translated">Obtient la version spécifiée de l'assembly satellite pour la culture donnée.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The specified satellite assembly.</source>
          <target state="translated">Assembly satellite spécifié.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</source>
          <target state="translated">Les assemblys satellites contiennent des ressources localisées, comme les assemblys d’application principaux qui contiennent du code exécutable non localisables et des ressources pour une culture unique utilisée comme culture neutre ou par défaut.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29&gt;</ph> overload to use your current assembly version.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29&gt;</ph> surcharge à utiliser votre version actuelle de l’assembly.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>If <ph id="ph1">`version`</ph> is <ph id="ph2">`null`</ph>, the current assembly version is used if both the resource and main assemblies are signed.</source>
          <target state="translated">Si <ph id="ph1">`version`</ph> est <ph id="ph2">`null`</ph>, la version actuelle de l’assembly est utilisée si la ressource et les assemblys principaux sont signés.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The satellite assembly with a matching file name was found, but the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> or the version did not match the one specified.</source>
          <target state="translated">L'assembly satellite avec un nom de fichier correspondant a été trouvé, mais <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> ou la version ne correspondait pas à celui spécifié.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The assembly cannot be found.</source>
          <target state="translated">L’assembly est introuvable.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The satellite assembly is not a valid assembly.</source>
          <target state="translated">L’assembly satellite n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the specified type.</source>
          <target state="translated">Obtient l'objet <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> qui représente le type spécifié.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The full name of the type.</source>
          <target state="translated">Nom complet du type.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance.</source>
          <target state="translated">Obtient l'objet <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> avec le nom spécifié dans l'instance de l'assembly.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>An object that represents the specified class, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the class is not found.</source>
          <target state="translated">Objet qui représente la classe spécifiée ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si la classe est introuvable.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">Cette méthode recherche uniquement l’instance actuelle de l’assembly.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated">Le <ph id="ph1">`name`</ph> paramètre inclut l’espace de noms mais pas l’assembly.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">Pour rechercher d’autres assemblys pour un type, utilisez le <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode qui peut éventuellement inclure un nom complet d’assembly en tant que partie du nom de type.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Si le type a été transmis à un autre assembly, il est toujours retourné par cette méthode.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le transfert de type, consultez <bpt id="p1">[</bpt>transfert de Type dans le Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The following example defines an abstract <ph id="ph1">`MeansOfTransportation`</ph> class in the <ph id="ph2">`Transportation`</ph> namespace.</source>
          <target state="translated">L’exemple suivant définit abstraite <ph id="ph1">`MeansOfTransportation`</ph> classe dans le <ph id="ph2">`Transportation`</ph> espace de noms.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>It calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> method to retrieve its <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, calls the <ph id="ph3">&lt;xref:System.Type.GetProperties%2A?displayProperty=nameWithType&gt;</ph> method to get an array of <ph id="ph4">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects that represent the type's properties, and then displays information on the type's abstract properties.</source>
          <target state="translated">Il appelle le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> pour récupérer son <ph id="ph2">&lt;xref:System.Type&gt;</ph> objet, appelle le <ph id="ph3">&lt;xref:System.Type.GetProperties%2A?displayProperty=nameWithType&gt;</ph> méthode pour obtenir un tableau de <ph id="ph4">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> les objets qui représentent les propriétés du type, puis affiche des informations du type abstrait propriétés.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>Note that the call to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> method uses the type's fully qualified name (that is, its namespace along with its type name).</source>
          <target state="translated">Notez que l’appel à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> méthode utilise le nom du type qualifié complet (autrement dit, son espace de noms, ainsi que son nom de type).</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requiert un assembly dépendant qui est introuvable.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Dans <bpt id="p1">[</bpt>.NET pour les applications du Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou la <bpt id="p2">[</bpt>Bibliothèque de classes portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, interceptez l’exception de la classe de base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, à la place.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;/para&gt;</ph><ph id="ph2">
</ph><ph id="ph3">&lt;/block&gt;</ph><ph id="ph4">
</ph><ph id="ph5">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;/para&gt;</ph><ph id="ph2">
</ph><ph id="ph3">&lt;/block&gt;</ph><ph id="ph4">
</ph><ph id="ph5">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui n’a pas été préchargé.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The full name of the type.</source>
          <target state="translated">Nom complet du type.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type is not found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour lever une exception si le type est introuvable ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour retourner la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</source>
          <target state="translated">Obtient l'objet <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> portant le nom spécifié dans l'instance de l'assembly et lève éventuellement une exception si le type est introuvable.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>An object that represents the specified class.</source>
          <target state="translated">Objet qui représente la classe spécifiée.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">Cette méthode recherche uniquement l’instance actuelle de l’assembly.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated">Le <ph id="ph1">`name`</ph> paramètre inclut l’espace de noms mais pas l’assembly.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">Pour rechercher d’autres assemblys pour un type, utilisez le <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode qui peut éventuellement inclure un nom complet d’assembly en tant que partie du nom de type.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Si le type a été transmis à un autre assembly, il est toujours retourné par cette méthode.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le transfert de type, consultez <bpt id="p1">[</bpt>transfert de Type dans le Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated">Le <ph id="ph1">`throwOnError`</ph> paramètre affecte uniquement ce qui se passe lorsque le type est introuvable.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Il n’affecte pas toutes les exceptions qui peuvent être levées.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">En particulier, si le type est trouvé mais ne peut pas être chargé, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> peut être levée même si <ph id="ph2">`throwOnError`</ph> est <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> exceeds 1024 characters.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> dépasse 1 024 caractères.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="true" /&gt;</ph> et le type est introuvable.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requiert un assembly dépendant qui est introuvable.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui n’a pas été préchargé.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The full name of the type.</source>
          <target state="translated">Nom complet du type.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type is not found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour lever une exception si le type est introuvable ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour retourner la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour ignorer la casse du nom de type ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</source>
          <target state="translated">Obtient l'objet <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> portant le nom spécifié dans l'instance de l'assembly et propose d'ignorer la casse et de lever une exception si le type est introuvable.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An object that represents the specified class.</source>
          <target state="translated">Objet qui représente la classe spécifiée.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">Cette méthode recherche uniquement l’instance actuelle de l’assembly.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated">Le <ph id="ph1">`name`</ph> paramètre inclut l’espace de noms mais pas l’assembly.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">Pour rechercher d’autres assemblys pour un type, utilisez le <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode qui peut éventuellement inclure un nom complet d’assembly en tant que partie du nom de type.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Si le type a été transmis à un autre assembly, il est toujours retourné par cette méthode.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le transfert de type, consultez <bpt id="p1">[</bpt>transfert de Type dans le Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated">Le <ph id="ph1">`throwOnError`</ph> paramètre affecte uniquement ce qui se passe lorsque le type est introuvable.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Il n’affecte pas toutes les exceptions qui peuvent être levées.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">En particulier, si le type est trouvé mais ne peut pas être chargé, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> peut être levée même si <ph id="ph2">`throwOnError`</ph> est <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> exceeds 1024 characters.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> dépasse 1 024 caractères.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="true" /&gt;</ph> et le type est introuvable.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requiert un assembly dépendant qui est introuvable.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui n’a pas été préchargé.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>Gets the types defined in this assembly.</source>
          <target state="translated">Obtient les types définis dans cet assembly.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>An array that contains all the types that are defined in this assembly.</source>
          <target state="translated">Tableau qui contient tous les types définis dans cet assembly.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The returned array includes nested types.</source>
          <target state="translated">Le tableau retourné inclut des types imbriqués.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <ph id="ph2">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> méthode est appelée sur un assembly et un type de cet assembly est dépendant d’un type dans un assembly qui n’a pas été chargé (par exemple, si elle dérive d’un type du second assembly), un <ph id="ph2">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>For example, this can happen if the first assembly was loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods, and the second assembly was not loaded.</source>
          <target state="translated">Par exemple, cela peut se produire si le premier assembly a été chargé avec le <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> méthodes et le second assembly n’a pas été chargé.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>It can also happen with assemblies loaded using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> methods if the second assembly cannot be located when the <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method is called.</source>
          <target state="translated">Il peut également se produire avec les assemblys chargés à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> méthodes si le second assembly ne peut pas être localisé lorsque le <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>If a type has been forwarded to another assembly, it is not included in the returned array.</source>
          <target state="translated">Si un type a été transmis à un autre assembly, il n’est pas inclus dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le transfert de type, consultez <bpt id="p1">[</bpt>transfert de Type dans le Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>To retrieve a collection of <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objects instead of an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects, use the <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Pour récupérer une collection de <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> des objets au lieu d’un tableau de <ph id="ph2">&lt;xref:System.Type&gt;</ph> objets, utilisez le <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The following example displays parameters of one method on a type in the specified assembly.</source>
          <target state="translated">L’exemple suivant affiche les paramètres d’une méthode sur un type dans l’assembly spécifié.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The assembly contains one or more types that cannot be loaded.</source>
          <target state="translated">L’assembly contient un ou plusieurs types qui ne peuvent pas être chargés.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The array returned by the <ph id="ph1">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /&gt;</ph> property of this exception contains a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object for each type that was loaded and <ph id="ph3">&lt;see langword="null" /&gt;</ph> for each type that could not be loaded, while the <ph id="ph4">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /&gt;</ph> property contains an exception for each type that could not be loaded.</source>
          <target state="translated">Le tableau retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /&gt;</ph> de cette exception contient un objet <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> pour chaque type qui a été chargé et <ph id="ph3">&lt;see langword="null" /&gt;</ph> pour chaque type qui n’a pas pu être chargé, tandis que la propriété <ph id="ph4">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /&gt;</ph> contient une exception pour chaque type qui n’a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.GlobalAssemblyCache">
          <source>Gets a value indicating whether the assembly was loaded from the global assembly cache.</source>
          <target state="translated">Obtient une valeur indiquant si l'assembly a été chargé à partir du Global Assembly Cache.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.GlobalAssemblyCache">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the assembly was loaded from the global assembly cache; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'assembly a été chargé à partir du Global Assembly Cache ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.HostContext">
          <source>Gets the host context with which the assembly was loaded.</source>
          <target state="translated">Obtient le contexte hôte avec lequel l'assembly a été chargé.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.HostContext">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> value that indicates the host context with which the assembly was loaded, if any.</source>
          <target state="translated">Valeur <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> qui indique le contexte hôte avec lequel l'assembly a été chargé, le cas échéant.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</source>
          <target state="translated">Obtient une représentation sous forme de chaîne de la version du Common Language Runtime (CLR) enregistrée dans le fichier contenant le manifeste.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>The CLR version folder name.</source>
          <target state="translated">Nom du dossier de la version CLR.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>This is not a full path.</source>
          <target state="translated">Il ne s’agit pas d’un chemin d’accès complet.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</source>
          <target state="translated">Par exemple, la valeur de la version 1.1 du .NET Framework serait v1.1.4322.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</source>
          <target state="translated">Les fichiers binaires pour cette version sont introuvable dans le chemin d’accès % windir%\Microsoft.NET\Framework\v1.1.4322.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>By default, <ph id="ph1">&lt;xref:System.Reflection.Assembly.ImageRuntimeVersion%2A&gt;</ph> is set to the version of the CLR used to build the assembly.</source>
          <target state="translated">Par défaut, <ph id="ph1">&lt;xref:System.Reflection.Assembly.ImageRuntimeVersion%2A&gt;</ph> est définie sur la version du CLR utilisée pour générer l’assembly.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>However, it might have been set to another value at compile time.</source>
          <target state="translated">Toutefois, elle peut avoir été définie à une autre valeur au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>The type of the attribute to be checked for this assembly.</source>
          <target state="translated">Type de l'attribut à vérifier pour cet assembly.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Cet argument est ignoré pour les objets de ce type.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether or not a specified attribute has been applied to the assembly.</source>
          <target state="translated">Indique si un attribut spécifié a été appliqué à l'assembly ou non.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the attribute has been applied to the assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'attribut a été appliqué à l'assembly ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>The following code example applies the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute to an assembly and then uses <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsDefined%2A&gt;</ph> to indicate whether it was applied.</source>
          <target state="translated">L’exemple de code suivant applique la <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribut à un assembly, puis utilise <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsDefined%2A&gt;</ph> pour indiquer s’il a été appliqué.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>It also tests an attribute that was not applied.</source>
          <target state="translated">Il teste également un attribut qui n’a été appliqué.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> uses an invalid type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> utilise un type non valide.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</source>
          <target state="translated">Obtient une valeur qui indique si l'assembly actuel a été généré dynamiquement dans le processus actuel à l'aide de l'émission de réflexion.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current assembly was generated dynamically in the current process; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'assembly actuel a été généré dynamiquement dans le processus actuel ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>Dynamic assemblies are represented by the derived class <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>.</source>
          <target state="translated">Assemblys dynamiques sont représentées par la classe dérivée <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</source>
          <target state="translated">Quand un assembly dynamique est enregistré sur le disque, l’assembly enregistré n’est pas dynamique.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>If the saved assembly is loaded into another application domain or process, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsDynamic%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si l’assembly enregistré est chargé dans un autre domaine d’application ou processus, la <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsDynamic%2A&gt;</ph> propriété renvoie <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.IsFullyTrusted">
          <source>Gets a value that indicates whether the current assembly is loaded with full trust.</source>
          <target state="translated">Obtient une valeur qui indique si l'assembly actuel est chargé avec une confiance totale.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsFullyTrusted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current assembly is loaded with full trust; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'assembly actuel est chargé avec une confiance totale ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly.</source>
          <target state="translated">Charge un assembly.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</source>
          <target state="translated">Charge l'assembly avec une image au format COFF (Common Object File Format) contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly est chargé dans le domaine d'application de l'appelant.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</source>
          <target state="translated">Le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance de l’assembly appelant.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>To load an assembly from a byte array with the trust level of the application domain, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> method overload.</source>
          <target state="translated">Pour charger un assembly à partir d’un tableau d’octets avec le niveau de confiance du domaine d’application, utilisez le <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>For more information about the use of evidence with overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that take byte arrays, see the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de la preuve avec les surcharges de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode qui acceptent les tableaux d’octets, consultez la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La réflexion sur des fichiers exécutables C++ peut lever un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Cela est probablement provoqué par le compilateur C++ adresses de réadressage ou <ph id="ph1">`.reloc`</ph> section à partir de votre fichier exécutable.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Pour conserver le <ph id="ph1">`.reloc`</ph> l’adresse de votre fichier exécutable C++, spécifiez <ph id="ph2">`/fixed:no`</ph> lors de la liaison.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">Notez que cette surcharge de méthode crée toujours un nouveau <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objet avec son propre mappage.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The object that describes the assembly to be loaded.</source>
          <target state="translated">Objet qui décrit l'assembly à charger.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Loads an assembly given its <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">Charge un assembly en fonction de son <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyRef`</ph> specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> est levée si <ph id="ph2">`assemblyRef`</ph> Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une version différente, la culture ou le jeton de clé publique.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">Le chargeur ne continue pas de détecter d’autres assemblys qui correspondent au nom simple.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Do not use an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> with only the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property set.</source>
          <target state="translated">N’utilisez pas un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> avec uniquement le <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> jeu de propriétés.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> propriété ne fournit pas tous les éléments de l’identité d’assembly (par exemple, le nom ou la version), ainsi le chargement ne se produit pas d’en fonction des règles de charge par identité, comme prévu à partir de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Instead, the assembly is loaded using load-from rules.</source>
          <target state="translated">Au lieu de cela, l’assembly est chargé à l’aide de règles de chargement.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>For information about the disadvantages of using the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method overload or <bpt id="p1">[</bpt>Best Practices for Assembly Loading<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les inconvénients de l’utilisation du contexte de chargement, consultez la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> surcharge de méthode ou <bpt id="p1">[</bpt>meilleures pratiques pour le chargement d’Assembly<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Les règles d’assembly et la fusion de la preuve de sécurité sont les suivantes :</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode sans aucune <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image COFF, la preuve est combinée.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> et <ph id="ph3">`Site`</ph> sont héritées de l’assembly appelant, et <ph id="ph4">`Hash`</ph> et <ph id="ph5">`StrongName`</ph> sont tirées de l’assembly COFF.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre et <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> pour charger une image COFF, seule la preuve fournie est utilisée.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La réflexion sur des fichiers exécutables C++ peut lever un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Cela est probablement provoqué par le compilateur C++ adresses de réadressage ou <ph id="ph1">`.reloc`</ph> section à partir de votre fichier exécutable.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Pour conserver le <ph id="ph1">`.reloc`</ph> l’adresse de votre fichier exécutable C++, spécifiez <ph id="ph2">`/fixed:no`</ph> lors de la liaison.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">Si les deux le <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> propriété et la <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> sont définies, la première tentative de charger l’assembly utilise le nom complet (y compris la version, culture et ainsi de suite, tel que retourné par le <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> propriété).</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> is used to search for the assembly.</source>
          <target state="translated">Si le fichier est introuvable, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> est utilisé pour rechercher l’assembly.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">Si l’assembly se trouve à l’aide de <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, le nom complet est comparé à l’assembly.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">Si la correspondance échoue, un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The following example instantiates an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and uses it to load the <ph id="ph2">`sysglobal.dll`</ph> assembly.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> de l’objet et l’utilise pour charger le <ph id="ph2">`sysglobal.dll`</ph> assembly.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The example then displays the full name of the assembly's public types.</source>
          <target state="translated">L’exemple affiche ensuite le nom complet de types publics de l’assembly.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Dans <bpt id="p1">[</bpt>.NET pour les applications du Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou la <bpt id="p2">[</bpt>Bibliothèque de classes portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, interceptez l’exception de la classe de base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, à la place.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The long form of the assembly name.</source>
          <target state="translated">Forme longue du nom d'assembly.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Loads an assembly given the long form of its name.</source>
          <target state="translated">Charge un assembly en fonction de la forme longue de son nom.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</source>
          <target state="translated">La forme longue du nom de l’assembly se compose de son nom simple (par exemple, « système » de l’assembly System.dll), ainsi que sa version, culture, jeton de clé publique et, éventuellement, son architecture de processeur.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>It corresponds to the assembly's <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> property.</source>
          <target state="translated">Il correspond à l’assembly <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation d’un nom de type long à charger l’assembly System.dll pour le .NET Framework 4.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyString`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> est levée si <ph id="ph2">`assemblyString`</ph> Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une version différente, la culture ou le jeton de clé publique.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">Le chargeur ne continue pas de détecter d’autres assemblys qui correspondent au nom simple.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Les règles d’assembly et la fusion de la preuve de sécurité sont les suivantes :</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode sans aucune <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image COFF, la preuve est combinée.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> et <ph id="ph3">`Site`</ph> sont héritées de l’assembly appelant, et <ph id="ph4">`Hash`</ph> et <ph id="ph5">`StrongName`</ph> sont tirées de l’assembly COFF.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre et <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> pour charger une image COFF, seule la preuve fournie est utilisée.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La réflexion sur des fichiers exécutables C++ peut lever un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Cela est probablement provoqué par le compilateur C++ adresses de réadressage ou <ph id="ph1">`.reloc`</ph> section à partir de votre fichier exécutable.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Pour conserver le <ph id="ph1">`.reloc`</ph> l’adresse de votre fichier exécutable C++, spécifiez <ph id="ph2">`/fixed:no`</ph> lors de la liaison.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Par exemple, « ProcessorArchitecture = msil ».</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>However, the recommended way to specify an assembly name is to create an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and pass it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Toutefois, la méthode recommandée pour spécifier un nom d’assembly consiste à créer un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> de l’objet et le passer à une surcharge appropriée de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</source>
          <target state="translated">L’exemple suivant charge un assembly en fonction de son nom complet et répertorie tous les types contenus dans l’assembly spécifié.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est une chaîne de longueur nulle.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</source>
          <target state="translated">Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles de l'assembly.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly est chargé dans le domaine d'application de l'appelant.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</source>
          <target state="translated">Le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance de l’assembly appelant.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>To load an assembly from a byte array with the trust level of the application domain, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> method overload.</source>
          <target state="translated">Pour charger un assembly à partir d’un tableau d’octets avec le niveau de confiance du domaine d’application, utilisez le <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>For more information about the use of evidence with overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that take byte arrays, see the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de la preuve avec les surcharges de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode qui acceptent les tableaux d’octets, consultez la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La réflexion sur des fichiers exécutables C++ peut lever un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Cela est probablement provoqué par le compilateur C++ adresses de réadressage ou <ph id="ph1">`.reloc`</ph> section à partir de votre fichier exécutable.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Pour conserver le <ph id="ph1">`.reloc`</ph> l’adresse de votre fichier exécutable C++, spécifiez <ph id="ph2">`/fixed:no`</ph> lors de la liaison.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">Notez que cette surcharge de méthode crée toujours un nouveau <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objet avec son propre mappage.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The object that describes the assembly to be loaded.</source>
          <target state="translated">Objet qui décrit l'assembly à charger.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">Charge un assembly en fonction de son <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyRef`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> est levée si <ph id="ph2">`assemblyRef`</ph> Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une version différente, la culture ou le jeton de clé publique.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">Le chargeur ne continue pas de détecter d’autres assemblys qui correspondent au nom simple.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Do not use an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> with only the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property set.</source>
          <target state="translated">N’utilisez pas un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> avec uniquement le <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> jeu de propriétés.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> propriété ne fournit pas tous les éléments de l’identité d’assembly (par exemple, le nom ou la version), ainsi le chargement ne se produit pas d’en fonction des règles de charge par identité, comme prévu à partir de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Instead, the assembly is loaded using load-from rules.</source>
          <target state="translated">Au lieu de cela, l’assembly est chargé à l’aide de règles de chargement.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>For information about the disadvantages of using the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method overload or <bpt id="p1">[</bpt>Best Practices for Assembly Loading<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les inconvénients de l’utilisation du contexte de chargement, consultez la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> surcharge de méthode ou <bpt id="p1">[</bpt>meilleures pratiques pour le chargement d’Assembly<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Les règles d’assembly et la fusion de la preuve de sécurité sont les suivantes :</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode sans aucune <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image COFF, la preuve est combinée.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> et <ph id="ph3">`Site`</ph> sont héritées de l’assembly appelant, et <ph id="ph4">`Hash`</ph> et <ph id="ph5">`StrongName`</ph> sont tirées de l’assembly COFF.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre et <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> pour charger une image COFF, seule la preuve fournie est utilisée.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La réflexion sur des fichiers exécutables C++ peut lever un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Cela est probablement provoqué par le compilateur C++ adresses de réadressage ou <ph id="ph1">`.reloc`</ph> section à partir de votre fichier exécutable.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Pour conserver le <ph id="ph1">`.reloc`</ph> l’adresse de votre fichier exécutable C++, spécifiez <ph id="ph2">`/fixed:no`</ph> lors de la liaison.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">Si les deux le <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> propriété et la <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> sont définies, la première tentative de charger l’assembly utilise le nom complet (y compris la version, culture et ainsi de suite, tel que retourné par le <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> propriété).</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> is used to search for the assembly.</source>
          <target state="translated">Si le fichier est introuvable, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> est utilisé pour rechercher l’assembly.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">Si l’assembly se trouve à l’aide de <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, le nom complet est comparé à l’assembly.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">Si la correspondance échoue, un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph2">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Si vous appelez le <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <ph id="ph2">&lt;xref:System.IO.FileLoadException&gt;</ph> , car l’égalité et l’intégrité des différentes spécifications de preuve ne peut pas être déterminé.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">La première preuve qui réussit est la preuve est utilisée.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</source>
          <target state="translated">Charge un assembly en fonction de son nom complet, en le chargeant dans le domaine de l'appelant à l'aide de la preuve fournie.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyString`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> est levée si <ph id="ph2">`assemblyString`</ph> Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une version différente, la culture ou le jeton de clé publique.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">Le chargeur ne continue pas de détecter d’autres assemblys qui correspondent au nom simple.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Les règles d’assembly et la fusion de la preuve de sécurité sont les suivantes :</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode sans aucune <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image COFF, la preuve est combinée.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> et <ph id="ph3">`Site`</ph> sont héritées de l’assembly appelant, et <ph id="ph4">`Hash`</ph> et <ph id="ph5">`StrongName`</ph> sont tirées de l’assembly COFF.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre et <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> pour charger une image COFF, seule la preuve fournie est utilisée.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La réflexion sur des fichiers exécutables C++ peut lever un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Cela est probablement provoqué par le compilateur C++ adresses de réadressage ou <ph id="ph1">`.reloc`</ph> section à partir de votre fichier exécutable.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Pour conserver le <ph id="ph1">`.reloc`</ph> l’adresse de votre fichier exécutable C++, spécifiez <ph id="ph2">`/fixed:no`</ph> lors de la liaison.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">La première preuve qui réussit est la preuve est utilisée.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Par exemple, « ProcessorArchitecture = msil ».</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>However, the recommended way to specify an assembly name is to create an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and pass it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Toutefois, la méthode recommandée pour spécifier un nom d’assembly consiste à créer un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> de l’objet et le passer à une surcharge appropriée de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Un fichier qui a été trouvé n’a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</source>
          <target state="translated">Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles et des preuves de l'assembly.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly est chargé dans le domaine d'application de l'appelant.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The raw bytes representing the symbols for the assembly are also loaded.</source>
          <target state="translated">Les octets bruts représentant les symboles de l’assembly sont également chargés.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Les règles d’assembly et la fusion de la preuve de sécurité sont les suivantes :</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode sans aucune <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image COFF, la preuve est héritée de l’assembly appelant.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> surcharge de méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image COFF, la preuve est combinée.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> et <ph id="ph3">`Site`</ph> sont héritées de l’assembly appelant, et <ph id="ph4">`Hash`</ph> et <ph id="ph5">`StrongName`</ph> sont tirées de l’assembly COFF.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre et <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> pour charger une image COFF, seule la preuve fournie est utilisée.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image are ignored.</source>
          <target state="translated">Preuve de l’assembly appelant et celle de l’image COFF sont ignorées.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La réflexion sur des fichiers exécutables C++ peut lever un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Cela est probablement provoqué par le compilateur C++ adresses de réadressage ou <ph id="ph1">`.reloc`</ph> section à partir de votre fichier exécutable.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Pour conserver le <ph id="ph1">`.reloc`</ph> l’adresse de votre fichier exécutable C++, spécifiez <ph id="ph2">`/fixed:no`</ph> lors de la liaison.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>If you call the [<ph id="ph1">\]</ph>, Byte<ph id="ph2">\&lt;</ph>xref:System.Reflection.Assembly.Load%2A&gt; method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph3">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Si vous appelez le [<ph id="ph1">\]</ph>, octet<ph id="ph2">\&lt;</ph>xref:System.Reflection.Assembly.Load%2A &gt; méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <ph id="ph3">&lt;xref:System.IO.FileLoadException&gt;</ph> , car le Impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">La première preuve qui réussit est la preuve est utilisée.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">Notez que cette surcharge de méthode crée toujours un nouveau <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objet avec son propre mappage.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>By default, legacy CAS policy is not enabled in the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>; when it is not enabled, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> must be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Par défaut, la stratégie CAS héritée n’est pas activée dans <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> ; quand elle n’est pas activée, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> doit avoir la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for the ability to supply evidence.</source>
          <target state="translated">pour la capacité à fournir une preuve.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The source of the security context.</source>
          <target state="translated">Source du contexte de sécurité.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</source>
          <target state="translated">Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles et qui spécifie la source du contexte de sécurité.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly est chargé dans le domaine d'application de l'appelant.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The assembly is loaded into the application domain of the caller using the specified source for the security context.</source>
          <target state="translated">L’assembly est chargé dans le domaine d’application de l’appelant à l’aide de la source spécifiée pour le contexte de sécurité.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>If <ph id="ph1">`rawSymbolStore`</ph> was specified, the raw bytes that represent the symbols for the assembly are also loaded.</source>
          <target state="translated">Si <ph id="ph1">`rawSymbolStore`</ph> a été spécifié, les octets bruts représentant les symboles de l’assembly sont également chargés.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The value of <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> is not one of the enumeration values.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph>  n'est pas l'une des valeurs d'énumération.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the contents of an assembly file.</source>
          <target state="translated">Charge le contenu d'un fichier d'assembly.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The fully qualified path of the file to load.</source>
          <target state="translated">Chemin d’accès complet du fichier à charger.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Loads the contents of an assembly file on the specified path.</source>
          <target state="translated">Charge le contenu d’un fichier d’assembly sur le chemin d’accès spécifié.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method to load and examine assemblies that have the same identity, but are located in different paths.<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph></source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> méthode pour charger et examiner les assemblys qui ont la même identité, mais qui se trouvent dans des chemins d’accès.<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method does.</source>
          <target state="translated">ne pas charger des fichiers dans le contexte de chargement et ne résout pas les dépendances à l’aide du chemin de chargement, comme le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> is useful in this limited scenario because <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> est utile dans ce scénario spécifique, car <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> ne peut pas être utilisé pour charger les assemblys qui ont la même identité mais des chemins d’accès ; il chargera uniquement le premier tel assembly.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> argument is not an absolute path.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="path" /&gt;</ph> n’est pas un chemin absolu.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="path" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is an empty string ("") or does not exist.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est une chaîne vide ("") ou n'existe pas.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="path" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="path" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The fully qualified path of the assembly file.</source>
          <target state="translated">Chemin complet du fichier d’assembly.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</source>
          <target state="translated">Charge un assembly en fonction de son chemin d’accès, en le chargeant dans le domaine de l’appelant à l’aide de la preuve fournie.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method to load and examine assemblies that have the same identity, but are located in different paths.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> méthode pour charger et examiner les assemblys qui ont la même identité, mais qui se trouvent dans des chemins d’accès.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> does not load files into the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> context, and does not resolve dependencies using the load path, as the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method does.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> ne pas charger des fichiers dans le <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> contexte et ne résout pas les dépendances à l’aide du chemin de chargement, comme le <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> is useful in this limited scenario because <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> est utile dans ce scénario spécifique, car <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> ne peut pas être utilisé pour charger les assemblys qui ont la même identité mais des chemins d’accès ; il chargera uniquement le premier tel assembly.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> argument is not an absolute path.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="path" /&gt;</ph> n’est pas un chemin absolu.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="path" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is an empty string ("") or does not exist.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est une chaîne vide ("") ou n'existe pas.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="path" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="path" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>By default, legacy CAS policy is not enabled in the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>; when it is not enabled, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> must be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Par défaut, la stratégie CAS héritée n’est pas activée dans <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> ; quand elle n’est pas activée, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> doit avoir la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly.</source>
          <target state="translated">Charge un assembly.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Loads an assembly given its file name or path.</source>
          <target state="translated">Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Le <ph id="ph1">`assemblyFile`</ph> paramètre doit faire référence à un URI sans caractères d’échappement.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Cette méthode fournit des caractères d’échappement pour tous les caractères non valides dans l’URI.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">Protocole de transfert de fichiers (FTP) n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">Si l’URI fourni pour <ph id="ph1">`assemblyFile`</ph> est une adresse FTP, l’assembly n’est pas chargé.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">Le contexte de chargement contient des assemblys trouvés par la détection : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated">La plupart des surcharges de la méthode <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> chargent les assemblys dans ce contexte.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sont des exemples de méthodes qui sont chargées via un chemin.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">Le contexte de réflexion uniquement contient des assemblys chargés avec les <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> des méthodes, le code dans ces contextes ne peut pas être exécutées.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">Cela s’applique aux assemblys chargés à l’aide de surcharges de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode qui spécifient un tableau d’octets contenant un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">Le contexte de chargement permet à un assembly doit être chargé à partir d’un chemin d’accès non inclus dans la détection et permet cependant les dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode présente les inconvénients suivants.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">Si un assembly avec la même identité est déjà chargé, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> retourne l’assembly chargé même si un autre chemin a été spécifié.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">Si un assembly est chargé avec <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom complet, la tentative de chargement échoue.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This can occur when an assembly is de-serialized.</source>
          <target state="translated">Cela peut se produire lorsqu’un assembly est désérialisé.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">Si un assembly est chargé avec <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, et le chemin d’accès de détection inclut un assembly avec la même identité mais un emplacement différent, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, ou tout autre comportement inattendu peut se produire.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demande <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, sur le chemin spécifié.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">S’il existe une image native pour <ph id="ph1">`assemblyFile`</ph>, il n’est pas utilisé.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">L’assembly ne peut pas être chargé comme indépendant du domaine.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The following example loads an assembly given its file name or path.</source>
          <target state="translated">L’exemple suivant charge un assembly en fonction de son nom de fichier ou le chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable ou le module que vous tentez de charger ne spécifie pas d'extension de nom de fichier.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n'est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>See the exception topic for more information.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique sur les exceptions.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">Un code base qui ne commence pas par "file://" a été spécifié sans le <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> requis.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">Le nom de l’assembly comprend plus de MAX_PATH caractères.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">pour lire un URI qui commence par « file:// ».</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its file name or path and supplying security evidence.</source>
          <target state="translated">Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès et en fournissant la preuve de sécurité.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Le <ph id="ph1">`assemblyFile`</ph> paramètre doit faire référence à un URI sans caractères d’échappement.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Cette méthode fournit des caractères d’échappement pour tous les caractères non valides dans l’URI.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">Protocole de transfert de fichiers (FTP) n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">Si l’URI fourni pour <ph id="ph1">`assemblyFile`</ph> est une adresse FTP, l’assembly n’est pas chargé.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">Le contexte de chargement contient des assemblys trouvés par la détection : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated">La plupart des surcharges de la méthode <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> chargent les assemblys dans ce contexte.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sont des exemples de méthodes qui sont chargées via un chemin.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">Le contexte de réflexion uniquement contient des assemblys chargés avec les <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> des méthodes, le code dans ces contextes ne peut pas être exécutées.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">Cela s’applique aux assemblys chargés à l’aide de surcharges de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode qui spécifient un tableau d’octets contenant un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">Le contexte de chargement permet à un assembly doit être chargé à partir d’un chemin d’accès non inclus dans la détection et permet cependant les dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode présente les inconvénients suivants.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">Si un assembly avec la même identité est déjà chargé, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> retourne l’assembly chargé même si un autre chemin a été spécifié.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">Si un assembly est chargé avec <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom complet, la tentative de chargement échoue.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">Ceci peut se produire quand un assembly est désérialisé.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">Si un assembly est chargé avec <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, et le chemin d’accès de détection inclut un assembly avec la même identité mais un emplacement différent, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, ou tout autre comportement inattendu peut se produire.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demande <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, sur le chemin spécifié.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">S’il existe une image native pour <ph id="ph1">`assemblyFile`</ph>, il n’est pas utilisé.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">L’assembly ne peut pas être chargé comme indépendant du domaine.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Les règles d’assembly et la fusion de la preuve de sécurité sont les suivantes :</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode sans aucune <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">La première preuve qui réussit est la preuve est utilisée.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is combined.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image common object file format (COFF), la preuve est combinée.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> et <ph id="ph3">`Site`</ph> sont héritées de l’assembly appelant, et <ph id="ph4">`Hash`</ph> et <ph id="ph5">`StrongName`</ph> sont tirées de l’assembly COFF.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre et <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> pour charger une image COFF, seule la preuve fournie est utilisée.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable ou le module que vous tentez de charger ne spécifie pas d'extension de nom de fichier.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not ambiguous and is determined to be invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> n'est pas ambigu et est considéré comme étant non valide.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n'est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>See the exception topic for more information.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique sur les exceptions.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">Un code base qui ne commence pas par "file://" a été spécifié sans le <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> requis.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">Le nom de l’assembly comprend plus de MAX_PATH caractères.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">pour lire un URI qui commence par « file:// ».</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value of the computed hash code.</source>
          <target state="translated">Valeur du code de hachage calculé.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The hash algorithm used for hashing files and for generating the strong name.</source>
          <target state="translated">Algorithme de hachage utilisé pour hacher les fichiers et pour générer le nom fort.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Loads an assembly given its file name or path, hash value, and hash algorithm.</source>
          <target state="translated">Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès, de la valeur de hachage et de l’algorithme de hachage.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Le <ph id="ph1">`assemblyFile`</ph> paramètre doit faire référence à un URI sans caractères d’échappement.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Cette méthode fournit des caractères d’échappement pour tous les caractères non valides dans l’URI.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">Protocole de transfert de fichiers (FTP) n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">Si l’URI fourni pour <ph id="ph1">`assemblyFile`</ph> est une adresse FTP, l’assembly n’est pas chargé.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">Le contexte de chargement contient des assemblys trouvés par la détection : dans le global assembly cache, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated">La plupart des surcharges de la méthode <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> chargent les assemblys dans ce contexte.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context contains assemblies for which the user provided a path that is not included in probing.</source>
          <target state="translated">Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès n’est pas inclus dans la détection.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sont des exemples de méthodes qui sont chargées via un chemin.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">Le contexte de réflexion uniquement contient des assemblys chargés avec les <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> des méthodes, le code dans ces contextes ne peut pas être exécutées.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">Cela s’applique aux assemblys chargés à l’aide de surcharges de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode qui spécifient un tableau d’octets contenant un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">Le contexte de chargement permet à un assembly doit être chargé à partir d’un chemin d’accès n’est pas inclus dans la détection et permet cependant les dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode présente les inconvénients suivants.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">Si un assembly avec la même identité est déjà chargé, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> retourne l’assembly chargé même si un autre chemin a été spécifié.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">Si un assembly est chargé avec <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom complet, la tentative de chargement échoue.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">Ceci peut se produire quand un assembly est désérialisé.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">Si un assembly est chargé avec <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, et le chemin d’accès de détection inclut un assembly avec la même identité mais un emplacement différent, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, ou tout autre comportement inattendu peut se produire.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demande <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, sur le chemin spécifié.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">S’il existe une image native pour <ph id="ph1">`assemblyFile`</ph>, il n’est pas utilisé.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly cannot be loaded as domain-neutral.</source>
          <target state="translated">L’assembly ne peut pas être chargé comme étant indépendant du domaine.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">L’assembly est chargé avec la preuve fournie par le chargeur.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a file name extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n'est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>See the exception topic for more information.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique sur les exceptions.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">Un code base qui ne commence pas par "file://" a été spécifié sans le <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> requis.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">Le nom de l’assembly comprend plus de MAX_PATH caractères.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">pour lire un URI qui commence par « file:// ».</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value of the computed hash code.</source>
          <target state="translated">Valeur du code de hachage calculé.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The hash algorithm used for hashing files and for generating the strong name.</source>
          <target state="translated">Algorithme de hachage utilisé pour hacher les fichiers et pour générer le nom fort.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</source>
          <target state="translated">Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès, de la preuve de sécurité, de la valeur de hachage et de l’algorithme de hachage.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Le <ph id="ph1">`assemblyFile`</ph> paramètre doit faire référence à un URI sans caractères d’échappement.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Cette méthode fournit des caractères d’échappement pour tous les caractères non valides dans l’URI.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">Protocole de transfert de fichiers (FTP) n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">Si l’URI fourni pour <ph id="ph1">`assemblyFile`</ph> est une adresse FTP, l’assembly n’est pas chargé.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">Le contexte de chargement contient des assemblys trouvés par la détection : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated">La plupart des surcharges de la méthode <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> chargent les assemblys dans ce contexte.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sont des exemples de méthodes qui sont chargées via un chemin.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">Le contexte de réflexion uniquement contient des assemblys chargés avec les <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> des méthodes, le code dans ces contextes ne peut pas être exécutées.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">Cela s’applique aux assemblys chargés à l’aide de surcharges de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode qui spécifient un tableau d’octets contenant un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">Le contexte de chargement permet à un assembly doit être chargé à partir d’un chemin d’accès non inclus dans la détection et permet cependant les dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode présente les inconvénients suivants.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">Si un assembly avec la même identité est déjà chargé, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> retourne l’assembly chargé même si un autre chemin a été spécifié.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">Si un assembly est chargé avec <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom complet, la tentative de chargement échoue.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">Ceci peut se produire quand un assembly est désérialisé.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">Si un assembly est chargé avec <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, et le chemin d’accès de détection inclut un assembly avec la même identité mais un emplacement différent, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, ou tout autre comportement inattendu peut se produire.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demande <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, sur le chemin spécifié.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">S’il existe une image native pour <ph id="ph1">`assemblyFile`</ph>, il n’est pas utilisé.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">L’assembly ne peut pas être chargé comme indépendant du domaine.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Les règles d’assembly et la fusion de la preuve de sécurité sont les suivantes :</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode sans aucune <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">La première preuve qui réussit est la preuve est utilisée.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is combined.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre pour charger une image common object file format (COFF), la preuve est combinée.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> et <ph id="ph3">`Site`</ph> sont héritées de l’assembly appelant, et <ph id="ph4">`Hash`</ph> et <ph id="ph5">`StrongName`</ph> sont tirées de l’assembly COFF.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Lorsque vous utilisez un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> méthode avec un <ph id="ph2">`Byte[]`</ph> paramètre et <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> pour charger une image COFF, seule la preuve fournie est utilisée.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable ou le module que vous tentez de charger ne spécifie pas d'extension de nom de fichier.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not ambiguous and is determined to be invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> n'est pas ambigu et est considéré comme étant non valide.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n'est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>See the exception topic for more information.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique sur les exceptions.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">Un code base qui ne commence pas par "file://" a été spécifié sans le <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> requis.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">Le nom de l’assembly comprend plus de MAX_PATH caractères.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">pour lire un URI qui commence par « file:// ».</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the module internal to this assembly.</source>
          <target state="translated">Charge le module interne à cet assembly.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>The name of the module.</source>
          <target state="translated">Nom du module.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>This string must correspond to a file name in this assembly's manifest.</source>
          <target state="translated">Cette chaîne doit correspondre à un nom de fichier du manifeste de cet assembly.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted module, or a resource.</source>
          <target state="translated">Tableau d'octets qui est une image COFF contenant un module émis ou une ressource.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</source>
          <target state="translated">Charge le module, interne à cet assembly, avec une image COFF (Common Object File Format) contenant un module émis ou un fichier de ressources.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>The loaded module.</source>
          <target state="translated">Module chargé.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> does not match a file entry in this assembly's manifest.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> ne correspond pas à une entrée de fichier du manifeste de cet assembly.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> is not a valid module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> n'est pas un module valide.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The name of the module.</source>
          <target state="translated">Nom du module.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>This string must correspond to a file name in this assembly's manifest.</source>
          <target state="translated">Cette chaîne doit correspondre à un nom de fichier du manifeste de cet assembly.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted module, or a resource.</source>
          <target state="translated">Tableau d'octets qui est une image COFF contenant un module émis ou une ressource.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A byte array containing the raw bytes representing the symbols for the module.</source>
          <target state="translated">Tableau d'octets contenant les octets bruts représentant les symboles du module.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if this is a resource file.</source>
          <target state="translated">Doit avoir la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph> s'il s'agit d'un fichier de ressources.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</source>
          <target state="translated">Charge le module, interne à cet assembly, avec une image COFF (Common Object File Format) contenant un module émis ou un fichier de ressources.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The raw bytes representing the symbols for the module are also loaded.</source>
          <target state="translated">Les octets bruts représentant les symboles du module sont également chargés.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The loaded module.</source>
          <target state="translated">Module chargé.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> does not match a file entry in this assembly's manifest.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> ne correspond pas à une entrée de fichier du manifeste de cet assembly.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> is not a valid module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> n'est pas un module valide.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType&gt;</ph> method are obsolete and have been retained for backward compatibility.</source>
          <target state="translated">Les surcharges de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType&gt;</ph> méthode sont obsolète et ont été conservés pour la compatibilité descendante.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L'alternative non obsolète est <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> is not found, this method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> est introuvable, cette méthode retourne <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29&gt;</ph> method is obsolete and has been retained for backward compatibility.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29&gt;</ph> méthode est obsolète et a été conservée pour la compatibilité descendante.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L'alternative non obsolète est <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Applications that load assemblies with this method will be affected by upgrades of those assemblies.</source>
          <target state="translated">Les applications qui chargent des assemblys avec cette méthode seront affectées par les mises à niveau de ces assemblys.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Therefore, do not use this method; redesign the application to use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29&gt;</ph> method overload or the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">Par conséquent, n’utilisez pas de cette méthode ; reconcevez l’application pour utiliser le <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29&gt;</ph> surcharge de méthode ou la <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>This method first calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode appelle d’abord <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</source>
          <target state="translated">Si l’assembly est introuvable, cette méthode retourne l’assembly dans le global assembly cache qui a le même nom simple et le numéro de version le plus élevé.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> is not found, this method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> est introuvable, cette méthode retourne <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29&gt;</ph> method is obsolete and has been retained for backward compatibility.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29&gt;</ph> méthode est obsolète et a été conservée pour la compatibilité descendante.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L'alternative non obsolète est <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</source>
          <target state="translated">La preuve est le jeu d'informations qui alimente les décisions de stratégie de sécurité, telles que les autorisations qui peuvent être accordées au code.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Applications that load assemblies with this method will be affected by upgrades of those assemblies.</source>
          <target state="translated">Les applications qui chargent des assemblys avec cette méthode seront affectées par les mises à niveau de ces assemblys.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Therefore, do not use this method; redesign the application to use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method.</source>
          <target state="translated">Par conséquent, n’utilisez pas de cette méthode ; reconcevez l’application pour utiliser le <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode ou la <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>This method first calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode appelle d’abord <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</source>
          <target state="translated">Si l’assembly est introuvable, cette méthode retourne l’assembly dans le global assembly cache qui a le même nom simple et le numéro de version le plus élevé.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different sets of evidence.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux ensembles de preuves différents.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>for calling unmanaged code and to load an assembly with evidence.</source>
          <target state="translated">pour appeler du code non managé et charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Location">
          <source>Gets the full path or UNC location of the loaded file that contains the manifest.</source>
          <target state="translated">Obtient le chemin d’accès complet ou l’emplacement UNC du fichier chargé qui contient le manifeste.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>The location of the loaded file that contains the manifest.</source>
          <target state="translated">Emplacement du fichier chargé qui contient le manifeste.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</source>
          <target state="translated">Si le fichier chargé était une copie fantôme, l'emplacement est celui du fichier après qu'il soit une copie fantôme.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>If the assembly is loaded from a byte array, such as when using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /&gt;</ph> method overload, the value returned is an empty string ("").</source>
          <target state="translated">Si l'assembly est chargé à partir d'un tableau d'octets, par exemple lors de l'utilisation de la surcharge de méthode <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /&gt;</ph>, la valeur retournée est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>To get the location before the file has been shadow-copied, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property.</source>
          <target state="translated">Pour obtenir l’emplacement avant que le fichier a été copié de clichés instantanés, utilisez le <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>The following example displays the location of the loaded file that contains the manifest.</source>
          <target state="translated">L’exemple suivant affiche l’emplacement du fichier chargé qui contient le manifeste.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Location">
          <source>The current assembly is a dynamic assembly, represented by an <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> object.</source>
          <target state="translated">L’assembly actuel est un assembly dynamique représenté par un objet <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>for access to the path.</source>
          <target state="translated">Pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ManifestModule">
          <source>Gets the module that contains the manifest for the current assembly.</source>
          <target state="translated">Obtient le module qui contient le manifeste de l'assembly actuel.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ManifestModule">
          <source>The module that contains the manifest for the assembly.</source>
          <target state="translated">Module qui contient le manifeste d'assembly.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</source>
          <target state="translated">Se produit si le chargeur de classes du Common Language Runtime ne peut pas résoudre une référence à un module interne d'un assembly à l'aide des moyens normaux.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>This event gives the callback a chance to find and load the module itself and return it.</source>
          <target state="translated">Cet événement permet le rappel pour trouver et charger le module lui-même et la retourner.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Modules">
          <source>Gets a collection that contains the modules in this assembly.</source>
          <target state="translated">Obtient une collection qui contient les modules dans cet assembly.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Modules">
          <source>A collection that contains the modules in this assembly.</source>
          <target state="translated">Collection qui contient les modules dans cet assembly.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Assembly à comparer à <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Assembly à comparer à <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indique si deux objets <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> sont égaux.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> est égal à <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ; sinon <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Assembly à comparer à <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Assembly à comparer à <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indique si deux objets <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> ne sont pas égaux.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> n'est pas égal à <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>Gets the grant set of the current assembly.</source>
          <target state="translated">Obtient le jeu accordé de l'assembly actuel.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>The grant set of the current assembly.</source>
          <target state="translated">Jeu accordé de l'assembly actuel.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source><ph id="ph1">&lt;xref:System.Security.PermissionSet&gt;</ph> objects can contain sensitive information such as paths.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.PermissionSet&gt;</ph> les objets peuvent contenir des informations sensibles telles que les chemins d’accès.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>Therefore, full trust is required to access these objects.</source>
          <target state="translated">Par conséquent, la confiance totale est requise pour accéder à ces objets.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value indicating whether this assembly was loaded into the reflection-only context.</source>
          <target state="translated">Obtient une valeur <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> indiquant si cet assembly a été chargé dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'assembly a été chargé dans le contexte de réflexion uniquement, plutôt que dans le contexte d'exécution ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>If an assembly has been loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, you cannot execute code in the assembly.</source>
          <target state="translated">Si un assembly a été chargé dans le contexte de réflexion uniquement, à l’aide du <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> (méthode), vous ne pouvez pas exécuter du code dans l’assembly.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>To execute code, the assembly must be loaded into the execution context.</source>
          <target state="translated">Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly into the reflection-only context, where it can be examined but not executed.</source>
          <target state="translated">Charge un assembly dans le contexte de réflexion uniquement, où il peut être examiné mais pas exécuté.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</source>
          <target state="translated">Charge l'assembly à partir d'une image au format COFF (Common Object File Format) contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The assembly is loaded into the reflection-only context of the caller's application domain.</source>
          <target state="translated">L'assembly est chargé dans le contexte de réflexion uniquement du domaine d'application de l'appelant.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>You cannot execute code from an assembly loaded into the reflection-only context.</source>
          <target state="translated">Vous ne pouvez pas exécuter du code à partir d’un assembly chargé dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>To execute code, the assembly must be loaded into the execution context as well, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution, à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">Le contexte de réflexion uniquement n’est pas différent des autres contextes.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">Les assemblys sont chargés dans le contexte peuvent être déchargés qu’en déchargeant le domaine d’application.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> cannot be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The display name of the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Reflection.AssemblyName.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom complet de l'assembly, tel que retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Reflection.AssemblyName.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Loads an assembly into the reflection-only context, given its display name.</source>
          <target state="translated">Charge un assembly dans le contexte de réflexion uniquement, étant donné son nom complet.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Dependencies are not automatically loaded into the reflection-only context.</source>
          <target state="translated">Dépendances ne sont pas chargés automatiquement dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>You cannot execute code from an assembly loaded into the reflection-only context.</source>
          <target state="translated">Vous ne pouvez pas exécuter du code à partir d’un assembly chargé dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>To execute code, the assembly must be loaded into the execution context as well, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution, à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Les règles d’assembly et la fusion de la preuve de sécurité sont les suivantes :</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Reflecting on executable files compiled in C++ might throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>.</source>
          <target state="translated">La réflexion sur des fichiers exécutables compilés en C++ peut lever un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</source>
          <target state="translated">Cela est probablement provoqué par le compilateur C++ suppression des adresses de réadressage ou de la section .reloc de votre fichier exécutable.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>To preserve the .reloc address, specify <ph id="ph1">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Pour conserver l’adresse .reloc, spécifiez <ph id="ph1">`/fixed:no`</ph> lors de la liaison.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">Le contexte de réflexion uniquement n’est pas différent des autres contextes.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">Les assemblys sont chargés dans le contexte peuvent être déchargés qu’en déchargeant le domaine d’application.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is an empty string ("").</source>
          <target state="translated">Le <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is found, but cannot be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> a été trouvé, mais ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Chemin d’accès du fichier qui contient le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Loads an assembly into the reflection-only context, given its path.</source>
          <target state="translated">Charge un assembly dans le contexte de réflexion uniquement, étant donné son chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Dependencies are not automatically loaded into the reflection-only context.</source>
          <target state="translated">Dépendances ne sont pas chargés automatiquement dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>To automatically load dependencies, handle the <ph id="ph1">&lt;xref:System.AppDomain.ReflectionOnlyAssemblyResolve&gt;</ph> event and load the dependency in the event handler.</source>
          <target state="translated">Pour charger automatiquement les dépendances, gérer le <ph id="ph1">&lt;xref:System.AppDomain.ReflectionOnlyAssemblyResolve&gt;</ph> événement et chargez la dépendance dans le Gestionnaire d’événements.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>You cannot execute code from an assembly that has been loaded into the reflection-only context.</source>
          <target state="translated">Vous ne pouvez pas exécuter du code à partir d’un assembly qui a été chargé dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>To execute the code, load the assembly with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Pour exécuter le code, chargez l’assembly avec le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Le <ph id="ph1">`assemblyFile`</ph> paramètre doit faire référence à un URI sans caractères d’échappement.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Cette méthode fournit des caractères d’échappement pour tous les caractères non valides dans l’URI.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The path specified for <ph id="ph1">`assemblyFile`</ph> is relative to the current directory.</source>
          <target state="translated">Le chemin d’accès spécifié pour <ph id="ph1">`assemblyFile`</ph> est relatif au répertoire en cours.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The assembly is loaded into the domain of the caller.</source>
          <target state="translated">L’assembly est chargé dans le domaine de l’appelant.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">Le contexte de réflexion uniquement n’est pas différent des autres contextes.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">Les assemblys sont chargés dans le contexte peuvent être déchargés qu’en déchargeant le domaine d’application.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a file name extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is found, but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été trouvé, mais n'a pas pu être chargé.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">Un code base qui ne commence pas par "file://" a été spécifié sans le <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> requis.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">Le nom de l’assembly est plus long que MAX_PATH caractères.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is an empty string ("").</source>
          <target state="translated">Le <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">pour lire un URI qui commence par « file:// ».</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</source>
          <target state="translated">Obtient une valeur qui indique quel ensemble de règles de sécurité le Common Language Runtime (CLR) applique pour cet assembly.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>The security rule set that the CLR enforces for this assembly.</source>
          <target state="translated">Ensemble de règles de sécurité que le CLR applique pour cet assembly.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>By default, assemblies that you compile with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> have  transparency, although you can explicitly make them  instead.</source>
          <target state="translated">Par défaut, les assemblys que vous compilez avec le <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> ont une transparence, bien que vous puissiez utiliser explicitement à la place.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</source>
          <target state="translated">Les assemblys qui ont été compilés avec les versions antérieures du .NET Framework ont la transparence de niveau 1.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>See <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Changements en matière de sécurité<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType">
          <source>Returns the type of the current instance.</source>
          <target state="translated">Retourne le type de l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType">
          <source>An object that represents the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> type.</source>
          <target state="translated">Objet qui représente le type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ToString">
          <source>Returns the full name of the assembly, also known as the display name.</source>
          <target state="translated">Retourne le nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ToString">
          <source>The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</source>
          <target state="translated">Nom complet de l'assembly, ou nom de la classe si le nom complet de l'assembly ne peut pas être déterminé.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Loads an assembly into the load-from context, bypassing some security checks.</source>
          <target state="translated">Charge un assembly dans le contexte de chargement, en ignorant des vérifications de sécurité.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</source>
          <target state="translated">Utilisez cette méthode pour charger un assembly local que le système d’exploitation a signalé comme ayant été chargé à partir du Web (par exemple, un fichier temporaire a été téléchargé depuis Internet ou intranet).</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Before the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, such assemblies were automatically loaded into a sandboxed application domain.</source>
          <target state="translated">Avant du <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, ces assemblys ont été chargés automatiquement dans un domaine d’application sandbox.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, they are loaded with full trust.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, elles sont chargées avec une confiance totale.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>As an alternative to using this method, you can apply the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept> in your application configuration file.</source>
          <target state="translated">Comme alternative à l’utilisation de cette méthode, vous pouvez appliquer la <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> élément<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept> dans votre fichier de configuration d’application.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>This causes the common language runtime to revert to the security policy of the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">Cela entraîne le common language runtime rétablir la stratégie de sécurité de le <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>If you use either of these solutions, you must be certain that it is safe to load <ph id="ph1">`assemblyFile`</ph> with full trust.</source>
          <target state="translated">Si vous utilisez une de ces solutions, vous devez être certain qu’elle est sécurisée pour charger <ph id="ph1">`assemblyFile`</ph> avec une confiance totale.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>For a discussion of load contexts, including the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">Pour en savoir plus sur les contextes de chargement, y compris le contexte de chargement, consultez la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable ou le module que vous tentez de charger ne spécifie pas d'extension de nom de fichier.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Impossible de charger l’un des fichiers trouvés.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">Un code base qui ne commence pas par "file://" a été spécifié sans le <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> requis.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">Le nom de l’assembly comprend plus de MAX_PATH caractères.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>