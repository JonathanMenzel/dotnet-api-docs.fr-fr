<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeDelegator.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b857fe3" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2eccf4de-4b1c-4706-8cb3-f46682ccfb72a4f7885feb36b422d1bc1a67c2ca21bdc27b7a81.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a4f7885feb36b422d1bc1a67c2ca21bdc27b7a81</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b15b8cf0f6dbc1504057c88969d9ef4b790891fe</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/11/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Wraps a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object and delegates methods to that <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</source>
          <target state="translated">Encapsule un objet <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> et délègue les méthodes à ce <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Derive from this type and override only those members you have to provide customization in, plus any members that are required by your program and not already implemented by <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>.</source>
          <target state="translated">Dérivez à partir de ce type et substituez uniquement les membres que vous devez fournir la personnalisation dans, ainsi que tous les membres qui sont requis par votre programme et pas déjà implémentés par <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> derives from <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> and implements most of the properties and methods of <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> dérive de <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> et implémente la plupart des propriétés et méthodes de <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>For each member it implements, <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> automatically delegates to the corresponding member of an internal <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, which is supplied as an argument to the constructor.</source>
          <target state="translated">Pour chaque membre qu’il implémente, <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> délègue automatiquement au membre correspondant d’interne <ph id="ph2">&lt;xref:System.Type&gt;</ph> objet, qui est fournie en tant qu’argument au constructeur.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>This internal <ph id="ph1">&lt;xref:System.Type&gt;</ph> object is exposed to deriving classes by the <ph id="ph2">`protected`</ph><ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> field.</source>
          <target state="translated">Ce interne <ph id="ph1">&lt;xref:System.Type&gt;</ph> objet est exposé aux classes dérivées par le <ph id="ph2">`protected`</ph> <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> champ.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Some members of <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> have implementations even though the members themselves are simply inherited from <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Certains membres de <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> ont des implémentations même si les membres eux-mêmes sont hérités simplement de <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>In these cases, the implementation is provided by an overridden <ph id="ph1">`protected`</ph> method that has a name that ends in "Impl".</source>
          <target state="translated">Dans ce cas, l’implémentation est fournie par un substituée <ph id="ph1">`protected`</ph> méthode qui a un nom qui se termine par « Impl ».</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>For example, the implementation for all overloads of the <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetMethods%2A&gt;</ph> method is supplied by the overridden <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.GetMethodImpl%2A&gt;</ph> method.</source>
          <target state="translated">Par exemple, l’implémentation pour toutes les surcharges de la <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetMethods%2A&gt;</ph> méthode est fournie par le substituée <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.GetMethodImpl%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The implementation for inherited properties such as <ph id="ph1">&lt;xref:System.Type.IsPublic%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph> is provided by the overridden <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A&gt;</ph> method.</source>
          <target state="translated">L’implémentation des propriétés héritées telles que <ph id="ph1">&lt;xref:System.Type.IsPublic%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph> est fournie par le substituée <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Deriving classes can provide a public constructor that takes a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as its parameter and simply passes that object to the <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29&gt;</ph> constructor, or can set the internal <ph id="ph3">&lt;xref:System.Type&gt;</ph> object in some other way.</source>
          <target state="translated">Classes dérivées peuvent fournir un constructeur public qui accepte un <ph id="ph1">&lt;xref:System.Type&gt;</ph> de l’objet comme paramètre et passe simplement à la <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29&gt;</ph> constructeur, ou vous pouvez définir le texte interne <ph id="ph3">&lt;xref:System.Type&gt;</ph> objet d’une autre manière.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>If a deriving class uses a member that is not implemented by <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>, it must override that member and provide an implementation.</source>
          <target state="translated">Si une classe dérivée utilise un membre qui n’est pas implémenté par <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>, il doit substituer ce membre et fournir une implémentation.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The simplest implementation is to call the corresponding member on the internal <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposed by the <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> field, but you can provide any implementation your application requires.</source>
          <target state="translated">L’implémentation la plus simple consiste à appeler le membre correspondant sur interne <ph id="ph1">&lt;xref:System.Type&gt;</ph> objet exposé par le <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> champ, mais vous pouvez fournir toute implémentation de votre application requiert.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>It is not necessary to override these members if they are not used by your application or by library functions your application calls (for example, by the <ph id="ph1">&lt;xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType&gt;</ph> constructor).</source>
          <target state="translated">Il n’est pas nécessaire de remplacer ces membres s’ils ne sont pas utilisés par votre application ou par la bibliothèque de fonctions de votre application appelle (par exemple, en le <ph id="ph1">&lt;xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType&gt;</ph> constructeur).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The following virtual methods (<ph id="ph1">`Overridable`</ph> methods in Visual Basic) of <ph id="ph2">&lt;xref:System.Type&gt;</ph> are not implemented by <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, <ph id="ph11">&lt;xref:System.Type.GetEnumNames%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.GetEnumValues%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.GetEnumUnderlyingType%2A&gt;</ph>, <ph id="ph14">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph>, <ph id="ph15">&lt;xref:System.Type.IsEnumDefined%2A&gt;</ph>, <ph id="ph16">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph>.</source>
          <target state="translated">Les méthodes virtuelles suivantes (<ph id="ph1">`Overridable`</ph> méthodes en Visual Basic) de <ph id="ph2">&lt;xref:System.Type&gt;</ph> ne sont pas implémentées par <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> , <ph id="ph11">&lt;xref:System.Type.GetEnumNames%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.GetEnumValues%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.GetEnumUnderlyingType%2A&gt;</ph>, <ph id="ph14">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph>, <ph id="ph15">&lt;xref:System.Type.IsEnumDefined%2A&gt;</ph>, <ph id="ph16">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The following virtual properties (<ph id="ph1">`Overridable`</ph> properties in Visual Basic) of <ph id="ph2">&lt;xref:System.Type&gt;</ph> are not implemented by <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>, <ph id="ph11">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>.</source>
          <target state="translated">Les propriétés virtuelles suivantes (<ph id="ph1">`Overridable`</ph> propriétés dans Visual Basic) de <ph id="ph2">&lt;xref:System.Type&gt;</ph> ne sont pas implémentées par <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> , <ph id="ph11">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class with default properties.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> avec des propriétés par défaut.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>The instance of the class <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that encapsulates the call to the method of an object.</source>
          <target state="translated">Instance de la classe <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> qui encapsule l'appel à la méthode d'un objet.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class specifying the encapsulating instance.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> spécifiant l'instance d'encapsulation.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>This constructor is called from a class to generate a delegate based upon the <ph id="ph1">`Type`</ph> object for the class defining the method.</source>
          <target state="translated">Ce constructeur est appelé à partir d’une classe pour générer un délégué basé sur le <ph id="ph1">`Type`</ph> objet pour la classe qui définit la méthode.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source><ph id="ph1">&lt;paramref name="delegatingType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegatingType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Gets the assembly of the implemented type.</source>
          <target state="translated">Obtient l'assembly du type implémenté.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> object representing the assembly of the implemented type.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> qui représente l'assembly du type implémenté.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Assemblies are the deployment units in the common language runtime.</source>
          <target state="translated">Les assemblys sont les unités de déploiement dans le common language runtime.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Assemblies establish the namespace for resolving requests and determine which resources are exposed externally and which are accessible from within the assembly.</source>
          <target state="translated">Les assemblys établissent l’espace de noms pour résoudre les demandes et déterminent quelles ressources sont exposées en externe et qui sont accessible à partir de l’assembly.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>The common language runtime can determine and locate the assembly for any running object.</source>
          <target state="translated">Le common language runtime peut déterminer et localiser l’assembly de n’importe quel objet en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.AssemblyQualifiedName">
          <source>Gets the assembly's fully qualified name.</source>
          <target state="translated">Obtient le nom qualifié complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.AssemblyQualifiedName">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the assembly's fully qualified name.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="String" /&gt;</ph> contenant le nom qualifié complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>Gets the base type for the current type.</source>
          <target state="translated">Obtient le type de base pour le type en cours.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>The base type for a type.</source>
          <target state="translated">Type de base d'un type.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>The base type is the type from which this type directly inherits.</source>
          <target state="translated">Le type de base est le type à partir duquel ce type hérite directement.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>Since the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class type is the ultimate base class of all the other types, it is the only type that does not have a base type.</source>
          <target state="translated">Étant donné que le <ph id="ph1">&lt;xref:System.Object&gt;</ph> type de classe est la classe de base fondamentale parmi tous les autres types, il est le seul type qui n’est pas un type de base.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>In this case, <ph id="ph1">`null`</ph> is returned as the base type of the <ph id="ph2">`Object`</ph> type.</source>
          <target state="translated">Dans ce cas, <ph id="ph1">`null`</ph> est retourné en tant que type de base de la <ph id="ph2">`Object`</ph> type.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>Gets the fully qualified name of the implemented type.</source>
          <target state="translated">Obtient le nom qualifié complet du type implémenté.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's fully qualified name.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="String" /&gt;</ph> contenant le nom qualifié complet du type.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>A string containing the fully qualified name of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">Chaîne contenant le nom qualifié complet de l’actuelle <ph id="ph1">`TypeDelegator`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>Gets the attributes assigned to the <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Obtient les attributs assignés au <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>A <ph id="ph1">&lt;see langword="TypeAttributes" /&gt;</ph> object representing the implementation attribute flags.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="TypeAttributes" /&gt;</ph> représentant les indicateurs d'attributs d'implémentation.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>This method can be used to determine if the <ph id="ph1">`TypeDelegator`</ph> is abstract, public, and so on.</source>
          <target state="translated">Cette méthode peut être utilisée pour déterminer si le <ph id="ph1">`TypeDelegator`</ph> est abstrait, public et ainsi de suite.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling conventions.</source>
          <target state="translated">Conventions d'appel.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing a list of the parameter number, order, and types.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> contenant la liste du nombre, de l'ordre et des types de paramètres.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>; use an appropriate <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">Les types ne peuvent pas être <ph id="ph1">&lt;see langword="null" /&gt;</ph> ; utilisez une méthode <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> appropriée ou un tableau vide pour rechercher une méthode sans paramètres.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph> having the same length as the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array, whose elements represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph>, de la même longueur que le tableau <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>, dont les éléments représentent les attributs associés aux paramètres de la méthode à obtenir.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Gets the constructor that implemented the <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Obtient le constructeur qui a implémenté le <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> object for the method that matches the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if a match cannot be found.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> de la méthode qui répond aux critères spécifiés ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si aucune correspondance n'existe.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">`callConvention`</ph> parameter indicates the calling convention for the entry point.</source>
          <target state="translated">Le <ph id="ph1">`callConvention`</ph> paramètre indique la convention d’appel pour le point d’entrée.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If no calling convention is specified, a default <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> value of <ph id="ph2">`Standard`</ph> is used.</source>
          <target state="translated">Si aucune convention d’appel n’est spécifiée, une valeur par défaut <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> valeur <ph id="ph2">`Standard`</ph> est utilisé.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing constructors defined for the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne un tableau d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> représentant les constructeurs définis pour le type encapsulé par le <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> containing the specified constructors defined for this class.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> contenant les constructeurs spécifiés définis pour cette classe.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>If no constructors are defined, an empty array is returned.</source>
          <target state="translated">Si aucun constructeur n’est défini, un tableau vide est retourné.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Depending on the value of a specified parameter, only public constructors or both public and non-public constructors will be returned.</source>
          <target state="translated">Selon la valeur d'un paramètre spécifié, seuls les constructeurs publics ou les constructeurs publics et non publics seront retournés.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Class initializers are available only through <ph id="ph1">`GetMember`</ph>, <ph id="ph2">`GetMembers`</ph>, <ph id="ph3">`FindMembers`</ph>, and <ph id="ph4">`GetConstructors`</ph>.</source>
          <target state="translated">Les initialiseurs de classe sont disponibles seulement via <ph id="ph1">`GetMember`</ph>, <ph id="ph2">`GetMembers`</ph>, <ph id="ph3">`FindMembers`</ph>, et <ph id="ph4">`GetConstructors`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Returns all the custom attributes defined for this type.</source>
          <target state="translated">Retourne tous les attributs personnalisés définis pour ce type.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">Spécifie s'il faut rechercher les attributs dans la chaîne d'héritage de ce type.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this type, specifying whether to search the type's inheritance chain.</source>
          <target state="translated">Retourne tous les attributs personnalisés définis pour ce type, en spécifiant si les attributs doivent être recherchés dans la chaîne d'héritage du type.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>An array of objects containing all the custom attributes defined for this type.</source>
          <target state="translated">Tableau d'objets contenant tous les attributs personnalisés définis pour ce type.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>A custom attribute type cannot be loaded.</source>
          <target state="translated">Un type d’attribut personnalisé ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes identified by type.</source>
          <target state="translated">Tableau d'attributs personnalisés identifiés par type.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">Spécifie s'il faut rechercher les attributs dans la chaîne d'héritage de ce type.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns an array of custom attributes identified by type.</source>
          <target state="translated">Retourne un tableau des attributs personnalisés identifiés par type.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of objects containing the custom attributes defined in this type that match the <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> parameter, specifying whether to search the type's inheritance chain, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no custom attributes are defined on this type.</source>
          <target state="translated">Un tableau d'objets contenant les attributs personnalisés définis dans ce type qui correspondent au paramètre <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> et spécifiant si les attributs doivent être recherchés dans la chaîne d'héritage du type, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si aucun attribut personnalisé n'a été défini sur ce type.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A custom attribute type cannot be loaded.</source>
          <target state="translated">Un type d’attribut personnalisé ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetElementType">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or ByRef.</source>
          <target state="translated">Retourne le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de l'objet englobé ou référencé par le tableau, le pointeur ou le ByRef en cours.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetElementType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> is not an array, a pointer or a <ph id="ph5">&lt;see langword="ByRef" /&gt;</ph>.</source>
          <target state="translated">Le type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de l'objet englobé ou référencé par le tableau, le pointeur ou le <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> en cours, ou <ph id="ph3">&lt;see langword="null" /&gt;</ph> si le <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> actuel n'est pas un tableau, un pointeur ou un <ph id="ph5">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The name of the event to get.</source>
          <target state="translated">Nom de l’événement à obtenir.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Returns the specified event.</source>
          <target state="translated">Retourne l'événement spécifié.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the event declared or inherited by this type with the specified name.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> représentant l'événement déclaré ou hérité par ce type avec le nom spécifié.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>This method returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such event is found.</source>
          <target state="translated">Cette méthode retourne <ph id="ph1">&lt;see langword="null" /&gt;</ph> si l'événement est introuvable.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.<ph id="ph3">`IgnoreCase`</ph>, the case of the <ph id="ph4">`name`</ph> parameter is ignored.</source>
          <target state="translated">Si <ph id="ph1">`bindingAttr`</ph> est <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.<ph id="ph3">`IgnoreCase`</ph>, le cas de la <ph id="ph4">`name`</ph> paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne un tableau d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> représentant tous les événements publics déclarés ou hérités par le <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne un tableau d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> représentant tous les événements publics déclarés ou hérités par le <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>Returns an array of type <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> containing all the events declared or inherited by the current type.</source>
          <target state="translated">Retourne un tableau de type <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> contenant tous les événements déclarés ou hérités par le type en cours.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>If there are no events, an empty array is returned.</source>
          <target state="translated">En l'absence d'événements, un tableau vide est retourné.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns the events specified in <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne les événements spécifiés dans <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> qui sont déclarés ou hérités par le <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> containing the events specified in <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> contenant les événements spécifiés dans <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>If there are no events, an empty array is returned.</source>
          <target state="translated">En l'absence d'événements, un tableau vide est retourné.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The name of the field to find.</source>
          <target state="translated">Le nom du champ à trouver.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field with the specified name.</source>
          <target state="translated">Retourne un objet <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> qui représente le champ portant le nom spécifié.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object representing the field declared or inherited by this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> with the specified name.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> représentant le champ déclaré ou hérité par ce <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> avec le nom spécifié.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such field is found.</source>
          <target state="translated">Retourne <ph id="ph1">&lt;see langword="null" /&gt;</ph> si le champ est introuvable.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Use a <ph id="ph1">`bindingAttr`</ph> of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic to return all public and nonpublic fields.</source>
          <target state="translated">Utilisez un <ph id="ph1">`bindingAttr`</ph> de <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>. NonPublic pour retourner tous les champs publics et non publics.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Use <ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of the fields, as the search is case-sensitive by default.</source>
          <target state="translated">Utilisez <ph id="ph1">`BindingFlags.IgnoreCase`</ph> pour ignorer la casse des champs, comme la recherche respecte la casse par défaut.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the data fields defined for the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne un tableau d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> représentant les champs de données définis pour le type encapsulé par le <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> containing the fields declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> contenant les champs déclarés ou hérités par le <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matched fields.</source>
          <target state="translated">En l'absence de champs correspondants, un tableau vide est retourné.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetFields%2A&gt;</ph> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Votre code ne doit pas dépendent de l’ordre dans lequel les champs sont retournés, car cet ordre peut varier.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Use a <ph id="ph1">`bindingAttr`</ph> of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic to return all public and nonpublic fields.</source>
          <target state="translated">Utilisez un <ph id="ph1">`bindingAttr`</ph> de <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>. NonPublic pour retourner tous les champs publics et non publics.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>The fully qualified name of the interface implemented by the current class.</source>
          <target state="translated">Nom qualifié complet de l'interface implémentée par la classe en cours.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the case is to be ignored; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la recherche ne respecte pas la casse ; sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>Returns the specified interface implemented by the type wrapped by the current <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne l'interface spécifiée qui est implémentée par le type encapsulé par le <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the interface implemented (directly or indirectly) by the current class with the fully qualified name matching the specified name.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="Type" /&gt;</ph> représentant l'interface implémentée (directement ou indirectement) par la classe en cours, avec le nom qualifié complet correspondant au nom spécifié.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>If no interface that matches name is found, null is returned.</source>
          <target state="translated">Si aucune interface correspondant à ce nom n'est trouvée, une valeur null est retournée.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the interface to retrieve a mapping of.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de l'interface dont le mappage doit être récupéré.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the specified interface type.</source>
          <target state="translated">Retourne un mappage d'interface pour le type interface spécifié.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.InterfaceMapping" /&gt;</ph> object representing the interface mapping for <ph id="ph2">&lt;paramref name="interfaceType" /&gt;</ph>.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.InterfaceMapping" /&gt;</ph> représentant le mappage d'interface pour <ph id="ph2">&lt;paramref name="interfaceType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</source>
          <target state="translated">Le mappage d’interface indique le mode de mappage d’une interface dans les méthodes réelles sur une classe qui implémente cette interface.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>Returns all the interfaces implemented on the current class and its base classes.</source>
          <target state="translated">Retourne toutes les interfaces implémentées sur la classe en cours et sur ses classes de base.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing all the interfaces implemented on the current class and its base classes.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> contenant toutes les interfaces implémentées sur la classe en cours et sur ses classes de base.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>If none are defined, an empty array is returned.</source>
          <target state="translated">Si aucune interface n’est définie, un tableau vide est retourné.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The name of the member to get.</source>
          <target state="translated">Nom du membre à obtenir.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The type of members to get.</source>
          <target state="translated">Type de membres à obtenir.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns members (properties, methods, constructors, fields, events, and nested types) specified by the given <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="type" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated">Retourne les membres (propriétés, méthodes, constructeurs, champs, événements et types imbriqués) spécifiés par les paramètres <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="type" /&gt;</ph> et <ph id="ph3">&lt;paramref name="bindingAttr" /&gt;</ph> donnés.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> containing all the members of the current class and its base class meeting the specified criteria.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> contenant tous les membres de la classe en cours et de sa classe de base correspondant aux critères spécifiés.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic, all the members will be considered.</source>
          <target state="translated">Si <ph id="ph1">`bindingAttr`</ph> est <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>. NonPublic, tous les membres sont considérés.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If there are no matches, an empty array is returned.</source>
          <target state="translated">S’il n’y a aucune correspondance, un tableau vide est retourné.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns members specified by <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated">Retourne les membres spécifiés par <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> containing all the members of the current class and its base classes that meet the <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> filter.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> contenant tous les membres de la classe en cours et de ses classes de base correspondant au filtre <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic, all the members will be considered.</source>
          <target state="translated">Si <ph id="ph1">`bindingAttr`</ph> est <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>. NonPublic, tous les membres sont considérés.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>If there are no matches, an empty array is returned.</source>
          <target state="translated">S’il n’y a aucune correspondance, un tableau vide est retourné.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Nom de la méthode.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling conventions.</source>
          <target state="translated">Conventions d'appel.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing a list of the parameter number, order, and types.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> contenant la liste du nombre, de l'ordre et des types de paramètres.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>; use an appropriate <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">Les types ne peuvent pas être <ph id="ph1">&lt;see langword="null" /&gt;</ph> ; utilisez une méthode <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> appropriée ou un tableau vide pour rechercher une méthode sans paramètres.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph> having the same length as the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array, whose elements represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph>, de la même longueur que le tableau <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>, dont les éléments représentent les attributs associés aux paramètres de la méthode à obtenir.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Recherche la méthode spécifiée dont les paramètres correspondent aux types d’arguments et aux modificateurs spécifiés, en utilisant les contraintes de liaison et la convention d’appel indiquées.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfoInfo" /&gt;</ph> object for the implementation method that matches the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if a match cannot be found.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="MethodInfoInfo" /&gt;</ph> de la méthode d'implémentation qui répond aux critères spécifiés ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si aucune correspondance n'existe.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">`callConvention`</ph> parameter indicates the calling convention for the entry point.</source>
          <target state="translated">Le <ph id="ph1">`callConvention`</ph> paramètre indique la convention d’appel pour le point d’entrée.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If no <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> is specified, a default <ph id="ph2">`CallingConventions`</ph> value of <ph id="ph3">`Standard`</ph> is used.</source>
          <target state="translated">Si aucun <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> est spécifié, une valeur par défaut <ph id="ph2">`CallingConventions`</ph> valeur <ph id="ph3">`Standard`</ph> est utilisé.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing specified methods of the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne un tableau d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> représentant les méthodes spécifiées du type encapsulé par le <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> objects representing the methods defined on this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> représentant les méthodes définies sur ce <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The nested type's name.</source>
          <target state="translated">Nom du type imbriqué.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Returns a nested type specified by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> and in <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the type represented by the current <ph id="ph3">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne un type imbriqué spécifié par <ph id="ph1">&lt;paramref name="name" /&gt;</ph> et dans <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> qui sont déclarés ou hérités par le type représenté par le <ph id="ph3">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the nested type.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="Type" /&gt;</ph> qui représente le type imbriqué.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Returns the nested types specified in <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne les types imbriqués spécifiés dans <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> qui sont déclarés ou hérités par le type encapsulé par le <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing the nested types.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> contenant les types imbriqués.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing properties of the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Retourne un tableau d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> représentant les propriétés du type encapsulé par le <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> objects representing properties defined on this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> représentant les propriétés définies sur ce <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The property to get.</source>
          <target state="translated">Propriété à obtenir.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Masque de bits qui affecte la manière dont la recherche est effectuée.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Type de retour de la propriété.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A list of parameter types.</source>
          <target state="translated">Liste de types de paramètres.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The list represents the number, order, and types of the parameters.</source>
          <target state="translated">La liste représente le nombre, l'ordre et les types de paramètres.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be null; use an appropriate <ph id="ph1">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">Les types ne peuvent pas être null ; utilisez une méthode <ph id="ph1">&lt;see langword="GetMethod" /&gt;</ph> appropriée ou un tableau vide pour rechercher une méthode sans paramètres.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of the same length as types with elements that represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated">Tableau de la même longueur que les types, avec des éléments qui représentent les attributs associés aux paramètres de la méthode à obtenir.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, recherche la propriété spécifiée dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, en utilisant les contraintes de liaison indiquées.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> object for the property that matches the specified criteria, or null if a match cannot be found.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> de la propriété qui répond aux critères spécifiés ou une valeur null si aucune correspondance n'existe.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>Gets the GUID (globally unique identifier) of the implemented type.</source>
          <target state="translated">Obtient l'identificateur global unique (GUID) du type implémenté.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>A GUID.</source>
          <target state="translated">GUID.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>The GUID (globally unique identifier) is a 128-bit unique identification string used to identify a class or an interface.</source>
          <target state="translated">Le GUID (identificateur global unique) est une chaîne d’identification 128 bits unique utilisée pour identifier une classe ou une interface.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>It is primarily useful for interoperability between the Microsoft .NET Framework and COM.</source>
          <target state="translated">Il est particulièrement utile pour l’interopérabilité entre le Microsoft .NET Framework et COM.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.HasElementTypeImpl">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer or a ByRef.</source>
          <target state="translated">Obtient une valeur indiquant si le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en cours inclut ou fait référence à un autre type, c'est-à-dire si le <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> en cours est un tableau, un pointeur ou un ByRef.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.HasElementTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer or a ByRef; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> est un tableau, un pointeur ou un ByRef ; sinon <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The name of the member to invoke.</source>
          <target state="translated">Nom du membre à appeler.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This may be a constructor, method, property, or field.</source>
          <target state="translated">Il peut s'agir d'un constructeur, d'une méthode, d'une propriété ou d'un champ.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If an empty string ("") is passed, the default member is invoked.</source>
          <target state="translated">Si vous passez une chaîne vide (""), le membre par défaut est appelé.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The invocation attribute.</source>
          <target state="translated">Attribut d’appel.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This must be one of the following <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="Static" /&gt;</ph>, <ph id="ph5">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph7">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph8">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated">Il doit s'agir de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="Static" /&gt;</ph>, <ph id="ph5">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph7">&lt;see langword="GetProperty" /&gt;</ph> ou <ph id="ph8">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A suitable invocation attribute must be specified.</source>
          <target state="translated">Un attribut d’appel approprié doit être spécifié.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If a static member is to be invoked, the <ph id="ph1">&lt;see langword="Static" /&gt;</ph> flag must be set.</source>
          <target state="translated">Si le membre à appeler est statique, l'indicateur <ph id="ph1">&lt;see langword="Static" /&gt;</ph> doit être défini.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Objet sur lequel appeler le membre spécifié.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> that contains the number, order, and type of the parameters of the member to be invoked.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> qui contient le nombre, l'ordre et le type des paramètres du membre à appeler.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> contains an uninitialized <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, it is treated as empty, which, with the default binder, can be widened to 0, 0.0 or a string.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> contient un <ph id="ph1">&lt;see langword="Object" /&gt;</ph> non initialisé, il est traité comme vide ce qui, avec le binder par défaut, peut être élargi à 0, 0.0 ou à une chaîne.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifer" /&gt;</ph> that is the same length as <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>, with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="ParameterModifer" /&gt;</ph>, de la même longueur que <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>, avec des éléments qui représentent les attributs associés aux arguments du membre à appeler.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter has attributes associated with it in the member's signature.</source>
          <target state="translated">Un paramètre a des attributs associés à celui-ci dans la signature du membre.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For ByRef, use <ph id="ph1">&lt;see langword="ParameterModifer.ByRef" /&gt;</ph>, and for none, use <ph id="ph2">&lt;see langword="ParameterModifer.None" /&gt;</ph>.</source>
          <target state="translated">Pour ByRef, utilisez <ph id="ph1">&lt;see langword="ParameterModifer.ByRef" /&gt;</ph> ; pour n'en avoir aucun, utilisez <ph id="ph2">&lt;see langword="ParameterModifer.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder does exact matching on these.</source>
          <target state="translated">Le binder par défaut recherche une correspondance exacte pour ceux-ci.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Attributes such as <ph id="ph1">&lt;see langword="In" /&gt;</ph> and <ph id="ph2">&lt;see langword="InOut" /&gt;</ph> are not used in binding, and can be viewed using <ph id="ph3">&lt;see langword="ParameterInfo" /&gt;</ph>.</source>
          <target state="translated">Les attributs tels que <ph id="ph1">&lt;see langword="In" /&gt;</ph> et <ph id="ph2">&lt;see langword="InOut" /&gt;</ph> ne sont pas utilisés pour la liaison ; ils peuvent être visualisés à l'aide de <ph id="ph3">&lt;see langword="ParameterInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Instance de <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> utilisée pour régir la contrainte des types.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This is necessary, for example, to convert a string that represents 1000 to a <ph id="ph1">&lt;see langword="Double" /&gt;</ph> value, since 1000 is represented differently by different cultures.</source>
          <target state="translated">Par exemple, cela est nécessaire pour la conversion d'une chaîne représentant 1000 en une valeur <ph id="ph1">&lt;see langword="Double" /&gt;</ph>, car 1000 est représenté de différentes manières selon la culture.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread's <ph id="ph3">&lt;see langword="CultureInfo" /&gt;</ph> is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> du <ph id="ph3">&lt;see langword="CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing parameter names that match up, starting at element zero, with the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="String" /&gt;</ph> contenant les noms de paramètres qui correspondent, à partir de l’élément 0, au tableau <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>There must be no holes in the array.</source>
          <target state="translated">Le tableau ne doit pas contenir d'espaces.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;see langword="Length" /&gt;</ph> is greater than <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Length" /&gt;</ph> est supérieur à <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;see langword="Length" /&gt;</ph>, the remaining parameters are filled in order.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Length" /&gt;</ph>, les paramètres restants sont remplis dans l'ordre.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invokes the specified member.</source>
          <target state="translated">Appelle le membre spécifié.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
          <target state="translated">La méthode à appeler doit être accessible et fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée, sous les contraintes des attributs de binder et d’appel spécifiés.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> representing the return value of the invoked member.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Object" /&gt;</ph> représentant la valeur de retour du membre appelé.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if both the following conditions are true:</source>
          <target state="translated">Une méthode est appelée si les deux conditions suivantes sont remplies :</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the specified argument list (unless default arguments are defined on the member).</source>
          <target state="translated">Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans la liste d’arguments spécifiée (sauf si les arguments par défaut sont définis sur le membre).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of each arguments can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Le type de chaque argument peut être converti par le binder pour le type du paramètre.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all the matching methods.</source>
          <target state="translated">Le binder va trouver toutes les méthodes correspondantes.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">`BindingFlags.MethodInvoke`</ph>, <ph id="ph2">`BindingFlags.GetProperties`</ph>, and so on).</source>
          <target state="translated">Ces méthodes sont recherchées en fonction du type de liaison demandé (<ph id="ph1">`BindingFlags.MethodInvoke`</ph>, <ph id="ph2">`BindingFlags.GetProperties`</ph>, et ainsi de suite).</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it will be invoked.</source>
          <target state="translated">Une fois que la méthode est sélectionnée, elle sera appelée.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">Accessibilité est vérifiée à ce stade.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method is responsible for selecting the method to be invoked.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> méthode est chargée de sélectionner la méthode à appeler.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Le binder par défaut sélectionne la correspondance la plus spécifique.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Restrictions d’accès sont ignorées pour le code de confiance totale.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using reflection whenever the code is fully trusted.</source>
          <target state="translated">Autrement dit, propriétés, méthodes, champs et constructeurs privés sont accessibles et appelé à l’aide de la réflexion lorsque le code est entièrement fiable.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Currently, <ph id="ph1">`InvokeMember`</ph> performs the Microsoft .NET Framework reflection semantics for every type of object.</source>
          <target state="translated">Actuellement, <ph id="ph1">`InvokeMember`</ph> effectue la sémantique de réflexion Microsoft .NET Framework pour chaque type d’objet.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the member specified by name is an array and the <ph id="ph1">`BindingFlags.GetField`</ph> flag is set on <ph id="ph2">`invokeAttr`</ph>, the <ph id="ph3">`args`</ph> array specifies the elements whose values are to be returned.</source>
          <target state="translated">Si le membre spécifié par le nom est un tableau et le <ph id="ph1">`BindingFlags.GetField`</ph> indicateur est défini sur <ph id="ph2">`invokeAttr`</ph>, le <ph id="ph3">`args`</ph> tableau spécifie les éléments dont les valeurs doivent être retournées.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, the following call through <ph id="ph1">`Type`</ph> object <ph id="ph2">`t`</ph> returns the value of the first element of the string array MyArray, which is a member of the calling object:</source>
          <target state="translated">Par exemple, l’appel suivant via <ph id="ph1">`Type`</ph> objet <ph id="ph2">`t`</ph> retourne la valeur du premier élément du tableau de chaînes MyArray, qui est un membre de l’objet appelant :</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can use <ph id="ph1">`InvokeMember`</ph> to set one or more elements of a member array.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">`InvokeMember`</ph> pour définir un ou plusieurs éléments d’un tableau de membres.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>All elements are set to the same value.</source>
          <target state="translated">Tous les éléments sont définies sur la même valeur.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`args`</ph> array must be formatted as follows:</source>
          <target state="translated">Le <ph id="ph1">`args`</ph> tableau doit être formaté comme suit :</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, to set the first member of MyArray from the previous example, the syntax is as follows:</source>
          <target state="translated">Par exemple, pour définir le premier membre de MyArray de l’exemple précédent, la syntaxe est la suivante :</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsArrayImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is an array.</source>
          <target state="translated">Retourne une valeur qui indique si l'objet <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> est un tableau.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsArrayImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> est un tableau ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The type to check.</source>
          <target state="translated">Type à vérifier.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Returns a value that indicates whether the specified type can be assigned to this type.</source>
          <target state="translated">Retourne une valeur qui indique si le type spécifié peut être affecté à ce type.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified type can be assigned to this type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le type spécifié peut être assigné à ce type ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsByRefImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">Retourne une valeur qui indique si le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> est passé par référence.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> est passé par référence ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsCOMObjectImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">Retourne une valeur qui indique si le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> est un objet COM.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsCOMObjectImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> est un objet COM ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Obtient une valeur qui indique si cet objet représente un type générique construit.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si cet objet représente un type générique construit ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">Spécifie s'il faut rechercher les attributs dans la chaîne d'héritage de ce type.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>An array of custom attributes identified by type.</source>
          <target state="translated">Tableau d'attributs personnalisés identifiés par type.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether a custom attribute identified by <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is defined.</source>
          <target state="translated">Indique si un attribut personnalisé identifié par <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est défini.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a custom attribute identified by <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> is defined; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si un attribut personnalisé identifié par <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> est défini ; sinon <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>The custom attribute type cannot be loaded.</source>
          <target state="translated">Le type d’attribut personnalisé ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPointerImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">Retourne une valeur qui indique si le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> est un pointeur.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPointerImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> est un pointeur ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPrimitiveImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">Retourne une valeur qui indique si le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> est l'un des types primitifs.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPrimitiveImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> est l'un des types primitifs ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsValueTypeImpl">
          <source>Returns a value that indicates whether the type is a value type; that is, not a class or an interface.</source>
          <target state="translated">Retourne une valeur qui indique si le type est un type valeur, autrement dit, il n'est ni une classe ni une interface.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsValueTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is a value type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le type est un type valeur ; sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>Gets a value that identifies this entity in metadata.</source>
          <target state="translated">Obtient une valeur qui identifie cette entité dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>A value which, in combination with the module, uniquely identifies this entity in metadata.</source>
          <target state="translated">Valeur qui, en association avec le module, identifie de manière unique cette entité dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged reflection API.</source>
          <target state="translated">Les jetons obtenus à l’aide de cette propriété peuvent être passés à l’API de réflexion non managée.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>API de réflexion non managée<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Module">
          <source>Gets the module that contains the implemented type.</source>
          <target state="translated">Obtient le module contenant le type implémenté.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> object representing the module of the implemented type.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> qui représente le module du type implémenté.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>A module is a loadable unit that can contain type declarations and implementations.</source>
          <target state="translated">Un module est une unité chargeable qui peut contenir les déclarations de type et leurs implémentations.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>Modules contain enough information to enable the common language runtime to locate all implementation bits when the module is loaded.</source>
          <target state="translated">Les modules contiennent suffisamment d’informations pour activer le common language runtime localiser tous les bits de la mise en œuvre lorsque le module est chargé.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Name">
          <source>Gets the name of the implemented type, with the path removed.</source>
          <target state="translated">Obtient le nom du type implémenté, sans le chemin d'accès.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's non-qualified name.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="String" /&gt;</ph> contenant le nom non complet du type.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>A string containing the name of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">Chaîne contenant le nom de l'élément <ph id="ph1">`TypeDelegator`</ph> actuel.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>Only the simple name, not the fully qualified name, is returned.</source>
          <target state="translated">Seul le nom simple, et pas le nom qualifié complet, est retourné.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>To get the name and the path, use <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.FullName%2A&gt;</ph>.</source>
          <target state="translated">Pour obtenir le nom et le chemin d’accès, utilisez <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.FullName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>Gets the namespace of the implemented type.</source>
          <target state="translated">Obtient l'espace de noms du type implémenté.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's namespace.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="String" /&gt;</ph> contenant l'espace de noms du type.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>This property gets a string containing the namespace of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">Cette propriété obtient une chaîne contenant l’espace de noms d’actuel <ph id="ph1">`TypeDelegator`</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>For example, if the <ph id="ph1">`TypeDelegator`</ph> is <ph id="ph2">&lt;xref:System.Reflection.TypeFilter&gt;</ph>, the returned namespace is <ph id="ph3">&lt;xref:System.Reflection&gt;</ph>.</source>
          <target state="translated">Par exemple, si le <ph id="ph1">`TypeDelegator`</ph> est <ph id="ph2">&lt;xref:System.Reflection.TypeFilter&gt;</ph>, l’espace de noms retourné est <ph id="ph3">&lt;xref:System.Reflection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>Gets a handle to the internal metadata representation of an implemented type.</source>
          <target state="translated">Obtient un handle vers la représentation interne des métadonnées d'un type implémenté.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>A <ph id="ph1">&lt;see langword="RuntimeTypeHandle" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="RuntimeTypeHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>A type handle is a unique integer value associated with each type.</source>
          <target state="translated">Un descripteur de type est une valeur d’entier unique associée à chaque type.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>The handle is unique during the runtime.</source>
          <target state="translated">Le handle est unique au cours de l’exécution.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="F:System.Reflection.TypeDelegator.typeImpl">
          <source>A value indicating type information.</source>
          <target state="translated">Valeur indiquant des informations sur le type.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.UnderlyingSystemType">
          <source>Gets the underlying <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that represents the implemented type.</source>
          <target state="translated">Obtient le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> sous-jacent qui représente le type implémenté.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.UnderlyingSystemType">
          <source>The underlying type.</source>
          <target state="translated">Type sous-jacent.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>