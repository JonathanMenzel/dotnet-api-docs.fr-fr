<Type Name="TypeDelegator" FullName="System.Reflection.TypeDelegator">
  <TypeSignature Language="C#" Value="public class TypeDelegator : System.Reflection.TypeInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit TypeDelegator extends System.Reflection.TypeInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.TypeDelegator" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeDelegator&#xA;Inherits TypeInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDelegator : System::Reflection::TypeInfo" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="38bb4-101">Encapsule un objet <see cref="T:System.Type" /> et délègue les méthodes à ce <see langword="Type" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-101">Wraps a <see cref="T:System.Type" /> object and delegates methods to that <see langword="Type" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-102">Dérivez à partir de ce type et substituez uniquement les membres que vous devez fournir la personnalisation dans, ainsi que tous les membres qui sont requis par votre programme et pas déjà implémentés par <xref:System.Reflection.TypeDelegator>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-102">Derive from this type and override only those members you have to provide customization in, plus any members that are required by your program and not already implemented by <xref:System.Reflection.TypeDelegator>.</span></span>  
  
 <span data-ttu-id="38bb4-103"><xref:System.Reflection.TypeDelegator> dérive de <xref:System.Type?displayProperty=nameWithType> et implémente la plupart des propriétés et méthodes de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-103"><xref:System.Reflection.TypeDelegator> derives from <xref:System.Type?displayProperty=nameWithType> and implements most of the properties and methods of <xref:System.Type>.</span></span> <span data-ttu-id="38bb4-104">Pour chaque membre qu’il implémente, <xref:System.Reflection.TypeDelegator> délègue automatiquement au membre correspondant d’interne <xref:System.Type> objet, qui est fournie en tant qu’argument au constructeur.</span><span class="sxs-lookup"><span data-stu-id="38bb4-104">For each member it implements, <xref:System.Reflection.TypeDelegator> automatically delegates to the corresponding member of an internal <xref:System.Type> object, which is supplied as an argument to the constructor.</span></span> <span data-ttu-id="38bb4-105">Ce interne <xref:System.Type> objet est exposé aux classes dérivées par le `protected` <xref:System.Reflection.TypeDelegator.typeImpl> champ.</span><span class="sxs-lookup"><span data-stu-id="38bb4-105">This internal <xref:System.Type> object is exposed to deriving classes by the `protected`<xref:System.Reflection.TypeDelegator.typeImpl> field.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="38bb4-106">Certains membres de <xref:System.Reflection.TypeDelegator> ont des implémentations même si les membres eux-mêmes sont hérités simplement de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-106">Some members of <xref:System.Reflection.TypeDelegator> have implementations even though the members themselves are simply inherited from <xref:System.Type>.</span></span> <span data-ttu-id="38bb4-107">Dans ce cas, l’implémentation est fournie par un substituée `protected` méthode qui a un nom qui se termine par « Impl ».</span><span class="sxs-lookup"><span data-stu-id="38bb4-107">In these cases, the implementation is provided by an overridden `protected` method that has a name that ends in "Impl".</span></span> <span data-ttu-id="38bb4-108">Par exemple, l’implémentation pour toutes les surcharges de la <xref:System.Reflection.TypeDelegator.GetMethods%2A> méthode est fournie par le substituée <xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="38bb4-108">For example, the implementation for all overloads of the <xref:System.Reflection.TypeDelegator.GetMethods%2A> method is supplied by the overridden <xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> method.</span></span> <span data-ttu-id="38bb4-109">L’implémentation des propriétés héritées telles que <xref:System.Type.IsPublic%2A> et <xref:System.Type.IsNestedAssembly%2A> est fournie par le substituée <xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="38bb4-109">The implementation for inherited properties such as <xref:System.Type.IsPublic%2A> and <xref:System.Type.IsNestedAssembly%2A> is provided by the overridden <xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> method.</span></span>  
  
 <span data-ttu-id="38bb4-110">Classes dérivées peuvent fournir un constructeur public qui accepte un <xref:System.Type> de l’objet comme paramètre et passe simplement à la <xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> constructeur, ou vous pouvez définir le texte interne <xref:System.Type> objet d’une autre manière.</span><span class="sxs-lookup"><span data-stu-id="38bb4-110">Deriving classes can provide a public constructor that takes a <xref:System.Type> object as its parameter and simply passes that object to the <xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> constructor, or can set the internal <xref:System.Type> object in some other way.</span></span>  
  
 <span data-ttu-id="38bb4-111">Si une classe dérivée utilise un membre qui n’est pas implémenté par <xref:System.Reflection.TypeDelegator>, il doit substituer ce membre et fournir une implémentation.</span><span class="sxs-lookup"><span data-stu-id="38bb4-111">If a deriving class uses a member that is not implemented by <xref:System.Reflection.TypeDelegator>, it must override that member and provide an implementation.</span></span> <span data-ttu-id="38bb4-112">L’implémentation la plus simple consiste à appeler le membre correspondant sur interne <xref:System.Type> objet exposé par le <xref:System.Reflection.TypeDelegator.typeImpl> champ, mais vous pouvez fournir toute implémentation de votre application requiert.</span><span class="sxs-lookup"><span data-stu-id="38bb4-112">The simplest implementation is to call the corresponding member on the internal <xref:System.Type> object exposed by the <xref:System.Reflection.TypeDelegator.typeImpl> field, but you can provide any implementation your application requires.</span></span> <span data-ttu-id="38bb4-113">Il n’est pas nécessaire de remplacer ces membres s’ils ne sont pas utilisés par votre application ou par la bibliothèque de fonctions de votre application appelle (par exemple, en le <xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType> constructeur).</span><span class="sxs-lookup"><span data-stu-id="38bb4-113">It is not necessary to override these members if they are not used by your application or by library functions your application calls (for example, by the <xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType> constructor).</span></span>  
  
 <span data-ttu-id="38bb4-114">Les méthodes virtuelles suivantes (`Overridable` méthodes en Visual Basic) de <xref:System.Type> ne sont pas implémentées par <xref:System.Reflection.TypeDelegator>: <xref:System.Type.MakeGenericType%2A>, <xref:System.Type.GetGenericTypeDefinition%2A>, <xref:System.Type.GetGenericArguments%2A>, <xref:System.Type.GetGenericParameterConstraints%2A>, <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakeByRefType%2A>, <xref:System.Type.MakePointerType%2A> , <xref:System.Type.GetEnumNames%2A>, <xref:System.Type.GetEnumValues%2A>, <xref:System.Type.GetEnumUnderlyingType%2A>, <xref:System.Type.GetTypeCodeImpl%2A>, <xref:System.Type.IsEnumDefined%2A>, <xref:System.Type.IsEquivalentTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-114">The following virtual methods (`Overridable` methods in Visual Basic) of <xref:System.Type> are not implemented by <xref:System.Reflection.TypeDelegator>: <xref:System.Type.MakeGenericType%2A>, <xref:System.Type.GetGenericTypeDefinition%2A>, <xref:System.Type.GetGenericArguments%2A>, <xref:System.Type.GetGenericParameterConstraints%2A>, <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakeByRefType%2A>, <xref:System.Type.MakePointerType%2A>, <xref:System.Type.GetEnumNames%2A>, <xref:System.Type.GetEnumValues%2A>, <xref:System.Type.GetEnumUnderlyingType%2A>, <xref:System.Type.GetTypeCodeImpl%2A>, <xref:System.Type.IsEnumDefined%2A>, <xref:System.Type.IsEquivalentTo%2A>.</span></span>  
  
 <span data-ttu-id="38bb4-115">Les propriétés virtuelles suivantes (`Overridable` propriétés dans Visual Basic) de <xref:System.Type> ne sont pas implémentées par <xref:System.Reflection.TypeDelegator>: <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, <xref:System.Type.ContainsGenericParameters%2A>, <xref:System.Type.DeclaringMethod%2A>, <xref:System.Type.GenericParameterAttributes%2A>, <xref:System.Type.GenericParameterPosition%2A> , <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, <xref:System.Type.IsSecurityTransparent%2A>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-115">The following virtual properties (`Overridable` properties in Visual Basic) of <xref:System.Type> are not implemented by <xref:System.Reflection.TypeDelegator>: <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, <xref:System.Type.ContainsGenericParameters%2A>, <xref:System.Type.DeclaringMethod%2A>, <xref:System.Type.GenericParameterAttributes%2A>, <xref:System.Type.GenericParameterPosition%2A>, <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, <xref:System.Type.IsSecurityTransparent%2A>.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38bb4-116">Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.TypeDelegator" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-116">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDelegator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDelegator();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-117">Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.TypeDelegator" /> avec des propriétés par défaut.</span><span class="sxs-lookup"><span data-stu-id="38bb4-117">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class with default properties.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeDelegator (Type delegatingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type delegatingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (delegatingType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeDelegator(Type ^ delegatingType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="delegatingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegatingType"><span data-ttu-id="38bb4-118">Instance de la classe <see cref="T:System.Type" /> qui encapsule l'appel à la méthode d'un objet.</span><span class="sxs-lookup"><span data-stu-id="38bb4-118">The instance of the class <see cref="T:System.Type" /> that encapsulates the call to the method of an object.</span></span></param>
        <summary><span data-ttu-id="38bb4-119">Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.TypeDelegator" /> spécifiant l'instance d'encapsulation.</span><span class="sxs-lookup"><span data-stu-id="38bb4-119">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class specifying the encapsulating instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-120">Ce constructeur est appelé à partir d’une classe pour générer un délégué basé sur le `Type` objet pour la classe qui définit la méthode.</span><span class="sxs-lookup"><span data-stu-id="38bb4-120">This constructor is called from a class to generate a delegate based upon the `Type` object for the class defining the method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="38bb4-121"><paramref name="delegatingType" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-121"><paramref name="delegatingType" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-122">Obtient l'assembly du type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-122">Gets the assembly of the implemented type.</span></span></summary>
        <value><span data-ttu-id="38bb4-123">Objet <see cref="T:System.Reflection.Assembly" /> qui représente l'assembly du type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-123">An <see cref="T:System.Reflection.Assembly" /> object representing the assembly of the implemented type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-124">Les assemblys sont les unités de déploiement dans le common language runtime.</span><span class="sxs-lookup"><span data-stu-id="38bb4-124">Assemblies are the deployment units in the common language runtime.</span></span> <span data-ttu-id="38bb4-125">Les assemblys établissent l’espace de noms pour résoudre les demandes et déterminent quelles ressources sont exposées en externe et qui sont accessible à partir de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="38bb4-125">Assemblies establish the namespace for resolving requests and determine which resources are exposed externally and which are accessible from within the assembly.</span></span> <span data-ttu-id="38bb4-126">Le common language runtime peut déterminer et localiser l’assembly de n’importe quel objet en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="38bb4-126">The common language runtime can determine and locate the assembly for any running object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-127">Obtient le nom qualifié complet de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="38bb4-127">Gets the assembly's fully qualified name.</span></span></summary>
        <value><span data-ttu-id="38bb4-128"><see langword="String" /> contenant le nom qualifié complet de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="38bb4-128">A <see langword="String" /> containing the assembly's fully qualified name.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-129">Obtient le type de base pour le type en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-129">Gets the base type for the current type.</span></span></summary>
        <value><span data-ttu-id="38bb4-130">Type de base d'un type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-130">The base type for a type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-131">Le type de base est le type à partir duquel ce type hérite directement.</span><span class="sxs-lookup"><span data-stu-id="38bb4-131">The base type is the type from which this type directly inherits.</span></span> <span data-ttu-id="38bb4-132">Étant donné que le <xref:System.Object> type de classe est la classe de base fondamentale parmi tous les autres types, il est le seul type qui n’est pas un type de base.</span><span class="sxs-lookup"><span data-stu-id="38bb4-132">Since the <xref:System.Object> class type is the ultimate base class of all the other types, it is the only type that does not have a base type.</span></span> <span data-ttu-id="38bb4-133">Dans ce cas, `null` est retourné en tant que type de base de la `Object` type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-133">In this case, `null` is returned as the base type of the `Object` type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-134">Obtient le nom qualifié complet du type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-134">Gets the fully qualified name of the implemented type.</span></span></summary>
        <value><span data-ttu-id="38bb4-135"><see langword="String" /> contenant le nom qualifié complet du type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-135">A <see langword="String" /> containing the type's fully qualified name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-136">Chaîne contenant le nom qualifié complet de l’actuelle `TypeDelegator`.</span><span class="sxs-lookup"><span data-stu-id="38bb4-136">A string containing the fully qualified name of the current `TypeDelegator`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-137">Obtient les attributs assignés au <see langword="TypeDelegator" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-137">Gets the attributes assigned to the <see langword="TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-138">Objet <see langword="TypeAttributes" /> représentant les indicateurs d'attributs d'implémentation.</span><span class="sxs-lookup"><span data-stu-id="38bb4-138">A <see langword="TypeAttributes" /> object representing the implementation attribute flags.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-139">Cette méthode peut être utilisée pour déterminer si le `TypeDelegator` est abstrait, public et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="38bb4-139">This method can be used to determine if the `TypeDelegator` is abstract, public, and so on.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="38bb4-140">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-140">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-141">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-141">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="38bb4-142">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion.</span><span class="sxs-lookup"><span data-stu-id="38bb4-142">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="38bb4-143">Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-143">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="callConvention"><span data-ttu-id="38bb4-144">Conventions d'appel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-144">The calling conventions.</span></span></param>
        <param name="types"><span data-ttu-id="38bb4-145">Tableau de type <see langword="Type" /> contenant la liste du nombre, de l'ordre et des types de paramètres.</span><span class="sxs-lookup"><span data-stu-id="38bb4-145">An array of type <see langword="Type" /> containing a list of the parameter number, order, and types.</span></span> <span data-ttu-id="38bb4-146">Les types ne peuvent pas être <see langword="null" /> ; utilisez une méthode <see langword="GetMethod" /> appropriée ou un tableau vide pour rechercher une méthode sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="38bb4-146">Types cannot be <see langword="null" />; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="38bb4-147">Tableau de type <see langword="ParameterModifier" />, de la même longueur que le tableau <c>types</c>, dont les éléments représentent les attributs associés aux paramètres de la méthode à obtenir.</span><span class="sxs-lookup"><span data-stu-id="38bb4-147">An array of type <see langword="ParameterModifier" /> having the same length as the <c>types</c> array, whose elements represent the attributes associated with the parameters of the method to get.</span></span></param>
        <summary><span data-ttu-id="38bb4-148">Obtient le constructeur qui a implémenté le <see langword="TypeDelegator" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-148">Gets the constructor that implemented the <see langword="TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-149">Objet <see langword="ConstructorInfo" /> de la méthode qui répond aux critères spécifiés ou <see langword="null" /> si aucune correspondance n'existe.</span><span class="sxs-lookup"><span data-stu-id="38bb4-149">A <see langword="ConstructorInfo" /> object for the method that matches the specified criteria, or <see langword="null" /> if a match cannot be found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-150">Le `callConvention` paramètre indique la convention d’appel pour le point d’entrée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-150">The `callConvention` parameter indicates the calling convention for the entry point.</span></span> <span data-ttu-id="38bb4-151">Si aucune convention d’appel n’est spécifiée, une valeur par défaut <xref:System.Reflection.CallingConventions> valeur `Standard` est utilisé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-151">If no calling convention is specified, a default <xref:System.Reflection.CallingConventions> value of `Standard` is used.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="38bb4-152">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-152">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-153">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-153">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-154">Retourne un tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs définis pour le type encapsulé par le <see cref="T:System.Reflection.TypeDelegator" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-154">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing constructors defined for the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-155">Tableau de type <see langword="ConstructorInfo" /> contenant les constructeurs spécifiés définis pour cette classe.</span><span class="sxs-lookup"><span data-stu-id="38bb4-155">An array of type <see langword="ConstructorInfo" /> containing the specified constructors defined for this class.</span></span> <span data-ttu-id="38bb4-156">Si aucun constructeur n’est défini, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="38bb4-156">If no constructors are defined, an empty array is returned.</span></span> <span data-ttu-id="38bb4-157">Selon la valeur d'un paramètre spécifié, seuls les constructeurs publics ou les constructeurs publics et non publics seront retournés.</span><span class="sxs-lookup"><span data-stu-id="38bb4-157">Depending on the value of a specified parameter, only public constructors or both public and non-public constructors will be returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-158">Les initialiseurs de classe sont disponibles seulement via `GetMember`, `GetMembers`, `FindMembers`, et `GetConstructors`.</span><span class="sxs-lookup"><span data-stu-id="38bb4-158">Class initializers are available only through `GetMember`, `GetMembers`, `FindMembers`, and `GetConstructors`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38bb4-159">Retourne tous les attributs personnalisés définis pour ce type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-159">Returns all the custom attributes defined for this type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="38bb4-160">Spécifie s'il faut rechercher les attributs dans la chaîne d'héritage de ce type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-160">Specifies whether to search this type's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="38bb4-161">Retourne tous les attributs personnalisés définis pour ce type, en spécifiant si les attributs doivent être recherchés dans la chaîne d'héritage du type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-161">Returns all the custom attributes defined for this type, specifying whether to search the type's inheritance chain.</span></span></summary>
        <returns><span data-ttu-id="38bb4-162">Tableau d'objets contenant tous les attributs personnalisés définis pour ce type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-162">An array of objects containing all the custom attributes defined for this type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="38bb4-163">Un type d’attribut personnalisé ne peut pas être chargé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-163">A custom attribute type cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="38bb4-164">Tableau d'attributs personnalisés identifiés par type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-164">An array of custom attributes identified by type.</span></span></param>
        <param name="inherit"><span data-ttu-id="38bb4-165">Spécifie s'il faut rechercher les attributs dans la chaîne d'héritage de ce type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-165">Specifies whether to search this type's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="38bb4-166">Retourne un tableau des attributs personnalisés identifiés par type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-166">Returns an array of custom attributes identified by type.</span></span></summary>
        <returns><span data-ttu-id="38bb4-167">Un tableau d'objets contenant les attributs personnalisés définis dans ce type qui correspondent au paramètre <paramref name="attributeType" /> et spécifiant si les attributs doivent être recherchés dans la chaîne d'héritage du type, ou <see langword="null" /> si aucun attribut personnalisé n'a été défini sur ce type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-167">An array of objects containing the custom attributes defined in this type that match the <paramref name="attributeType" /> parameter, specifying whether to search the type's inheritance chain, or <see langword="null" /> if no custom attributes are defined on this type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="38bb4-168"><paramref name="attributeType" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-168"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="38bb4-169">Un type d’attribut personnalisé ne peut pas être chargé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-169">A custom attribute type cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-170">Retourne le <see cref="T:System.Type" /> de l'objet englobé ou référencé par le tableau, le pointeur ou le ByRef en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-170">Returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or ByRef.</span></span></summary>
        <returns><span data-ttu-id="38bb4-171">Le type <see cref="T:System.Type" /> de l'objet englobé ou référencé par le tableau, le pointeur ou le <see langword="ByRef" /> en cours, ou <see langword="null" /> si le <see cref="T:System.Type" /> actuel n'est pas un tableau, un pointeur ou un <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-171">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or <see langword="ByRef" />, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array, a pointer or a <see langword="ByRef" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="38bb4-172">Nom de l’événement à obtenir.</span><span class="sxs-lookup"><span data-stu-id="38bb4-172">The name of the event to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="38bb4-173">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-173">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-174">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-174">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-175">Retourne l'événement spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-175">Returns the specified event.</span></span></summary>
        <returns><span data-ttu-id="38bb4-176">Objet <see cref="T:System.Reflection.EventInfo" /> représentant l'événement déclaré ou hérité par ce type avec le nom spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-176">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name.</span></span> <span data-ttu-id="38bb4-177">Cette méthode retourne <see langword="null" /> si l'événement est introuvable.</span><span class="sxs-lookup"><span data-stu-id="38bb4-177">This method returns <see langword="null" /> if no such event is found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-178">Si `bindingAttr` est <xref:System.Reflection.BindingFlags>.`IgnoreCase`, le cas de la `name` paramètre est ignoré.</span><span class="sxs-lookup"><span data-stu-id="38bb4-178">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.`IgnoreCase`, the case of the `name` parameter is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38bb4-179">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-179">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38bb4-180">Retourne un tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant tous les événements publics déclarés ou hérités par le <see langword="TypeDelegator" /> en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-180">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events declared or inherited by the current <see langword="TypeDelegator" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-181">Retourne un tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant tous les événements publics déclarés ou hérités par le <see langword="TypeDelegator" /> en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-181">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events declared or inherited by the current <see langword="TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-182">Retourne un tableau de type <see langword="EventInfo" /> contenant tous les événements déclarés ou hérités par le type en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-182">Returns an array of type <see langword="EventInfo" /> containing all the events declared or inherited by the current type.</span></span> <span data-ttu-id="38bb4-183">En l'absence d'événements, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="38bb4-183">If there are no events, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="38bb4-184">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-184">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-185">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-185">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-186">Retourne les événements spécifiés dans <paramref name="bindingAttr" /> qui sont déclarés ou hérités par le <see langword="TypeDelegator" /> en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-186">Returns the events specified in <paramref name="bindingAttr" /> that are declared or inherited by the current <see langword="TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-187">Tableau de type <see langword="EventInfo" /> contenant les événements spécifiés dans <paramref name="bindingAttr" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-187">An array of type <see langword="EventInfo" /> containing the events specified in <paramref name="bindingAttr" />.</span></span> <span data-ttu-id="38bb4-188">En l'absence d'événements, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="38bb4-188">If there are no events, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="38bb4-189">Le nom du champ à trouver.</span><span class="sxs-lookup"><span data-stu-id="38bb4-189">The name of the field to find.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="38bb4-190">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-190">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-191">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-191">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-192">Retourne un objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ portant le nom spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-192">Returns a <see cref="T:System.Reflection.FieldInfo" /> object representing the field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="38bb4-193">Objet <see langword="FieldInfo" /> représentant le champ déclaré ou hérité par ce <see langword="TypeDelegator" /> avec le nom spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-193">A <see langword="FieldInfo" /> object representing the field declared or inherited by this <see langword="TypeDelegator" /> with the specified name.</span></span> <span data-ttu-id="38bb4-194">Retourne <see langword="null" /> si le champ est introuvable.</span><span class="sxs-lookup"><span data-stu-id="38bb4-194">Returns <see langword="null" /> if no such field is found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-195">Utilisez un `bindingAttr` de <xref:System.Reflection.BindingFlags>. NonPublic pour retourner tous les champs publics et non publics.</span><span class="sxs-lookup"><span data-stu-id="38bb4-195">Use a `bindingAttr` of <xref:System.Reflection.BindingFlags>.NonPublic to return all public and nonpublic fields.</span></span> <span data-ttu-id="38bb4-196">Utilisez `BindingFlags.IgnoreCase` pour ignorer la casse des champs, comme la recherche respecte la casse par défaut.</span><span class="sxs-lookup"><span data-stu-id="38bb4-196">Use `BindingFlags.IgnoreCase` to ignore the case of the fields, as the search is case-sensitive by default.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38bb4-197">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-197">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="38bb4-198">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-198">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-199">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-199">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-200">Retourne un tableau d'objets <see cref="T:System.Reflection.FieldInfo" /> représentant les champs de données définis pour le type encapsulé par le <see cref="T:System.Reflection.TypeDelegator" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-200">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the data fields defined for the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-201">Tableau de type <see langword="FieldInfo" /> contenant les champs déclarés ou hérités par le <see langword="TypeDelegator" /> en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-201">An array of type <see langword="FieldInfo" /> containing the fields declared or inherited by the current <see langword="TypeDelegator" />.</span></span> <span data-ttu-id="38bb4-202">En l'absence de champs correspondants, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="38bb4-202">An empty array is returned if there are no matched fields.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-203">Le <xref:System.Reflection.TypeDelegator.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="38bb4-203">The <xref:System.Reflection.TypeDelegator.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="38bb4-204">Votre code ne doit pas dépendent de l’ordre dans lequel les champs sont retournés, car cet ordre peut varier.</span><span class="sxs-lookup"><span data-stu-id="38bb4-204">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="38bb4-205">Utilisez un `bindingAttr` de <xref:System.Reflection.BindingFlags>. NonPublic pour retourner tous les champs publics et non publics.</span><span class="sxs-lookup"><span data-stu-id="38bb4-205">Use a `bindingAttr` of <xref:System.Reflection.BindingFlags>.NonPublic to return all public and nonpublic fields.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="38bb4-206">Nom qualifié complet de l'interface implémentée par la classe en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-206">The fully qualified name of the interface implemented by the current class.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="38bb4-207"><see langword="true" /> si la recherche ne respecte pas la casse ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-207"><see langword="true" /> if the case is to be ignored; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-208">Retourne l'interface spécifiée qui est implémentée par le type encapsulé par le <see cref="T:System.Reflection.TypeDelegator" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-208">Returns the specified interface implemented by the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-209">Objet <see langword="Type" /> représentant l'interface implémentée (directement ou indirectement) par la classe en cours, avec le nom qualifié complet correspondant au nom spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-209">A <see langword="Type" /> object representing the interface implemented (directly or indirectly) by the current class with the fully qualified name matching the specified name.</span></span> <span data-ttu-id="38bb4-210">Si aucune interface correspondant à ce nom n'est trouvée, une valeur null est retournée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-210">If no interface that matches name is found, null is returned.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38bb4-211">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-211">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="38bb4-212"><see cref="T:System.Type" /> de l'interface dont le mappage doit être récupéré.</span><span class="sxs-lookup"><span data-stu-id="38bb4-212">The <see cref="T:System.Type" /> of the interface to retrieve a mapping of.</span></span></param>
        <summary><span data-ttu-id="38bb4-213">Retourne un mappage d'interface pour le type interface spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-213">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="38bb4-214">Objet <see cref="T:System.Reflection.InterfaceMapping" /> représentant le mappage d'interface pour <paramref name="interfaceType" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-214">An <see cref="T:System.Reflection.InterfaceMapping" /> object representing the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-215">Le mappage d’interface indique le mode de mappage d’une interface dans les méthodes réelles sur une classe qui implémente cette interface.</span><span class="sxs-lookup"><span data-stu-id="38bb4-215">The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-216">Retourne toutes les interfaces implémentées sur la classe en cours et sur ses classes de base.</span><span class="sxs-lookup"><span data-stu-id="38bb4-216">Returns all the interfaces implemented on the current class and its base classes.</span></span></summary>
        <returns><span data-ttu-id="38bb4-217">Tableau de type <see langword="Type" /> contenant toutes les interfaces implémentées sur la classe en cours et sur ses classes de base.</span><span class="sxs-lookup"><span data-stu-id="38bb4-217">An array of type <see langword="Type" /> containing all the interfaces implemented on the current class and its base classes.</span></span> <span data-ttu-id="38bb4-218">Si aucune interface n’est définie, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="38bb4-218">If none are defined, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="38bb4-219">Nom du membre à obtenir.</span><span class="sxs-lookup"><span data-stu-id="38bb4-219">The name of the member to get.</span></span></param>
        <param name="type"><span data-ttu-id="38bb4-220">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-220">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-221">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-221">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="38bb4-222">Type de membres à obtenir.</span><span class="sxs-lookup"><span data-stu-id="38bb4-222">The type of members to get.</span></span></param>
        <summary><span data-ttu-id="38bb4-223">Retourne les membres (propriétés, méthodes, constructeurs, champs, événements et types imbriqués) spécifiés par les paramètres <paramref name="name" />, <paramref name="type" /> et <paramref name="bindingAttr" /> donnés.</span><span class="sxs-lookup"><span data-stu-id="38bb4-223">Returns members (properties, methods, constructors, fields, events, and nested types) specified by the given <paramref name="name" />, <paramref name="type" />, and <paramref name="bindingAttr" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-224">Tableau de type <see langword="MemberInfo" /> contenant tous les membres de la classe en cours et de sa classe de base correspondant aux critères spécifiés.</span><span class="sxs-lookup"><span data-stu-id="38bb4-224">An array of type <see langword="MemberInfo" /> containing all the members of the current class and its base class meeting the specified criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-225">Si `bindingAttr` est <xref:System.Reflection.BindingFlags>. NonPublic, tous les membres sont considérés.</span><span class="sxs-lookup"><span data-stu-id="38bb4-225">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.NonPublic, all the members will be considered.</span></span> <span data-ttu-id="38bb4-226">S’il n’y a aucune correspondance, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="38bb4-226">If there are no matches, an empty array is returned.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38bb4-227">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-227">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="38bb4-228">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-228">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-229">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-229">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-230">Retourne les membres spécifiés par <paramref name="bindingAttr" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-230">Returns members specified by <paramref name="bindingAttr" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-231">Tableau de type <see langword="MemberInfo" /> contenant tous les membres de la classe en cours et de ses classes de base correspondant au filtre <paramref name="bindingAttr" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-231">An array of type <see langword="MemberInfo" /> containing all the members of the current class and its base classes that meet the <paramref name="bindingAttr" /> filter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-232">Si `bindingAttr` est <xref:System.Reflection.BindingFlags>. NonPublic, tous les membres sont considérés.</span><span class="sxs-lookup"><span data-stu-id="38bb4-232">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.NonPublic, all the members will be considered.</span></span> <span data-ttu-id="38bb4-233">S’il n’y a aucune correspondance, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="38bb4-233">If there are no matches, an empty array is returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="38bb4-234">Nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="38bb4-234">The method name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="38bb4-235">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-235">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-236">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-236">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="38bb4-237">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion.</span><span class="sxs-lookup"><span data-stu-id="38bb4-237">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="38bb4-238">Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-238">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="callConvention"><span data-ttu-id="38bb4-239">Conventions d'appel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-239">The calling conventions.</span></span></param>
        <param name="types"><span data-ttu-id="38bb4-240">Tableau de type <see langword="Type" /> contenant la liste du nombre, de l'ordre et des types de paramètres.</span><span class="sxs-lookup"><span data-stu-id="38bb4-240">An array of type <see langword="Type" /> containing a list of the parameter number, order, and types.</span></span> <span data-ttu-id="38bb4-241">Les types ne peuvent pas être <see langword="null" /> ; utilisez une méthode <see langword="GetMethod" /> appropriée ou un tableau vide pour rechercher une méthode sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="38bb4-241">Types cannot be <see langword="null" />; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="38bb4-242">Tableau de type <see langword="ParameterModifier" />, de la même longueur que le tableau <c>types</c>, dont les éléments représentent les attributs associés aux paramètres de la méthode à obtenir.</span><span class="sxs-lookup"><span data-stu-id="38bb4-242">An array of type <see langword="ParameterModifier" /> having the same length as the <c>types</c> array, whose elements represent the attributes associated with the parameters of the method to get.</span></span></param>
        <summary><span data-ttu-id="38bb4-243">Recherche la méthode spécifiée dont les paramètres correspondent aux types d’arguments et aux modificateurs spécifiés, en utilisant les contraintes de liaison et la convention d’appel indiquées.</span><span class="sxs-lookup"><span data-stu-id="38bb4-243">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="38bb4-244">Objet <see langword="MethodInfoInfo" /> de la méthode d'implémentation qui répond aux critères spécifiés ou <see langword="null" /> si aucune correspondance n'existe.</span><span class="sxs-lookup"><span data-stu-id="38bb4-244">A <see langword="MethodInfoInfo" /> object for the implementation method that matches the specified criteria, or <see langword="null" /> if a match cannot be found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-245">Le `callConvention` paramètre indique la convention d’appel pour le point d’entrée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-245">The `callConvention` parameter indicates the calling convention for the entry point.</span></span> <span data-ttu-id="38bb4-246">Si aucun <xref:System.Reflection.CallingConventions> est spécifié, une valeur par défaut `CallingConventions` valeur `Standard` est utilisé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-246">If no <xref:System.Reflection.CallingConventions> is specified, a default `CallingConventions` value of `Standard` is used.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="38bb4-247">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-247">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-248">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-248">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-249">Retourne un tableau d'objets <see cref="T:System.Reflection.MethodInfo" /> représentant les méthodes spécifiées du type encapsulé par le <see cref="T:System.Reflection.TypeDelegator" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-249">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing specified methods of the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-250">Tableau d'objets <see langword="MethodInfo" /> représentant les méthodes définies sur ce <see langword="TypeDelegator" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-250">An array of <see langword="MethodInfo" /> objects representing the methods defined on this <see langword="TypeDelegator" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="38bb4-251">Nom du type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="38bb4-251">The nested type's name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="38bb4-252">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-252">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-253">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-253">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-254">Retourne un type imbriqué spécifié par <paramref name="name" /> et dans <paramref name="bindingAttr" /> qui sont déclarés ou hérités par le type représenté par le <see cref="T:System.Reflection.TypeDelegator" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-254">Returns a nested type specified by <paramref name="name" /> and in <paramref name="bindingAttr" /> that are declared or inherited by the type represented by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-255">Objet <see langword="Type" /> qui représente le type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="38bb4-255">A <see langword="Type" /> object representing the nested type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38bb4-256">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-256">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="38bb4-257">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-257">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-258">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-258">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-259">Retourne les types imbriqués spécifiés dans <paramref name="bindingAttr" /> qui sont déclarés ou hérités par le type encapsulé par le <see cref="T:System.Reflection.TypeDelegator" /> en cours.</span><span class="sxs-lookup"><span data-stu-id="38bb4-259">Returns the nested types specified in <paramref name="bindingAttr" /> that are declared or inherited by the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-260">Tableau de type <see langword="Type" /> contenant les types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="38bb4-260">An array of type <see langword="Type" /> containing the nested types.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="38bb4-261">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-261">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-262">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-262">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="38bb4-263">Retourne un tableau d'objets <see cref="T:System.Reflection.PropertyInfo" /> représentant les propriétés du type encapsulé par le <see cref="T:System.Reflection.TypeDelegator" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-263">Returns an array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing properties of the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="38bb4-264">Tableau d'objets <see langword="PropertyInfo" /> représentant les propriétés définies sur ce <see langword="TypeDelegator" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-264">An array of <see langword="PropertyInfo" /> objects representing properties defined on this <see langword="TypeDelegator" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="38bb4-265">Propriété à obtenir.</span><span class="sxs-lookup"><span data-stu-id="38bb4-265">The property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="38bb4-266">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-266">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="38bb4-267">La valeur est une combinaison de zéro ou de plusieurs indicateurs binaires de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-267">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="38bb4-268">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion.</span><span class="sxs-lookup"><span data-stu-id="38bb4-268">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="38bb4-269">Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-269">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="38bb4-270">Consultez <see cref="T:System.Reflection.Binder" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-270">See <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="38bb4-271">Type de retour de la propriété.</span><span class="sxs-lookup"><span data-stu-id="38bb4-271">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="38bb4-272">Liste de types de paramètres.</span><span class="sxs-lookup"><span data-stu-id="38bb4-272">A list of parameter types.</span></span> <span data-ttu-id="38bb4-273">La liste représente le nombre, l'ordre et les types de paramètres.</span><span class="sxs-lookup"><span data-stu-id="38bb4-273">The list represents the number, order, and types of the parameters.</span></span> <span data-ttu-id="38bb4-274">Les types ne peuvent pas être null ; utilisez une méthode <see langword="GetMethod" /> appropriée ou un tableau vide pour rechercher une méthode sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="38bb4-274">Types cannot be null; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="38bb4-275">Tableau de la même longueur que les types, avec des éléments qui représentent les attributs associés aux paramètres de la méthode à obtenir.</span><span class="sxs-lookup"><span data-stu-id="38bb4-275">An array of the same length as types with elements that represent the attributes associated with the parameters of the method to get.</span></span></param>
        <summary><span data-ttu-id="38bb4-276">En cas de substitution dans une classe dérivée, recherche la propriété spécifiée dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, en utilisant les contraintes de liaison indiquées.</span><span class="sxs-lookup"><span data-stu-id="38bb4-276">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="38bb4-277">Objet <see cref="T:System.Reflection.PropertyInfo" /> de la propriété qui répond aux critères spécifiés ou une valeur null si aucune correspondance n'existe.</span><span class="sxs-lookup"><span data-stu-id="38bb4-277">A <see cref="T:System.Reflection.PropertyInfo" /> object for the property that matches the specified criteria, or null if a match cannot be found.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-278">Obtient l'identificateur global unique (GUID) du type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-278">Gets the GUID (globally unique identifier) of the implemented type.</span></span></summary>
        <value><span data-ttu-id="38bb4-279">GUID.</span><span class="sxs-lookup"><span data-stu-id="38bb4-279">A GUID.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-280">Le GUID (identificateur global unique) est une chaîne d’identification 128 bits unique utilisée pour identifier une classe ou une interface.</span><span class="sxs-lookup"><span data-stu-id="38bb4-280">The GUID (globally unique identifier) is a 128-bit unique identification string used to identify a class or an interface.</span></span> <span data-ttu-id="38bb4-281">Il est particulièrement utile pour l’interopérabilité entre le Microsoft .NET Framework et COM.</span><span class="sxs-lookup"><span data-stu-id="38bb4-281">It is primarily useful for interoperability between the Microsoft .NET Framework and COM.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-282">Obtient une valeur indiquant si le <see cref="T:System.Type" /> en cours inclut ou fait référence à un autre type, c'est-à-dire si le <see cref="T:System.Type" /> en cours est un tableau, un pointeur ou un ByRef.</span><span class="sxs-lookup"><span data-stu-id="38bb4-282">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer or a ByRef.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-283"><see langword="true" /> si <see cref="T:System.Type" /> est un tableau, un pointeur ou un ByRef ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-283"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer or a ByRef; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="38bb4-284">Nom du membre à appeler.</span><span class="sxs-lookup"><span data-stu-id="38bb4-284">The name of the member to invoke.</span></span> <span data-ttu-id="38bb4-285">Il peut s'agir d'un constructeur, d'une méthode, d'une propriété ou d'un champ.</span><span class="sxs-lookup"><span data-stu-id="38bb4-285">This may be a constructor, method, property, or field.</span></span> <span data-ttu-id="38bb4-286">Si vous passez une chaîne vide (""), le membre par défaut est appelé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-286">If an empty string ("") is passed, the default member is invoked.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="38bb4-287">Attribut d’appel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-287">The invocation attribute.</span></span> <span data-ttu-id="38bb4-288">Il doit s'agir de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-288">This must be one of the following <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span> <span data-ttu-id="38bb4-289">Un attribut d’appel approprié doit être spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-289">A suitable invocation attribute must be specified.</span></span> <span data-ttu-id="38bb4-290">Si le membre à appeler est statique, l'indicateur <see langword="Static" /> doit être défini.</span><span class="sxs-lookup"><span data-stu-id="38bb4-290">If a static member is to be invoked, the <see langword="Static" /> flag must be set.</span></span></param>
        <param name="binder"><span data-ttu-id="38bb4-291">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion.</span><span class="sxs-lookup"><span data-stu-id="38bb4-291">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="38bb4-292">Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-292">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="38bb4-293">Consultez <see cref="T:System.Reflection.Binder" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-293">See <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="target"><span data-ttu-id="38bb4-294">Objet sur lequel appeler le membre spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-294">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="38bb4-295">Tableau de type <see langword="Object" /> qui contient le nombre, l'ordre et le type des paramètres du membre à appeler.</span><span class="sxs-lookup"><span data-stu-id="38bb4-295">An array of type <see langword="Object" /> that contains the number, order, and type of the parameters of the member to be invoked.</span></span> <span data-ttu-id="38bb4-296">Si <c>args</c> contient un <see langword="Object" /> non initialisé, il est traité comme vide ce qui, avec le binder par défaut, peut être élargi à 0, 0.0 ou à une chaîne.</span><span class="sxs-lookup"><span data-stu-id="38bb4-296">If <c>args</c> contains an uninitialized <see langword="Object" />, it is treated as empty, which, with the default binder, can be widened to 0, 0.0 or a string.</span></span></param>
        <param name="modifiers"><span data-ttu-id="38bb4-297">Tableau de type <see langword="ParameterModifer" />, de la même longueur que <c>args</c>, avec des éléments qui représentent les attributs associés aux arguments du membre à appeler.</span><span class="sxs-lookup"><span data-stu-id="38bb4-297">An array of type <see langword="ParameterModifer" /> that is the same length as <c>args</c>, with elements that represent the attributes associated with the arguments of the member to be invoked.</span></span> <span data-ttu-id="38bb4-298">Un paramètre a des attributs associés à celui-ci dans la signature du membre.</span><span class="sxs-lookup"><span data-stu-id="38bb4-298">A parameter has attributes associated with it in the member's signature.</span></span> <span data-ttu-id="38bb4-299">Pour ByRef, utilisez <see langword="ParameterModifer.ByRef" /> ; pour n'en avoir aucun, utilisez <see langword="ParameterModifer.None" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-299">For ByRef, use <see langword="ParameterModifer.ByRef" />, and for none, use <see langword="ParameterModifer.None" />.</span></span> <span data-ttu-id="38bb4-300">Le binder par défaut recherche une correspondance exacte pour ceux-ci.</span><span class="sxs-lookup"><span data-stu-id="38bb4-300">The default binder does exact matching on these.</span></span> <span data-ttu-id="38bb4-301">Les attributs tels que <see langword="In" /> et <see langword="InOut" /> ne sont pas utilisés pour la liaison ; ils peuvent être visualisés à l'aide de <see langword="ParameterInfo" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-301">Attributes such as <see langword="In" /> and <see langword="InOut" /> are not used in binding, and can be viewed using <see langword="ParameterInfo" />.</span></span></param>
        <param name="culture"><span data-ttu-id="38bb4-302">Instance de <see langword="CultureInfo" /> utilisée pour régir la contrainte des types.</span><span class="sxs-lookup"><span data-stu-id="38bb4-302">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="38bb4-303">Par exemple, cela est nécessaire pour la conversion d'une chaîne représentant 1000 en une valeur <see langword="Double" />, car 1000 est représenté de différentes manières selon la culture.</span><span class="sxs-lookup"><span data-stu-id="38bb4-303">This is necessary, for example, to convert a string that represents 1000 to a <see langword="Double" /> value, since 1000 is represented differently by different cultures.</span></span> <span data-ttu-id="38bb4-304">Si <c>culture</c> a la valeur <see langword="null" />, le <see langword="CultureInfo" /> du <see langword="CultureInfo" /> du thread actuel est utilisé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-304">If <c>culture</c> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread's <see langword="CultureInfo" /> is used.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="38bb4-305">Tableau de type <see langword="String" /> contenant les noms de paramètres qui correspondent, à partir de l’élément 0, au tableau <c>args</c>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-305">An array of type <see langword="String" /> containing parameter names that match up, starting at element zero, with the <c>args</c> array.</span></span> <span data-ttu-id="38bb4-306">Le tableau ne doit pas contenir d'espaces.</span><span class="sxs-lookup"><span data-stu-id="38bb4-306">There must be no holes in the array.</span></span> <span data-ttu-id="38bb4-307">Si <c>args</c>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-307">If <c>args</c>.</span></span> <span data-ttu-id="38bb4-308"><see langword="Length" /> est supérieur à <c>namedParameters</c>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-308"><see langword="Length" /> is greater than <c>namedParameters</c>.</span></span> <span data-ttu-id="38bb4-309"><see langword="Length" />, les paramètres restants sont remplis dans l'ordre.</span><span class="sxs-lookup"><span data-stu-id="38bb4-309"><see langword="Length" />, the remaining parameters are filled in order.</span></span></param>
        <summary><span data-ttu-id="38bb4-310">Appelle le membre spécifié.</span><span class="sxs-lookup"><span data-stu-id="38bb4-310">Invokes the specified member.</span></span> <span data-ttu-id="38bb4-311">La méthode à appeler doit être accessible et fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée, sous les contraintes des attributs de binder et d’appel spécifiés.</span><span class="sxs-lookup"><span data-stu-id="38bb4-311">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span></span></summary>
        <returns><span data-ttu-id="38bb4-312"><see langword="Object" /> représentant la valeur de retour du membre appelé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-312">An <see langword="Object" /> representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-313">Une méthode est appelée si les deux conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="38bb4-313">A method will be invoked if both the following conditions are true:</span></span>  
  
-   <span data-ttu-id="38bb4-314">Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans la liste d’arguments spécifiée (sauf si les arguments par défaut sont définis sur le membre).</span><span class="sxs-lookup"><span data-stu-id="38bb4-314">The number of parameters in the method declaration equals the number of arguments in the specified argument list (unless default arguments are defined on the member).</span></span>  
  
-   <span data-ttu-id="38bb4-315">Le type de chaque argument peut être converti par le binder pour le type du paramètre.</span><span class="sxs-lookup"><span data-stu-id="38bb4-315">The type of each arguments can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="38bb4-316">Le binder va trouver toutes les méthodes correspondantes.</span><span class="sxs-lookup"><span data-stu-id="38bb4-316">The binder will find all the matching methods.</span></span> <span data-ttu-id="38bb4-317">Ces méthodes sont recherchées en fonction du type de liaison demandé (`BindingFlags.MethodInvoke`, `BindingFlags.GetProperties`, et ainsi de suite).</span><span class="sxs-lookup"><span data-stu-id="38bb4-317">These methods are found based upon the type of binding requested (`BindingFlags.MethodInvoke`, `BindingFlags.GetProperties`, and so on).</span></span> <span data-ttu-id="38bb4-318">L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur.</span><span class="sxs-lookup"><span data-stu-id="38bb4-318">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="38bb4-319">Une fois que la méthode est sélectionnée, elle sera appelée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-319">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="38bb4-320">Accessibilité est vérifiée à ce stade.</span><span class="sxs-lookup"><span data-stu-id="38bb4-320">Accessibility is checked at that point.</span></span> <span data-ttu-id="38bb4-321">La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode.</span><span class="sxs-lookup"><span data-stu-id="38bb4-321">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="38bb4-322">Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode est chargée de sélectionner la méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="38bb4-322">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="38bb4-323">Le binder par défaut sélectionne la correspondance la plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="38bb4-323">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="38bb4-324">Restrictions d’accès sont ignorées pour le code de confiance totale.</span><span class="sxs-lookup"><span data-stu-id="38bb4-324">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="38bb4-325">Autrement dit, propriétés, méthodes, champs et constructeurs privés sont accessibles et appelé à l’aide de la réflexion lorsque le code est entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="38bb4-325">That is, private constructors, methods, fields, and properties can be accessed and invoked using reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="38bb4-326">Actuellement, `InvokeMember` effectue la sémantique de réflexion Microsoft .NET Framework pour chaque type d’objet.</span><span class="sxs-lookup"><span data-stu-id="38bb4-326">Currently, `InvokeMember` performs the Microsoft .NET Framework reflection semantics for every type of object.</span></span>  
  
 <span data-ttu-id="38bb4-327">Si le membre spécifié par le nom est un tableau et le `BindingFlags.GetField` indicateur est défini sur `invokeAttr`, le `args` tableau spécifie les éléments dont les valeurs doivent être retournées.</span><span class="sxs-lookup"><span data-stu-id="38bb4-327">If the member specified by name is an array and the `BindingFlags.GetField` flag is set on `invokeAttr`, the `args` array specifies the elements whose values are to be returned.</span></span> <span data-ttu-id="38bb4-328">Par exemple, l’appel suivant via `Type` objet `t` retourne la valeur du premier élément du tableau de chaînes MyArray, qui est un membre de l’objet appelant :</span><span class="sxs-lookup"><span data-stu-id="38bb4-328">For example, the following call through `Type` object `t` returns the value of the first element of the string array MyArray, which is a member of the calling object:</span></span>  
  
 `String ret = (String) t.InvokeMember ("MyArray", BindingFlags.GetField, null, this, new Variant[]{0});`  
  
 <span data-ttu-id="38bb4-329">Vous pouvez utiliser `InvokeMember` pour définir un ou plusieurs éléments d’un tableau de membres.</span><span class="sxs-lookup"><span data-stu-id="38bb4-329">You can use `InvokeMember` to set one or more elements of a member array.</span></span> <span data-ttu-id="38bb4-330">Tous les éléments sont définies sur la même valeur.</span><span class="sxs-lookup"><span data-stu-id="38bb4-330">All elements are set to the same value.</span></span> <span data-ttu-id="38bb4-331">Le `args` tableau doit être formaté comme suit :</span><span class="sxs-lookup"><span data-stu-id="38bb4-331">The `args` array must be formatted as follows:</span></span>  
  
```  
{index1,  
    index2,, value}  
```  
  
 <span data-ttu-id="38bb4-332">Par exemple, pour définir le premier membre de MyArray de l’exemple précédent, la syntaxe est la suivante :</span><span class="sxs-lookup"><span data-stu-id="38bb4-332">For example, to set the first member of MyArray from the previous example, the syntax is as follows:</span></span>  
  
```csharp  
t.InvokeMember ("MyArray", BindingFlags.SetField, null, this, new  
    Variant[]{0,"Updated"});  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-333">Retourne une valeur qui indique si l'objet <see cref="T:System.Type" /> est un tableau.</span><span class="sxs-lookup"><span data-stu-id="38bb4-333">Returns a value that indicates whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-334"><see langword="true" /> si <see cref="T:System.Type" /> est un tableau ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-334"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo"><span data-ttu-id="38bb4-335">Type à vérifier.</span><span class="sxs-lookup"><span data-stu-id="38bb4-335">The type to check.</span></span></param>
        <summary><span data-ttu-id="38bb4-336">Retourne une valeur qui indique si le type spécifié peut être affecté à ce type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-336">Returns a value that indicates whether the specified type can be assigned to this type.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-337"><see langword="true" /> si le type spécifié peut être assigné à ce type ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-337"><see langword="true" /> if the specified type can be assigned to this type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-338">Retourne une valeur qui indique si le <see cref="T:System.Type" /> est passé par référence.</span><span class="sxs-lookup"><span data-stu-id="38bb4-338">Returns a value that indicates whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-339"><see langword="true" /> si <see cref="T:System.Type" /> est passé par référence ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-339"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-340">Retourne une valeur qui indique si le <see cref="T:System.Type" /> est un objet COM.</span><span class="sxs-lookup"><span data-stu-id="38bb4-340">Returns a value that indicates whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-341"><see langword="true" /> si <see cref="T:System.Type" /> est un objet COM ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-341"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-342">Obtient une valeur qui indique si cet objet représente un type générique construit.</span><span class="sxs-lookup"><span data-stu-id="38bb4-342">Gets a value that indicates whether this object represents a constructed generic type.</span></span></summary>
        <value>
          <span data-ttu-id="38bb4-343"><see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-343"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="38bb4-344">Spécifie s'il faut rechercher les attributs dans la chaîne d'héritage de ce type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-344">Specifies whether to search this type's inheritance chain to find the attributes.</span></span></param>
        <param name="inherit"><span data-ttu-id="38bb4-345">Tableau d'attributs personnalisés identifiés par type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-345">An array of custom attributes identified by type.</span></span></param>
        <summary><span data-ttu-id="38bb4-346">Indique si un attribut personnalisé identifié par <paramref name="attributeType" /> est défini.</span><span class="sxs-lookup"><span data-stu-id="38bb4-346">Indicates whether a custom attribute identified by <paramref name="attributeType" /> is defined.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-347"><see langword="true" /> si un attribut personnalisé identifié par <paramref name="attributeType" /> est défini ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-347"><see langword="true" /> if a custom attribute identified by <paramref name="attributeType" /> is defined; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="38bb4-348"><paramref name="attributeType" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-348"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="38bb4-349">Le type d’attribut personnalisé ne peut pas être chargé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-349">The custom attribute type cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-350">Retourne une valeur qui indique si le <see cref="T:System.Type" /> est un pointeur.</span><span class="sxs-lookup"><span data-stu-id="38bb4-350">Returns a value that indicates whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-351"><see langword="true" /> si <see cref="T:System.Type" /> est un pointeur ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-351"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-352">Retourne une valeur qui indique si le <see cref="T:System.Type" /> est l'un des types primitifs.</span><span class="sxs-lookup"><span data-stu-id="38bb4-352">Returns a value that indicates whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-353"><see langword="true" /> si <see cref="T:System.Type" /> est l'un des types primitifs ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-353"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38bb4-354">Retourne une valeur qui indique si le type est un type valeur, autrement dit, il n'est ni une classe ni une interface.</span><span class="sxs-lookup"><span data-stu-id="38bb4-354">Returns a value that indicates whether the type is a value type; that is, not a class or an interface.</span></span></summary>
        <returns>
          <span data-ttu-id="38bb4-355"><see langword="true" /> si le type est un type valeur ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-355"><see langword="true" /> if the type is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-356">Obtient une valeur qui identifie cette entité dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="38bb4-356">Gets a value that identifies this entity in metadata.</span></span></summary>
        <value><span data-ttu-id="38bb4-357">Valeur qui, en association avec le module, identifie de manière unique cette entité dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="38bb4-357">A value which, in combination with the module, uniquely identifies this entity in metadata.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-358">Les jetons obtenus à l’aide de cette propriété peuvent être passés à l’API de réflexion non managée.</span><span class="sxs-lookup"><span data-stu-id="38bb4-358">The tokens obtained using this property can be passed to the unmanaged reflection API.</span></span> <span data-ttu-id="38bb4-359">Pour plus d’informations, consultez [API de réflexion non managée](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span><span class="sxs-lookup"><span data-stu-id="38bb4-359">For more information, see [Unmanaged Reflection API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-360">Obtient le module contenant le type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-360">Gets the module that contains the implemented type.</span></span></summary>
        <value><span data-ttu-id="38bb4-361">Objet <see cref="T:System.Reflection.Module" /> qui représente le module du type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-361">A <see cref="T:System.Reflection.Module" /> object representing the module of the implemented type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-362">Un module est une unité chargeable qui peut contenir les déclarations de type et leurs implémentations.</span><span class="sxs-lookup"><span data-stu-id="38bb4-362">A module is a loadable unit that can contain type declarations and implementations.</span></span> <span data-ttu-id="38bb4-363">Les modules contiennent suffisamment d’informations pour activer le common language runtime localiser tous les bits de la mise en œuvre lorsque le module est chargé.</span><span class="sxs-lookup"><span data-stu-id="38bb4-363">Modules contain enough information to enable the common language runtime to locate all implementation bits when the module is loaded.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-364">Obtient le nom du type implémenté, sans le chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="38bb4-364">Gets the name of the implemented type, with the path removed.</span></span></summary>
        <value><span data-ttu-id="38bb4-365"><see langword="String" /> contenant le nom non complet du type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-365">A <see langword="String" /> containing the type's non-qualified name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-366">Chaîne contenant le nom de l'élément `TypeDelegator` actuel.</span><span class="sxs-lookup"><span data-stu-id="38bb4-366">A string containing the name of the current `TypeDelegator`.</span></span> <span data-ttu-id="38bb4-367">Seul le nom simple, et pas le nom qualifié complet, est retourné.</span><span class="sxs-lookup"><span data-stu-id="38bb4-367">Only the simple name, not the fully qualified name, is returned.</span></span> <span data-ttu-id="38bb4-368">Pour obtenir le nom et le chemin d’accès, utilisez <xref:System.Reflection.TypeDelegator.FullName%2A>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-368">To get the name and the path, use <xref:System.Reflection.TypeDelegator.FullName%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-369">Obtient l'espace de noms du type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-369">Gets the namespace of the implemented type.</span></span></summary>
        <value><span data-ttu-id="38bb4-370"><see langword="String" /> contenant l'espace de noms du type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-370">A <see langword="String" /> containing the type's namespace.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-371">Cette propriété obtient une chaîne contenant l’espace de noms d’actuel `TypeDelegator`.</span><span class="sxs-lookup"><span data-stu-id="38bb4-371">This property gets a string containing the namespace of the current `TypeDelegator`.</span></span> <span data-ttu-id="38bb4-372">Par exemple, si le `TypeDelegator` est <xref:System.Reflection.TypeFilter>, l’espace de noms retourné est <xref:System.Reflection>.</span><span class="sxs-lookup"><span data-stu-id="38bb4-372">For example, if the `TypeDelegator` is <xref:System.Reflection.TypeFilter>, the returned namespace is <xref:System.Reflection>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-373">Obtient un handle vers la représentation interne des métadonnées d'un type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-373">Gets a handle to the internal metadata representation of an implemented type.</span></span></summary>
        <value><span data-ttu-id="38bb4-374">Objet <see langword="RuntimeTypeHandle" />.</span><span class="sxs-lookup"><span data-stu-id="38bb4-374">A <see langword="RuntimeTypeHandle" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38bb4-375">Un descripteur de type est une valeur d’entier unique associée à chaque type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-375">A type handle is a unique integer value associated with each type.</span></span> <span data-ttu-id="38bb4-376">Le handle est unique au cours de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="38bb4-376">The handle is unique during the runtime.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.RuntimeTypeHandle" />
      </Docs>
    </Member>
    <Member MemberName="typeImpl">
      <MemberSignature Language="C#" Value="protected Type typeImpl;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Type typeImpl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.TypeDelegator.typeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected typeImpl As Type " />
      <MemberSignature Language="C++ CLI" Value="protected: Type ^ typeImpl;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-377">Valeur indiquant des informations sur le type.</span><span class="sxs-lookup"><span data-stu-id="38bb4-377">A value indicating type information.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38bb4-378">Obtient le <see cref="T:System.Type" /> sous-jacent qui représente le type implémenté.</span><span class="sxs-lookup"><span data-stu-id="38bb4-378">Gets the underlying <see cref="T:System.Type" /> that represents the implemented type.</span></span></summary>
        <value><span data-ttu-id="38bb4-379">Type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="38bb4-379">The underlying type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>