<Type Name="Module" FullName="System.Reflection.Module">
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3951e-101">Effectue une réflexion sur un module.</span><span class="sxs-lookup"><span data-stu-id="3951e-101">Performs reflection on a module.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-102">Un module est un fichier exécutable portable, telles que le type.dll ou application.exe, comprenant une ou plusieurs classes et interfaces.</span><span class="sxs-lookup"><span data-stu-id="3951e-102">A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</span></span> <span data-ttu-id="3951e-103">Un module peut contenir plusieurs espaces de noms et un espace de noms peut s'étendre sur plusieurs modules.</span><span class="sxs-lookup"><span data-stu-id="3951e-103">There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</span></span>  
  
 <span data-ttu-id="3951e-104">Un ou plusieurs modules déployés en tant qu'unité composent un assembly.</span><span class="sxs-lookup"><span data-stu-id="3951e-104">One or more modules deployed as a unit compose an assembly.</span></span> <span data-ttu-id="3951e-105">Pour plus d’informations sur la création d’un assembly avec plusieurs modules, consultez [multifichier assemblys](~/docs/framework/app-domains/multifile-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="3951e-105">For information about creating an assembly with more than one module, see [Multifile Assemblies](~/docs/framework/app-domains/multifile-assemblies.md).</span></span>  
  
 <span data-ttu-id="3951e-106">Notez qu’un module .NET Framework n’est pas identique à un module dans Visual Basic, qui est utilisé par un programmeur pour organiser des fonctions et des sous-routines dans une application.</span><span class="sxs-lookup"><span data-stu-id="3951e-106">Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-107">Les exemples de code suivants montrent comment utiliser la réflexion pour obtenir des informations sur les modules :</span><span class="sxs-lookup"><span data-stu-id="3951e-107">The following code examples show how to use reflection to get information about modules:</span></span>  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="3951e-108">pour la confiance totale pour les héritiers de.</span><span class="sxs-lookup"><span data-stu-id="3951e-108">for full trust for inheritors.</span></span> <span data-ttu-id="3951e-109">Cette classe ne peut pas être héritée par du code partiellement fiable.</span><span class="sxs-lookup"><span data-stu-id="3951e-109">This class cannot be inherited by partially trusted code.</span></span></permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-110">Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Module" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-110">Initializes a new instance of the <see cref="T:System.Reflection.Module" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-111">Ce constructeur est appelé par les classes dérivées lors de la construction de <xref:System.Reflection.Module> objets.</span><span class="sxs-lookup"><span data-stu-id="3951e-111">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Module> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-112">Obtient le <see cref="T:System.Reflection.Assembly" /> approprié pour cette instance de <see cref="T:System.Reflection.Module" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-112">Gets the appropriate <see cref="T:System.Reflection.Assembly" /> for this instance of <see cref="T:System.Reflection.Module" />.</span></span></summary>
        <value><span data-ttu-id="3951e-113">Objet <see langword="Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-113">An <see langword="Assembly" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3951e-114">L’exemple suivant affiche le nom complet de l’assembly spécifié dans le module spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-114">The following example displays the full name of the specified assembly in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-115">Obtient une collection qui contient les attributs personnalisés de ce module.</span><span class="sxs-lookup"><span data-stu-id="3951e-115">Gets a collection that contains this module's custom attributes.</span></span></summary>
        <value><span data-ttu-id="3951e-116">Collection qui contient les attributs personnalisés de ce module.</span><span class="sxs-lookup"><span data-stu-id="3951e-116">A collection that contains this module's custom attributes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="3951e-117">Objet à comparer avec cette instance.</span><span class="sxs-lookup"><span data-stu-id="3951e-117">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="3951e-118">Détermine si ce module et l'objet spécifié sont égaux.</span><span class="sxs-lookup"><span data-stu-id="3951e-118">Determines whether this module and the specified object are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="3951e-119"><see langword="true" /> si <paramref name="o" /> est égal à cette instance ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-119"><see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-120">Objet <see langword="TypeFilter" /> qui permet de filtrer la liste des types définis dans ce module en fonction du nom.</span><span class="sxs-lookup"><span data-stu-id="3951e-120">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span></span> <span data-ttu-id="3951e-121">Ce champ est en lecture seule et respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="3951e-121">This field is case-sensitive and read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-122">Le filtre prend en charge un caractère « \* » générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-122">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-123">L’exemple suivant affiche les noms de module qui correspondent aux critères de recherche spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-123">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-124">Objet <see langword="TypeFilter" /> qui permet de filtrer la liste des types définis dans ce module en fonction du nom.</span><span class="sxs-lookup"><span data-stu-id="3951e-124">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span></span> <span data-ttu-id="3951e-125">Ce champ est en lecture seule et ne respecte pas la casse.</span><span class="sxs-lookup"><span data-stu-id="3951e-125">This field is case-insensitive and read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-126">Le filtre prend en charge un caractère « \* » générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-126">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-127">L’exemple suivant affiche les noms de module qui correspondent aux critères de recherche spécifiés, en ignorant la casse.</span><span class="sxs-lookup"><span data-stu-id="3951e-127">The following example displays the module names that match the specified search criteria, ignoring the case.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="3951e-128">Le délégué utilisé pour filtrer les classes.</span><span class="sxs-lookup"><span data-stu-id="3951e-128">The delegate used to filter the classes.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="3951e-129">Un objet utilisé pour filtrer les classes.</span><span class="sxs-lookup"><span data-stu-id="3951e-129">An Object used to filter the classes.</span></span></param>
        <summary><span data-ttu-id="3951e-130">Retourne un tableau de classes acceptées par le filtre donné et les critères de filtre.</span><span class="sxs-lookup"><span data-stu-id="3951e-130">Returns an array of classes accepted by the given filter and filter criteria.</span></span></summary>
        <returns><span data-ttu-id="3951e-131">Un tableau de type <see langword="Type" /> contenant les classes qui ont été acceptées par le filtre.</span><span class="sxs-lookup"><span data-stu-id="3951e-131">An array of type <see langword="Type" /> containing classes that were accepted by the filter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-132"><xref:System.Reflection.ReflectionTypeLoadException> est une exception de chargement de classe spéciale.</span><span class="sxs-lookup"><span data-stu-id="3951e-132"><xref:System.Reflection.ReflectionTypeLoadException> is a special class load exception.</span></span> <span data-ttu-id="3951e-133">Le `ReflectionTypeLoadException.Types` propriété contient le tableau des classes qui ont été définies dans le module et chargées.</span><span class="sxs-lookup"><span data-stu-id="3951e-133">The `ReflectionTypeLoadException.Types` property contains the array of classes that were defined in the module and were loaded.</span></span> <span data-ttu-id="3951e-134">Ce tableau peut contenir des valeurs null.</span><span class="sxs-lookup"><span data-stu-id="3951e-134">This array may contain some null values.</span></span> <span data-ttu-id="3951e-135">Le `ReflectionTypeLoadException.LoaderExceptions` propriété est un tableau d’exceptions qui représentent les exceptions levées par le chargeur de classes.</span><span class="sxs-lookup"><span data-stu-id="3951e-135">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the class loader.</span></span> <span data-ttu-id="3951e-136">Les trous dans le tableau de classe s’aligner avec les exceptions.</span><span class="sxs-lookup"><span data-stu-id="3951e-136">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="3951e-137">Le délégué donné par `filter` est appelée pour chaque classe dans le module, en passant le `Type` objet qui représente la classe, ainsi que les donné `filterCriteria`.</span><span class="sxs-lookup"><span data-stu-id="3951e-137">The delegate given by `filter` is called for each class in the module, passing along the `Type` object representing the class as well as the given `filterCriteria`.</span></span> <span data-ttu-id="3951e-138">Si `filter` retourne tant que classe est incluse dans le tableau retourné de la classe.</span><span class="sxs-lookup"><span data-stu-id="3951e-138">If `filter` returns a particular class, that class will be included in the returned array.</span></span> <span data-ttu-id="3951e-139">Si `filter` retourne `null`, toutes les classes sont retournées et `filterCriteria` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="3951e-139">If `filter` returns `null`, all classes are returned and `filterCriteria` is ignored.</span></span>  
  
 <span data-ttu-id="3951e-140">`FindTypes` ne peut pas être utilisé pour rechercher des types paramétrés tels que les tableaux.</span><span class="sxs-lookup"><span data-stu-id="3951e-140">`FindTypes` cannot be used to look up parameterized types such as arrays.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-141">L’exemple suivant illustre la `FindTypes` (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-141">The following example demonstrates the `FindTypes` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="3951e-142">Au moins une des classes d’un module n’a pas pu être chargée.</span><span class="sxs-lookup"><span data-stu-id="3951e-142">One or more classes in a module could not be loaded.</span></span></exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-143">Obtient une chaîne représentant le nom qualifié complet et le chemin d'accès de ce module.</span><span class="sxs-lookup"><span data-stu-id="3951e-143">Gets a string representing the fully qualified name and path to this module.</span></span></summary>
        <value><span data-ttu-id="3951e-144">Nom qualifié complet du module.</span><span class="sxs-lookup"><span data-stu-id="3951e-144">The fully qualified module name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-145">Pour obtenir le nom sans le chemin d’accès, utilisez <xref:System.Reflection.Module.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="3951e-145">To get the name without the path, use <xref:System.Reflection.Module.Name%2A>.</span></span>  
  
 <span data-ttu-id="3951e-146">Si l’assembly de ce module a été chargé à partir d’un tableau d’octets le `FullyQualifiedName` pour le module sera : \<inconnu >.</span><span class="sxs-lookup"><span data-stu-id="3951e-146">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-147">La casse du nom de module est dépendante de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="3951e-147">The case of module name is platform-dependent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-148">L’exemple suivant affiche le nom qualifié complet du module spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-148">The following example displays the fully qualified name of the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3951e-149">L’appelant n’a pas les autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="3951e-149">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="3951e-150">Pour accéder aux informations contenues dans le chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="3951e-150">for access to information in the path.</span></span> <span data-ttu-id="3951e-151">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-151">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-152">Retourne les attributs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="3951e-152">Returns custom attributes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="3951e-153">Cet argument est ignoré pour les objets de ce type.</span><span class="sxs-lookup"><span data-stu-id="3951e-153">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="3951e-154">Retourne tous les attributs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="3951e-154">Returns all custom attributes.</span></span></summary>
        <returns><span data-ttu-id="3951e-155">Tableau de type <see langword="Object" /> contenant tous les attributs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="3951e-155">An array of type <see langword="Object" /> containing all custom attributes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3951e-156">L’exemple suivant affiche les noms de module qui correspondent aux critères de recherche spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-156">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="3951e-157">Type de l'attribut à obtenir.</span><span class="sxs-lookup"><span data-stu-id="3951e-157">The type of attribute to get.</span></span></param>
        <param name="inherit"><span data-ttu-id="3951e-158">Cet argument est ignoré pour les objets de ce type.</span><span class="sxs-lookup"><span data-stu-id="3951e-158">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="3951e-159">Obtient les attributs personnalisés du type spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-159">Gets custom attributes of the specified type.</span></span></summary>
        <returns><span data-ttu-id="3951e-160">Tableau de type <see langword="Object" /> contenant tous les attributs personnalisés du type spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-160">An array of type <see langword="Object" /> containing all custom attributes of the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3951e-161">L’exemple suivant affiche les noms de module du type spécifié qui correspondent aux critères de recherche spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-161">The following example displays the module names of the specified type that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-162"><paramref name="attributeType" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-162"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-163"><paramref name="attributeType" /> n'est pas un objet <see cref="T:System.Type" /> fourni par le runtime.</span><span class="sxs-lookup"><span data-stu-id="3951e-163"><paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span></span> <span data-ttu-id="3951e-164">Par exemple, <paramref name="attributeType" /> est un objet <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-164">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-165">Retourne une liste d'objets <see cref="T:System.Reflection.CustomAttributeData" /> pour le module actuel, qui peuvent être utilisés dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="3951e-165">Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects for the current module, which can be used in the reflection-only context.</span></span></summary>
        <returns><span data-ttu-id="3951e-166">Liste générique d'objets <see cref="T:System.Reflection.CustomAttributeData" /> représentant des données relatives aux attributs qui ont été appliqués au module actif.</span><span class="sxs-lookup"><span data-stu-id="3951e-166">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-167">Utilisez cette méthode pour examiner les attributs personnalisés du code dans le contexte de réflexion uniquement, dans les cas où les attributs personnalisés eux-mêmes sont définis dans le code qui est chargé dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="3951e-167">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="3951e-168">Les méthodes telles que <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> et <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> ne peut pas être utilisé dans ce cas, parce qu’elles créent des instances des attributs.</span><span class="sxs-lookup"><span data-stu-id="3951e-168">Methods such as <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="3951e-169">Impossible d’exécuter le code dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="3951e-169">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="3951e-170">Pour plus d’informations et des exemples de code, consultez la <xref:System.Reflection.CustomAttributeData> classe.</span><span class="sxs-lookup"><span data-stu-id="3951e-170">For more information and example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-171">Retourne un champ spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-171">Returns a specified field.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3951e-172">Nom du champ.</span><span class="sxs-lookup"><span data-stu-id="3951e-172">The field name.</span></span></param>
        <summary><span data-ttu-id="3951e-173">Retourne un champ portant le nom spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-173">Returns a field having the specified name.</span></span></summary>
        <returns><span data-ttu-id="3951e-174">Objet <see langword="FieldInfo" /> portant le nom spécifié, ou <see langword="null" /> si le champ n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="3951e-174">A <see langword="FieldInfo" /> object having the specified name, or <see langword="null" /> if the field does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3951e-175">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-175">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3951e-176">Nom du champ.</span><span class="sxs-lookup"><span data-stu-id="3951e-176">The field name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="3951e-177">Un des indicateurs à un bit <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</span><span class="sxs-lookup"><span data-stu-id="3951e-177">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <summary><span data-ttu-id="3951e-178">Retourne un champ portant le nom et les attributs de liaison spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-178">Returns a field having the specified name and binding attributes.</span></span></summary>
        <returns><span data-ttu-id="3951e-179">Objet <see langword="FieldInfo" /> portant le nom et les attributs de liaison spécifiés, ou <see langword="null" /> si le champ n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="3951e-179">A <see langword="FieldInfo" /> object having the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3951e-180">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-180">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-181">Retourne les champs globaux définis sur le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-181">Returns the global fields defined on the module.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-182">Retourne les champs globaux définis sur le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-182">Returns the global fields defined on the module.</span></span></summary>
        <returns><span data-ttu-id="3951e-183">Un tableau d’objets <see cref="T:System.Reflection.FieldInfo" /> représentant les champs globaux définis sur le module ; s’il n’y a aucun champ global, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="3951e-183">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-184">Le <xref:System.Reflection.Module.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="3951e-184">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="3951e-185">Votre code ne doit pas dépendent de l’ordre dans lequel les champs sont retournés, car cet ordre peut varier.</span><span class="sxs-lookup"><span data-stu-id="3951e-185">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags"><span data-ttu-id="3951e-186">Combinaison de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limitent la recherche.</span><span class="sxs-lookup"><span data-stu-id="3951e-186">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span></span></param>
        <summary><span data-ttu-id="3951e-187">Retourne les champs globaux définis sur le module, qui correspondent aux indicateurs de liaison spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-187">Returns the global fields defined on the module that match the specified binding flags.</span></span></summary>
        <returns><span data-ttu-id="3951e-188">Tableau de type <see cref="T:System.Reflection.FieldInfo" /> représentant les champs globaux définis sur le module, qui correspondent aux indicateurs de liaison spécifiés. Si aucun champ global ne correspond aux indicateurs de liaison, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="3951e-188">An array of type <see cref="T:System.Reflection.FieldInfo" /> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-189">Le <xref:System.Reflection.Module.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="3951e-189">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="3951e-190">Votre code ne doit pas dépendent de l’ordre dans lequel les champs sont retournés, car cet ordre peut varier.</span><span class="sxs-lookup"><span data-stu-id="3951e-190">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-191">Retourne le code de hachage de cette instance.</span><span class="sxs-lookup"><span data-stu-id="3951e-191">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="3951e-192">Code de hachage d'un entier signé 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3951e-192">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-193">Retourne une méthode ayant les critères spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-193">Returns a method having the specified criteria.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3951e-194">Nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-194">The method name.</span></span></param>
        <summary><span data-ttu-id="3951e-195">Retourne une méthode portant le nom spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-195">Returns a method having the specified name.</span></span></summary>
        <returns><span data-ttu-id="3951e-196">Objet <see langword="MethodInfo" /> portant le nom spécifié, ou <see langword="null" /> si la méthode n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="3951e-196">A <see langword="MethodInfo" /> object having the specified name, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-197"><paramref name="name" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-197"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3951e-198">Nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-198">The method name.</span></span></param>
        <param name="types"><span data-ttu-id="3951e-199">Types de paramètre à rechercher.</span><span class="sxs-lookup"><span data-stu-id="3951e-199">The parameter types to search for.</span></span></param>
        <summary><span data-ttu-id="3951e-200">Retourne une méthode avec les types de paramètre et de nom spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-200">Returns a method having the specified name and parameter types.</span></span></summary>
        <returns><span data-ttu-id="3951e-201">Objet <see langword="MethodInfo" /> conforme aux critères spécifiés ou <see langword="null" /> si la méthode n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="3951e-201">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-202"><paramref name="name" /> a la valeur <see langword="null" />, <paramref name="types" /> a la valeur <see langword="null" /> ou <paramref name="types" /> (i) a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-202"><paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3951e-203">Nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-203">The method name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="3951e-204">Un des indicateurs à un bit <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</span><span class="sxs-lookup"><span data-stu-id="3951e-204">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <param name="binder"><span data-ttu-id="3951e-205">Objet qui implémente <see langword="Binder" />, contenant les propriétés associées à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-205">An object that implements <see langword="Binder" />, containing properties related to this method.</span></span></param>
        <param name="callConvention"><span data-ttu-id="3951e-206">Convention d’appel de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-206">The calling convention for the method.</span></span></param>
        <param name="types"><span data-ttu-id="3951e-207">Types de paramètre à rechercher.</span><span class="sxs-lookup"><span data-stu-id="3951e-207">The parameter types to search for.</span></span></param>
        <param name="modifiers"><span data-ttu-id="3951e-208">Tableau de modificateurs de paramètres utilisé pour que la liaison fonctionne avec des signatures de paramètres dans lesquelles les types ont été modifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-208">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span></span></param>
        <summary><span data-ttu-id="3951e-209">Retourne une méthode avec le nom, les informations de liaison, la convention d’appel ainsi que les types et modificateurs de paramètres spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-209">Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="3951e-210">Objet <see langword="MethodInfo" /> conforme aux critères spécifiés ou <see langword="null" /> si la méthode n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="3951e-210">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-211"><paramref name="name" /> a la valeur <see langword="null" />, <paramref name="types" /> a la valeur <see langword="null" /> ou <paramref name="types" /> (i) a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-211"><paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3951e-212">Nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-212">The method name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="3951e-213">Un des indicateurs à un bit <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</span><span class="sxs-lookup"><span data-stu-id="3951e-213">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <param name="binder"><span data-ttu-id="3951e-214">Objet qui implémente <see langword="Binder" />, contenant les propriétés associées à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-214">An object that implements <see langword="Binder" />, containing properties related to this method.</span></span></param>
        <param name="callConvention"><span data-ttu-id="3951e-215">Convention d’appel de la méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-215">The calling convention for the method.</span></span></param>
        <param name="types"><span data-ttu-id="3951e-216">Types de paramètre à rechercher.</span><span class="sxs-lookup"><span data-stu-id="3951e-216">The parameter types to search for.</span></span></param>
        <param name="modifiers"><span data-ttu-id="3951e-217">Tableau de modificateurs de paramètres utilisé pour que la liaison fonctionne avec des signatures de paramètres dans lesquelles les types ont été modifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-217">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span></span></param>
        <summary><span data-ttu-id="3951e-218">Retourne l'implémentation de méthode, conformément aux critères spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-218">Returns the method implementation in accordance with the specified criteria.</span></span></summary>
        <returns><span data-ttu-id="3951e-219">Objet <see langword="MethodInfo" /> contenant les informations relatives à l'implémentation, comme spécifié, ou <see langword="null" /> si la méthode n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="3951e-219">A <see langword="MethodInfo" /> object containing implementation information as specified, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="3951e-220"><paramref name="types" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-220"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-221">Retourne les méthodes globales définies sur le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-221">Returns the global methods defined on the module</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-222">Retourne les méthodes globales définies sur le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-222">Returns the global methods defined on the module.</span></span></summary>
        <returns><span data-ttu-id="3951e-223">Tableau d’objets <see cref="T:System.Reflection.MethodInfo" /> représentant toutes les méthodes globales définies sur le module ; s’il n’y a aucune méthode globale, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="3951e-223">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags"><span data-ttu-id="3951e-224">Combinaison de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limitent la recherche.</span><span class="sxs-lookup"><span data-stu-id="3951e-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span></span></param>
        <summary><span data-ttu-id="3951e-225">Retourne les méthodes globales, définies sur le module, qui correspondent aux indicateurs de liaison spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-225">Returns the global methods defined on the module that match the specified binding flags.</span></span></summary>
        <returns><span data-ttu-id="3951e-226">Tableau de type <see cref="T:System.Reflection.MethodInfo" /> représentant les méthodes globales, définies sur le module, qui correspondent aux indicateurs de liaison spécifiés ; si aucune méthode globale ne correspond aux indicateurs de liaison, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="3951e-226">An array of type <see cref="T:System.Reflection.MethodInfo" /> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="3951e-227">Informations et données nécessaires pour la sérialisation et la désérialisation d'un objet.</span><span class="sxs-lookup"><span data-stu-id="3951e-227">The information and data needed to serialize or deserialize an object.</span></span></param>
        <param name="context"><span data-ttu-id="3951e-228">Contexte pour la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="3951e-228">The context for the serialization.</span></span></param>
        <summary><span data-ttu-id="3951e-229">Fournit une implémentation de <see cref="T:System.Runtime.Serialization.ISerializable" /> pour les objets sérialisés.</span><span class="sxs-lookup"><span data-stu-id="3951e-229">Provides an <see cref="T:System.Runtime.Serialization.ISerializable" /> implementation for serialized objects.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-230"><paramref name="info" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-230"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3951e-231">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="3951e-231">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="3951e-232">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="3951e-232">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind"><span data-ttu-id="3951e-233">Cette méthode retourne une combinaison des valeurs <see cref="T:System.Reflection.PortableExecutableKinds" /> indiquant la nature du code dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-233">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</span></span></param>
        <param name="machine"><span data-ttu-id="3951e-234">Cette méthode retourne une des valeurs <see cref="T:System.Reflection.ImageFileMachine" /> indiquant la plateforme ciblée par le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-234">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</span></span></param>
        <summary><span data-ttu-id="3951e-235">Obtient une paire de valeurs indiquant la nature du code dans un module et la plateforme ciblée par le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-235">Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-236">Retourne un objet <see langword="X509Certificate" /> correspondant au certificat inclus dans la signature Authenticode de l'assembly auquel appartient ce module.</span><span class="sxs-lookup"><span data-stu-id="3951e-236">Returns an <see langword="X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</span></span> <span data-ttu-id="3951e-237">Si l'assembly n'est pas signé avec Authenticode, <see langword="null" /> est retournée.</span><span class="sxs-lookup"><span data-stu-id="3951e-237">If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</span></span></summary>
        <returns><span data-ttu-id="3951e-238">Un objet <see langword="X509Certificate" />, ou <see langword="null" /> si l'assembly auquel appartient ce module n'est pas signé avec Authenticode.</span><span class="sxs-lookup"><span data-stu-id="3951e-238">An <see langword="X509Certificate" /> object, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-239">Retourne le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-239">Returns the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="3951e-240">Le nom du type à localiser.</span><span class="sxs-lookup"><span data-stu-id="3951e-240">The name of the type to locate.</span></span> <span data-ttu-id="3951e-241">Le nom doit être complet avec l’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="3951e-241">The name must be fully qualified with the namespace.</span></span></param>
        <summary><span data-ttu-id="3951e-242">Retourne le type spécifié en exécutant une recherche qui respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="3951e-242">Returns the specified type, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="3951e-243">Objet <see langword="Type" /> représentant le type donné, si le type est dans ce module, sinon, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-243">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3951e-244">Si le type a été transmis à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-244">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="3951e-245">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="3951e-245">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="3951e-246">Un type peut être récupéré à partir d’un module spécifique à l’aide de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3951e-246">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3951e-247">Appel de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> sur le module qui contient le manifeste ne recherche pas la totalité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="3951e-247">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="3951e-248">Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3951e-248">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-249">L’exemple suivant affiche le nom d’un type dans le module spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-249">The following example displays the name of a type in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-250"><paramref name="className" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-250"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="3951e-251">Les initialiseurs de classe sont appelés et une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="3951e-251">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-252"><paramref name="className" /> est une chaîne de longueur nulle.</span><span class="sxs-lookup"><span data-stu-id="3951e-252"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="3951e-253"><paramref name="className" /> requiert un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3951e-253"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="3951e-254"><paramref name="className" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="3951e-254"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
 <span data-ttu-id="3951e-255">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-255">-or-</span></span>  
  
 <span data-ttu-id="3951e-256">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="className" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="3951e-256">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="3951e-257"><paramref name="className" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="3951e-257"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
 <span data-ttu-id="3951e-258">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-258">-or-</span></span>  
  
 <span data-ttu-id="3951e-259"><paramref name="className" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="3951e-259"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="3951e-260">Le nom du type à localiser.</span><span class="sxs-lookup"><span data-stu-id="3951e-260">The name of the type to locate.</span></span> <span data-ttu-id="3951e-261">Le nom doit être complet avec l’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="3951e-261">The name must be fully qualified with the namespace.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="3951e-262"><see langword="true" /> pour une recherche qui ne respecte pas la casse ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-262"><see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3951e-263">Retourne le type spécifié, en parcourant le module avec la casse spécifiée.</span><span class="sxs-lookup"><span data-stu-id="3951e-263">Returns the specified type, searching the module with the specified case sensitivity.</span></span></summary>
        <returns><span data-ttu-id="3951e-264">Objet <see langword="Type" /> représentant le type donné, si le type est dans ce module, sinon, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-264">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3951e-265">Si le type a été transmis à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-265">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="3951e-266">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="3951e-266">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="3951e-267">Un type peut être récupéré à partir d’un module spécifique à l’aide de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3951e-267">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3951e-268">Appel de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> sur le module qui contient le manifeste ne recherche pas la totalité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="3951e-268">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="3951e-269">Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3951e-269">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-270">L’exemple suivant affiche le nom d’un type dans le module spécifié, en spécifiant `false` pour la `ignoreCase` paramètre afin que la casse n’est pas ignorée.</span><span class="sxs-lookup"><span data-stu-id="3951e-270">The following example displays the name of a type in the specified module, specifying `false` for the `ignoreCase` parameter so that case will not be ignored.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-271"><paramref name="className" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-271"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="3951e-272">Les initialiseurs de classe sont appelés et une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="3951e-272">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-273"><paramref name="className" /> est une chaîne de longueur nulle.</span><span class="sxs-lookup"><span data-stu-id="3951e-273"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="3951e-274"><paramref name="className" /> requiert un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3951e-274"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="3951e-275"><paramref name="className" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="3951e-275"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
 <span data-ttu-id="3951e-276">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-276">-or-</span></span>  
  
 <span data-ttu-id="3951e-277">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="className" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="3951e-277">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="3951e-278"><paramref name="className" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="3951e-278"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
 <span data-ttu-id="3951e-279">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-279">-or-</span></span>  
  
 <span data-ttu-id="3951e-280"><paramref name="className" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="3951e-280"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="3951e-281">Le nom du type à localiser.</span><span class="sxs-lookup"><span data-stu-id="3951e-281">The name of the type to locate.</span></span> <span data-ttu-id="3951e-282">Le nom doit être complet avec l’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="3951e-282">The name must be fully qualified with the namespace.</span></span></param>
        <param name="throwOnError">
          <span data-ttu-id="3951e-283"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-283"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="3951e-284"><see langword="true" /> pour une recherche qui ne respecte pas la casse ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-284"><see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3951e-285">Retourne le type spécifié, en spécifiant s'il faut faire une recherche du module respectant la casse et s'il faut lever une exception si le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3951e-285">Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</span></span></summary>
        <returns><span data-ttu-id="3951e-286">Objet <see cref="T:System.Type" /> représentant le type spécifié, s'il est déclaré dans ce module ; sinon, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-286">A <see cref="T:System.Type" /> object representing the specified type, if the type is declared in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-287">Le `throwOnError` paramètre affecte uniquement ce qui se passe lorsque le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3951e-287">The `throwOnError` parameter affects only what happens when the type is not found.</span></span> <span data-ttu-id="3951e-288">Il n’affecte pas toutes les exceptions qui peuvent être levées.</span><span class="sxs-lookup"><span data-stu-id="3951e-288">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="3951e-289">En particulier, si le type est trouvé mais ne peut pas être chargé, <xref:System.TypeLoadException> peut être levée même si `throwOnError` est `false`.</span><span class="sxs-lookup"><span data-stu-id="3951e-289">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-290">Si le type a été transmis à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="3951e-290">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="3951e-291">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="3951e-291">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="3951e-292">Un type peut être récupéré à partir d’un module spécifique à l’aide de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3951e-292">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3951e-293">Appel de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> sur le module qui contient le manifeste ne recherche pas la totalité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="3951e-293">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="3951e-294">Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3951e-294">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-295">L’exemple suivant affiche le nom d’un type dans le module spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-295">The following example displays the name of a type in the specified module.</span></span> <span data-ttu-id="3951e-296">Le `throwOnError` et `ignoreCase` paramètres sont spécifiés en tant que `false`.</span><span class="sxs-lookup"><span data-stu-id="3951e-296">The `throwOnError` and `ignoreCase` parameters are specified as `false`.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-297"><paramref name="className" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-297"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="3951e-298">Les initialiseurs de classe sont appelés et une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="3951e-298">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-299"><paramref name="className" /> est une chaîne de longueur nulle.</span><span class="sxs-lookup"><span data-stu-id="3951e-299"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="3951e-300"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3951e-300"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="3951e-301"><paramref name="className" /> requiert un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="3951e-301"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="3951e-302"><paramref name="className" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="3951e-302"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
 <span data-ttu-id="3951e-303">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-303">-or-</span></span>  
  
 <span data-ttu-id="3951e-304">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="className" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="3951e-304">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="3951e-305"><paramref name="className" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="3951e-305"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
 <span data-ttu-id="3951e-306">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-306">-or-</span></span>  
  
 <span data-ttu-id="3951e-307"><paramref name="className" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="3951e-307"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-308">Retourne tous les types définis dans ce module.</span><span class="sxs-lookup"><span data-stu-id="3951e-308">Returns all the types defined within this module.</span></span></summary>
        <returns><span data-ttu-id="3951e-309">Tableau de type <see langword="Type" /> contenant les types définis dans le module reflété par cette instance.</span><span class="sxs-lookup"><span data-stu-id="3951e-309">An array of type <see langword="Type" /> containing types defined within the module that is reflected by this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-310">`ReflectionTypeLoadException` est une exception de chargement.</span><span class="sxs-lookup"><span data-stu-id="3951e-310">`ReflectionTypeLoadException` is a special load exception.</span></span> <span data-ttu-id="3951e-311">Le `ReflectionTypeLoadException.Types` propriété contient le tableau de types qui ont été définies dans le module et chargées.</span><span class="sxs-lookup"><span data-stu-id="3951e-311">The `ReflectionTypeLoadException.Types` property contains the array of types that were defined in the module and were loaded.</span></span> <span data-ttu-id="3951e-312">Ce tableau peut contenir des valeurs null.</span><span class="sxs-lookup"><span data-stu-id="3951e-312">This array may contain some null values.</span></span> <span data-ttu-id="3951e-313">Le `ReflectionTypeLoadException.LoaderExceptions` propriété est un tableau d’exceptions qui représentent les exceptions levées par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="3951e-313">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the loader.</span></span> <span data-ttu-id="3951e-314">Les trous dans le tableau de classe s’aligner avec les exceptions.</span><span class="sxs-lookup"><span data-stu-id="3951e-314">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="3951e-315">Par exemple, si les initialiseurs de classe d’une des classes lève une exception pendant elle est chargée, un `TargetInvocationException` est stocké dans l’élément correspondant de le `LoaderExceptions` tableau.</span><span class="sxs-lookup"><span data-stu-id="3951e-315">For example, if the class initializers of one of the classes throws an exception while it is being loaded, a `TargetInvocationException` is stored in the corresponding element of the `LoaderExceptions` array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-316">Si un type a été transmis à un autre assembly, il n’est pas inclus dans le tableau retourné.</span><span class="sxs-lookup"><span data-stu-id="3951e-316">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="3951e-317">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="3951e-317">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="3951e-318">Au moins une des classes d’un module n’a pas pu être chargée.</span><span class="sxs-lookup"><span data-stu-id="3951e-318">One or more classes in a module could not be loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3951e-319">L'appelant n'a pas l'autorisation requise.</span><span class="sxs-lookup"><span data-stu-id="3951e-319">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3951e-320">Autorisation de réflexion pour le module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-320">Reflection permission for the current module.</span></span></permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="3951e-321">Type de l'attribut personnalisé à tester.</span><span class="sxs-lookup"><span data-stu-id="3951e-321">The type of custom attribute to test for.</span></span></param>
        <param name="inherit"><span data-ttu-id="3951e-322">Cet argument est ignoré pour les objets de ce type.</span><span class="sxs-lookup"><span data-stu-id="3951e-322">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="3951e-323">Retourne une valeur qui indique si le type d'attribut spécifié a été appliqué à ce module.</span><span class="sxs-lookup"><span data-stu-id="3951e-323">Returns a value that indicates whether the specified attribute type has been applied to this module.</span></span></summary>
        <returns>
          <span data-ttu-id="3951e-324"><see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" /> ont été appliquées à ce module ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-324"><see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3951e-325">L’exemple suivant illustre une utilisation de la `IsDefined` (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-325">The following example demonstrates a use of the `IsDefined` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3951e-326"><paramref name="attributeType" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-326"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-327"><paramref name="attributeType" /> n'est pas un objet <see cref="T:System.Type" /> fourni par le runtime.</span><span class="sxs-lookup"><span data-stu-id="3951e-327"><paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span></span> <span data-ttu-id="3951e-328">Par exemple, <paramref name="attributeType" /> est un objet <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-328">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-329">Obtient une valeur indiquant si l'objet est une ressource.</span><span class="sxs-lookup"><span data-stu-id="3951e-329">Gets a value indicating whether the object is a resource.</span></span></summary>
        <returns>
          <span data-ttu-id="3951e-330"><see langword="true" /> si l'objet est une ressource ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-330"><see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3951e-331">L’exemple suivant illustre une utilisation de la `IsResource` (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-331">The following example demonstrates a use of the `IsResource` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-332">Obtient la version de flux des métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-332">Gets the metadata stream version.</span></span></summary>
        <value><span data-ttu-id="3951e-333">Entier 32 bits représentant la version de flux des métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-333">A 32-bit integer representing the metadata stream version.</span></span> <span data-ttu-id="3951e-334">Les deux octets de poids fort représentent le numéro de la version principale, et les deux octets de poids faible représentent le numéro de la version secondaire.</span><span class="sxs-lookup"><span data-stu-id="3951e-334">The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3951e-335">Pour plus d’informations sur l’en-tête de métadonnées, consultez « Partition II : Metadata Definition et Semantics » dans la documentation du Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="3951e-335">For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</span></span> <span data-ttu-id="3951e-336">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-336">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-337">Obtient un jeton qui identifie le module dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-337">Gets a token that identifies the module in metadata.</span></span></summary>
        <value><span data-ttu-id="3951e-338">Jeton d'entier qui identifie le module actuel dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-338">An integer token that identifies the current module in metadata.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-339">Les jetons obtenus à l’aide de cette propriété peuvent être passés à l’API de réflexion non managée.</span><span class="sxs-lookup"><span data-stu-id="3951e-339">The tokens obtained using this property can be passed to the unmanaged Reflection API.</span></span> <span data-ttu-id="3951e-340">Pour plus d’informations, consultez [API de réflexion non managée](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span><span class="sxs-lookup"><span data-stu-id="3951e-340">For more information, see [Unmanaged Reflection API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-341">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-341">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-342">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-342">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-343">Obtient un handle pour le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-343">Gets a handle for the module.</span></span></summary>
        <value><span data-ttu-id="3951e-344">Structure <see cref="T:System.ModuleHandle" /> pour le module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-344">A <see cref="T:System.ModuleHandle" /> structure for the current module.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-345">Obtient un identificateur unique universel (UUID) qui peut être utilisé pour faire la distinction entre deux versions d’un module.</span><span class="sxs-lookup"><span data-stu-id="3951e-345">Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</span></span></summary>
        <value><span data-ttu-id="3951e-346"><see cref="T:System.Guid" /> qui peut être utilisé pour faire la distinction entre deux versions d’un module.</span><span class="sxs-lookup"><span data-stu-id="3951e-346">A <see cref="T:System.Guid" /> that can be used to distinguish between two versions of a module.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-347">Dans les métadonnées non managées, le GUID retourné par le <xref:System.Reflection.Module.ModuleVersionId%2A> propriété constitue le `mvid`et est stocké dans le tas GUID.</span><span class="sxs-lookup"><span data-stu-id="3951e-347">In unmanaged metadata, the GUID returned by the <xref:System.Reflection.Module.ModuleVersionId%2A> property is referred to as the `mvid`, and is stored in the GUID heap.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-348">Vous trouverez plus d’informations sur les métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-348">More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-349">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-349">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-350">Obtient un <see langword="String" /> représentant le nom du module, sans le chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="3951e-350">Gets a <see langword="String" /> representing the name of the module with the path removed.</span></span></summary>
        <value><span data-ttu-id="3951e-351">Nom du module sans le chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="3951e-351">The module name with no path.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-352">`Name` est une chaîne dépend de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="3951e-352">`Name` is a platform-dependent string.</span></span>  
  
 <span data-ttu-id="3951e-353">Si l’assembly de ce module a été chargé à partir d’un tableau d’octets le `FullyQualifiedName` pour le module sera : \<inconnu >.</span><span class="sxs-lookup"><span data-stu-id="3951e-353">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
 <span data-ttu-id="3951e-354">Pour obtenir le nom et le chemin d’accès, utilisez <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="3951e-354">To get the name and the path, use <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-355">Cet exemple montre l’effet de la `ScopeName`, `FullyQualifiedName`, et `Name` propriétés.</span><span class="sxs-lookup"><span data-stu-id="3951e-355">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="3951e-356">Premier objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="3951e-356">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="3951e-357">Deuxième objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="3951e-357">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="3951e-358">Indique si deux objets <see cref="T:System.Reflection.Module" /> sont égaux.</span><span class="sxs-lookup"><span data-stu-id="3951e-358">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="3951e-359"><see langword="true" /> si <paramref name="left" /> est égal à <paramref name="right" /> ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-359"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="3951e-360">Premier objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="3951e-360">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="3951e-361">Deuxième objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="3951e-361">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="3951e-362">Indique si deux objets <see cref="T:System.Reflection.Module" /> ne sont pas égaux.</span><span class="sxs-lookup"><span data-stu-id="3951e-362">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="3951e-363"><see langword="true" /> si <paramref name="left" /> n'est pas égal à <paramref name="right" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3951e-363"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-364">Retourne le champ identifié par un jeton de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-364">Returns the field identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-365">Jeton de métadonnées qui identifie un champ dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-365">A metadata token that identifies a field in the module.</span></span></param>
        <summary><span data-ttu-id="3951e-366">Retourne le champ identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-366">Returns the field identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="3951e-367">Objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-367">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-368">Pour résoudre un jeton de métadonnées qui identifie un champ dont le parent `TypeSpec` a une signature contenant le type d’élément `ELEMENT_TYPE_VAR` ou `ELEMENT_TYPE_MVAR`, utilisez le <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, ce qui vous permet de fournir le contexte nécessaire.</span><span class="sxs-lookup"><span data-stu-id="3951e-368">To resolve a metadata token that identifies a field whose parent `TypeSpec` has a signature containing element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="3951e-369">Autrement dit, lorsque vous résolvez un jeton de métadonnées pour un champ qui dépend des paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé, vous devez utiliser la surcharge qui vous permet de fournir les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="3951e-369">That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-370">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-370">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-371">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-371">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="3951e-372">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-372">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-373"><paramref name="metadataToken" /> n'est pas un jeton de champ dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-373"><paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span></span>  
  
 <span data-ttu-id="3951e-374">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-374">-or-</span></span>  
  
 <span data-ttu-id="3951e-375"><paramref name="metadataToken" /> identifie un champ dont le <see langword="TypeSpec" /> parent a une signature qui contient le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique).</span><span class="sxs-lookup"><span data-stu-id="3951e-375"><paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-376"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-376"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-377">Jeton de métadonnées qui identifie un champ dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-377">A metadata token that identifies a field in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="3951e-378">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-378">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="3951e-379">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-379">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="3951e-380">Retourne le champ identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-380">Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="3951e-381">Objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-381">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-382">Utilisez le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur le type où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="3951e-382">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="3951e-383">Utilisez le <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur la méthode où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="3951e-383">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="3951e-384">Il est recommandé de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="3951e-384">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-385">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-385">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-386">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-386">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="3951e-387">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-387">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-388"><paramref name="metadataToken" /> n'est pas un jeton de champ dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-388"><paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span></span>  
  
 <span data-ttu-id="3951e-389">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-389">-or-</span></span>  
  
 <span data-ttu-id="3951e-390"><paramref name="metadataToken" /> identifie un champ dont le <see langword="TypeSpec" /> parent a une signature contenant le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</span><span class="sxs-lookup"><span data-stu-id="3951e-390"><paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-391"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-391"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-392">Retourne le type ou le membre identifié par un jeton de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-392">Returns the type or member identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-393">Jeton de métadonnées qui identifie un type ou un membre dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-393">A metadata token that identifies a type or member in the module.</span></span></param>
        <summary><span data-ttu-id="3951e-394">Retourne le type ou le membre identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-394">Returns the type or member identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="3951e-395">Objet <see cref="T:System.Reflection.MemberInfo" /> représentant le type ou le membre identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-395">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-396">Pour résoudre un jeton de métadonnées pour un `MethodSpec` ou `TypeSpec` dont la signature contient le type d’élément `ELEMENT_TYPE_VAR` ou `ELEMENT_TYPE_MVAR`, utilisez le <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, ce qui vous permet de fournir le contexte nécessaire.</span><span class="sxs-lookup"><span data-stu-id="3951e-396">To resolve a metadata token for a `MethodSpec` or `TypeSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="3951e-397">Autrement dit, lorsque vous résolvez un jeton de métadonnées pour un membre qui dépend des paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé, vous devez utiliser la surcharge qui vous permet de fournir les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="3951e-397">That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-398">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-398">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-399">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-399">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="3951e-400">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-400">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-401"><paramref name="metadataToken" /> n'est pas un jeton pour un type ou un membre dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-401"><paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span></span>  
  
 <span data-ttu-id="3951e-402">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-402">-or-</span></span>  
  
 <span data-ttu-id="3951e-403"><paramref name="metadataToken" /> est un <see langword="MethodSpec" /> ou un <see langword="TypeSpec" /> dont la signature contient le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique).</span><span class="sxs-lookup"><span data-stu-id="3951e-403"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span>  
  
 <span data-ttu-id="3951e-404">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-404">-or-</span></span>  
  
 <span data-ttu-id="3951e-405"><paramref name="metadataToken" /> identifie une propriété ou un événement.</span><span class="sxs-lookup"><span data-stu-id="3951e-405"><paramref name="metadataToken" /> identifies a property or event.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-406"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-406"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-407">Jeton de métadonnées qui identifie un type ou un membre dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-407">A metadata token that identifies a type or member in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="3951e-408">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-408">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="3951e-409">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-409">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="3951e-410">Retourne le type ou le membre identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-410">Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="3951e-411">Objet <see cref="T:System.Reflection.MemberInfo" /> représentant le type ou le membre identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-411">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-412">Utilisez le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur le type où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="3951e-412">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="3951e-413">Utilisez le <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur la méthode où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="3951e-413">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="3951e-414">Il est recommandé de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="3951e-414">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-415">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-415">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-416">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="3951e-417">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-417">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-418"><paramref name="metadataToken" /> n'est pas un jeton pour un type ou un membre dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-418"><paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span></span>  
  
 <span data-ttu-id="3951e-419">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-419">-or-</span></span>  
  
 <span data-ttu-id="3951e-420"><paramref name="metadataToken" /> est un <see langword="MethodSpec" /> ou <see langword="TypeSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</span><span class="sxs-lookup"><span data-stu-id="3951e-420"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span>  
  
 <span data-ttu-id="3951e-421">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-421">-or-</span></span>  
  
 <span data-ttu-id="3951e-422"><paramref name="metadataToken" /> identifie une propriété ou un événement.</span><span class="sxs-lookup"><span data-stu-id="3951e-422"><paramref name="metadataToken" /> identifies a property or event.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-423"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-423"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-424">Retourne la méthode identifiée par un jeton de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-424">Returns the method identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-425">Jeton de métadonnées qui identifie une méthode ou un constructeur dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-425">A metadata token that identifies a method or constructor in the module.</span></span></param>
        <summary><span data-ttu-id="3951e-426">Retourne la méthode ou le constructeur identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-426">Returns the method or constructor identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="3951e-427">Objet <see cref="T:System.Reflection.MethodBase" /> représentant la méthode ou le constructeur identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-427">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-428">Pour résoudre un jeton de métadonnées pour un `MethodSpec` dont la signature contient le type d’élément `ELEMENT_TYPE_VAR` ou `ELEMENT_TYPE_MVAR`, utilisez le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, ce qui vous permet de fournir le contexte nécessaire.</span><span class="sxs-lookup"><span data-stu-id="3951e-428">To resolve a metadata token for a `MethodSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="3951e-429">Autrement dit, lorsque vous résolvez un jeton de métadonnées pour une méthode qui dépend des paramètres de type générique du type générique ou la méthode générique à laquelle le jeton est incorporé, vous devez utiliser la surcharge qui vous permet de fournir les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="3951e-429">That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-430">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-430">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-431">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-431">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-432">L’exemple suivant montre comment utiliser les deux surcharges de la <xref:System.Reflection.Module.ResolveMethod%2A> méthode pour résoudre les jetons de métadonnées à partir de l’appel de sites dans des contextes génériques et non génériques.</span><span class="sxs-lookup"><span data-stu-id="3951e-432">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="3951e-433">L’exemple de code définit deux types génériques, `G1<Tg1>` et `G2<Tg2>` (`G1(Of Tg1)` et `G2(Of Tg2)` en Visual Basic), chacun d’eux possède une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-433">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>` (`G1(Of Tg1)` and `G2(Of Tg2)` in Visual Basic), each of which has a generic method.</span></span> <span data-ttu-id="3951e-434">`G1<Tg1>` a également une méthode non générique qui utilise le paramètre de type `Tg1` pour son paramètre.</span><span class="sxs-lookup"><span data-stu-id="3951e-434">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="3951e-435">La méthode générique `GM2<Tgm2>` dans le type `G2<Tg2>` contient plusieurs appels de méthode :</span><span class="sxs-lookup"><span data-stu-id="3951e-435">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="3951e-436">Cas 1 : La méthode générique `GM1<Tgm1>` est appelée, à l’aide des paramètres de type de `G2<Tg2>` et `GM2<Tgm2>` comme arguments de type.</span><span class="sxs-lookup"><span data-stu-id="3951e-436">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="3951e-437">En d’autres termes, les types de paramètres de la méthode appelée dépend les types qui sont utilisés pour construire un type générique fermé à partir de la définition de type pour `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="3951e-437">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="3951e-438">Cas 2 : La méthode non générique `M1` est appelée.</span><span class="sxs-lookup"><span data-stu-id="3951e-438">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="3951e-439">Le paramètre de cette méthode utilise le paramètre de type du type définissant, `G1<Tg1>`, qui est remplacé dans ce cas par le paramètre de type du type englobant, `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="3951e-439">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="3951e-440">Cas 3 : La méthode générique `GM1<Tgm1>` est appelée, en spécifiant <xref:System.Int32> et <xref:System.Object> pour les arguments de type du type générique et la méthode générique, respectivement.</span><span class="sxs-lookup"><span data-stu-id="3951e-440">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="3951e-441">Cet appel de méthode ne dépend pas de paramètres de type de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="3951e-441">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="3951e-442">Cas n° 4 : La méthode non générique `M1` de la `Example` classe est appelée.</span><span class="sxs-lookup"><span data-stu-id="3951e-442">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="3951e-443">Cet appel de méthode ne dépend pas de paramètres de type de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="3951e-443">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="3951e-444">En outre, l’exemple définit non générique `Example` classe.</span><span class="sxs-lookup"><span data-stu-id="3951e-444">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="3951e-445">Cette classe a une méthode `M` qui effectue un appel à une méthode générique :</span><span class="sxs-lookup"><span data-stu-id="3951e-445">This class has a method `M` that makes a call to a generic method:</span></span>  
  
-   <span data-ttu-id="3951e-446">Cas 5 : La méthode générique `GM1` est appelée, en spécifiant <xref:System.Int32> et <xref:System.Object> pour les arguments de type du type générique et la méthode générique, respectivement.</span><span class="sxs-lookup"><span data-stu-id="3951e-446">Case 5: The generic method `GM1` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="3951e-447">Le contexte de cette méthode n’a aucune englobant type générique ou méthode générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-447">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="3951e-448">Pour chaque cas, l’exemple construit d’abord un <xref:System.Reflection.MethodInfo> qui représente la méthode appelée, puis il résout le jeton à l’aide du <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, à l’aide de la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> et <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthodes pour obtenir les valeurs pour le `genericTypeArguments` et `genericMethodArguments` paramètres.</span><span class="sxs-lookup"><span data-stu-id="3951e-448">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="3951e-449">Cette technique fonctionne dans tous les cas, étant donné que les méthodes retournent <xref:System.Type.EmptyTypes?displayProperty=nameWithType> pour des contextes non générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-449">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="3951e-450">L’exemple compare le résolu <xref:System.Reflection.MethodInfo> avec construit <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="3951e-450">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="3951e-451">L’exemple tente alors d’utiliser le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> surcharge de méthode pour résoudre le jeton.</span><span class="sxs-lookup"><span data-stu-id="3951e-451">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="3951e-452">Cela fonctionne dans les cas 3, 4 et 5, étant donné que les appels de méthode ne dépendent pas du contexte générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-452">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="3951e-453">Dans les cas 1 et 2, une exception est levée, car les informations sont insuffisantes pour résoudre le jeton.</span><span class="sxs-lookup"><span data-stu-id="3951e-453">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="3951e-454">Les valeurs de jeton de métadonnées sont codés en dur en tant qu’énumération.</span><span class="sxs-lookup"><span data-stu-id="3951e-454">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="3951e-455">Si vous modifiez cet exemple de code, les valeurs de jeton sont susceptibles de changer.</span><span class="sxs-lookup"><span data-stu-id="3951e-455">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="3951e-456">Pour déterminer les nouvelles valeurs de jeton, compilez le code et utilisez Ildasm.exe avec la **/Tokens** option pour examiner l’assembly.</span><span class="sxs-lookup"><span data-stu-id="3951e-456">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="3951e-457">Les jetons sont accessibles aux points d’appel.</span><span class="sxs-lookup"><span data-stu-id="3951e-457">The tokens can be found at the points of call.</span></span> <span data-ttu-id="3951e-458">Pour ce faire, insérez les nouvelles valeurs dans l’énumération et recompiler l’exemple.</span><span class="sxs-lookup"><span data-stu-id="3951e-458">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-459"><paramref name="metadataToken" /> n'est pas un jeton pour une méthode ou un constructeur dans la portée du module en cours.</span><span class="sxs-lookup"><span data-stu-id="3951e-459"><paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span></span>  
  
 <span data-ttu-id="3951e-460">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-460">-or-</span></span>  
  
 <span data-ttu-id="3951e-461"><paramref name="metadataToken" /> est un <see langword="MethodSpec" /> dont la signature contient le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique).</span><span class="sxs-lookup"><span data-stu-id="3951e-461"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-462"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-462"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-463">Jeton de métadonnées qui identifie une méthode ou un constructeur dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-463">A metadata token that identifies a method or constructor in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="3951e-464">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-464">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="3951e-465">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-465">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="3951e-466">Retourne la méthode ou le constructeur identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-466">Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="3951e-467">Objet <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode identifiée par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-467">A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-468">Utilisez le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur le type où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="3951e-468">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="3951e-469">Utilisez le <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur la méthode où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericMethodArguments`.</span><span class="sxs-lookup"><span data-stu-id="3951e-469">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericMethodArguments`.</span></span> <span data-ttu-id="3951e-470">Il est recommandé de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="3951e-470">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-471">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-471">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-472">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-472">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-473">L’exemple suivant montre comment utiliser les deux surcharges de la <xref:System.Reflection.Module.ResolveMethod%2A> méthode pour résoudre les jetons de métadonnées à partir de l’appel de sites dans des contextes génériques et non génériques.</span><span class="sxs-lookup"><span data-stu-id="3951e-473">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="3951e-474">L’exemple de code définit deux types génériques, `G1<Tg1>` et `G2<Tg2>`, chacune d’elles possède une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-474">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>`, each of which has a generic method.</span></span> <span data-ttu-id="3951e-475">`G1<Tg1>` a également une méthode non générique qui utilise le paramètre de type `Tg1` pour son paramètre.</span><span class="sxs-lookup"><span data-stu-id="3951e-475">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="3951e-476">La méthode générique `GM2<Tgm2>` dans le type `G2<Tg2>` contient plusieurs appels de méthode :</span><span class="sxs-lookup"><span data-stu-id="3951e-476">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="3951e-477">Cas 1 : La méthode générique `GM1<Tgm1>` est appelée, à l’aide des paramètres de type de `G2<Tg2>` et `GM2<Tgm2>` comme arguments de type.</span><span class="sxs-lookup"><span data-stu-id="3951e-477">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="3951e-478">En d’autres termes, les types de paramètres de la méthode appelée dépend les types qui sont utilisés pour construire un type générique fermé à partir de la définition de type pour `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="3951e-478">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="3951e-479">Cas 2 : La méthode non générique `M1` est appelée.</span><span class="sxs-lookup"><span data-stu-id="3951e-479">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="3951e-480">Le paramètre de cette méthode utilise le paramètre de type du type définissant, `G1<Tg1>`, qui est remplacé dans ce cas par le paramètre de type du type englobant, `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="3951e-480">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="3951e-481">Cas 3 : La méthode générique `GM1<Tgm1>` est appelée, en spécifiant <xref:System.Int32> et <xref:System.Object> pour les arguments de type du type générique et la méthode générique, respectivement.</span><span class="sxs-lookup"><span data-stu-id="3951e-481">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="3951e-482">Cet appel de méthode ne dépend pas de paramètres de type de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="3951e-482">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="3951e-483">Cas n° 4 : La méthode non générique `M1` de la `Example` classe est appelée.</span><span class="sxs-lookup"><span data-stu-id="3951e-483">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="3951e-484">Cet appel de méthode ne dépend pas de paramètres de type de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="3951e-484">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="3951e-485">En outre, l’exemple définit non générique `Example` classe.</span><span class="sxs-lookup"><span data-stu-id="3951e-485">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="3951e-486">Cette classe a une méthode `M` qui effectue un appel à une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-486">This class has a method `M` that makes a call to a generic method.</span></span>  
  
-   <span data-ttu-id="3951e-487">Cas 5 : La méthode générique `GM1<Tgm1>` est appelée, en spécifiant <xref:System.Int32> et <xref:System.Object> pour les arguments de type du type générique et la méthode générique, respectivement.</span><span class="sxs-lookup"><span data-stu-id="3951e-487">Case 5: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="3951e-488">Le contexte de cette méthode n’a aucune englobant type générique ou méthode générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-488">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="3951e-489">Pour chaque cas, l’exemple construit d’abord un <xref:System.Reflection.MethodInfo> qui représente la méthode appelée, puis il résout le jeton à l’aide du <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, à l’aide de la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> et <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthodes pour obtenir les valeurs pour le `genericTypeArguments` et `genericMethodArguments` paramètres.</span><span class="sxs-lookup"><span data-stu-id="3951e-489">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="3951e-490">Cette technique fonctionne dans tous les cas, étant donné que les méthodes retournent <xref:System.Type.EmptyTypes?displayProperty=nameWithType> pour des contextes non générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-490">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="3951e-491">L’exemple compare le résolu <xref:System.Reflection.MethodInfo> avec construit <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="3951e-491">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="3951e-492">L’exemple tente alors d’utiliser le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> surcharge de méthode pour résoudre le jeton.</span><span class="sxs-lookup"><span data-stu-id="3951e-492">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="3951e-493">Cela fonctionne dans les cas 3, 4 et 5, étant donné que les appels de méthode ne dépendent pas du contexte générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-493">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="3951e-494">Dans les cas 1 et 2, une exception est levée, car les informations sont insuffisantes pour résoudre le jeton.</span><span class="sxs-lookup"><span data-stu-id="3951e-494">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="3951e-495">Les valeurs de jeton de métadonnées sont codés en dur en tant qu’énumération.</span><span class="sxs-lookup"><span data-stu-id="3951e-495">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="3951e-496">Si vous modifiez cet exemple de code, les valeurs de jeton sont susceptibles de changer.</span><span class="sxs-lookup"><span data-stu-id="3951e-496">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="3951e-497">Pour déterminer les nouvelles valeurs de jeton, compilez le code et utilisez Ildasm.exe avec la **/Tokens** option pour examiner l’assembly.</span><span class="sxs-lookup"><span data-stu-id="3951e-497">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="3951e-498">Les jetons sont accessibles aux points d’appel.</span><span class="sxs-lookup"><span data-stu-id="3951e-498">The tokens can be found at the points of call.</span></span> <span data-ttu-id="3951e-499">Pour ce faire, insérez les nouvelles valeurs dans l’énumération et recompiler l’exemple.</span><span class="sxs-lookup"><span data-stu-id="3951e-499">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-500"><paramref name="metadataToken" /> n'est pas un jeton pour une méthode ou un constructeur dans la portée du module en cours.</span><span class="sxs-lookup"><span data-stu-id="3951e-500"><paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span></span>  
  
 <span data-ttu-id="3951e-501">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-501">-or-</span></span>  
  
 <span data-ttu-id="3951e-502"><paramref name="metadataToken" /> est un <see langword="MethodSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</span><span class="sxs-lookup"><span data-stu-id="3951e-502"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-503"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-503"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-504">Jeton de métadonnées qui identifie une signature dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-504">A metadata token that identifies a signature in the module.</span></span></param>
        <summary><span data-ttu-id="3951e-505">Retourne le blob de signature identifié par un jeton de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-505">Returns the signature blob identified by a metadata token.</span></span></summary>
        <returns><span data-ttu-id="3951e-506">Tableau d'octets représentant le blob de signature.</span><span class="sxs-lookup"><span data-stu-id="3951e-506">An array of bytes representing the signature blob.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3951e-507">Vous trouverez des informations sur les jetons de métadonnées et les signatures dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-507">Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-508">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-508">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-509"><paramref name="metadataToken" />n'est pas un <see langword="MemberRef" />, un <see langword="MethodDef" />, un <see langword="TypeSpec" />, une signature ou un jeton <see langword="FieldDef" /> valide dans la portée du module en cours.</span><span class="sxs-lookup"><span data-stu-id="3951e-509"><paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-510"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-510"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-511">Jeton de métadonnées qui identifie une chaîne dans le tas de chaînes du module.</span><span class="sxs-lookup"><span data-stu-id="3951e-511">A metadata token that identifies a string in the string heap of the module.</span></span></param>
        <summary><span data-ttu-id="3951e-512">Retourne la chaîne identifiée par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-512">Returns the string identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="3951e-513"><see cref="T:System.String" /> contenant une valeur de chaîne du tas de chaînes des métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-513">A <see cref="T:System.String" /> containing a string value from the metadata string heap.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3951e-514">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-514">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-515">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-515">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-516"><paramref name="metadataToken" /> n'est pas un jeton pour une chaîne dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-516"><paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-517"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-517"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3951e-518">Retourne le type identifié par un jeton de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-518">Returns the type identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-519">Jeton de métadonnées qui identifie un type dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-519">A metadata token that identifies a type in the module.</span></span></param>
        <summary><span data-ttu-id="3951e-520">Retourne le type identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-520">Returns the type identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="3951e-521">Objet <see cref="T:System.Type" /> qui représente le type identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-521">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-522">Pour résoudre un jeton de métadonnées pour un `TypeSpec` dont la signature contient `ELEMENT_TYPE_VAR` ou `ELEMENT_TYPE_MVAR`, utilisez le <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, ce qui vous permet de fournir le contexte nécessaire.</span><span class="sxs-lookup"><span data-stu-id="3951e-522">To resolve a metadata token for a `TypeSpec` whose signature contains `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="3951e-523">Autrement dit, lorsque vous résolvez un jeton de métadonnées pour un type qui dépend des paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé, vous devez utiliser la surcharge qui vous permet de fournir les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="3951e-523">That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-524">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-524">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-525">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-525">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-526"><paramref name="metadataToken" /> n'est pas le jeton d'un type dans la portée du module en cours.</span><span class="sxs-lookup"><span data-stu-id="3951e-526"><paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span></span>  
  
 <span data-ttu-id="3951e-527">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-527">-or-</span></span>  
  
 <span data-ttu-id="3951e-528"><paramref name="metadataToken" /> est un <see langword="TypeSpec" /> dont la signature contient le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique).</span><span class="sxs-lookup"><span data-stu-id="3951e-528"><paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-529"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-529"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="3951e-530">Jeton de métadonnées qui identifie un type dans le module.</span><span class="sxs-lookup"><span data-stu-id="3951e-530">A metadata token that identifies a type in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="3951e-531">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-531">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="3951e-532">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</span><span class="sxs-lookup"><span data-stu-id="3951e-532">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="3951e-533">Retourne le type identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</span><span class="sxs-lookup"><span data-stu-id="3951e-533">Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="3951e-534">Objet <see cref="T:System.Type" /> qui représente le type identifié par le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="3951e-534">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-535">Utilisez le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur le type où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="3951e-535">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="3951e-536">Utilisez le <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur la méthode où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="3951e-536">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="3951e-537">Il est recommandé de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="3951e-537">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3951e-538">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="3951e-538">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3951e-539">La documentation est disponible en ligne. consultez [Common Language Infrastructure Standards et c# ECMA](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="3951e-539">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="3951e-540">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-540">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3951e-541"><paramref name="metadataToken" /> n'est pas le jeton d'un type dans la portée du module en cours.</span><span class="sxs-lookup"><span data-stu-id="3951e-541"><paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span></span>  
  
 <span data-ttu-id="3951e-542">- ou -</span><span class="sxs-lookup"><span data-stu-id="3951e-542">-or-</span></span>  
  
 <span data-ttu-id="3951e-543"><paramref name="metadataToken" /> est un <see langword="TypeSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</span><span class="sxs-lookup"><span data-stu-id="3951e-543"><paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3951e-544"><paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span><span class="sxs-lookup"><span data-stu-id="3951e-544"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3951e-545">Obtient une chaîne représentant le nom du module.</span><span class="sxs-lookup"><span data-stu-id="3951e-545">Gets a string representing the name of the module.</span></span></summary>
        <value><span data-ttu-id="3951e-546">Nom du module.</span><span class="sxs-lookup"><span data-stu-id="3951e-546">The module name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-547">Le `ScopeName` propriété n’est pas utilisée par le common language runtime, mais vous pouvez l’utiliser pour stocker une chaîne dans la propriété lorsque vous émettez un module à l’aide de l’API de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="3951e-547">The `ScopeName` property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</span></span> <span data-ttu-id="3951e-548">Réflexion lui-même n’autorise pas vous permet de définir le `ScopeName` propriété.</span><span class="sxs-lookup"><span data-stu-id="3951e-548">Reflection itself does not allow you to set the `ScopeName` property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3951e-549">Cet exemple montre l’effet de la `ScopeName`, `FullyQualifiedName`, et `Name` propriétés.</span><span class="sxs-lookup"><span data-stu-id="3951e-549">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="3951e-550">Réservé à un usage ultérieur.</span><span class="sxs-lookup"><span data-stu-id="3951e-550">Reserved for future use.</span></span> <span data-ttu-id="3951e-551">Doit être IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="3951e-551">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="3951e-552">Tableau passé des noms à mapper.</span><span class="sxs-lookup"><span data-stu-id="3951e-552">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="3951e-553">Compte des noms à mapper.</span><span class="sxs-lookup"><span data-stu-id="3951e-553">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="3951e-554">Contexte des paramètres régionaux dans lequel interpréter les noms.</span><span class="sxs-lookup"><span data-stu-id="3951e-554">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="3951e-555">Tableau, alloué par l'appelant, qui reçoit les ID correspondant aux noms.</span><span class="sxs-lookup"><span data-stu-id="3951e-555">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="3951e-556">Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</span><span class="sxs-lookup"><span data-stu-id="3951e-556">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-557">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="3951e-557">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3951e-558">Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3951e-558">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3951e-559">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3951e-559">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="3951e-560">Informations de type à retourner.</span><span class="sxs-lookup"><span data-stu-id="3951e-560">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="3951e-561">Identificateur des paramètres régionaux pour les informations de type.</span><span class="sxs-lookup"><span data-stu-id="3951e-561">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="3951e-562">Reçoit un pointeur vers l'objet d'informations de type demandé.</span><span class="sxs-lookup"><span data-stu-id="3951e-562">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="3951e-563">Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</span><span class="sxs-lookup"><span data-stu-id="3951e-563">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-564">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="3951e-564">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3951e-565">Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3951e-565">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3951e-566">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3951e-566">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="3951e-567">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</span><span class="sxs-lookup"><span data-stu-id="3951e-567">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="3951e-568">Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</span><span class="sxs-lookup"><span data-stu-id="3951e-568">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-569">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="3951e-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3951e-570">Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3951e-570">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3951e-571">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3951e-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="3951e-572">Identifie le membre.</span><span class="sxs-lookup"><span data-stu-id="3951e-572">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="3951e-573">Réservé à un usage ultérieur.</span><span class="sxs-lookup"><span data-stu-id="3951e-573">Reserved for future use.</span></span> <span data-ttu-id="3951e-574">Doit être IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="3951e-574">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="3951e-575">Contexte des paramètres régionaux dans lequel interpréter les arguments.</span><span class="sxs-lookup"><span data-stu-id="3951e-575">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="3951e-576">Indicateurs décrivant le contexte de l'appel.</span><span class="sxs-lookup"><span data-stu-id="3951e-576">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="3951e-577">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</span><span class="sxs-lookup"><span data-stu-id="3951e-577">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="3951e-578">Pointeur vers l'emplacement où le résultat doit être stocké.</span><span class="sxs-lookup"><span data-stu-id="3951e-578">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="3951e-579">Pointeur vers une structure qui contient les informations sur les exceptions.</span><span class="sxs-lookup"><span data-stu-id="3951e-579">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="3951e-580">Index du premier argument comportant une erreur.</span><span class="sxs-lookup"><span data-stu-id="3951e-580">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="3951e-581">Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</span><span class="sxs-lookup"><span data-stu-id="3951e-581">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3951e-582">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="3951e-582">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3951e-583">Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3951e-583">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3951e-584">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3951e-584">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3951e-585">Retourne le nom du module.</span><span class="sxs-lookup"><span data-stu-id="3951e-585">Returns the name of the module.</span></span></summary>
        <returns><span data-ttu-id="3951e-586"><see langword="String" /> représentant le nom de ce module.</span><span class="sxs-lookup"><span data-stu-id="3951e-586">A <see langword="String" /> representing the name of this module.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3951e-587">L’exemple suivant illustre une utilisation de la `ToString` (méthode).</span><span class="sxs-lookup"><span data-stu-id="3951e-587">The following example demonstrates a use of the `ToString` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>