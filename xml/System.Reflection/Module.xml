<Type Name="Module" FullName="System.Reflection.Module">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7e44325ef5b3af5671d9bd28885d3d54eef547d6" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52384417" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Module = class&#xA;    interface ISerializable&#xA;    interface ICustomAttributeProvider&#xA;    interface _Module" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="8747b-101">Effectue une réflexion sur un module.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8747b-101">Performs reflection on a module.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-102">Un module est un fichier exécutable portable, tel que type.dll ou application.exe, comprenant une ou plusieurs classes et interfaces.</span><span class="sxs-lookup"><span data-stu-id="8747b-102">A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</span></span> <span data-ttu-id="8747b-103">Un module peut contenir plusieurs espaces de noms et un espace de noms peut s'étendre sur plusieurs modules.</span><span class="sxs-lookup"><span data-stu-id="8747b-103">There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</span></span>  
  
 <span data-ttu-id="8747b-104">Un ou plusieurs modules déployés en tant qu'unité composent un assembly.</span><span class="sxs-lookup"><span data-stu-id="8747b-104">One or more modules deployed as a unit compose an assembly.</span></span> <span data-ttu-id="8747b-105">Pour plus d’informations sur la création d’un assembly avec plusieurs modules, consultez [multifichier assemblys](~/docs/framework/app-domains/multifile-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="8747b-105">For information about creating an assembly with more than one module, see [Multifile Assemblies](~/docs/framework/app-domains/multifile-assemblies.md).</span></span>  
  
 <span data-ttu-id="8747b-106">Notez qu’un module .NET Framework n’est pas identique à un module dans Visual Basic, qui est utilisé par un programmeur pour organiser des fonctions et des sous-routines dans une application.</span><span class="sxs-lookup"><span data-stu-id="8747b-106">Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-107">Les exemples de code suivants montrent comment utiliser la réflexion pour obtenir des informations sur les modules :</span><span class="sxs-lookup"><span data-stu-id="8747b-107">The following code examples show how to use reflection to get information about modules:</span></span>  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="8747b-108">pour la confiance totale pour les héritiers.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8747b-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="8747b-109">Cette classe ne peut pas être héritée par du code partiellement fiable.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8747b-109">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-110">Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-110">Initializes a new instance of the <see cref="T:System.Reflection.Module" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-111">Ce constructeur est appelé par les classes dérivées lors de la construction de <xref:System.Reflection.Module> objets.</span><span class="sxs-lookup"><span data-stu-id="8747b-111">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Module> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Module.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-112">Obtient le <see cref="T:System.Reflection.Assembly" /> approprié pour cette instance de <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-112">Gets the appropriate <see cref="T:System.Reflection.Assembly" /> for this instance of <see cref="T:System.Reflection.Module" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-113">Objet <see langword="Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-113">An <see langword="Assembly" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8747b-114">L’exemple suivant affiche le nom complet de l’assembly spécifié dans le module spécifié.</span><span class="sxs-lookup"><span data-stu-id="8747b-114">The following example displays the full name of the specified assembly in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Module.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-115">Obtient une collection qui contient les attributs personnalisés de ce module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-115">Gets a collection that contains this module's custom attributes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-116">Collection qui contient les attributs personnalisés de ce module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-116">A collection that contains this module's custom attributes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="module.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="8747b-117">Objet à comparer avec cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-117">The object to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-118">Détermine si ce module et l'objet spécifié sont égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-118">Determines whether this module and the specified object are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-119">
            <see langword="true" /> si <paramref name="o" /> est égal à cette instance ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-119">
              <see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterTypeName : System.Reflection.TypeFilter" Usage="System.Reflection.Module.FilterTypeName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-120">Objet <see langword="TypeFilter" /> qui permet de filtrer la liste des types définis dans ce module en fonction du nom.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-120">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          </span>
          <span data-ttu-id="8747b-121">Ce champ est en lecture seule et respecte la casse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-121">This field is case-sensitive and read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-122">Le filtre prend en charge une fin « \* » générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-122">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-123">L’exemple suivant affiche les noms de module qui correspondent aux critères de recherche spécifiés.</span><span class="sxs-lookup"><span data-stu-id="8747b-123">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterTypeNameIgnoreCase : System.Reflection.TypeFilter" Usage="System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-124">Objet <see langword="TypeFilter" /> qui permet de filtrer la liste des types définis dans ce module en fonction du nom.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-124">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          </span>
          <span data-ttu-id="8747b-125">Ce champ est en lecture seule et ne respecte pas la casse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-125">This field is case-insensitive and read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-126">Le filtre prend en charge une fin « \* » générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-126">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-127">L’exemple suivant affiche les noms de module qui correspondent aux critères de recherche spécifiés, en ignorant la casse.</span><span class="sxs-lookup"><span data-stu-id="8747b-127">The following example displays the module names that match the specified search criteria, ignoring the case.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindTypes : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindTypes : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="module.FindTypes (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="8747b-128">Le délégué utilisé pour filtrer les classes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-128">The delegate used to filter the classes.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="8747b-129">Un objet utilisé pour filtrer les classes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-129">An Object used to filter the classes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-130">Retourne un tableau de classes acceptées par le filtre donné et les critères de filtre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-130">Returns an array of classes accepted by the given filter and filter criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-131">Un tableau de type <see langword="Type" /> contenant les classes qui ont été acceptées par le filtre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-131">An array of type <see langword="Type" /> containing classes that were accepted by the filter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-132"><xref:System.Reflection.ReflectionTypeLoadException> est une exception de chargement de classe spécial.</span><span class="sxs-lookup"><span data-stu-id="8747b-132"><xref:System.Reflection.ReflectionTypeLoadException> is a special class load exception.</span></span> <span data-ttu-id="8747b-133">Le `ReflectionTypeLoadException.Types` propriété contient le tableau de classes qui ont été définies dans le module et chargées.</span><span class="sxs-lookup"><span data-stu-id="8747b-133">The `ReflectionTypeLoadException.Types` property contains the array of classes that were defined in the module and were loaded.</span></span> <span data-ttu-id="8747b-134">Ce tableau peut contenir des valeurs null.</span><span class="sxs-lookup"><span data-stu-id="8747b-134">This array may contain some null values.</span></span> <span data-ttu-id="8747b-135">Le `ReflectionTypeLoadException.LoaderExceptions` propriété est un tableau d’exceptions qui représentent les exceptions levées par le chargeur de classes.</span><span class="sxs-lookup"><span data-stu-id="8747b-135">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the class loader.</span></span> <span data-ttu-id="8747b-136">Les trous dans le tableau de classe s’alignent sur les exceptions.</span><span class="sxs-lookup"><span data-stu-id="8747b-136">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="8747b-137">Le délégué donné par `filter` est appelé pour chaque classe dans le module, en passant le `Type` objet représentant la classe ainsi que la donnée `filterCriteria`.</span><span class="sxs-lookup"><span data-stu-id="8747b-137">The delegate given by `filter` is called for each class in the module, passing along the `Type` object representing the class as well as the given `filterCriteria`.</span></span> <span data-ttu-id="8747b-138">Si `filter` retourne un particulier de classe, que la classe est incluse dans le tableau retourné.</span><span class="sxs-lookup"><span data-stu-id="8747b-138">If `filter` returns a particular class, that class will be included in the returned array.</span></span> <span data-ttu-id="8747b-139">Si `filter` retourne `null`, toutes les classes sont retournées et `filterCriteria` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="8747b-139">If `filter` returns `null`, all classes are returned and `filterCriteria` is ignored.</span></span>  
  
 <span data-ttu-id="8747b-140">`FindTypes` ne peut pas être utilisé pour rechercher des types paramétrés tels que des tableaux.</span><span class="sxs-lookup"><span data-stu-id="8747b-140">`FindTypes` cannot be used to look up parameterized types such as arrays.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-141">L’exemple suivant montre le `FindTypes` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-141">The following example demonstrates the `FindTypes` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="8747b-142">Au moins une des classes d’un module n’a pas pu être chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-142">One or more classes in a module could not be loaded.</span>
          </span>
        </exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedName : string" Usage="System.Reflection.Module.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-143">Obtient une chaîne représentant le nom qualifié complet et le chemin d'accès de ce module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-143">Gets a string representing the fully qualified name and path to this module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-144">Nom qualifié complet du module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-144">The fully qualified module name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-145">Pour obtenir le nom sans le chemin d’accès, utilisez <xref:System.Reflection.Module.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="8747b-145">To get the name without the path, use <xref:System.Reflection.Module.Name%2A>.</span></span>  
  
 <span data-ttu-id="8747b-146">Si l’assembly de ce module a été chargé à partir d’un tableau d’octets le `FullyQualifiedName` pour le module sera : \<inconnue >.</span><span class="sxs-lookup"><span data-stu-id="8747b-146">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-147">La casse du nom de module est dépendante de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="8747b-147">The case of module name is platform-dependent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-148">L’exemple suivant affiche le nom qualifié complet du module spécifié.</span><span class="sxs-lookup"><span data-stu-id="8747b-148">The following example displays the fully qualified name of the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8747b-149">L’appelant n’a pas les autorisations requises.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-149">The caller does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="8747b-150">Pour accéder aux informations contenues dans le chemin d’accès.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-150">for access to information in the path.</span>
          </span>
          <span data-ttu-id="8747b-151">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-151">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-152">Retourne les attributs personnalisés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-152">Returns custom attributes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="module.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="8747b-153">Cet argument est ignoré pour les objets de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-153">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-154">Retourne tous les attributs personnalisés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-154">Returns all custom attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-155">Tableau de type <see langword="Object" /> contenant tous les attributs personnalisés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-155">An array of type <see langword="Object" /> containing all custom attributes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8747b-156">L’exemple suivant affiche les noms de module qui correspondent aux critères de recherche spécifiés.</span><span class="sxs-lookup"><span data-stu-id="8747b-156">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="module.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="8747b-157">Type de l'attribut à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-157">The type of attribute to get.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="8747b-158">Cet argument est ignoré pour les objets de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-158">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-159">Obtient les attributs personnalisés du type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-159">Gets custom attributes of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-160">Tableau de type <see langword="Object" /> contenant tous les attributs personnalisés du type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-160">An array of type <see langword="Object" /> containing all custom attributes of the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8747b-161">L’exemple suivant affiche les noms de module du type spécifié qui correspondent aux critères de recherche spécifiés.</span><span class="sxs-lookup"><span data-stu-id="8747b-161">The following example displays the module names of the specified type that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-162">
            <paramref name="attributeType" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-162">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-163">
            <paramref name="attributeType" /> n’est pas un objet <see cref="T:System.Type" /> fourni par le runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-163">
              <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          </span>
          <span data-ttu-id="8747b-164">Par exemple, <paramref name="attributeType" /> est un objet <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-164">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="module.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-165">Retourne une liste d'objets <see cref="T:System.Reflection.CustomAttributeData" /> pour le module actuel, qui peuvent être utilisés dans le contexte de réflexion uniquement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-165">Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects for the current module, which can be used in the reflection-only context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-166">Liste générique d’objets <see cref="T:System.Reflection.CustomAttributeData" /> représentant des données sur les attributs qui ont été appliqués au module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-166">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-167">Utilisez cette méthode pour examiner les attributs personnalisés du code dans le contexte de réflexion uniquement, dans les cas où les attributs personnalisés eux-mêmes sont définis dans le code qui est chargé dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="8747b-167">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="8747b-168">Méthodes telles que <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> et <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> ne peut pas être utilisé dans ce cas, car ils créent des instances des attributs.</span><span class="sxs-lookup"><span data-stu-id="8747b-168">Methods such as <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="8747b-169">Impossible d’exécuter le code dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="8747b-169">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="8747b-170">Pour plus d’informations et des exemples de code, consultez la <xref:System.Reflection.CustomAttributeData> classe.</span><span class="sxs-lookup"><span data-stu-id="8747b-170">For more information and example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-171">Retourne un champ spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-171">Returns a specified field.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="module.GetField name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8747b-172">Nom du champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-172">The field name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-173">Retourne un champ portant le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-173">Returns a field having the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-174">Objet <see langword="FieldInfo" /> portant le nom spécifié, ou <see langword="null" /> si le champ n’existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-174">A <see langword="FieldInfo" /> object having the specified name, or <see langword="null" /> if the field does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-175">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-175">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="module.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8747b-176">Nom du champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-176">The field name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="8747b-177">Un des indicateurs à un bit <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-177">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-178">Retourne un champ portant le nom et les attributs de liaison spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-178">Returns a field having the specified name and binding attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-179">Objet <see langword="FieldInfo" /> portant le nom et les attributs de liaison spécifiés, ou <see langword="null" /> si le champ n’existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-179">A <see langword="FieldInfo" /> object having the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-180">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-180">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-181">Retourne les champs globaux définis sur le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-181">Returns the global fields defined on the module.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="module.GetFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-182">Retourne les champs globaux définis sur le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-182">Returns the global fields defined on the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-183">Un tableau d’objets <see cref="T:System.Reflection.FieldInfo" /> représentant les champs globaux définis sur le module ; s’il n’y a aucun champ global, un tableau vide est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-183">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-184">Le <xref:System.Reflection.Module.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="8747b-184">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="8747b-185">Votre code ne doit pas dépendent de l’ordre dans lequel les champs sont retournés, car cet ordre peut varier.</span><span class="sxs-lookup"><span data-stu-id="8747b-185">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="module.GetFields bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">
          <span data-ttu-id="8747b-186">Combinaison de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limitent la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-186">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-187">Retourne les champs globaux définis sur le module, qui correspondent aux indicateurs de liaison spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-187">Returns the global fields defined on the module that match the specified binding flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-188">Tableau de type <see cref="T:System.Reflection.FieldInfo" /> représentant les champs globaux définis sur le module, qui correspondent aux indicateurs de liaison spécifiés. Si aucun champ global ne correspond aux indicateurs de liaison, un tableau vide est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-188">An array of type <see cref="T:System.Reflection.FieldInfo" /> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-189">Le <xref:System.Reflection.Module.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="8747b-189">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="8747b-190">Votre code ne doit pas dépendent de l’ordre dans lequel les champs sont retournés, car cet ordre peut varier.</span><span class="sxs-lookup"><span data-stu-id="8747b-190">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="module.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-191">Retourne le code de hachage de cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-191">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-192">Code de hachage d'un entier signé 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-192">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-193">Retourne une méthode ayant les critères spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-193">Returns a method having the specified criteria.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8747b-194">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-194">The method name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-195">Retourne une méthode portant le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-195">Returns a method having the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-196">Objet <see langword="MethodInfo" /> portant le nom spécifié, ou <see langword="null" /> si la méthode n’existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-196">A <see langword="MethodInfo" /> object having the specified name, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-197">
            <paramref name="name" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-197">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8747b-198">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-198">The method name.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="8747b-199">Types de paramètre à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-199">The parameter types to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-200">Retourne une méthode avec les types de paramètre et de nom spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-200">Returns a method having the specified name and parameter types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-201">Objet <see langword="MethodInfo" /> conforme aux critères spécifiés ou <see langword="null" /> si la méthode n’existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-201">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-202">
            <paramref name="name" /> a la valeur <see langword="null" />, <paramref name="types" /> a la valeur <see langword="null" /> ou <paramref name="types" /> (i) a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-202">
              <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8747b-203">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-203">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="8747b-204">Un des indicateurs à un bit <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-204">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="8747b-205">Objet qui implémente <see langword="Binder" />, contenant les propriétés associées à cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-205">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="8747b-206">Convention d’appel de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-206">The calling convention for the method.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="8747b-207">Types de paramètre à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-207">The parameter types to search for.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="8747b-208">Tableau de modificateurs de paramètres utilisé pour que la liaison fonctionne avec des signatures de paramètres dans lesquelles les types ont été modifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-208">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-209">Retourne une méthode avec le nom, les informations de liaison, la convention d’appel ainsi que les types et modificateurs de paramètres spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-209">Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-210">Objet <see langword="MethodInfo" /> conforme aux critères spécifiés ou <see langword="null" /> si la méthode n’existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-210">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-211">
            <paramref name="name" /> a la valeur <see langword="null" />, <paramref name="types" /> a la valeur <see langword="null" /> ou <paramref name="types" /> (i) a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-211">
              <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8747b-212">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-212">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="8747b-213">Un des indicateurs à un bit <see langword="BindingFlags" /> utilisés pour contrôler la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-213">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="8747b-214">Objet qui implémente <see langword="Binder" />, contenant les propriétés associées à cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-214">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="8747b-215">Convention d’appel de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-215">The calling convention for the method.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="8747b-216">Types de paramètre à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-216">The parameter types to search for.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="8747b-217">Tableau de modificateurs de paramètres utilisé pour que la liaison fonctionne avec des signatures de paramètres dans lesquelles les types ont été modifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-217">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-218">Retourne l'implémentation de méthode, conformément aux critères spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-218">Returns the method implementation in accordance with the specified criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-219">Objet <see langword="MethodInfo" /> contenant les informations relatives à l'implémentation, comme spécifié, ou <see langword="null" /> si la méthode n'existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-219">A <see langword="MethodInfo" /> object containing implementation information as specified, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="8747b-220">
            <paramref name="types" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-220">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-221">Retourne les méthodes globales définies sur le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-221">Returns the global methods defined on the module</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="module.GetMethods " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-222">Retourne les méthodes globales définies sur le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-222">Returns the global methods defined on the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-223">Tableau d’objets <see cref="T:System.Reflection.MethodInfo" /> représentant toutes les méthodes globales définies sur le module ; s’il n’y a aucune méthode globale, un tableau vide est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-223">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="module.GetMethods bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">
          <span data-ttu-id="8747b-224">Combinaison de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limitent la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-225">Retourne les méthodes globales, définies sur le module, qui correspondent aux indicateurs de liaison spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-225">Returns the global methods defined on the module that match the specified binding flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-226">Tableau de type <see cref="T:System.Reflection.MethodInfo" /> représentant les méthodes globales, définies sur le module, qui correspondent aux indicateurs de liaison spécifiés ; si aucune méthode globale ne correspond aux indicateurs de liaison, un tableau vide est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-226">An array of type <see cref="T:System.Reflection.MethodInfo" /> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="module.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="8747b-227">Informations et données nécessaires pour la sérialisation et la désérialisation d'un objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-227">The information and data needed to serialize or deserialize an object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="8747b-228">Contexte pour la sérialisation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-228">The context for the serialization.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-229">Fournit une implémentation de <see cref="T:System.Runtime.Serialization.ISerializable" /> pour les objets sérialisés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-229">Provides an <see cref="T:System.Runtime.Serialization.ISerializable" /> implementation for serialized objects.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-230">
            <paramref name="info" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-230">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8747b-231">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-231">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8747b-232">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-232">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberSignature Language="F#" Value="abstract member GetPEKind :  *  -&gt; unit&#xA;override this.GetPEKind :  *  -&gt; unit" Usage="module.GetPEKind (peKind, machine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">
          <span data-ttu-id="8747b-233">Cette méthode retourne une combinaison des valeurs <see cref="T:System.Reflection.PortableExecutableKinds" /> indiquant la nature du code dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-233">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</span>
          </span>
        </param>
        <param name="machine">
          <span data-ttu-id="8747b-234">Cette méthode retourne une des valeurs <see cref="T:System.Reflection.ImageFileMachine" /> indiquant la plateforme ciblée par le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-234">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-235">Obtient une paire de valeurs indiquant la nature du code dans un module et la plateforme ciblée par le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-235">Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberSignature Language="F#" Value="abstract member GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate&#xA;override this.GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate" Usage="module.GetSignerCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-236">Retourne un objet <see langword="X509Certificate" /> correspondant au certificat inclus dans la signature Authenticode de l'assembly auquel appartient ce module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-236">Returns an <see langword="X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</span>
          </span>
          <span data-ttu-id="8747b-237">Si l'assembly n'est pas signé avec Authenticode, <see langword="null" /> est retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-237">If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-238">Un objet <see langword="X509Certificate" />, ou <see langword="null" /> si l'assembly auquel appartient ce module n'est pas signé avec Authenticode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-238">An <see langword="X509Certificate" /> object, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-239">Retourne le type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-239">Returns the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="module.GetType className" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="8747b-240">Le nom du type à localiser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-240">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="8747b-241">Le nom doit être complet avec l’espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-241">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-242">Retourne le type spécifié en exécutant une recherche qui respecte la casse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-242">Returns the specified type, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-243">Objet <see langword="Type" /> représentant le type donné, si le type est dans ce module, sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-243">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="8747b-244">Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="8747b-244">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="8747b-245">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="8747b-245">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="8747b-246">Un type peut être récupéré à partir d’un module spécifique <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8747b-246">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8747b-247">Appel de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> sur le module qui contient le manifeste ne recherche pas la totalité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="8747b-247">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="8747b-248">Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8747b-248">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-249">L’exemple suivant affiche le nom d’un type dans le module spécifié.</span><span class="sxs-lookup"><span data-stu-id="8747b-249">The following example displays the name of a type in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-250">
            <paramref name="className" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-250">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="8747b-251">Les initialiseurs de classe sont appelés et une exception est levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-251">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-252">
            <paramref name="className" /> est une chaîne de longueur nulle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-252">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="8747b-253">
            <paramref name="className" /> requiert un assembly dépendant qui est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-253">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="8747b-254">
            <paramref name="className" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-254">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="8747b-255">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-255">-or-</span>
          </span>
          <span data-ttu-id="8747b-256">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="className" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-256">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="8747b-257">
            <paramref name="className" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-257">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="8747b-258">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-258">-or-</span>
          </span>
          <span data-ttu-id="8747b-259">
            <paramref name="className" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-259">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="module.GetType (className, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="8747b-260">Le nom du type à localiser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-260">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="8747b-261">Le nom doit être complet avec l’espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-261">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="8747b-262">
            <see langword="true" /> pour une recherche qui ne respecte pas la casse ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-262">
              <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-263">Retourne le type spécifié, en parcourant le module avec la casse spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-263">Returns the specified type, searching the module with the specified case sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-264">Objet <see langword="Type" /> représentant le type donné, si le type est dans ce module, sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-264">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="8747b-265">Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="8747b-265">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="8747b-266">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="8747b-266">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="8747b-267">Un type peut être récupéré à partir d’un module spécifique <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8747b-267">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8747b-268">Appel de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> sur le module qui contient le manifeste ne recherche pas la totalité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="8747b-268">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="8747b-269">Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8747b-269">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-270">L’exemple suivant affiche le nom d’un type dans le module spécifié, en spécifiant `false` pour le `ignoreCase` paramètre donc ce cas sont ignoré.</span><span class="sxs-lookup"><span data-stu-id="8747b-270">The following example displays the name of a type in the specified module, specifying `false` for the `ignoreCase` parameter so that case will not be ignored.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-271">
            <paramref name="className" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-271">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="8747b-272">Les initialiseurs de classe sont appelés et une exception est levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-272">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-273">
            <paramref name="className" /> est une chaîne de longueur nulle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-273">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="8747b-274">
            <paramref name="className" /> requiert un assembly dépendant qui est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-274">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="8747b-275">
            <paramref name="className" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-275">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="8747b-276">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-276">-or-</span>
          </span>
          <span data-ttu-id="8747b-277">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="className" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-277">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="8747b-278">
            <paramref name="className" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-278">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="8747b-279">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-279">-or-</span>
          </span>
          <span data-ttu-id="8747b-280">
            <paramref name="className" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-280">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="module.GetType (className, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="8747b-281">Le nom du type à localiser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-281">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="8747b-282">Le nom doit être complet avec l’espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-282">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="8747b-283">
            <see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-283">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="8747b-284">
            <see langword="true" /> pour une recherche qui ne respecte pas la casse ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-284">
              <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-285">Retourne le type spécifié, en spécifiant s'il faut faire une recherche du module respectant la casse et s'il faut lever une exception si le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-285">Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-286">Objet <see cref="T:System.Type" /> représentant le type spécifié, s'il est déclaré dans ce module ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-286">A <see cref="T:System.Type" /> object representing the specified type, if the type is declared in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-287">Le `throwOnError` paramètre affecte uniquement ce qui se passe lorsque le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="8747b-287">The `throwOnError` parameter affects only what happens when the type is not found.</span></span> <span data-ttu-id="8747b-288">Il n’affecte pas toutes les exceptions levées.</span><span class="sxs-lookup"><span data-stu-id="8747b-288">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="8747b-289">En particulier, si le type est trouvé mais ne peut pas être chargé, <xref:System.TypeLoadException> peut être levée même si `throwOnError` est `false`.</span><span class="sxs-lookup"><span data-stu-id="8747b-289">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-290">Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="8747b-290">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="8747b-291">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="8747b-291">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="8747b-292">Un type peut être récupéré à partir d’un module spécifique <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8747b-292">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8747b-293">Appel de <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> sur le module qui contient le manifeste ne recherche pas la totalité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="8747b-293">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="8747b-294">Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8747b-294">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-295">L’exemple suivant affiche le nom d’un type dans le module spécifié.</span><span class="sxs-lookup"><span data-stu-id="8747b-295">The following example displays the name of a type in the specified module.</span></span> <span data-ttu-id="8747b-296">Le `throwOnError` et `ignoreCase` paramètres sont spécifiés en tant que `false`.</span><span class="sxs-lookup"><span data-stu-id="8747b-296">The `throwOnError` and `ignoreCase` parameters are specified as `false`.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-297">
            <paramref name="className" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-297">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="8747b-298">Les initialiseurs de classe sont appelés et une exception est levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-298">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-299">
            <paramref name="className" /> est une chaîne de longueur nulle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-299">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="8747b-300">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-300">
              <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="8747b-301">
            <paramref name="className" /> requiert un assembly dépendant qui est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-301">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="8747b-302">
            <paramref name="className" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-302">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="8747b-303">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-303">-or-</span>
          </span>
          <span data-ttu-id="8747b-304">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="className" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-304">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="8747b-305">
            <paramref name="className" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-305">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="8747b-306">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-306">-or-</span>
          </span>
          <span data-ttu-id="8747b-307">
            <paramref name="className" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-307">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="module.GetTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-308">Retourne tous les types définis dans ce module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-308">Returns all the types defined within this module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-309">Tableau de type <see langword="Type" /> contenant les types définis dans le module reflété par cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-309">An array of type <see langword="Type" /> containing types defined within the module that is reflected by this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-310">`ReflectionTypeLoadException` est une exception de chargement spéciales.</span><span class="sxs-lookup"><span data-stu-id="8747b-310">`ReflectionTypeLoadException` is a special load exception.</span></span> <span data-ttu-id="8747b-311">Le `ReflectionTypeLoadException.Types` propriété contient le tableau de types qui ont été définies dans le module et chargées.</span><span class="sxs-lookup"><span data-stu-id="8747b-311">The `ReflectionTypeLoadException.Types` property contains the array of types that were defined in the module and were loaded.</span></span> <span data-ttu-id="8747b-312">Ce tableau peut contenir des valeurs null.</span><span class="sxs-lookup"><span data-stu-id="8747b-312">This array may contain some null values.</span></span> <span data-ttu-id="8747b-313">Le `ReflectionTypeLoadException.LoaderExceptions` propriété est un tableau d’exceptions qui représentent les exceptions levées par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="8747b-313">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the loader.</span></span> <span data-ttu-id="8747b-314">Les trous dans le tableau de classe s’alignent sur les exceptions.</span><span class="sxs-lookup"><span data-stu-id="8747b-314">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="8747b-315">Par exemple, si les initialiseurs de classe d’une des classes lève une exception lors de son chargement, un `TargetInvocationException` est stocké dans l’élément correspondant de le `LoaderExceptions` tableau.</span><span class="sxs-lookup"><span data-stu-id="8747b-315">For example, if the class initializers of one of the classes throws an exception while it is being loaded, a `TargetInvocationException` is stored in the corresponding element of the `LoaderExceptions` array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-316">Si un type a été transféré à un autre assembly, il n’est pas inclus dans le tableau retourné.</span><span class="sxs-lookup"><span data-stu-id="8747b-316">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="8747b-317">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="8747b-317">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="8747b-318">Au moins une des classes d’un module n’a pas pu être chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-318">One or more classes in a module could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8747b-319">L'appelant n'a pas l'autorisation requise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-319">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8747b-320">Autorisation de réflexion pour le module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-320">Reflection permission for the current module.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="module.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="8747b-321">Type de l'attribut personnalisé à tester.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-321">The type of custom attribute to test for.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="8747b-322">Cet argument est ignoré pour les objets de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-322">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-323">Retourne une valeur qui indique si le type d'attribut spécifié a été appliqué à ce module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-323">Returns a value that indicates whether the specified attribute type has been applied to this module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-324">
            <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" /> ont été appliquées à ce module ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-324">
              <see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8747b-325">L’exemple suivant montre une utilisation de la `IsDefined` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-325">The following example demonstrates a use of the `IsDefined` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8747b-326">
            <paramref name="attributeType" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-326">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-327">
            <paramref name="attributeType" /> n’est pas un objet <see cref="T:System.Type" /> fourni par le runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-327">
              <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          </span>
          <span data-ttu-id="8747b-328">Par exemple, <paramref name="attributeType" /> est un objet <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-328">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberSignature Language="F#" Value="abstract member IsResource : unit -&gt; bool&#xA;override this.IsResource : unit -&gt; bool" Usage="module.IsResource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-329">Obtient une valeur indiquant si l'objet est une ressource.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-329">Gets a value indicating whether the object is a resource.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-330">
            <see langword="true" /> si l'objet est une ressource ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-330">
              <see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8747b-331">L’exemple suivant montre une utilisation de la `IsResource` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-331">The following example demonstrates a use of the `IsResource` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MDStreamVersion : int" Usage="System.Reflection.Module.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-332">Obtient la version de flux des métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-332">Gets the metadata stream version.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-333">Entier 32 bits représentant la version de flux des métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-333">A 32-bit integer representing the metadata stream version.</span>
          </span>
          <span data-ttu-id="8747b-334">Les deux octets de poids fort représentent le numéro de la version principale, et les deux octets de poids faible représentent le numéro de la version secondaire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-334">The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="8747b-335">Pour plus d’informations sur l’en-tête de métadonnées, consultez « Partition II : Metadata Definition and Semantics » dans la documentation du Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="8747b-335">For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</span></span> <span data-ttu-id="8747b-336">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-336">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.Module.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-337">Obtient un jeton qui identifie le module dans les métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-337">Gets a token that identifies the module in metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-338">Jeton d'entier qui identifie le module actuel dans les métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-338">An integer token that identifies the current module in metadata.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-339">Les jetons obtenus à l’aide de cette propriété peuvent être passés à l’API de réflexion non managée.</span><span class="sxs-lookup"><span data-stu-id="8747b-339">The tokens obtained using this property can be passed to the unmanaged Reflection API.</span></span> <span data-ttu-id="8747b-340">Pour plus d’informations, consultez [API de réflexion non managée](https://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span><span class="sxs-lookup"><span data-stu-id="8747b-340">For more information, see [Unmanaged Reflection API](https://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-341">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-341">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-342">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-342">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleHandle : ModuleHandle" Usage="System.Reflection.Module.ModuleHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-343">Obtient un handle pour le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-343">Gets a handle for the module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-344">Structure <see cref="T:System.ModuleHandle" /> pour le module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-344">A <see cref="T:System.ModuleHandle" /> structure for the current module.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleVersionId : Guid" Usage="System.Reflection.Module.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-345">Obtient un identificateur unique universel (UUID) qui peut être utilisé pour faire la distinction entre deux versions d’un module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-345">Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-346">
            <see cref="T:System.Guid" /> qui peut être utilisé pour faire la distinction entre deux versions d’un module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-346">A <see cref="T:System.Guid" /> that can be used to distinguish between two versions of a module.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-347">Dans les métadonnées non managées, le GUID renvoyé par le <xref:System.Reflection.Module.ModuleVersionId%2A> propriété est appelée le `mvid`et est stocké dans le tas GUID.</span><span class="sxs-lookup"><span data-stu-id="8747b-347">In unmanaged metadata, the GUID returned by the <xref:System.Reflection.Module.ModuleVersionId%2A> property is referred to as the `mvid`, and is stored in the GUID heap.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-348">Vous trouverez plus d’informations sur les métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-348">More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-349">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-349">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Module.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-350">Obtient un <see langword="String" /> représentant le nom du module, sans le chemin d'accès.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-350">Gets a <see langword="String" /> representing the name of the module with the path removed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-351">Nom du module sans le chemin d'accès.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-351">The module name with no path.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-352">`Name` est une chaîne dépend de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="8747b-352">`Name` is a platform-dependent string.</span></span>  
  
 <span data-ttu-id="8747b-353">Si l’assembly de ce module a été chargé à partir d’un tableau d’octets le `FullyQualifiedName` pour le module sera : \<inconnue >.</span><span class="sxs-lookup"><span data-stu-id="8747b-353">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
 <span data-ttu-id="8747b-354">Pour obtenir le nom et le chemin d’accès, utilisez <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="8747b-354">To get the name and the path, use <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-355">Cet exemple montre l’effet de la `ScopeName`, `FullyQualifiedName`, et `Name` propriétés.</span><span class="sxs-lookup"><span data-stu-id="8747b-355">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Module * System.Reflection.Module -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="8747b-356">Premier objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-356">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="8747b-357">Deuxième objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-357">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-358">Indique si deux objets <see cref="T:System.Reflection.Module" /> sont égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-358">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-359">
            <see langword="true" /> si <paramref name="left" /> est égal à <paramref name="right" /> ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-359">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Module * System.Reflection.Module -&gt; bool" Usage="System.Reflection.Module.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="8747b-360">Premier objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-360">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="8747b-361">Deuxième objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-361">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-362">Indique si deux objets <see cref="T:System.Reflection.Module" /> ne sont pas égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-362">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-363">
            <see langword="true" /> si <paramref name="left" /> n'est pas égal à <paramref name="right" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-363">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-364">Retourne le champ identifié par un jeton de métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-364">Returns the field identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveField : int -&gt; System.Reflection.FieldInfo" Usage="module.ResolveField metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-365">Jeton de métadonnées qui identifie un champ dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-365">A metadata token that identifies a field in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-366">Retourne le champ identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-366">Returns the field identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-367">Objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-367">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-368">Pour résoudre un jeton de métadonnées qui identifie un champ dont le parent `TypeSpec` a une signature contenant le type d’élément `ELEMENT_TYPE_VAR` ou `ELEMENT_TYPE_MVAR`, utilisez le <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, qui vous permet de fournir le contexte nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8747b-368">To resolve a metadata token that identifies a field whose parent `TypeSpec` has a signature containing element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="8747b-369">Autrement dit, lors de la résolution d’un jeton de métadonnées pour un champ qui dépend des paramètres de type générique de type générique ou de la méthode générique, dans laquelle le jeton est incorporé, vous devez utiliser la surcharge qui vous permet de fournir les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="8747b-369">That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-370">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-370">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-371">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-371">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="8747b-372">Pour le code qui montre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique, dans laquelle le jeton est incorporé) consultez le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-372">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-373">
            <paramref name="metadataToken" /> n'est pas un jeton de champ dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-373">
              <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          </span>
          <span data-ttu-id="8747b-374">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-374">-or-</span>
          </span>
          <span data-ttu-id="8747b-375">
            <paramref name="metadataToken" /> identifie un champ dont le <see langword="TypeSpec" /> parent a une signature qui contient le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-375">
              <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-376">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-376">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo&#xA;override this.ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo" Usage="module.ResolveField (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-377">Jeton de métadonnées qui identifie un champ dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-377">A metadata token that identifies a field in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="8747b-378">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-378">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="8747b-379">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-379">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-380">Retourne le champ identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-380">Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-381">Objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-381">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-382">Utilisez le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur le type où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="8747b-382">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="8747b-383">Utilisez le <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur la méthode où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="8747b-383">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="8747b-384">Il est toujours plus sûr de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="8747b-384">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-385">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-385">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-386">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-386">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="8747b-387">Pour le code qui montre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique, dans laquelle le jeton est incorporé) consultez le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-387">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-388">
            <paramref name="metadataToken" /> n'est pas un jeton de champ dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-388">
              <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          </span>
          <span data-ttu-id="8747b-389">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-389">-or-</span>
          </span>
          <span data-ttu-id="8747b-390">
            <paramref name="metadataToken" /> identifie un champ dont le <see langword="TypeSpec" /> parent a une signature contenant le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-390">
              <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-391">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-391">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-392">Retourne le type ou le membre identifié par un jeton de métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-392">Returns the type or member identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveMember : int -&gt; System.Reflection.MemberInfo" Usage="module.ResolveMember metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-393">Jeton de métadonnées qui identifie un type ou un membre dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-393">A metadata token that identifies a type or member in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-394">Retourne le type ou le membre identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-394">Returns the type or member identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-395">Objet <see cref="T:System.Reflection.MemberInfo" /> représentant le type ou le membre identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-395">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-396">Pour résoudre un jeton de métadonnées pour un `MethodSpec` ou `TypeSpec` dont la signature contient le type d’élément `ELEMENT_TYPE_VAR` ou `ELEMENT_TYPE_MVAR`, utilisez le <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, qui vous permet de fournir le contexte nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8747b-396">To resolve a metadata token for a `MethodSpec` or `TypeSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="8747b-397">Autrement dit, lorsque vous résolvez un jeton de métadonnées pour un membre qui dépend des paramètres de type générique de type générique ou de la méthode générique, dans laquelle le jeton est incorporé, vous devez utiliser la surcharge qui vous permet de fournir les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="8747b-397">That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-398">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-398">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-399">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-399">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="8747b-400">Pour le code qui montre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique, dans laquelle le jeton est incorporé) consultez le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-400">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-401">
            <paramref name="metadataToken" /> n'est pas un jeton pour un type ou un membre dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-401">
              <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          </span>
          <span data-ttu-id="8747b-402">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-402">-or-</span>
          </span>
          <span data-ttu-id="8747b-403">
            <paramref name="metadataToken" /> est un <see langword="MethodSpec" /> ou un <see langword="TypeSpec" /> dont la signature contient le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-403">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
          <span data-ttu-id="8747b-404">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-404">-or-</span>
          </span>
          <span data-ttu-id="8747b-405">
            <paramref name="metadataToken" /> identifie une propriété ou un événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-405">
              <paramref name="metadataToken" /> identifies a property or event.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-406">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-406">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo&#xA;override this.ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo" Usage="module.ResolveMember (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-407">Jeton de métadonnées qui identifie un type ou un membre dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-407">A metadata token that identifies a type or member in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="8747b-408">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-408">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="8747b-409">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-409">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-410">Retourne le type ou le membre identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-410">Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-411">Objet <see cref="T:System.Reflection.MemberInfo" /> représentant le type ou le membre identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-411">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-412">Utilisez le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur le type où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="8747b-412">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="8747b-413">Utilisez le <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur la méthode où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="8747b-413">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="8747b-414">Il est toujours plus sûr de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="8747b-414">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-415">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-415">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-416">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="8747b-417">Pour le code qui montre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique, dans laquelle le jeton est incorporé) consultez le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-417">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-418">
            <paramref name="metadataToken" /> n'est pas un jeton pour un type ou un membre dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-418">
              <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          </span>
          <span data-ttu-id="8747b-419">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-419">-or-</span>
          </span>
          <span data-ttu-id="8747b-420">
            <paramref name="metadataToken" /> est un <see langword="MethodSpec" /> ou <see langword="TypeSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-420">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
          <span data-ttu-id="8747b-421">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-421">-or-</span>
          </span>
          <span data-ttu-id="8747b-422">
            <paramref name="metadataToken" /> identifie une propriété ou un événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-422">
              <paramref name="metadataToken" /> identifies a property or event.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-423">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-423">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-424">Retourne la méthode identifiée par un jeton de métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-424">Returns the method identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveMethod : int -&gt; System.Reflection.MethodBase" Usage="module.ResolveMethod metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-425">Jeton de métadonnées qui identifie une méthode ou un constructeur dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-425">A metadata token that identifies a method or constructor in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-426">Retourne la méthode ou le constructeur identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-426">Returns the method or constructor identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-427">Objet <see cref="T:System.Reflection.MethodBase" /> représentant la méthode ou le constructeur identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-427">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-428">Pour résoudre un jeton de métadonnées pour un `MethodSpec` dont la signature contient le type d’élément `ELEMENT_TYPE_VAR` ou `ELEMENT_TYPE_MVAR`, utilisez le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, qui vous permet de fournir le contexte nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8747b-428">To resolve a metadata token for a `MethodSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="8747b-429">Autrement dit, lors de la résolution d’un jeton de métadonnées pour une méthode qui dépend des paramètres de type générique du type générique et/ou de la méthode générique, dans laquelle le jeton est incorporé, vous devez utiliser la surcharge qui vous permet de fournir les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="8747b-429">That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-430">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-430">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-431">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-431">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-432">L’exemple suivant montre comment utiliser les deux surcharges de la <xref:System.Reflection.Module.ResolveMethod%2A> méthode pour résoudre les jetons de métadonnées à partir de l’appel de sites dans des contextes génériques et non génériques.</span><span class="sxs-lookup"><span data-stu-id="8747b-432">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="8747b-433">L’exemple de code définit deux types génériques, `G1<Tg1>` et `G2<Tg2>` (`G1(Of Tg1)` et `G2(Of Tg2)` en Visual Basic), chacun d'entre eux ayant une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-433">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>` (`G1(Of Tg1)` and `G2(Of Tg2)` in Visual Basic), each of which has a generic method.</span></span> <span data-ttu-id="8747b-434">`G1<Tg1>` a également une méthode non générique qui utilise le paramètre de type `Tg1` pour son paramètre.</span><span class="sxs-lookup"><span data-stu-id="8747b-434">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="8747b-435">La méthode générique `GM2<Tgm2>` dans type `G2<Tg2>` contient plusieurs appels de méthode :</span><span class="sxs-lookup"><span data-stu-id="8747b-435">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="8747b-436">Cas 1 : La méthode générique `GM1<Tgm1>` est appelée, à l’aide des paramètres de type de `G2<Tg2>` et `GM2<Tgm2>` comme arguments de type.</span><span class="sxs-lookup"><span data-stu-id="8747b-436">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="8747b-437">En d’autres termes, les types de paramètres de la méthode appelée varie sur les types qui sont utilisés pour construire un type générique fermé à partir de la définition de type pour `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="8747b-437">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="8747b-438">Cas 2 : La méthode non générique `M1` est appelée.</span><span class="sxs-lookup"><span data-stu-id="8747b-438">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="8747b-439">Le paramètre de cette méthode utilise le paramètre de type du type définissant, `G1<Tg1>`, qui est remplacé dans ce cas par le paramètre de type du type englobant, `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="8747b-439">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="8747b-440">Cas 3 : La méthode générique `GM1<Tgm1>` est appelé, en spécifiant <xref:System.Int32> et <xref:System.Object> pour les arguments de type du type générique et la méthode générique, respectivement.</span><span class="sxs-lookup"><span data-stu-id="8747b-440">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="8747b-441">Cet appel de méthode ne dépend pas de paramètres de type de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="8747b-441">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="8747b-442">Cas 4 : La méthode non générique `M1` de la `Example` classe est appelée.</span><span class="sxs-lookup"><span data-stu-id="8747b-442">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="8747b-443">Cet appel de méthode ne dépend pas de paramètres de type de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="8747b-443">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="8747b-444">En outre, l’exemple définit le non générique `Example` classe.</span><span class="sxs-lookup"><span data-stu-id="8747b-444">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="8747b-445">Cette classe possède une méthode `M` qui effectue un appel à une méthode générique :</span><span class="sxs-lookup"><span data-stu-id="8747b-445">This class has a method `M` that makes a call to a generic method:</span></span>  
  
-   <span data-ttu-id="8747b-446">Cas 5 : La méthode générique `GM1` est appelé, en spécifiant <xref:System.Int32> et <xref:System.Object> pour les arguments de type du type générique et la méthode générique, respectivement.</span><span class="sxs-lookup"><span data-stu-id="8747b-446">Case 5: The generic method `GM1` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="8747b-447">Le contexte de cette méthode n’a aucun englobante type générique ou méthode générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-447">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="8747b-448">Pour chaque cas, l’exemple construit d’abord un <xref:System.Reflection.MethodInfo> qui représente la méthode appelée, puis il résout le jeton à l’aide la <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, à l’aide de la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> et <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthodes pour obtenir les valeurs pour le `genericTypeArguments` et `genericMethodArguments` paramètres.</span><span class="sxs-lookup"><span data-stu-id="8747b-448">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="8747b-449">Cette technique fonctionne dans tous les cas, étant donné que les méthodes retournent <xref:System.Type.EmptyTypes?displayProperty=nameWithType> pour les contextes non génériques.</span><span class="sxs-lookup"><span data-stu-id="8747b-449">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="8747b-450">L’exemple compare résolu <xref:System.Reflection.MethodInfo> avec construit <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="8747b-450">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="8747b-451">L’exemple tente alors d’utiliser le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> surcharge de méthode pour résoudre le jeton.</span><span class="sxs-lookup"><span data-stu-id="8747b-451">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="8747b-452">Cela fonctionne dans les cas 3, 4 et 5, étant donné que les appels de méthode ne dépendent pas du contexte générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-452">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="8747b-453">Dans les cas 1 et 2, une exception est levée, car les informations sont insuffisantes pour résoudre le jeton.</span><span class="sxs-lookup"><span data-stu-id="8747b-453">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="8747b-454">Les valeurs de jeton de métadonnées sont codées en dur en tant qu’énumération.</span><span class="sxs-lookup"><span data-stu-id="8747b-454">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="8747b-455">Si vous modifiez cet exemple de code, les valeurs de jeton sont susceptibles de changer.</span><span class="sxs-lookup"><span data-stu-id="8747b-455">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="8747b-456">Pour déterminer les nouvelles valeurs de jeton, compilez le code et utilisez Ildasm.exe avec le **/jetons** option pour examiner l’assembly.</span><span class="sxs-lookup"><span data-stu-id="8747b-456">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="8747b-457">Vous trouverez les jetons aux points d’appel.</span><span class="sxs-lookup"><span data-stu-id="8747b-457">The tokens can be found at the points of call.</span></span> <span data-ttu-id="8747b-458">Insérez les nouvelles valeurs dans l’énumération et recompiler l’exemple.</span><span class="sxs-lookup"><span data-stu-id="8747b-458">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-459">
            <paramref name="metadataToken" /> n'est pas un jeton pour une méthode ou un constructeur dans la portée du module en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-459">
              <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          </span>
          <span data-ttu-id="8747b-460">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-460">-or-</span>
          </span>
          <span data-ttu-id="8747b-461">
            <paramref name="metadataToken" /> est un <see langword="MethodSpec" /> dont la signature contient le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-461">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-462">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-462">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase&#xA;override this.ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase" Usage="module.ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-463">Jeton de métadonnées qui identifie une méthode ou un constructeur dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-463">A metadata token that identifies a method or constructor in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="8747b-464">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-464">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="8747b-465">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-465">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-466">Retourne la méthode ou le constructeur identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-466">Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-467">Objet <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode identifiée par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-467">A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-468">Utilisez le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur le type où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="8747b-468">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="8747b-469">Utilisez le <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur la méthode où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericMethodArguments`.</span><span class="sxs-lookup"><span data-stu-id="8747b-469">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericMethodArguments`.</span></span> <span data-ttu-id="8747b-470">Il est toujours plus sûr de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="8747b-470">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-471">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-471">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-472">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-472">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-473">L’exemple suivant montre comment utiliser les deux surcharges de la <xref:System.Reflection.Module.ResolveMethod%2A> méthode pour résoudre les jetons de métadonnées à partir de l’appel de sites dans des contextes génériques et non génériques.</span><span class="sxs-lookup"><span data-stu-id="8747b-473">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="8747b-474">L’exemple de code définit deux types génériques, `G1<Tg1>` et `G2<Tg2>`, chacun d'entre eux ayant une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-474">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>`, each of which has a generic method.</span></span> <span data-ttu-id="8747b-475">`G1<Tg1>` a également une méthode non générique qui utilise le paramètre de type `Tg1` pour son paramètre.</span><span class="sxs-lookup"><span data-stu-id="8747b-475">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="8747b-476">La méthode générique `GM2<Tgm2>` dans type `G2<Tg2>` contient plusieurs appels de méthode :</span><span class="sxs-lookup"><span data-stu-id="8747b-476">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="8747b-477">Cas 1 : La méthode générique `GM1<Tgm1>` est appelée, à l’aide des paramètres de type de `G2<Tg2>` et `GM2<Tgm2>` comme arguments de type.</span><span class="sxs-lookup"><span data-stu-id="8747b-477">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="8747b-478">En d’autres termes, les types de paramètres de la méthode appelée varie sur les types qui sont utilisés pour construire un type générique fermé à partir de la définition de type pour `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="8747b-478">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="8747b-479">Cas 2 : La méthode non générique `M1` est appelée.</span><span class="sxs-lookup"><span data-stu-id="8747b-479">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="8747b-480">Le paramètre de cette méthode utilise le paramètre de type du type définissant, `G1<Tg1>`, qui est remplacé dans ce cas par le paramètre de type du type englobant, `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="8747b-480">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="8747b-481">Cas 3 : La méthode générique `GM1<Tgm1>` est appelé, en spécifiant <xref:System.Int32> et <xref:System.Object> pour les arguments de type du type générique et la méthode générique, respectivement.</span><span class="sxs-lookup"><span data-stu-id="8747b-481">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="8747b-482">Cet appel de méthode ne dépend pas de paramètres de type de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="8747b-482">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="8747b-483">Cas 4 : La méthode non générique `M1` de la `Example` classe est appelée.</span><span class="sxs-lookup"><span data-stu-id="8747b-483">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="8747b-484">Cet appel de méthode ne dépend pas de paramètres de type de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="8747b-484">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="8747b-485">En outre, l’exemple définit le non générique `Example` classe.</span><span class="sxs-lookup"><span data-stu-id="8747b-485">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="8747b-486">Cette classe possède une méthode `M` qui effectue un appel à une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-486">This class has a method `M` that makes a call to a generic method.</span></span>  
  
-   <span data-ttu-id="8747b-487">Cas 5 : La méthode générique `GM1<Tgm1>` est appelé, en spécifiant <xref:System.Int32> et <xref:System.Object> pour les arguments de type du type générique et la méthode générique, respectivement.</span><span class="sxs-lookup"><span data-stu-id="8747b-487">Case 5: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="8747b-488">Le contexte de cette méthode n’a aucun englobante type générique ou méthode générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-488">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="8747b-489">Pour chaque cas, l’exemple construit d’abord un <xref:System.Reflection.MethodInfo> qui représente la méthode appelée, puis il résout le jeton à l’aide la <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, à l’aide de la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> et <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthodes pour obtenir les valeurs pour le `genericTypeArguments` et `genericMethodArguments` paramètres.</span><span class="sxs-lookup"><span data-stu-id="8747b-489">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="8747b-490">Cette technique fonctionne dans tous les cas, étant donné que les méthodes retournent <xref:System.Type.EmptyTypes?displayProperty=nameWithType> pour les contextes non génériques.</span><span class="sxs-lookup"><span data-stu-id="8747b-490">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="8747b-491">L’exemple compare résolu <xref:System.Reflection.MethodInfo> avec construit <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="8747b-491">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="8747b-492">L’exemple tente alors d’utiliser le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> surcharge de méthode pour résoudre le jeton.</span><span class="sxs-lookup"><span data-stu-id="8747b-492">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="8747b-493">Cela fonctionne dans les cas 3, 4 et 5, étant donné que les appels de méthode ne dépendent pas du contexte générique.</span><span class="sxs-lookup"><span data-stu-id="8747b-493">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="8747b-494">Dans les cas 1 et 2, une exception est levée, car les informations sont insuffisantes pour résoudre le jeton.</span><span class="sxs-lookup"><span data-stu-id="8747b-494">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="8747b-495">Les valeurs de jeton de métadonnées sont codées en dur en tant qu’énumération.</span><span class="sxs-lookup"><span data-stu-id="8747b-495">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="8747b-496">Si vous modifiez cet exemple de code, les valeurs de jeton sont susceptibles de changer.</span><span class="sxs-lookup"><span data-stu-id="8747b-496">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="8747b-497">Pour déterminer les nouvelles valeurs de jeton, compilez le code et utilisez Ildasm.exe avec le **/jetons** option pour examiner l’assembly.</span><span class="sxs-lookup"><span data-stu-id="8747b-497">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="8747b-498">Vous trouverez les jetons aux points d’appel.</span><span class="sxs-lookup"><span data-stu-id="8747b-498">The tokens can be found at the points of call.</span></span> <span data-ttu-id="8747b-499">Insérez les nouvelles valeurs dans l’énumération et recompiler l’exemple.</span><span class="sxs-lookup"><span data-stu-id="8747b-499">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-500">
            <paramref name="metadataToken" /> n'est pas un jeton pour une méthode ou un constructeur dans la portée du module en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-500">
              <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          </span>
          <span data-ttu-id="8747b-501">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-501">-or-</span>
          </span>
          <span data-ttu-id="8747b-502">
            <paramref name="metadataToken" /> est un <see langword="MethodSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-502">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-503">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-503">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberSignature Language="F#" Value="abstract member ResolveSignature : int -&gt; byte[]&#xA;override this.ResolveSignature : int -&gt; byte[]" Usage="module.ResolveSignature metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-504">Jeton de métadonnées qui identifie une signature dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-504">A metadata token that identifies a signature in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-505">Retourne le blob de signature identifié par un jeton de métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-505">Returns the signature blob identified by a metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-506">Tableau d'octets représentant le blob de signature.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-506">An array of bytes representing the signature blob.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="8747b-507">Vous trouverez des informations sur les jetons de métadonnées et les signatures dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-507">Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-508">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-508">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-509">
            <paramref name="metadataToken" />n'est pas un <see langword="MemberRef" />, un <see langword="MethodDef" />, un <see langword="TypeSpec" />, une signature ou un jeton <see langword="FieldDef" /> valide dans la portée du module en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-509">
              <paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-510">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-510">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberSignature Language="F#" Value="abstract member ResolveString : int -&gt; string&#xA;override this.ResolveString : int -&gt; string" Usage="module.ResolveString metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-511">Jeton de métadonnées qui identifie une chaîne dans le tas de chaînes du module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-511">A metadata token that identifies a string in the string heap of the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-512">Retourne la chaîne identifiée par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-512">Returns the string identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-513">
            <see cref="T:System.String" /> contenant une valeur de chaîne du tas de chaînes des métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-513">A <see cref="T:System.String" /> containing a string value from the metadata string heap.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="8747b-514">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-514">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-515">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-515">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-516">
            <paramref name="metadataToken" /> n'est pas un jeton pour une chaîne dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-516">
              <paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-517">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-517">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-518">Retourne le type identifié par un jeton de métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-518">Returns the type identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveType : int -&gt; Type" Usage="module.ResolveType metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-519">Jeton de métadonnées qui identifie un type dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-519">A metadata token that identifies a type in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-520">Retourne le type identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-520">Returns the type identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-521">Objet <see cref="T:System.Type" /> qui représente le type identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-521">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-522">Pour résoudre un jeton de métadonnées pour un `TypeSpec` dont la signature contient `ELEMENT_TYPE_VAR` ou `ELEMENT_TYPE_MVAR`, utilisez le <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> surcharge de méthode, qui vous permet de fournir le contexte nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8747b-522">To resolve a metadata token for a `TypeSpec` whose signature contains `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="8747b-523">Autrement dit, lors de la résolution d’un jeton de métadonnées pour un type qui dépend des paramètres de type générique de type générique ou de la méthode générique, dans laquelle le jeton est incorporé, vous devez utiliser la surcharge qui vous permet de fournir les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="8747b-523">That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-524">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-524">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-525">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-525">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-526">
            <paramref name="metadataToken" /> n'est pas le jeton d'un type dans la portée du module en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-526">
              <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          </span>
          <span data-ttu-id="8747b-527">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-527">-or-</span>
          </span>
          <span data-ttu-id="8747b-528">
            <paramref name="metadataToken" /> est un <see langword="TypeSpec" /> dont la signature contient le type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-528">
              <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-529">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-529">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveType : int * Type[] * Type[] -&gt; Type&#xA;override this.ResolveType : int * Type[] * Type[] -&gt; Type" Usage="module.ResolveType (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="8747b-530">Jeton de métadonnées qui identifie un type dans le module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-530">A metadata token that identifies a type in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="8747b-531">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <see langword="null" /> si ce type n'est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-531">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="8747b-532">Tableau d'objets <see cref="T:System.Type" /> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <see langword="null" /> si cette méthode n'est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-532">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-533">Retourne le type identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-533">Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-534">Objet <see cref="T:System.Type" /> qui représente le type identifié par le jeton de métadonnées spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-534">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-535">Utilisez le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur le type où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="8747b-535">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="8747b-536">Utilisez le <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> méthode sur la méthode où `metadataToken` est dans la portée pour obtenir un tableau d’arguments de type générique pour `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="8747b-536">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="8747b-537">Il est toujours plus sûr de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="8747b-537">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8747b-538">Vous trouverez des informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="8747b-538">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8747b-539">La documentation est disponible en ligne. consultez [ECMA c# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="8747b-539">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="8747b-540">Pour le code qui montre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique, dans laquelle le jeton est incorporé) consultez le <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-540">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8747b-541">
            <paramref name="metadataToken" /> n'est pas le jeton d'un type dans la portée du module en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-541">
              <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          </span>
          <span data-ttu-id="8747b-542">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-542">-or-</span>
          </span>
          <span data-ttu-id="8747b-543">
            <paramref name="metadataToken" /> est un <see langword="TypeSpec" /> dont la signature contient un type d'élément <see langword="var" /> (un paramètre de type d'un type générique) ou <see langword="mvar" /> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" /> (ou pour les deux).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-543">
              <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8747b-544">
            <paramref name="metadataToken" /> n'est pas un jeton valide dans la portée du module actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-544">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScopeName : string" Usage="System.Reflection.Module.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8747b-545">Obtient une chaîne représentant le nom du module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-545">Gets a string representing the name of the module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8747b-546">Nom du module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-546">The module name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-547">Le `ScopeName` propriété n’est pas utilisée par le common language runtime, mais vous pouvez l’utiliser pour stocker n’importe quelle chaîne que vous souhaitez dans la propriété lorsque vous émettez un module à l’aide de l’API de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="8747b-547">The `ScopeName` property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</span></span> <span data-ttu-id="8747b-548">Réflexion proprement dit ne vous permet pas de définir le `ScopeName` propriété.</span><span class="sxs-lookup"><span data-stu-id="8747b-548">Reflection itself does not allow you to set the `ScopeName` property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8747b-549">Cet exemple montre l’effet de la `ScopeName`, `FullyQualifiedName`, et `Name` propriétés.</span><span class="sxs-lookup"><span data-stu-id="8747b-549">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="8747b-550">Réservé à un usage ultérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-550">Reserved for future use.</span>
          </span>
          <span data-ttu-id="8747b-551">Doit être IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-551">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="8747b-552">Tableau passé des noms à mapper.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-552">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="8747b-553">Compte des noms à mapper.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-553">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8747b-554">Contexte des paramètres régionaux dans lequel interpréter les noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-554">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="8747b-555">Tableau, alloué par l'appelant, qui reçoit les ID correspondant aux noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-555">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-556">Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-556">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-557">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="8747b-557">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8747b-558">Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="8747b-558">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8747b-559">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-559">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="8747b-560">Informations de type à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-560">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8747b-561">Identificateur des paramètres régionaux pour les informations de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-561">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="8747b-562">Reçoit un pointeur vers l'objet d'informations de type demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-562">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-563">Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-563">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-564">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="8747b-564">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8747b-565">Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="8747b-565">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8747b-566">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-566">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="8747b-567">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-567">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-568">Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-568">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-569">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="8747b-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8747b-570">Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="8747b-570">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8747b-571">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="8747b-572">Identifie le membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-572">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="8747b-573">Réservé à un usage ultérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-573">Reserved for future use.</span>
          </span>
          <span data-ttu-id="8747b-574">Doit être IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-574">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8747b-575">Contexte des paramètres régionaux dans lequel interpréter les arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-575">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="8747b-576">Indicateurs décrivant le contexte de l'appel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-576">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="8747b-577">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-577">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="8747b-578">Pointeur vers l'emplacement où le résultat doit être stocké.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-578">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="8747b-579">Pointeur vers une structure qui contient les informations sur les exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-579">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="8747b-580">Index du premier argument comportant une erreur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-580">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8747b-581">Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-581">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8747b-582">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="8747b-582">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8747b-583">Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="8747b-583">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8747b-584">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-584">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="module.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8747b-585">Retourne le nom du module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-585">Returns the name of the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8747b-586">
            <see langword="String" /> représentant le nom de ce module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8747b-586">A <see langword="String" /> representing the name of this module.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8747b-587">L’exemple suivant montre une utilisation de la `ToString` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8747b-587">The following example demonstrates a use of the `ToString` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>