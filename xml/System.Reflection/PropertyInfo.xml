<Type Name="PropertyInfo" FullName="System.Reflection.PropertyInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f8855b4214d11dfdc6a06fd63df550d25f741b16" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37640747" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PropertyInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._PropertyInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit PropertyInfo extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._PropertyInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.PropertyInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PropertyInfo&#xA;Inherits MemberInfo&#xA;Implements _PropertyInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyInfo abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_PropertyInfo" />
  <TypeSignature Language="F#" Value="type PropertyInfo = class&#xA;    inherit MemberInfo&#xA;    interface _PropertyInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._PropertyInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._PropertyInfo))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Discovers the attributes of a property and provides access to property metadata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés sont logiquement les mêmes en tant que champs. Une propriété est un aspect nommé de l’état d’un objet dont la valeur est généralement accessible via `get` et `set` accesseurs. Propriétés peuvent être en lecture seule, auquel cas une routine de jeu n’est pas pris en charge.  
  
> [!NOTE]
>  Pour déterminer si une propriété est `static`, vous devez obtenir le <xref:System.Reflection.MethodInfo> pour le `get` ou `set` accesseur, en appelant le <xref:System.Reflection.PropertyInfo.GetGetMethod%2A> ou le <xref:System.Reflection.PropertyInfo.GetSetMethod%2A> (méthode) et examiner ses <xref:System.Reflection.MethodBase.IsStatic%2A> propriété.  
  
 Plusieurs méthodes de cette classe supposent que le `get` accesseur et `set` méthodes d’accesseur d’une propriété utilisent des formats spécifiques. Les signatures de la `get` et `set` méthodes doivent correspondre à la convention suivante :  
  
-   Le type de retour de la `get` (méthode) et le dernier argument de la `set` méthode doit être identique. Il s’agit du type de la propriété.  
  
-   Le `get` et `set` les méthodes doivent avoir le même nombre, type et ordre d’index.  
  
 Si ce format n’est pas respecté, le comportement de la `GetValue` et `SetValue` méthodes n’est pas défini.  
  
 Appel <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A?displayProperty=nameWithType> sur `PropertyInfo` lorsque le `inherit` paramètre de `GetCustomAttributes` est `true` ne décrit pas la hiérarchie des types. Utilisez <xref:System.Attribute?displayProperty=nameWithType> pour hériter des attributs personnalisés.  
  
   
  
## Examples  
 Cet exemple montre comment utiliser les diverses classes de réflexion pour analyser les métadonnées contenues dans un assembly.  
  
> [!NOTE]
>  Cet exemple génère environ 55 000 lignes de données, que vous pouvez rediriger vers un fichier texte à l’invite de commandes, comme suit : **example.exe > propertyinfo.txt**  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Cette classe ne peut pas être héritée par du code partiellement fiable.</permission>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Lorsque vous héritez de <see cref="T:System.Reflection.PropertyInfo" />, vous devez substituer les membres suivants : <see cref="M:System.Reflection.PropertyInfo.GetValue(System.Object,System.Object[])" />, <see cref="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.PropertyInfo.GetAccessors(System.Boolean)" />, <see cref="M:System.Reflection.PropertyInfo.GetGetMethod(System.Boolean)" />, <see cref="M:System.Reflection.PropertyInfo.GetSetMethod(System.Boolean)" />, et <see cref="M:System.Reflection.PropertyInfo.GetIndexParameters" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Reflection.PropertyInfo" /> class.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.PropertyAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As PropertyAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::PropertyAttributes Attributes { System::Reflection::PropertyAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.PropertyAttributes" Usage="System.Reflection.PropertyInfo.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the attributes for this property.</summary>
        <value>Les attributs de cette propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.PropertyInfo.Attributes%2A> propriété retourne les attributs associés à la propriété représentée par ce <xref:System.Reflection.PropertyInfo> objet.  Les attributs sont principalement les modificateurs appliqués par un compilateur lors de la création d’une propriété ; ils indiquent si une propriété est la propriété par défaut, un `SpecialName` propriété et ainsi de suite. Notez que, pour presque toutes les propriétés trouvées dans les types dans la bibliothèque de classes .NET Framework, la valeur de la <xref:System.Reflection.PropertyInfo.Attributes%2A> propriété est <xref:System.Reflection.PropertyAttributes.None?displayProperty=nameWithType>.  
  
> [!TIP]
>  Dans la plupart des cas, vous souhaitez récupérer les attributs personnalisés associés à une propriété. Pour ce faire, récupérez la valeur de la <xref:System.Reflection.MemberInfo.CustomAttributes%2A> propriété ou appeler l’une des surcharges de la <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> (méthode).  
  
 Pour obtenir le <xref:System.Reflection.PropertyInfo.Attributes%2A> propriété :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le type auquel appartient la propriété.  
  
2.  Obtenir le <xref:System.Reflection.PropertyInfo> objet en appelant une surcharge de la <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> (méthode).  
  
3.  Récupérer les attributs de la propriété à partir de la <xref:System.Reflection.PropertyInfo.Attributes%2A> propriété.  
  
 Vous pouvez définir les attributs d’une propriété pour un type créé dynamiquement à l’aide de la réflexion émettre en appelant une surcharge de la <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A> (méthode) et en fournissant une valeur pour le `attributes` argument.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MemberInfo.CustomAttributes" />
        <altmember cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Reflection.PropertyInfo.CanRead" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.CanRead</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the property can be read.</summary>
        <value>
          <see langword="true" /> si la propriété peut être lue ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la propriété n’a pas un `get` accesseur, il ne peut pas être lu.  
  
 Pour obtenir le `CanRead` propriété, commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le `PropertyInfo`. À partir de la `PropertyInfo`, obtenir le `CanRead` valeur.  
  
   
  
## Examples  
 L’exemple suivant définit deux propriétés. La première propriété est lisible et `CanRead` propriété est `true`. La deuxième propriété n’est pas lisible (il n’est pas d’accesseur get) et le `CanRead` propriété est `false`.  
  
 [!code-cpp[Classic PropertyInfo.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Reflection.PropertyInfo.CanWrite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.CanWrite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the property can be written to.</summary>
        <value>
          <see langword="true" /> s'il est possible d'écrire dans la propriété ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.PropertyInfo.CanWrite%2A> Retourne `true` si la propriété possède un `set` accesseur, même si l’accesseur est `private`, `internal` (ou `Friend` en Visual Basic), ou `protected`.   Si la propriété n’a pas un `set` accesseur, la méthode retourne `false`.  
  
 Pour obtenir la valeur de la <xref:System.Reflection.PropertyInfo.CanWrite%2A> propriété :  
  
1.  Obtenir le <xref:System.Type> objet du type qui inclut la propriété.  
  
2.  Appelez le <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> pour obtenir le <xref:System.Reflection.PropertyInfo> objet qui représente la propriété.  
  
3.  Récupérer la valeur de la <xref:System.Reflection.PropertyInfo.CanWrite%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant définit deux propriétés. La première propriété est accessible en écriture et le `CanWrite` propriété est `true`. La deuxième propriété n’est pas accessible en écriture (il existe aucune `set` accesseur) et le `CanWrite` propriété est `false`.  
  
 [!code-cpp[Classic PropertyInfo.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="propertyInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">An object to compare with this instance, or <see langword="null" />.</param>
        <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessors">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an array of the <see langword="get" /> and <see langword="set" /> accessors on this property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessors">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetAccessors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetAccessors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetAccessors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessors () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetAccessors();" />
      <MemberSignature Language="F#" Value="abstract member GetAccessors : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetAccessors : unit -&gt; System.Reflection.MethodInfo[]" Usage="propertyInfo.GetAccessors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetAccessors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array whose elements reflect the public <see langword="get" /> and <see langword="set" /> accessors of the property reflected by the current instance.</summary>
        <returns>An array of <see cref="T:System.Reflection.MethodInfo" /> objects that reflect the public <see langword="get" /> and <see langword="set" /> accessors of the property reflected by the current instance, if found; otherwise, this method returns an array with zero (0) elements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour appeler le <xref:System.Reflection.PropertyInfo.GetAccessors%2A> méthode :  
  
1.  Obtenir un <xref:System.Type> objet qui représente la classe.  
  
2.  À partir de la <xref:System.Type> d’objet, obtenir le <xref:System.Reflection.PropertyInfo> objet.  
  
3.  À partir de la <xref:System.Reflection.PropertyInfo> de l’objet, appelez le <xref:System.Reflection.PropertyInfo.GetAccessors%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant récupère les accesseurs publics de la `ClassWithProperty.Caption` propriété et affiche des informations à leur sujet. Il appelle également la <xref:System.Reflection.MethodBase.Invoke%2A> méthode de la méthode setter pour définir la valeur de propriété et de l’accesseur Get pour récupérer la valeur de propriété.  
  
 [!code-csharp[System.Reflection.PropertyInfo.GetAccessors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.propertyinfo.getaccessors/cs/source.cs#1)]
 [!code-vb[System.Reflection.PropertyInfo.GetAccessors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.propertyinfo.getaccessors/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetAccessors (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetAccessors(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetAccessors(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAccessors (nonPublic As Boolean) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetAccessors(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetAccessors : bool -&gt; System.Reflection.MethodInfo[]" Usage="propertyInfo.GetAccessors nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetAccessors(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">Indicates whether non-public methods should be returned in the returned array. <see langword="true" /> if non-public methods are to be included; otherwise, <see langword="false" />.</param>
        <summary>Returns an array whose elements reflect the public and, if specified, non-public <see langword="get" /> and <see langword="set" /> accessors of the property reflected by the current instance.</summary>
        <returns>An array whose elements reflect the <see langword="get" /> and <see langword="set" /> accessors of the property reflected by the current instance. If <paramref name="nonPublic" /> is <see langword="true" />, this array contains public and non-public <see langword="get" /> and <see langword="set" /> accessors. If <paramref name="nonPublic" /> is <see langword="false" />, this array contains only public <see langword="get" /> and <see langword="set" /> accessors. If no accessors with the specified visibility are found, this method returns an array with zero (0) elements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour appeler le <xref:System.Reflection.PropertyInfo.GetAccessors%2A> méthode :  
  
1.  Obtenir un <xref:System.Type> objet qui représente la classe.  
  
2.  À partir de la <xref:System.Type> d’objet, obtenir le <xref:System.Reflection.PropertyInfo> objet.  
  
3.  À partir de la <xref:System.Reflection.PropertyInfo> de l’objet, appelez le <xref:System.Reflection.PropertyInfo.GetAccessors%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant récupère les accesseurs de la `ClassWithProperty.Caption` propriété et affiche des informations à leur sujet. Il appelle également la <xref:System.Reflection.MethodBase.Invoke%2A> méthode de la méthode setter pour définir la valeur de propriété et de l’accesseur Get pour récupérer la valeur de propriété.  
  
 [!code-csharp[Classic PropertyInfo.GetAccessors1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetAccessors1 Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.GetAccessors1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.GetAccessors1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetConstantValue">
      <MemberSignature Language="C#" Value="public virtual object GetConstantValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetConstantValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetConstantValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConstantValue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetConstantValue();" />
      <MemberSignature Language="F#" Value="abstract member GetConstantValue : unit -&gt; obj&#xA;override this.GetConstantValue : unit -&gt; obj" Usage="propertyInfo.GetConstantValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a literal value associated with the property by a compiler.</summary>
        <returns>An <see cref="T:System.Object" /> that contains the literal value associated with the property. If the literal value is a class type with an element value of zero, the return value is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour les concepteurs de compilateurs managés et des analyseurs de code.  
  
> [!NOTE]
>  N’utilisez pas cette méthode dans le contexte de réflexion uniquement, car il peut provoquer l’exécution de code. Utilisez plutôt la méthode <xref:System.Reflection.PropertyInfo.GetRawConstantValue%2A>.  
  
 Dans les métadonnées non managées, la table Constant est utilisée pour stocker les valeurs de constante pour les champs, des paramètres et des propriétés. Informations constantes n’influencent pas directement le comportement d’exécution. Les compilateurs inspectent ces informations au moment de la compilation, lors de l’importation de métadonnées. Si utilisé, la valeur d’une constante est incorporée dans le flux de Microsoft intermediate language (MSIL) le compilateur émet. Il n’existe aucune instruction MSIL qui peut être utilisée pour accéder à la table constante au moment de l’exécution.  
  
> [!NOTE]
>  Pour plus d’informations sur les valeurs de constante et la table Constant, consultez la documentation ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The Constant table in unmanaged metadata does not contain a constant value for the current property.</exception>
        <exception cref="T:System.FormatException">The type of the value is not one of the types permitted by the Common Language Specification (CLS). See the ECMA Partition II specification, Metadata.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see langword="MethodInfo" /> representing the <see langword="get" /> accessor for this property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetGetMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGetMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetGetMethod" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGetMethod () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetGetMethod();" />
      <MemberSignature Language="F#" Value="abstract member GetGetMethod : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetGetMethod : unit -&gt; System.Reflection.MethodInfo" Usage="propertyInfo.GetGetMethod " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetGetMethod</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the public <see langword="get" /> accessor for this property.</summary>
        <returns>A <see langword="MethodInfo" /> object representing the public <see langword="get" /> accessor for this property, or <see langword="null" /> if the <see langword="get" /> accessor is non-public or does not exist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui fournit une implémentation pour l’abstraite `GetGetMethod` méthode avec le `nonPublic` paramètre défini sur `false`.  
  
 Pour utiliser le `GetGetMethod` (méthode), commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le <xref:System.Reflection.PropertyInfo>. À partir de la <xref:System.Reflection.PropertyInfo>, utilisez le `GetGetMethod` (méthode).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetGetMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetGetMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGetMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetGetMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetGetMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetGetMethod(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetGetMethod : bool -&gt; System.Reflection.MethodInfo" Usage="propertyInfo.GetGetMethod nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetGetMethod(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">Indicates whether a non-public <see langword="get" /> accessor should be returned. <see langword="true" /> if a non-public accessor is to be returned; otherwise, <see langword="false" />.</param>
        <summary>When overridden in a derived class, returns the public or non-public <see langword="get" /> accessor for this property.</summary>
        <returns>A <see langword="MethodInfo" /> object representing the <see langword="get" /> accessor for this property, if <paramref name="nonPublic" /> is <see langword="true" />. Returns <see langword="null" /> if <paramref name="nonPublic" /> is <see langword="false" /> and the <see langword="get" /> accessor is non-public, or if <paramref name="nonPublic" /> is <see langword="true" /> but no <see langword="get" /> accessors exist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est le <xref:System.Reflection.MethodInfo> représentant l’accesseur get.  
  
 Pour utiliser le `GetGetMethod` (méthode), commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le <xref:System.Reflection.PropertyInfo>. À partir de la <xref:System.Reflection.PropertyInfo>, utilisez le `GetGetMethod` (méthode).  
  
   
  
## Examples  
 L’exemple suivant affiche le public ou non public `get` accesseur pour la propriété spécifiée.  
  
 [!code-cpp[Classic PropertyInfo.GetGetMethod1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetGetMethod1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.GetGetMethod1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetGetMethod1 Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.GetGetMethod1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.GetGetMethod1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The requested method is non-public and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission" /> to reflect on this non-public method.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="propertyInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIndexParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetIndexParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetIndexParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetIndexParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetIndexParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetIndexParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetIndexParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="propertyInfo.GetIndexParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetIndexParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns an array of all the index parameters for the property.</summary>
        <returns>An array of type <see langword="ParameterInfo" /> containing the parameters for the indexes. If the property is not indexed, the array has 0 (zero) elements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Permet d’extraire des informations de paramètre obligatoire à partir du tableau retourné.  
  
 Pour utiliser le `GetIndexParameters` (méthode), commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le `PropertyInfo`. À partir de la `PropertyInfo`, utilisez le `GetIndexParameters` (méthode).  
  
   
  
## Examples  
 L’exemple suivant affiche les paramètres d’index de la propriété spécifiée.  
  
 [!code-cpp[Classic PropertyInfo.GetIndexParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetIndexParameters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.GetIndexParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetIndexParameters Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.GetIndexParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.GetIndexParameters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo GetMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo GetMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.GetMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GetMethod As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ GetMethod { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GetMethod : System.Reflection.MethodInfo" Usage="System.Reflection.PropertyInfo.GetMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see langword="get" /> accessor for this property.</summary>
        <value>Accesseur <see langword="get" /> de cette propriété.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOptionalCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetOptionalCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetOptionalCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetOptionalCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOptionalCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetOptionalCustomModifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetOptionalCustomModifiers : unit -&gt; Type[]&#xA;override this.GetOptionalCustomModifiers : unit -&gt; Type[]" Usage="propertyInfo.GetOptionalCustomModifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of types representing the optional custom modifiers of the property.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects that identify the optional custom modifiers of the current property, such as <see cref="T:System.Runtime.CompilerServices.IsConst" /> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.PropertyInfo.GetOptionalCustomModifiers%2A> et <xref:System.Reflection.PropertyInfo.GetRequiredCustomModifiers%2A> méthodes sont fournies pour les concepteurs de compilateurs managés. Pour plus d’informations sur les modificateurs personnalisés, consultez <xref:System.Runtime.CompilerServices.IsBoxed> et les classes associées dans le <xref:System.Runtime.CompilerServices> espace de noms et la spécification de métadonnées dans la documentation ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawConstantValue">
      <MemberSignature Language="C#" Value="public virtual object GetRawConstantValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetRawConstantValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetRawConstantValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRawConstantValue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetRawConstantValue();" />
      <MemberSignature Language="F#" Value="abstract member GetRawConstantValue : unit -&gt; obj&#xA;override this.GetRawConstantValue : unit -&gt; obj" Usage="propertyInfo.GetRawConstantValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a literal value associated with the property by a compiler.</summary>
        <returns>An <see cref="T:System.Object" /> that contains the literal value associated with the property. If the literal value is a class type with an element value of zero, the return value is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour les concepteurs de compilateurs managés et des analyseurs de code.  
  
 Cette méthode peut être utilisée dans le contexte d’exécution et le contexte de réflexion uniquement.  
  
 Dans les métadonnées non managées, la table Constant est utilisée pour stocker les valeurs de constante pour les champs, des paramètres et des propriétés. Informations constantes n’influencent pas directement le comportement d’exécution. Les compilateurs inspectent ces informations au moment de la compilation, lors de l’importation de métadonnées. Si utilisé, la valeur d’une constante est incorporée dans le flux de Microsoft intermediate language (MSIL) le compilateur émet. Il n’existe aucune instruction MSIL qui peut être utilisée pour accéder à la table constante au moment de l’exécution.  
  
> [!NOTE]
>  Pour plus d’informations sur les valeurs de constante et la table Constant, consultez la documentation ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The Constant table in unmanaged metadata does not contain a constant value for the current property.</exception>
        <exception cref="T:System.FormatException">The type of the value is not one of the types permitted by the Common Language Specification (CLS). See the ECMA Partition II specification, Metadata Logical Format: Other Structures, Element Types used in Signatures.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequiredCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetRequiredCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetRequiredCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetRequiredCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRequiredCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetRequiredCustomModifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetRequiredCustomModifiers : unit -&gt; Type[]&#xA;override this.GetRequiredCustomModifiers : unit -&gt; Type[]" Usage="propertyInfo.GetRequiredCustomModifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of types representing the required custom modifiers of the property.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects that identify the required custom modifiers of the current property, such as <see cref="T:System.Runtime.CompilerServices.IsConst" /> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.PropertyInfo.GetOptionalCustomModifiers%2A> et <xref:System.Reflection.PropertyInfo.GetRequiredCustomModifiers%2A> méthodes sont fournies pour les concepteurs de compilateurs managés. Pour plus d’informations sur les modificateurs personnalisés, consultez <xref:System.Runtime.CompilerServices.IsBoxed> et les classes associées dans le <xref:System.Runtime.CompilerServices> espace de noms et la spécification de métadonnées dans la documentation ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see cref="T:System.Reflection.MethodInfo" /> representing the <see langword="set" /> accessor for this property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetSetMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetSetMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetSetMethod" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetMethod () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetSetMethod();" />
      <MemberSignature Language="F#" Value="abstract member GetSetMethod : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetSetMethod : unit -&gt; System.Reflection.MethodInfo" Usage="propertyInfo.GetSetMethod " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetSetMethod</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the public <see langword="set" /> accessor for this property.</summary>
        <returns>The <see langword="MethodInfo" /> object representing the <see langword="Set" /> method for this property if the <see langword="set" /> accessor is public, or <see langword="null" /> if the <see langword="set" /> accessor is not public.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui fournit une implémentation pour l’abstraite `GetSetMethod` méthode avec le `nonPublic` paramètre défini sur `false`.  
  
 Pour utiliser le `GetSetMethod` (méthode), commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le <xref:System.Reflection.PropertyInfo>. À partir de la `PropertyInfo`, utilisez le `GetSetMethod` (méthode).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetSetMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetSetMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetSetMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetSetMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetSetMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetSetMethod(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetSetMethod : bool -&gt; System.Reflection.MethodInfo" Usage="propertyInfo.GetSetMethod nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetSetMethod(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">Indicates whether the accessor should be returned if it is non-public. <see langword="true" /> if a non-public accessor is to be returned; otherwise, <see langword="false" />.</param>
        <summary>When overridden in a derived class, returns the <see langword="set" /> accessor for this property.</summary>
        <returns>This property's <see langword="Set" /> method, or <see langword="null" />, as shown in the following table.  
  
 <list type="table"><listheader><term> Value  </term><description> Condition  </description></listheader><item><term> The <see langword="Set" /> method for this property.  </term><description> The <see langword="set" /> accessor is public.  -or-  <paramref name="nonPublic" /> is <see langword="true" /> and the <see langword="set" /> accessor is non-public.  </description></item><item><term><see langword="null" /></term><description><paramref name="nonPublic" /> is <see langword="true" />, but the property is read-only.  -or-  <paramref name="nonPublic" /> is <see langword="false" /> and the <see langword="set" /> accessor is non-public.  -or-  There is no <see langword="set" /> accessor.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser le `GetSetMethod` (méthode), commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le <xref:System.Reflection.PropertyInfo>. À partir de la `PropertyInfo`, utilisez le `GetSetMethod` (méthode).  
  
   
  
## Examples  
 L’exemple suivant affiche le `set` accesseur pour la propriété spécifiée.  
  
 [!code-cpp[Classic PropertyInfo.GetSetMethod1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetSetMethod1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.GetSetMethod1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.GetSetMethod1 Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.GetSetMethod1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.GetSetMethod1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The requested method is non-public and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission" /> to reflect on this non-public method.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="propertyInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the property value of a specified object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.GetValue : obj -&gt; obj" Usage="propertyInfo.GetValue obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object whose property value will be returned.</param>
        <summary>Returns the property value of a specified object.</summary>
        <returns>The property value of the specified object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous appelez le <xref:System.Reflection.PropertyInfo.GetValue%28System.Object%29> surcharger pour récupérer la valeur d’une propriété non indexée ; si vous essayez de récupérer la valeur d’une propriété indexée, la méthode lève un <xref:System.Reflection.TargetParameterCountException> exception. Vous pouvez déterminer si une propriété est indexée ou non en appelant le <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> (méthode). Si la longueur de retourné <xref:System.Reflection.ParameterInfo> tableau est égal à zéro, la propriété n’est pas indexée.  
  
 Il s’agit d’une méthode pratique qui fournit une implémentation pour l’abstraite <xref:System.Reflection.PropertyInfo.GetValue%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> méthode avec le <xref:System.Reflection.BindingFlags> paramètre défini sur <xref:System.Reflection.BindingFlags.Default?displayProperty=nameWithType>, le <xref:System.Reflection.Binder> définie sur `null`, le tableau d’objets de valeurs d’index défini sur `null`, et le <xref:System.Globalization.CultureInfo> défini sur `null`.  
  
   
  
## Examples  
 L’exemple suivant définit un `Planet` classe qui a deux propriétés : `Name`, le nom de la planète ; et `Distance`, distance de la planète terre. L’exemple instancie un `Planet` objet qui représente la planète Jupiter et le transmet à un `GetPropertyValues` méthode qui affiche des informations sur les propriétés et les utilise le <xref:System.Reflection.PropertyInfo.GetValue%2A> méthode pour obtenir la valeur de chaque `Planet` propriété.  
  
 [!code-csharp[System.Reflection.PropertyInfo.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.propertyinfo.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Reflection.PropertyInfo.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.propertyinfo.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public virtual object GetValue (object obj, object[] index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object obj, object[] index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetValue(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValue (obj As Object, index As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetValue(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ index);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj * obj[] -&gt; obj&#xA;override this.GetValue : obj * obj[] -&gt; obj" Usage="propertyInfo.GetValue (obj, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetValue(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="index" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">The object whose property value will be returned.</param>
        <param name="index">Optional index values for indexed properties. The indexes of indexed properties are zero-based. This value should be <see langword="null" /> for non-indexed properties.</param>
        <summary>Returns the property value of a specified object with optional index values for indexed properties.</summary>
        <returns>The property value of the specified object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si une propriété est indexée, utilisez le <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> (méthode). Si le tableau obtenu a 0 (zéro) élément, la propriété n’est pas indexée.  
  
 Il s’agit d’une méthode pratique qui fournit une implémentation pour l’abstraite `GetValue` méthode avec un `BindingFlags` paramètre de `Default`, le `Binder` définie sur `null`et le `CultureInfo` défini sur `null`.  
  
 Étant donné que les propriétés statiques appartiennent au type, pas des objets spécifiques, obtenez les propriétés statiques en passant `null` en tant qu’argument de l’objet. Par exemple, utilisez le code suivant pour obtenir la méthode statique `CurrentCulture` propriété du `CultureInfo` :  
  
```csharp  
PropertyInfo CurCultProp =   
    (typeof(CultureInfo)).GetProperty("CurrentCulture");   
Console.WriteLine("CurrCult: " +  
    CurCultProp.GetValue(null,null));  
```  
  
 Pour utiliser le `GetValue` (méthode), commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le `PropertyInfo`. À partir de la `PropertyInfo`, utilisez le `GetValue` (méthode).  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir la valeur d’une propriété indexée. Le <xref:System.String.Chars%2A?displayProperty=nameWithType> propriété est la propriété par défaut (l’indexeur en c#) de la <xref:System.String> classe.  
  
 [!code-csharp[System.Reflection.PropertyInfo.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.PropertyInfo.GetValue Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.PropertyInfo.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.PropertyInfo.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="index" /> array does not contain the type of arguments needed.  -or-  The property's <see langword="get" /> accessor is not found.</exception>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para> In the <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET for Windows Store apps</see> or the <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.  </para>
          </block>  The object does not match the target type, or a property is an instance property but <paramref name="obj" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">The number of parameters in <paramref name="index" /> does not match the number of parameters the indexed property takes.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> In the <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET for Windows Store apps</see> or the <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.  </para>
          </block>  There was an illegal attempt to access a private or protected method inside a class.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">An error occurred while retrieving the property value. For example, an index value specified for an indexed property is out of range. The <see cref="P:System.Exception.InnerException" /> property indicates the reason for the error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] index, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ index, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="propertyInfo.GetValue (obj, invokeAttr, binder, index, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="index" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">The object whose property value will be returned.</param>
        <param name="invokeAttr">A bitwise combination of the following enumeration members that specify the invocation attribute: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, and <see langword="SetProperty" />. You must specify a suitable invocation attribute. For example, to invoke a static member, set the <see langword="Static" /> flag.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <c>binder</c> is <see langword="null" />, the default binder is used.</param>
        <param name="index">Optional index values for indexed properties. This value should be <see langword="null" /> for non-indexed properties.</param>
        <param name="culture">The culture for which the resource is to be localized. If the resource is not localized for this culture, the <see cref="P:System.Globalization.CultureInfo.Parent" /> property will be called successively in search of a match. If this value is <see langword="null" />, the culture-specific information is obtained from the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> property.</param>
        <summary>When overridden in a derived class, returns the property value of a specified object that has the specified binding, index, and culture-specific information.</summary>
        <returns>The property value of the specified object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si une propriété est indexée, utilisez le <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> (méthode). Si le tableau obtenu a 0 (zéro) élément, la propriété n’est pas indexée.  
  
 Étant donné que les propriétés statiques appartiennent au type, pas des objets spécifiques, obtenez les propriétés statiques en passant `null` en tant qu’argument de l’objet. Par exemple, utilisez le code suivant pour obtenir la méthode statique `CurrentCulture` propriété du `CultureInfo` :  
  
```csharp  
PropertyInfo CurCultProp =   
       (typeof(CultureInfo)).GetProperty("CurrentCulture");   
Console.WriteLine("CurrCult: " +  
       CurCultProp.GetValue(null,null));  
```  
  
 Pour utiliser le `GetValue` (méthode), commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le `PropertyInfo`. À partir de la `PropertyInfo`, utilisez le `GetValue` (méthode).  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="index" /> array does not contain the type of arguments needed.  -or-  The property's <see langword="get" /> accessor is not found.</exception>
        <exception cref="T:System.Reflection.TargetException">The object does not match the target type, or a property is an instance property but <paramref name="obj" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">The number of parameters in <paramref name="index" /> does not match the number of parameters the indexed property takes.</exception>
        <exception cref="T:System.MethodAccessException">There was an illegal attempt to access a private or protected method inside a class.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">An error occurred while retrieving the property value. For example, an index value specified for an indexed property is out of range. The <see cref="P:System.Exception.InnerException" /> property indicates the reason for the error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.PropertyInfo.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the property is the special name.</summary>
        <value>
          <see langword="true" /> si cette propriété correspond au nom spécial ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `SpecialName` bit est défini pour signaler des membres qui sont traités de manière spécifique par certains compilateurs (tels que les accesseurs de propriété et les méthodes de surcharge d’opérateur).  
  
 Pour obtenir le `IsSpecialName` propriété, commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le `PropertyInfo`. À partir de la `PropertyInfo`, obtenir le `IsSpecialName` valeur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.PropertyInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a property.</summary>
        <value>Valeur <see cref="T:System.Reflection.MemberTypes" /> indiquant que ce membre est une propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété remplace <xref:System.Reflection.MemberInfo.MemberType%2A>. Par conséquent, lorsque vous examinez un ensemble de <xref:System.Reflection.MemberInfo> objets — par exemple, le tableau retourné par <xref:System.Type.GetMembers%2A> — le <xref:System.Reflection.MemberInfo.MemberType%2A> propriété retourne <xref:System.Reflection.MemberTypes.Property> uniquement quand un membre donné est une propriété.  
  
 `MemberType` est une classe dérivée de `MemberInfo` et spécifie le type de ce membre. Types de membres sont des constructeurs, propriétés, champs et méthodes. Dans la mesure où il s’agit d’un `PropertyInfo` propriété, le type retourné est une propriété.  
  
 Pour obtenir le `MemberType` propriété, commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le `PropertyInfo`. À partir de la `PropertyInfo`, obtenir le `MemberType` valeur.  
  
   
  
## Examples  
 L’exemple suivant affiche le type du membre spécifié.  
  
 [!code-cpp[Classic PropertyInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.PropertyInfo left, class System.Reflection.PropertyInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.op_Equality(System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As PropertyInfo, right As PropertyInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::PropertyInfo ^ left, System::Reflection::PropertyInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.PropertyInfo * System.Reflection.PropertyInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="right" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="left">The first object to compare.</param>
        <param name="right">The second object to compare.</param>
        <summary>Indicates whether two <see cref="T:System.Reflection.PropertyInfo" /> objects are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.PropertyInfo left, class System.Reflection.PropertyInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.op_Inequality(System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As PropertyInfo, right As PropertyInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::PropertyInfo ^ left, System::Reflection::PropertyInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.PropertyInfo * System.Reflection.PropertyInfo -&gt; bool" Usage="System.Reflection.PropertyInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="right" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="left">The first object to compare.</param>
        <param name="right">The second object to compare.</param>
        <summary>Indicates whether two <see cref="T:System.Reflection.PropertyInfo" /> objects are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public abstract Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Reflection.PropertyInfo.PropertyType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._PropertyInfo.PropertyType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of this property.</summary>
        <value>Type de cette propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer le type d’une propriété particulière, procédez comme suit :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le type (la classe ou structure) qui contient la propriété. Si vous travaillez avec un objet (il s’agit d’une instance d’un type), vous pouvez appeler son <xref:System.Object.GetType%2A> (méthode). Sinon, vous pouvez utiliser l’opérateur c# ou l’opérateur Visual Basic, comme l’exemple.  
  
2.  Obtenir un <xref:System.Reflection.PropertyInfo> objet qui représente la propriété qui vous intéresse. Ce faire, vous pouvez l’obtention d’un tableau de toutes les propriétés de la <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> (méthode), puis l’itération les éléments dans le tableau, ou vous peuvent récupérer le <xref:System.Reflection.PropertyInfo> objet qui représente la propriété directement en appelant le <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> méthode et en spécifiant le nom de propriété.  
  
3.  Récupérer la valeur de la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriété à partir de la <xref:System.Reflection.PropertyInfo> objet.  
  
   
  
## Examples  
 L’exemple suivant définit un `Employee` classe qui a cinq propriétés. Il utilise récupère un tableau de <xref:System.Reflection.PropertyInfo> objets qui représentent ces propriétés et affiche le nom et le type de chacun d’eux.  
  
 [!code-csharp[System.Reflection.PropertyInfo.PropertyType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.propertyinfo.propertytype/cs/propertytype1.cs#1)]
 [!code-vb[System.Reflection.PropertyInfo.PropertyType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.propertyinfo.propertytype/vb/propertytype1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo SetMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo SetMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PropertyInfo.SetMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SetMethod As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ SetMethod { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetMethod : System.Reflection.MethodInfo" Usage="System.Reflection.PropertyInfo.SetMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see langword="set" /> accessor for this property.</summary>
        <value>Le <see langword="set" /> accesseur pour cette propriété, ou <see langword="null" /> si la propriété est en lecture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupération de la valeur de la <xref:System.Reflection.PropertyInfo.SetMethod%2A> propriété est équivalente à l’appel le <xref:System.Reflection.PropertyInfo.GetSetMethod%28System.Boolean%29> méthode avec une valeur de `true` pour le `nonPublic` argument.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.PropertyInfo.GetMethod" />
        <altmember cref="P:System.Reflection.PropertyInfo.CanWrite" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the property value for a specified object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object obj, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object obj, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (obj As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ obj, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * obj -&gt; unit" Usage="propertyInfo.SetValue (obj, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object whose property value will be set.</param>
        <param name="value">The new property value.</param>
        <summary>Sets the property value of a specified object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%29> surcharge définit la valeur d’une propriété non indexée. Pour déterminer si une propriété est indexée, appelez le <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> (méthode). Si le tableau obtenu a 0 (zéro) élément, la propriété n’est pas indexée. Pour définir la valeur d’une propriété indexée, appelez le <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%2CSystem.Object%5B%5D%29> de surcharge.  
  
 Si la propriété type de ce <xref:System.Reflection.PropertyInfo> objet est un type valeur et `value` est `null`, la propriété définira la valeur par défaut pour ce type.  
  
 Il s’agit d’une méthode pratique qui appelle l’implémentation de l’exécution du résumé <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> (méthode), en spécifiant <xref:System.Reflection.BindingFlags.Default?displayProperty=nameWithType> pour le `BindingFlags` paramètre, `null` pour `Binder`, `null` pour `Object[]`et `null` pour `CultureInfo`.  
  
 Pour utiliser le <xref:System.Reflection.PropertyInfo.SetValue%2A> (méthode), commencez par en obtenir un <xref:System.Type> objet qui représente la classe. À partir de la <xref:System.Type>, obtenir le <xref:System.Reflection.PropertyInfo> objet. À partir de la <xref:System.Reflection.PropertyInfo> de l’objet, appelez le <xref:System.Reflection.PropertyInfo.SetValue%2A> (méthode).  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant déclare une classe nommée `Example` avec un `static` (`Shared` en Visual Basic) et la propriété d’une seule instance. L’exemple utilise le <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%29> valeurs de méthode pour modifier la propriété d’origine et affiche les valeurs d’origine et finales.  
  
 [!code-cpp[PropertyInfo.SetValue#2](~/samples/snippets/cpp/VS_Snippets_CLR/PropertyInfo.SetValue/cpp/example2.cpp#2)]
 [!code-csharp[PropertyInfo.SetValue#2](~/samples/snippets/csharp/VS_Snippets_CLR/PropertyInfo.SetValue/cs/example2.cs#2)]
 [!code-vb[PropertyInfo.SetValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PropertyInfo.SetValue/vb/example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The property's <see langword="set" /> accessor is not found.  -or-  <paramref name="value" /> cannot be converted to the type of <see cref="P:System.Reflection.PropertyInfo.PropertyType" />.</exception>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para> In the <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET for Windows Store apps</see> or the <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.  </para>
          </block>  The type of <paramref name="obj" /> does not match the target type, or a property is an instance property but <paramref name="obj" /> is <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> In the <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET for Windows Store apps</see> or the <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.  </para>
          </block>  There was an illegal attempt to access a private or protected method inside a class.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">An error occurred while setting the property value. The <see cref="P:System.Exception.InnerException" /> property indicates the reason for the error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public virtual void SetValue (object obj, object value, object[] index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value, object[] index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValue (obj As Object, value As Object, index As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetValue(System::Object ^ obj, System::Object ^ value, cli::array &lt;System::Object ^&gt; ^ index);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj * obj[] -&gt; unit&#xA;override this.SetValue : obj * obj * obj[] -&gt; unit" Usage="propertyInfo.SetValue (obj, value, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.SetValue(System.Object,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">The object whose property value will be set.</param>
        <param name="value">The new property value.</param>
        <param name="index">Optional index values for indexed properties. This value should be <see langword="null" /> for non-indexed properties.</param>
        <summary>Sets the property value of a specified object with optional index values for index properties.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette <xref:System.Reflection.PropertyInfo> objet est un type valeur et `value` est `null`, la propriété définit la valeur par défaut pour ce type.  
  
 Pour déterminer si une propriété est indexée, utilisez le <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> (méthode). Si le tableau obtenu a 0 (zéro) élément, la propriété n’est pas indexée.  
  
 Il s’agit d’une méthode pratique qui appelle l’implémentation de l’exécution du résumé <xref:System.Reflection.PropertyInfo.SetValue%28System.Object%2CSystem.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> (méthode), en spécifiant <xref:System.Reflection.BindingFlags.Default?displayProperty=nameWithType> pour le `BindingFlags` paramètre, `null` pour `Binder`, et `null` pour `CultureInfo`.  
  
 Pour utiliser le <xref:System.Reflection.PropertyInfo.SetValue%2A> (méthode), commencez par en obtenir un <xref:System.Type> objet qui représente la classe. À partir de la <xref:System.Type>, obtenir le <xref:System.Reflection.PropertyInfo>. À partir de la <xref:System.Reflection.PropertyInfo>, utilisez le <xref:System.Reflection.PropertyInfo.SetValue%2A> (méthode).  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant définit une classe nommée `TestClass` qui a une propriété en lecture-écriture nommée `Caption`. Il affiche la valeur par défaut de la `Caption` propriété, appelle le <xref:System.Reflection.PropertyInfo.SetValue%2A> méthode pour modifier la valeur de propriété et affiche le résultat.  
  
 [!code-cpp[Classic PropertyInfo.SetValue1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PropertyInfo.SetValue1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PropertyInfo.SetValue1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PropertyInfo.SetValue1 Example/CS/source.cs#1)]
 [!code-vb[Classic PropertyInfo.SetValue1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PropertyInfo.SetValue1 Example/VB/source.vb#1)]  
  
 Notez que, étant donné que le `Caption` propriété n’est pas un tableau de paramètres, le `index` argument est `null`.  
  
 L’exemple suivant déclare une classe nommée `Example` avec trois propriétés : une `static` propriété (`Shared` en Visual Basic), une propriété d’instance et une propriété d’instance indexée. L’exemple utilise le <xref:System.Reflection.PropertyInfo.SetValue%2A> méthode pour modifier les valeurs par défaut des propriétés et affiche les valeurs d’origine et finales.  
  
 Le nom qui est utilisé pour rechercher pour une propriété d’instance indexée avec la réflexion est différent selon le langage et les attributs appliqués à la propriété.  
  
-   Dans Visual Basic, le nom de propriété est toujours utilisé pour rechercher la propriété avec la réflexion. Vous pouvez utiliser le `Default` mot clé à la propriété par défaut de propriété indexée, auquel cas vous pouvez omettre le nom lorsque vous accédez à la propriété, comme dans cet exemple. Vous pouvez également utiliser le nom de propriété.  
  
-   En c#, la propriété d’instance indexée est une propriété par défaut appelée un indexeur, et le nom n’est jamais utilisé lors de l’accès à la propriété dans le code. Par défaut, le nom de la propriété est `Item`, et vous devez utiliser ce nom lorsque vous effectuez une recherche pour la propriété avec la réflexion. Vous pouvez utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut à donner un nom différent à l’indexeur. Dans cet exemple, le nom est `IndexedInstanceProperty`.  
  
-   En C++, le `default` spécificateur peut être utilisé pour définir une propriété indexée par défaut (indexeur de classe) de propriété indexée. Dans ce cas, le nom de la propriété par défaut est `Item`, et vous devez utiliser ce nom lorsque vous effectuez une recherche pour la propriété avec la réflexion, comme dans cet exemple. Vous pouvez utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> pour donner un nom différent à l’indexeur de classe dans la réflexion d’attribut, mais vous ne pouvez pas utiliser ce nom pour accéder à la propriété dans le code. Une propriété indexée qui n’est pas un indexeur de classe est accessible à l’aide de son nom, à la fois dans le code et dans la réflexion.  
  
 [!code-cpp[PropertyInfo.SetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/PropertyInfo.SetValue/cpp/Example.cpp#1)]
 [!code-csharp[PropertyInfo.SetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/PropertyInfo.SetValue/cs/Example.cs#1)]
 [!code-vb[PropertyInfo.SetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PropertyInfo.SetValue/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="index" /> array does not contain the type of arguments needed.  -or-  The property's <see langword="set" /> accessor is not found.  -or-  <paramref name="value" /> cannot be converted to the type of <see cref="P:System.Reflection.PropertyInfo.PropertyType" />.</exception>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para> In the <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET for Windows Store apps</see> or the <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.  </para>
          </block>  The object does not match the target type, or a property is an instance property but <paramref name="obj" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">The number of parameters in <paramref name="index" /> does not match the number of parameters the indexed property takes.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> In the <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET for Windows Store apps</see> or the <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.  </para>
          </block>  There was an illegal attempt to access a private or protected method inside a class.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">An error occurred while setting the property value. For example, an index value specified for an indexed property is out of range. The <see cref="P:System.Exception.InnerException" /> property indicates the reason for the error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] index, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ obj, System::Object ^ value, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ index, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; unit" Usage="propertyInfo.SetValue (obj, value, invokeAttr, binder, index, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="index" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">The object whose property value will be set.</param>
        <param name="value">The new property value.</param>
        <param name="invokeAttr">A bitwise combination of the following enumeration members that specify the invocation attribute: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />. You must specify a suitable invocation attribute. For example, to invoke a static member, set the <see langword="Static" /> flag.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <c>binder</c> is <see langword="null" />, the default binder is used.</param>
        <param name="index">Optional index values for indexed properties. This value should be <see langword="null" /> for non-indexed properties.</param>
        <param name="culture">The culture for which the resource is to be localized. If the resource is not localized for this culture, the <see cref="P:System.Globalization.CultureInfo.Parent" /> property will be called successively in search of a match. If this value is <see langword="null" />, the culture-specific information is obtained from the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> property.</param>
        <summary>When overridden in a derived class, sets the property value for a specified object that has the specified binding, index, and culture-specific information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette <xref:System.Reflection.PropertyInfo> objet est un type valeur et `value` est `null`, la propriété définit la valeur par défaut pour ce type.  
  
 Pour déterminer si une propriété est indexée, utilisez le <xref:System.Reflection.PropertyInfo.GetIndexParameters%2A> (méthode). Si le tableau obtenu a 0 (zéro) élément, la propriété n’est pas indexée.  
  
 Restrictions d’accès sont ignorées pour le code totalement approuvé. Autrement dit, les propriétés, méthodes, champs et constructeurs privés sont accessibles et peuvent être appelées via la réflexion chaque fois que le code est entièrement fiable.  
  
 Pour utiliser le `SetValue` (méthode), commencez par obtenir la classe `Type`. À partir de la `Type`, obtenir le `PropertyInfo`. À partir de la `PropertyInfo`, utilisez le `SetValue` (méthode).  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="index" /> array does not contain the type of arguments needed.  -or-  The property's <see langword="set" /> accessor is not found.  -or-  <paramref name="value" /> cannot be converted to the type of <see cref="P:System.Reflection.PropertyInfo.PropertyType" />.</exception>
        <exception cref="T:System.Reflection.TargetException">The object does not match the target type, or a property is an instance property but <paramref name="obj" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">The number of parameters in <paramref name="index" /> does not match the number of parameters the indexed property takes.</exception>
        <exception cref="T:System.MethodAccessException">There was an illegal attempt to access a private or protected method inside a class.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">An error occurred while setting the property value. For example, an index value specified for an indexed property is out of range. The <see cref="P:System.Exception.InnerException" /> property indicates the reason for the error.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _PropertyInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _PropertyInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_PropertyInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array which receives the IDs corresponding to the names.</param>
        <summary>Maps a set of names to a corresponding set of dispatch identifiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.GetType">
      <MemberSignature Language="C#" Value="Type _PropertyInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._PropertyInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _PropertyInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._PropertyInfo.GetType() = System::Runtime::InteropServices::_PropertyInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.PropertyInfo" /> type.</summary>
        <returns>A <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.PropertyInfo" /> type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _PropertyInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _PropertyInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_PropertyInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">Receives a pointer to the requested type information object.</param>
        <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _PropertyInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _PropertyInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_PropertyInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Points to a location that receives the number of type information interfaces provided by the object.</param>
        <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._PropertyInfo.Invoke">
      <MemberSignature Language="C#" Value="void _PropertyInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._PropertyInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PropertyInfo.System#Runtime#InteropServices#_PropertyInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _PropertyInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._PropertyInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_PropertyInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._PropertyInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifies the member.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>Provides access to properties and methods exposed by an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
  </Members>
</Type>