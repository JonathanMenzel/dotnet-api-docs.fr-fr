<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5a27c711459e7ed675df80d23d28b658e1d7b113" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ef357-101">Fournit des informations sur les méthodes et les constructeurs.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ef357-101">Provides information about methods and constructors.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-102">`MethodBase` est la classe de base de <xref:System.Reflection.MethodInfo> et <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="ef357-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="ef357-103">pour la confiance totale pour les héritiers de.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ef357-103">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="ef357-104">Cette classe ne peut pas être héritée par du code partiellement fiable.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ef357-104">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="ef357-105">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ef357-105">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="ef357-106">Lorsque vous héritez de <see langword="MethodBase" />, vous devez substituer les membres suivants : <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> , <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, et <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="ef357-106">When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        </span>
      </para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ef357-107">Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-108">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ef357-109">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-110">Obtient les attributs associés à cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-110">Gets the attributes associated with this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-111">Une des valeurs de <see cref="T:System.Reflection.MethodAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-112">Tous les membres ont un ensemble d’attributs qui sont définies en fonction du type spécifique du membre.</span><span class="sxs-lookup"><span data-stu-id="ef357-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="ef357-113">Pour obtenir le <xref:System.Reflection.MethodAttributes>, tout d’abord obtenir le type.</span><span class="sxs-lookup"><span data-stu-id="ef357-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="ef357-114">À partir du type, obtenez la méthode.</span><span class="sxs-lookup"><span data-stu-id="ef357-114">From the type, get the method.</span></span> <span data-ttu-id="ef357-115">À partir de la méthode, obtenez le <xref:System.Reflection.MethodAttributes>.</span><span class="sxs-lookup"><span data-stu-id="ef357-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-116">L’exemple de code suivant affiche les attributs de la méthode Mymethod définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ef357-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="ef357-117">Ce code génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="ef357-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="ef357-118">Exemple de Reflection.MethodBase.Attributes</span><span class="sxs-lookup"><span data-stu-id="ef357-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="ef357-119">Mymethodbase = Mymethod Void (ByRef de System.String System.String ByRef, Int32)</span><span class="sxs-lookup"><span data-stu-id="ef357-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="ef357-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="ef357-120">PrivateScope</span></span>  
  
 <span data-ttu-id="ef357-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="ef357-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="ef357-122">Famille</span><span class="sxs-lookup"><span data-stu-id="ef357-122">Family</span></span>  
  
 <span data-ttu-id="ef357-123">Public</span><span class="sxs-lookup"><span data-stu-id="ef357-123">Public</span></span>  
  
 <span data-ttu-id="ef357-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="ef357-124">HideBySig</span></span>  
  
 <span data-ttu-id="ef357-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="ef357-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="ef357-126">Utilisez le <see cref="P:System.Reflection.MethodBase.Attributes" /> propriété pour déterminer si une méthode est <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, et ainsi de suite.</span>
            <span class="sxs-lookup">
              <span data-stu-id="ef357-126">Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-127">Obtient une valeur indiquant les conventions d'appel de cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-127">Gets a value indicating the calling conventions for this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-128">
            <see cref="T:System.Reflection.CallingConventions" /> de cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-129">Obtient une valeur indiquant si la méthode générique contient des paramètres de type générique non assignés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-130">
            <see langword="true" /> si l'objet <see cref="T:System.Reflection.MethodBase" /> actuel représente une méthode générique contenant des paramètres de type générique non assignés ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-130">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-131">Une méthode générique peut être appelée uniquement si aucune des définitions de type générique ou les types construits ouverts dans les arguments de type de la méthode elle-même ou dans tout type englobant.</span><span class="sxs-lookup"><span data-stu-id="ef357-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="ef357-132">Étant donné que les types peuvent être arbitrairement complexes, cette détermination récursive est difficile.</span><span class="sxs-lookup"><span data-stu-id="ef357-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="ef357-133">Pour plus de commodité et pour réduire le risque d’erreur, le <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriété fournit un moyen standard de distinguer les méthodes construites fermées, ce qui peuvent être appelés, des méthodes, ce qui ne peut pas construites ouvertes.</span><span class="sxs-lookup"><span data-stu-id="ef357-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="ef357-134">Si le <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriété renvoie `true`, la méthode ne peut pas être appelée.</span><span class="sxs-lookup"><span data-stu-id="ef357-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="ef357-135">Le <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriété recherche de manière récursive pour les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="ef357-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="ef357-136">Par exemple, elle retourne `true` pour toute méthode dans un type ouvert `A<T>` (`A(Of T)` en Visual Basic), bien que la méthode elle-même n’est pas générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="ef357-137">Ceci contraste avec le comportement de la <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriété qui retourne `false` pour une telle méthode.</span><span class="sxs-lookup"><span data-stu-id="ef357-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="ef357-138">De même, la <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> le paramètre de propriété retourne `true` pour tout autre constructeur dans un type ouvert, même si les constructeurs ne peuvent pas avoir leurs propres paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="ef357-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="ef357-139">Pour obtenir la liste des conditions invariantes des termes spécifiques aux méthodes génériques, consultez le <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="ef357-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="ef357-140">Pour obtenir la liste des conditions invariantes pour les termes utilisés dans la réflexion générique, consultez la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="ef357-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="ef357-141">Objet à comparer à cette instance ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-141">An object to compare with this instance, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-142">Retourne une valeur qui indique si cette instance est égale à un objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-142">Returns a value that indicates whether this instance is equal to a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-143">
            <see langword="true" /> si <paramref name="obj" /> est égal au type et à la valeur de cette instance ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-143">
              <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ef357-144">Retourne un <see langword="MethodBase" /> objet représentant la méthode en cours d’exécution.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-145">
            <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> est une méthode statique appelée à partir d’une méthode en cours d’exécution et qui retourne des informations sur cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-145">
              <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span>
          </span>
          <span data-ttu-id="ef357-146">Objet <see langword="MethodBase" /> représentant la méthode en cours d’exécution.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-146">A <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-147">Si la méthode en cours d’exécution est définie sur un type générique, la <xref:System.Reflection.MethodInfo> qui est retourné par <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> est obtenu à partir de la définition de type générique (autrement dit, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> retourne `true`).</span><span class="sxs-lookup"><span data-stu-id="ef357-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="ef357-148">Par conséquent, il ne reflète pas les arguments de type qui ont été utilisés lors de la méthode a été appelée.</span><span class="sxs-lookup"><span data-stu-id="ef357-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="ef357-149">Par exemple, si une méthode `M()` est défini sur un type générique `C<T>` (`C(Of T)` en Visual Basic), et <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> est appelée à partir de `C<string>.M()`, puis <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> retourne `C<T>.M()` (`C(Of T).M()` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ef357-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="ef357-150">Si la méthode en cours d’exécution est une méthode générique, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> retourne la définition de méthode générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="ef357-151">Si la méthode générique est définie sur un type générique, le <xref:System.Reflection.MethodInfo> est obtenu à partir de la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-152">L’exemple suivant définit deux types.</span><span class="sxs-lookup"><span data-stu-id="ef357-152">The following example defines two types.</span></span> <span data-ttu-id="ef357-153">La première est une classe non générique, `TestClass`, inclut un constructeur, une méthode nommée `GetValue`et une propriété en lecture-écriture nommée `GetValue`.</span><span class="sxs-lookup"><span data-stu-id="ef357-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="ef357-154">La deuxième est une classe générique nommée `TestClass<T>` qui inclut un constructeur, une `GetValue` (méthode) et une méthode générique, `ConvertValue<Y>`.</span><span class="sxs-lookup"><span data-stu-id="ef357-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="ef357-155">Chaque constructeur, une méthode et un accesseur de propriété incluent un appel à la <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ef357-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="ef357-156">Ce membre a été appelé avec un mécanisme de liaison tardive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-156">This member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-157">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ef357-158">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ef357-159">Retourne un tableau d'objets <see cref="T:System.Type" /> qui représentent les arguments de type d'une méthode générique ou les paramètres de type d'une définition de méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-160">Tableau d'objets <see cref="T:System.Type" /> qui représentent les arguments de type d'une méthode générique ou les paramètres de type d'une définition de méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
          <span data-ttu-id="ef357-161">Retourne un tableau vide si la méthode actuelle n'est pas une méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-161">Returns an empty array if the current method is not a generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-162">Les éléments du tableau retourné sont dans l’ordre dans lequel elles apparaissent dans la liste des paramètres de type pour la méthode générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="ef357-163">Si la méthode actuelle est une méthode construite fermée (autrement dit, le <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriété renvoie `false`), le tableau retourné par la <xref:System.Reflection.MethodBase.GetGenericArguments%2A> méthode contient les types qui ont été attribuées aux paramètres de type générique de la méthode générique définition.</span><span class="sxs-lookup"><span data-stu-id="ef357-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="ef357-164">Si la méthode actuelle est une définition de méthode générique, le tableau contient les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="ef357-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="ef357-165">Si la méthode actuelle est une méthode construite ouverte (autrement dit, le <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriété renvoie `true`) dans lequel des types spécifiques ont été assignés à certains paramètres de type et du type des paramètres de types génériques englobants ont été assignés à un autre type paramètres, le tableau contient les types et le type de paramètres.</span><span class="sxs-lookup"><span data-stu-id="ef357-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="ef357-166">Utilisez le <xref:System.Type.IsGenericParameter%2A> propriété pour les distinguer.</span><span class="sxs-lookup"><span data-stu-id="ef357-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="ef357-167">Pour une démonstration de ce scénario, consultez l’exemple de code fourni pour le <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="ef357-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="ef357-168">Dans .NET Framework version 2.0, les constructeurs génériques ne sont pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="ef357-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ef357-169">Cette propriété lève <xref:System.NotSupportedException> si ne pas substituée dans une classe dérivée, par conséquent, une exception est levée si l’instance actuelle est de type <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="ef357-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="ef357-170">Pour obtenir la liste des conditions invariantes des termes spécifiques aux méthodes génériques, consultez le <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="ef357-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="ef357-171">Pour obtenir la liste des conditions invariantes pour les termes utilisés dans la réflexion générique, consultez la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="ef357-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ef357-172">L'objet actuel est <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          </span>
          <span data-ttu-id="ef357-173">Dans .NET Framework version 2.0, les constructeurs génériques ne sont pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-173">Generic constructors are not supported in the .NET Framework version 2.0.</span>
          </span>
          <span data-ttu-id="ef357-174">Cette exception est le comportement par défaut si cette méthode n'est pas substituée dans une classe dérivée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-174">This exception is the default behavior if this method is not overridden in a derived class.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ef357-175">Retourne le code de hachage de cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-175">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-176">Code de hachage d'un entier signé 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-176">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ef357-177">En cas de substitution dans une classe dérivée, obtient un objet <see cref="T:System.Reflection.MethodBody" /> qui donne accès au flux MSIL, aux variables locales et aux exceptions pour la méthode actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-178">Objet <see cref="T:System.Reflection.MethodBody" /> qui donne accès au flux MSIL, aux variables locales et aux exceptions pour la méthode actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-179">Vous n’êtes pas obligé de remplacer le <xref:System.Reflection.MethodBase.GetMethodBody%2A> pour pouvoir l’utiliser.</span><span class="sxs-lookup"><span data-stu-id="ef357-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="ef357-180">Vous pouvez appeler la <xref:System.Reflection.MethodBase.GetMethodBody%2A> méthode sur <xref:System.Reflection.MethodInfo> et <xref:System.Reflection.ConstructorInfo> des objets, car la méthode est substituée dans les versions du runtime de ces classes.</span><span class="sxs-lookup"><span data-stu-id="ef357-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="ef357-181">Par exemple, la version du runtime de la <xref:System.Reflection.MethodInfo> dérive de la classe le <xref:System.Reflection.MethodInfo> (classe), qui à son tour dérive de la <xref:System.Reflection.MethodBase> classe.</span><span class="sxs-lookup"><span data-stu-id="ef357-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-182">L’exemple de code suivant définit une méthode de test nommée `MethodBodyExample` et affiche ses informations de variable locale et les clauses de gestion des exceptions.</span><span class="sxs-lookup"><span data-stu-id="ef357-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="ef357-183">Le <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> méthode est utilisée pour obtenir un <xref:System.Reflection.MethodBody> objet pour la méthode de test.</span><span class="sxs-lookup"><span data-stu-id="ef357-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="ef357-184">Le <xref:System.Reflection.MethodBody.LocalVariables%2A> propriété est utilisée pour obtenir une liste des <xref:System.Reflection.LocalVariableInfo> des objets et afficher leurs types et ordre d’index.</span><span class="sxs-lookup"><span data-stu-id="ef357-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="ef357-185">Le <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> propriété est utilisée pour obtenir une liste des clauses de gestion des exceptions.</span><span class="sxs-lookup"><span data-stu-id="ef357-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-186">Pas de tous les langages de programmation peuvent générer <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span><span class="sxs-lookup"><span data-stu-id="ef357-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="ef357-187">L’exemple Visual Basic montre une clause de filtre, l’aide de Visual Basic `When` expression, qui est omise dans les exemples pour d’autres langues.</span><span class="sxs-lookup"><span data-stu-id="ef357-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ef357-188">Cette méthode n'est pas valide, à moins qu'elle soit substituée dans une classe dérivée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-188">This method is invalid unless overridden in a derived class.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-189">Pour accéder aux métadonnées pour les membres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-189">for the access to metadata for members.</span>
          </span>
          <span data-ttu-id="ef357-190">Valeur d’autorisation : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-191">Obtient des informations sur la méthode à l'aide du handle spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-191">Gets method information using the specified handle.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="ef357-192">Handle de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-192">The method's handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-193">Obtient des informations sur une méthode en utilisant la représentation interne des métadonnées (handle) de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-193">Gets method information by using the method's internal metadata representation (handle).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-194">
            <see langword="MethodBase" /> contenant les informations sur la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-194">A <see langword="MethodBase" /> containing information about the method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-195">Poignées sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.</span><span class="sxs-lookup"><span data-stu-id="ef357-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ef357-196">
            <paramref name="handle" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-196">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-197">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ef357-198">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="ef357-199">Handle vers la représentation interne des métadonnées d'un constructeur ou d'une méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-199">A handle to the internal metadata representation of a constructor or method.</span>
          </span>
        </param>
        <param name="declaringType">
          <span data-ttu-id="ef357-200">Handle vers le type générique qui définit le constructeur ou la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-200">A handle to the generic type that defines the constructor or method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-201">Obtient un objet <see cref="T:System.Reflection.MethodBase" /> pour le constructeur ou la méthode représentés par le handle spécifié, pour le type générique donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-202">Objet <see cref="T:System.Reflection.MethodBase" /> représentant la méthode ou le constructeur spécifiés par <paramref name="handle" /> dans le type générique spécifié par <paramref name="declaringType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-203">Poignées sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.</span><span class="sxs-lookup"><span data-stu-id="ef357-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="ef357-204">A <xref:System.RuntimeMethodHandle> structure d’un constructeur ou une méthode d’un type générique peut représenter différents <xref:System.Reflection.MethodBase> objets, selon les types spécifiés pour les paramètres de type du type générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="ef357-205">Par exemple, si `class G<T>` (`class G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) possède une méthode qui retourne le type `T`, le <xref:System.Reflection.MethodBase> telles que l’objet de cette méthode dans une classe construite `G<int>` est différente de la <xref:System.Reflection.MethodBase>objet pour cette méthode dans la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ef357-206">
            <paramref name="handle" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-206">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-207">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ef357-208">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ef357-209">Lors du remplacement dans une classe dérivée, retourne les indicateurs <see cref="T:System.Reflection.MethodImplAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-210">Les indicateurs <see langword="MethodImplAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-210">The <see langword="MethodImplAttributes" /> flags.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ef357-211">L’exemple suivant définit un constructeur dans un assembly dynamique, puis utilise la <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> méthode pour afficher les indicateurs d’implémentation de méthode qui sont définis par défaut.</span><span class="sxs-lookup"><span data-stu-id="ef357-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-212">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ef357-213">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ef357-214">En cas de substitution dans une classe dérivée, obtient les paramètres de la méthode ou du constructeur spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-215">Tableau de type <see langword="ParameterInfo" /> contenant des informations correspondant à la signature de la méthode ou du constructeur réfléchi par cette instance de <see langword="MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ef357-216">L’exemple suivant utilise le <xref:System.Reflection.MethodBase.GetParameters%2A> méthode pour récupérer les paramètres de la `Invoke` méthode d’un délégué.</span><span class="sxs-lookup"><span data-stu-id="ef357-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="ef357-217">L’exemple définit un délégué nommé `MyDelegate` et un événement nommé `ev` de type `MyDelegate`.</span><span class="sxs-lookup"><span data-stu-id="ef357-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="ef357-218">Le code dans le `Main` méthode détecte la signature d’événement en obtenant le type délégué de l’événement, mise en route le `Invoke` le type délégué, la récupération et afficher les paramètres de méthode.</span><span class="sxs-lookup"><span data-stu-id="ef357-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-219">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ef357-220">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-221">Appelle la méthode ou le constructeur réfléchi par cette instance de <see langword="MethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="ef357-222">L’objet sur lequel la méthode ou le constructeur doit être appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-222">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="ef357-223">En cas de méthode statique, cet argument est ignoré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-223">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="ef357-224">En cas de constructeur statique, cet argument doit être <see langword="null" /> ou une instance de la classe qui définit le constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ef357-225">Liste d’arguments de la méthode ou du constructeur appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-225">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="ef357-226">Il s’agit d’un tableau d’objets présentant les mêmes nombre, ordre et type que les paramètres de la méthode ou du constructeur à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="ef357-227">En l’absence de paramètres, <c>parameters</c> doit avoir la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-227">If there are no parameters, <c>parameters</c> should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ef357-228">Si la méthode ou le constructeur représenté par cette instance accepte un paramètre <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic), aucun attribut spécial de ce paramètre n’est requis pour appeler la méthode ou le constructeur à l’aide de cette fonction.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="ef357-229">Tout objet de ce tableau qui n’est pas explicitement initialisé avec une valeur contiendra la valeur par défaut pour ce type d’objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="ef357-230">Pour les éléments de type référence, cette valeur est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-230">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ef357-231">Pour les éléments de type valeur, cette valeur est 0, 0.0 ou <see langword="false" />, selon le type d’élément spécifique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-232">Appelle la méthode ou le constructeur représenté par l’instance actuelle, selon les paramètres spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-233">Objet contenant la valeur de retour de la méthode appelée, ou <see langword="null" /> dans le cas d’un constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-234">Il s’agit d’une méthode pratique qui appelle la <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> surcharge de méthode, en passant <xref:System.Reflection.BindingFlags.Default> pour `invokeAttr` et `null` pour `binder` et `culture`.</span><span class="sxs-lookup"><span data-stu-id="ef357-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="ef357-235">Si la méthode appelée lève une exception, le <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> méthode retourne l’exception.</span><span class="sxs-lookup"><span data-stu-id="ef357-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="ef357-236">Pour appeler une méthode statique à l’aide de son <xref:System.Reflection.MethodInfo> de l’objet, passez `null` pour `obj`.</span><span class="sxs-lookup"><span data-stu-id="ef357-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-237">Si cette surcharge de méthode est utilisée pour appeler un constructeur d’instance, l’objet fourni pour `obj` est réinitialisé ; autrement dit, tous les initialiseurs d’instance sont exécutés.</span><span class="sxs-lookup"><span data-stu-id="ef357-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="ef357-238">La valeur de retour est `null`.</span><span class="sxs-lookup"><span data-stu-id="ef357-238">The return value is `null`.</span></span> <span data-ttu-id="ef357-239">Si un constructeur de classe est appelé, la classe est réinitialisée ; Autrement dit, tous les initialiseurs de classe sont exécutées.</span><span class="sxs-lookup"><span data-stu-id="ef357-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="ef357-240">La valeur de retour est `null`.</span><span class="sxs-lookup"><span data-stu-id="ef357-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-241">En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</span><span class="sxs-lookup"><span data-stu-id="ef357-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ef357-242">(Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="ef357-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ef357-243">Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="ef357-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="ef357-244">Si un paramètre de la méthode actuelle est un type valeur et l’argument correspondant dans `parameters` est `null`, le runtime passe une instance initialisée à zéro du type valeur.</span><span class="sxs-lookup"><span data-stu-id="ef357-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-245">L’exemple de code suivant illustre la recherche de méthode dynamique à l’aide de la réflexion.</span><span class="sxs-lookup"><span data-stu-id="ef357-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="ef357-246">Notez que vous ne pouvez pas utiliser le <xref:System.Reflection.MethodInfo> objet à partir de la classe de base pour appeler la méthode substituée dans la classe dérivée, car la liaison tardive ne peut pas résoudre les substitutions.</span><span class="sxs-lookup"><span data-stu-id="ef357-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="ef357-247">Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez <see cref="T:System.Exception" /> à la place.</span>
              <span class="sxs-lookup">
                <span data-stu-id="ef357-247">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="ef357-248">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" /> et la méthode n’est pas statique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-248">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="ef357-249">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-249">-or-</span>
          </span>
          <span data-ttu-id="ef357-250">La méthode n’est ni déclarée, ni héritée par la classe de <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-250">The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="ef357-251">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-251">-or-</span>
          </span>
          <span data-ttu-id="ef357-252">Un constructeur statique est appelé, et <paramref name="obj" /> n’est ni <see langword="null" /> ni une instance de la classe qui a déclaré le constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-252">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ef357-253">Les éléments du tableau <paramref name="parameters" /> ne correspondent pas à la signature de la méthode ou du constructeur réfléchis par cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-253">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="ef357-254">La méthode ou le constructeur appelé lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-254">The invoked method or constructor throws an exception.</span>
          </span>
          <span data-ttu-id="ef357-255">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-255">-or-</span>
          </span>
          <span data-ttu-id="ef357-256">L’instance actuelle est un <see cref="T:System.Reflection.Emit.DynamicMethod" /> qui contient du code non vérifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-256">The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span>
          </span>
          <span data-ttu-id="ef357-257">Consultez la section « Vérification » dans la section Notes pour <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-257">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="ef357-258">Le tableau <paramref name="parameters" /> n’a pas le nombre correct d’arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-258">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="ef357-259">Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.MemberAccessException" />, à la place.</span>
              <span class="sxs-lookup">
                <span data-stu-id="ef357-259">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="ef357-260">L’appelant n’a pas l’autorisation d’exécuter la méthode ou le constructeur représenté par l’instance actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-260">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ef357-261">Le type qui déclare la méthode est un type générique ouvert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-261">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="ef357-262">Autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> renvoie <see langword="true" /> pour le type déclarant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-262">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ef357-263">L’instance actuelle est un <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-263">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-264">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-264">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ef357-265">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-265">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="ef357-266">L’objet sur lequel la méthode ou le constructeur doit être appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-266">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="ef357-267">En cas de méthode statique, cet argument est ignoré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-267">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="ef357-268">En cas de constructeur statique, cet argument doit être <see langword="null" /> ou une instance de la classe qui définit le constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-268">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="ef357-269">Masque de bits qui est une combinaison de 0 ou de plusieurs bits indicateur de <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-269">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
          <span data-ttu-id="ef357-270">Si <c>binder</c> a la valeur <see langword="null" />, la valeur <see cref="F:System.Reflection.BindingFlags.Default" /> est assignée à ce paramètre et toute valeur passée est donc ignorée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-270">If <c>binder</c> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="ef357-271">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-271">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="ef357-272">Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-272">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ef357-273">Liste d’arguments de la méthode ou du constructeur appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-273">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="ef357-274">Il s’agit d’un tableau d’objets présentant les mêmes nombre, ordre et type que les paramètres de la méthode ou du constructeur à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-274">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="ef357-275">En l'absence de paramètres, la valeur doit être <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-275">If there are no parameters, this should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ef357-276">Si la méthode ou le constructeur représenté par cette instance accepte un paramètre ByRef, aucun attribut spécial n'est requis pour ce paramètre pour appeler la méthode ou le constructeur utilisant cette fonction.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-276">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="ef357-277">Tout objet de ce tableau qui n’est pas explicitement initialisé avec une valeur contiendra la valeur par défaut pour ce type d’objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-277">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="ef357-278">Pour les éléments de type référence, cette valeur est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-278">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ef357-279">Pour les éléments de type valeur, cette valeur est 0, 0.0 ou <see langword="false" />, selon le type d’élément spécifique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-279">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="ef357-280">Instance de <see langword="CultureInfo" /> utilisée pour régir la contrainte des types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-280">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="ef357-281">Si la valeur est <see langword="null" />, le <see langword="CultureInfo" /> du thread actuel est utilisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-281">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="ef357-282">(Par exemple, cela est nécessaire pour convertir un <see langword="String" /> représentant 1000 en valeur <see langword="Double" />, car 1000 est représenté de différentes manières selon la culture.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-282">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-283">En cas de substitution dans une classe dérivée, appelle la méthode ou le constructeur réfléchi avec les paramètres donnés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-283">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-284">
            <see langword="Object" /> contenant la valeur de retour de la méthode appelée <see langword="null" /> dans le cas d'un constructeur, ou <see langword="null" /> si le type de retour de la méthode est <see langword="void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-284">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span>
          </span>
          <span data-ttu-id="ef357-285">Avant d'appeler la méthode ou le constructeur, <see langword="Invoke" /> vérifie si l'utilisateur dispose d'une autorisation d'accès et si les paramètres sont valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-285">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-286">Appelle de manière dynamique la méthode réfléchie par cette instance sur `obj`et transmet les paramètres spécifiés.</span><span class="sxs-lookup"><span data-stu-id="ef357-286">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="ef357-287">Si la méthode est statique, le `obj` paramètre est ignoré.</span><span class="sxs-lookup"><span data-stu-id="ef357-287">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="ef357-288">Pour les méthodes non statiques, `obj` doit être une instance d’une classe qui hérite ou déclare la méthode doit être du même type que cette classe.</span><span class="sxs-lookup"><span data-stu-id="ef357-288">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="ef357-289">Si la méthode n’a aucun paramètre, la valeur de `parameters` doit être `null`.</span><span class="sxs-lookup"><span data-stu-id="ef357-289">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="ef357-290">Sinon, le nombre, le type et l’ordre des éléments dans `parameters` doivent être identiques pour le nombre, le type et l’ordre des paramètres de la méthode réfléchie par cette instance.</span><span class="sxs-lookup"><span data-stu-id="ef357-290">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="ef357-291">Vous ne pouvez pas omettre les paramètres optionnels dans les appels à `Invoke`.</span><span class="sxs-lookup"><span data-stu-id="ef357-291">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="ef357-292">Pour appeler une méthode en omettant les paramètres facultatifs, vous devez appeler `Type.InvokeMember` à la place.</span><span class="sxs-lookup"><span data-stu-id="ef357-292">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-293">Si cette surcharge de méthode est utilisée pour appeler un constructeur d’instance, l’objet fourni pour `obj` est réinitialisé ; autrement dit, tous les initialiseurs d’instance sont exécutés.</span><span class="sxs-lookup"><span data-stu-id="ef357-293">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="ef357-294">La valeur de retour est `null`.</span><span class="sxs-lookup"><span data-stu-id="ef357-294">The return value is `null`.</span></span> <span data-ttu-id="ef357-295">Si un constructeur de classe est appelé, la classe est réinitialisée ; Autrement dit, tous les initialiseurs de classe sont exécutées.</span><span class="sxs-lookup"><span data-stu-id="ef357-295">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="ef357-296">La valeur de retour est `null`.</span><span class="sxs-lookup"><span data-stu-id="ef357-296">The return value is `null`.</span></span>  
  
 <span data-ttu-id="ef357-297">Pour les paramètres de la primitive passés par valeur, une conversion étendue normale est effectuée (Int16 -> Int32, par exemple).</span><span class="sxs-lookup"><span data-stu-id="ef357-297">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="ef357-298">Pour les paramètres de référence de passage par valeur, l’étendue de référence normale est autorisée (classe dérivée de la classe de base et la classe de base pour le type d’interface).</span><span class="sxs-lookup"><span data-stu-id="ef357-298">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="ef357-299">Toutefois, pour les paramètres de la primitive passés par référence, les types doivent correspondre exactement.</span><span class="sxs-lookup"><span data-stu-id="ef357-299">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="ef357-300">La conversion étendue normale reste applicable aux paramètres de référence de passage par référence.</span><span class="sxs-lookup"><span data-stu-id="ef357-300">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="ef357-301">Par exemple, si la méthode réfléchie par cette instance est déclarée en tant que `public boolean Compare(String a, String b)`, puis `parameters` doit être un tableau de `Objects` dont la longueur 2 telle que `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span><span class="sxs-lookup"><span data-stu-id="ef357-301">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="ef357-302">Si un paramètre de la méthode actuelle est un type valeur et l’argument correspondant dans `parameters` est `null`, le runtime passe une instance initialisée à zéro du type valeur.</span><span class="sxs-lookup"><span data-stu-id="ef357-302">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="ef357-303">Réflexion utilise une recherche de méthode dynamique lors de l’appel de méthodes virtuelles.</span><span class="sxs-lookup"><span data-stu-id="ef357-303">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="ef357-304">Par exemple, supposons que la classe B hérite de la classe A, et ils implémentent tous deux une méthode virtuelle nommée M. Supposons maintenant que vous avez un `MethodInfo` objet qui représente M sur la classe A. Si vous utilisez la `Invoke` méthode à appeler M sur un objet de type B, puis la réflexion utilisera l’implémentation donnée par la classe B. Même si l’objet de type B est casté en un, l’implémentation donnée par la classe B est utilisée (voir l’exemple de code ci-dessous).</span><span class="sxs-lookup"><span data-stu-id="ef357-304">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="ef357-305">En revanche, si la méthode non virtuelle, puis réflexion utilisera l’implémentation donnée par le type à partir duquel le `MethodInfo` a été obtenu, quel que soit le type de l’objet passé en tant que la cible.</span><span class="sxs-lookup"><span data-stu-id="ef357-305">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="ef357-306">Restrictions d’accès sont ignorées pour le code de confiance totale.</span><span class="sxs-lookup"><span data-stu-id="ef357-306">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="ef357-307">Autrement dit, les propriétés, méthodes, champs et constructeurs privés sont accessibles et peuvent être appelées via la réflexion chaque fois que le code est entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="ef357-307">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="ef357-308">Si la méthode appelée lève une exception, `TargetInvocationException.GetException` retourne l’exception.</span><span class="sxs-lookup"><span data-stu-id="ef357-308">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="ef357-309">Cette implémentation lève une `NotSupportedException`.</span><span class="sxs-lookup"><span data-stu-id="ef357-309">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-310">En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</span><span class="sxs-lookup"><span data-stu-id="ef357-310">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ef357-311">(Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="ef357-311">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ef357-312">Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="ef357-312">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-313">L’exemple suivant montre tous les membres de la <xref:System.Reflection.Binder?displayProperty=nameWithType> classe à l’aide d’une surcharge de <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ef357-313">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ef357-314">La méthode privée `CanConvertFrom` recherche des types compatibles pour un type donné.</span><span class="sxs-lookup"><span data-stu-id="ef357-314">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="ef357-315">Pour un autre exemple d’appel de membres dans un scénario de liaison personnalisée, consultez [dynamiquement le chargement et utilisation des Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span><span class="sxs-lookup"><span data-stu-id="ef357-315">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="ef357-316">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" /> et la méthode n’est pas statique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-316">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="ef357-317">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-317">-or-</span>
          </span>
          <span data-ttu-id="ef357-318">La méthode n’est ni déclarée, ni héritée par la classe de <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-318">The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="ef357-319">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-319">-or-</span>
          </span>
          <span data-ttu-id="ef357-320">Un constructeur statique est appelé, et <paramref name="obj" /> n’est ni <see langword="null" /> ni une instance de la classe qui a déclaré le constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-320">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ef357-321">Le type du paramètre <paramref name="parameters" /> ne correspond pas à la signature de la méthode ou du constructeur réfléchi par cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-321">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="ef357-322">Le tableau <paramref name="parameters" /> n’a pas le nombre correct d’arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-322">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="ef357-323">La méthode ou le constructeur appelé lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-323">The invoked method or constructor throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ef357-324">L’appelant n’a pas l’autorisation d’exécuter la méthode ou le constructeur représenté par l’instance actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-324">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ef357-325">Le type qui déclare la méthode est un type générique ouvert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-325">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="ef357-326">Autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> renvoie <see langword="true" /> pour le type déclarant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-326">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ef357-327">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-327">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ef357-328">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-328">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-329">Obtient une valeur indiquant si la méthode est abstraite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-329">Gets a value indicating whether the method is abstract.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-330">
            <see langword="true" /> si la méthode est abstraite ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-330">
              <see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-331">Un membre abstrait est déclaré sur une classe de base et aucune implémentation n’a fourni.</span><span class="sxs-lookup"><span data-stu-id="ef357-331">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="ef357-332">Pour obtenir le <xref:System.Reflection.MethodBase>, tout d’abord obtenir le type.</span><span class="sxs-lookup"><span data-stu-id="ef357-332">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="ef357-333">À partir du type, obtenez la méthode.</span><span class="sxs-lookup"><span data-stu-id="ef357-333">From the type, get the method.</span></span> <span data-ttu-id="ef357-334">À partir de la méthode, obtenez le `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="ef357-334">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="ef357-335">Si le `MethodBase` ou constructeur n’est pas public, il est protégé et ne peut pas être facilement accessibles.</span><span class="sxs-lookup"><span data-stu-id="ef357-335">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="ef357-336">Pour accéder à une méthode non publique, définissez la <xref:System.Reflection.BindingFlags> au masque `NonPublic` dans `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="ef357-336">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-337">L’exemple suivant détermine si la méthode est abstraite et affiche le résultat spécifiés.</span><span class="sxs-lookup"><span data-stu-id="ef357-337">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-338">Obtient une valeur indiquant si la visibilité potentielle de cette méthode ou de ce constructeur est décrite par <see cref="F:System.Reflection.MethodAttributes.Assembly" />, c'est-à-dire si la méthode ou le constructeur est visible au maximum par d'autres types du même assembly, et n'est pas visible par des types dérivés à l'extérieur de l'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-338">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-339">
            <see langword="true" /> si la visibilité de cette méthode ou de ce constructeur est décrite exactement par <see cref="F:System.Reflection.MethodAttributes.Assembly" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-339">
              <see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-340">La visibilité réelle d’une méthode est limitée par la visibilité de son type.</span><span class="sxs-lookup"><span data-stu-id="ef357-340">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="ef357-341">Le <xref:System.Reflection.MethodBase.IsAssembly%2A> propriété peut être `true` pour une méthode, mais si elle est une méthode d’un type imbriqué privé, la méthode n’est pas visible en dehors du type conteneur.</span><span class="sxs-lookup"><span data-stu-id="ef357-341">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="ef357-342">La visibilité d’une méthode ou un constructeur est décrite exactement par <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> si le seul modificateur de visibilité est `internal` (`Friend` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ef357-342">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="ef357-343">Cette propriété est `false` pour les méthodes qui sont `protected internal` en c# (`Protected Friend` en Visual Basic, `protected public` en C++) ; utilisez le <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propriété pour identifier de telles méthodes.</span><span class="sxs-lookup"><span data-stu-id="ef357-343">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-344">L’exemple de code suivant définit des méthodes avec des niveaux de visibilité et affiche les valeurs de leurs <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, et <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="ef357-344">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-345">Les langages Visual Basic et c# ne peut pas définir des méthodes avec <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilité ; que le niveau d’accès apparaît uniquement dans l’exemple C++.</span><span class="sxs-lookup"><span data-stu-id="ef357-345">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-346">Obtient une valeur indiquant si la méthode est un constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-346">Gets a value indicating whether the method is a constructor.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-347">
            <see langword="true" /> si cette méthode est un constructeur représenté par un objet <see cref="T:System.Reflection.ConstructorInfo" /> (consultez la section Notes relative aux objets <see cref="T:System.Reflection.Emit.ConstructorBuilder" />) ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-347">
              <see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ef357-348">Le <xref:System.Reflection.MethodBase.IsConstructor%2A> propriété renvoie `false` pour un <xref:System.Reflection.Emit.ConstructorBuilder> de l’objet dans un type dynamique, à moins que le <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> indicateur a été inclus dans le `attributes` paramètre lorsque le constructeur a été défini.</span><span class="sxs-lookup"><span data-stu-id="ef357-348">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="ef357-349">L’omission de la <xref:System.Reflection.MethodAttributes.RTSpecialName> indicateur n’affecte pas l’exactitude du constructeur émis.</span><span class="sxs-lookup"><span data-stu-id="ef357-349">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-350">Obtient une valeur indiquant si la visibilité de cette méthode ou de ce constructeur est décrite par <see cref="F:System.Reflection.MethodAttributes.Family" />, c'est-à-dire si la méthode ou le constructeur est visible uniquement dans sa classe et dans ses classes dérivées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-350">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-351">
            <see langword="true" /> si l'accès à cette méthode ou à ce constructeur est décrit exactement par <see cref="F:System.Reflection.MethodAttributes.Family" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-351">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-352">La visibilité d’une méthode ou un constructeur est décrite exactement par <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> si le seul modificateur de visibilité est `protected`.</span><span class="sxs-lookup"><span data-stu-id="ef357-352">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="ef357-353">Cette propriété est `false` pour les méthodes qui sont `protected internal` en c# (`Protected Friend` en Visual Basic, `protected public` en C++) ; utilisez le <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propriété pour identifier de telles méthodes.</span><span class="sxs-lookup"><span data-stu-id="ef357-353">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-354">L’exemple de code suivant définit des méthodes avec des niveaux de visibilité et affiche les valeurs de leurs <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, et <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="ef357-354">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-355">Les langages Visual Basic et c# ne peut pas définir des méthodes avec <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilité ; que le niveau d’accès apparaît uniquement dans l’exemple C++.</span><span class="sxs-lookup"><span data-stu-id="ef357-355">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-356">Obtient une valeur indiquant si la visibilité de cette méthode ou de ce constructeur est décrite par <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />, c'est-à-dire si la méthode ou le constructeur peut être appelé par des classes dérivées, mais uniquement si elles se trouvent dans le même assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-356">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-357">
            <see langword="true" /> si l'accès à cette méthode ou à ce constructeur est décrit exactement par <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-357">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-358">La visibilité d’une méthode ou un constructeur est décrite exactement par <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> si le modificateur de visibilité est `protected private` en C++.</span><span class="sxs-lookup"><span data-stu-id="ef357-358">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="ef357-359">Méthodes ayant cette visibilité ne peut pas être définies dans Visual Basic ou c#.</span><span class="sxs-lookup"><span data-stu-id="ef357-359">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-360">L’exemple de code suivant définit des méthodes avec des niveaux de visibilité et affiche les valeurs de leurs <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, et <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="ef357-360">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-361">Les langages Visual Basic et c# ne peut pas définir des méthodes avec <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilité ; que le niveau d’accès apparaît uniquement dans l’exemple C++.</span><span class="sxs-lookup"><span data-stu-id="ef357-361">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-362">Obtient une valeur indiquant si la visibilité potentielle de cette méthode ou de ce constructeur est décrite par <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />, c'est-à-dire si la méthode ou le constructeur peut être appelé par des classes dérivées où qu'elles se trouvent, et par des classes du même assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-362">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-363">
            <see langword="true" /> si l'accès à cette méthode ou à ce constructeur est décrit exactement par <see cref="F:System.Reflection.MethodAttributes.FamORAssem" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-363">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-364">Si un membre de type a <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibilité, il peut être appelé à partir de n’importe quel membre dans une classe dérivée ou n’importe quel membre du même assembly, mais pas à partir de n’importe quel autre type.</span><span class="sxs-lookup"><span data-stu-id="ef357-364">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="ef357-365">La visibilité réelle d’une méthode est limitée par la visibilité de son type.</span><span class="sxs-lookup"><span data-stu-id="ef357-365">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="ef357-366">Le <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propriété peut être `true` pour une méthode, mais si elle est une méthode d’un type imbriqué privé, la méthode n’est pas visible en dehors du type conteneur.</span><span class="sxs-lookup"><span data-stu-id="ef357-366">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="ef357-367">La visibilité d’une méthode ou un constructeur est décrite exactement par <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> si le modificateur de visibilité est `protected internal` en c# (`Protected Friend` en Visual Basic, `protected public` en C++).</span><span class="sxs-lookup"><span data-stu-id="ef357-367">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-368">L’exemple de code suivant définit des méthodes avec des niveaux de visibilité et affiche les valeurs de leurs <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, et <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="ef357-368">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-369">Les langages Visual Basic et c# ne peut pas définir des méthodes avec <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilité ; que le niveau d’accès apparaît uniquement dans l’exemple C++.</span><span class="sxs-lookup"><span data-stu-id="ef357-369">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-370">Obtient une valeur indiquant si cette méthode est <see langword="final" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-370">Gets a value indicating whether this method is <see langword="final" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-371">
            <see langword="true" /> si cette méthode est <see langword="final" /> ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-371">
              <see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-372">Pour déterminer si une méthode est substituable, il n’est pas suffisante pour vérifier que <xref:System.Reflection.MethodBase.IsVirtual%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="ef357-372">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="ef357-373">Pour une méthode soit substituable, `IsVirtual` doit être `true` et `IsFinal` doit être `false`.</span><span class="sxs-lookup"><span data-stu-id="ef357-373">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="ef357-374">Par exemple, une méthode peut être non virtuelle, mais elle implémente une méthode d’interface.</span><span class="sxs-lookup"><span data-stu-id="ef357-374">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="ef357-375">Le common language runtime nécessite que toutes les méthodes qui implémentent des membres d’interface doivent être marqués comme `virtual`; par conséquent, le compilateur marque la méthode `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="ef357-375">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="ef357-376">Pour les cas où une méthode est marquée comme `virtual` mais n’est pas substituable.</span><span class="sxs-lookup"><span data-stu-id="ef357-376">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="ef357-377">Pour établir avec certitude si une méthode est substituable, utilisez le code tel que :</span><span class="sxs-lookup"><span data-stu-id="ef357-377">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="ef357-378">Si `IsVirtual` est `false` ou `IsFinal` est `true`, puis la méthode ne peut pas être substituée.</span><span class="sxs-lookup"><span data-stu-id="ef357-378">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-379">L’exemple suivant affiche `false` pour `IsFinal`, ce qui peut vous amener à penser que MyMethod est substituable.</span><span class="sxs-lookup"><span data-stu-id="ef357-379">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="ef357-380">Le code imprime `false` même si MyMethod n’est pas marquée `virtual` et ne peut donc pas être substitué.</span><span class="sxs-lookup"><span data-stu-id="ef357-380">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-381">Obtient une valeur indiquant si la méthode est générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-381">Gets a value indicating whether the method is generic.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-382">
            <see langword="true" /> si le <see cref="T:System.Reflection.MethodBase" /> actuel représente une méthode générique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-382">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-383">Utilisez le <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriété pour déterminer si actuel <xref:System.Reflection.MethodBase> objet représente une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-383">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="ef357-384">Utilisez le <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriété pour déterminer si actuel <xref:System.Reflection.MethodBase> objet représente une méthode construite ouverte ou une méthode construite fermée.</span><span class="sxs-lookup"><span data-stu-id="ef357-384">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-385">Les génériques ne sont pas pris en charge par défaut ; Cette propriété retourne `false` si ne pas substituée dans une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="ef357-385">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="ef357-386">Les constructeurs génériques ne sont pas pris en charge dans le .NET Framework version 2.0, cette propriété retourne `false` si l’instance actuelle est de type <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="ef357-386">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="ef357-387">Le tableau suivant résume les conditions invariantes pour les termes spécifiques aux méthodes génériques.</span><span class="sxs-lookup"><span data-stu-id="ef357-387">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="ef357-388">Pour d’autres termes utilisés dans la réflexion générique, tel que *paramètre de type générique* et *type générique*, consultez le <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="ef357-388">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="ef357-389">Terme</span><span class="sxs-lookup"><span data-stu-id="ef357-389">Term</span></span>|<span data-ttu-id="ef357-390">Condition indifférente</span><span class="sxs-lookup"><span data-stu-id="ef357-390">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="ef357-391">définition de méthode générique</span><span class="sxs-lookup"><span data-stu-id="ef357-391">generic method definition</span></span>| <span data-ttu-id="ef357-392">La propriété <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="ef357-392">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="ef357-393">Définit une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-393">Defines a generic method.</span></span> <span data-ttu-id="ef357-394">Une méthode construite est créée en appelant le <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> méthode sur un <xref:System.Reflection.MethodInfo> de l’objet qui représente une définition de méthode générique et en spécifiant un tableau d’arguments de type.</span><span class="sxs-lookup"><span data-stu-id="ef357-394">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="ef357-395">Le <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> méthode peut être appelée uniquement sur les définitions de méthode générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-395">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="ef357-396">Toute définition de méthode générique est une méthode générique, mais l’inverse n’est pas vrai.</span><span class="sxs-lookup"><span data-stu-id="ef357-396">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="ef357-397">méthode générique</span><span class="sxs-lookup"><span data-stu-id="ef357-397">generic method</span></span>|<span data-ttu-id="ef357-398">La propriété `IsGenericMethod` a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="ef357-398">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="ef357-399">Peut être une définition de méthode générique, une méthode construite ouverte ou une méthode construite fermée.</span><span class="sxs-lookup"><span data-stu-id="ef357-399">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="ef357-400">méthode construite ouverte</span><span class="sxs-lookup"><span data-stu-id="ef357-400">open constructed method</span></span>|<span data-ttu-id="ef357-401">La propriété <xref:System.Reflection.MethodBase.ContainsGenericParameters> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="ef357-401">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="ef357-402">Il n’est pas possible d’appeler une méthode construite ouverte.</span><span class="sxs-lookup"><span data-stu-id="ef357-402">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="ef357-403">méthode construite fermée</span><span class="sxs-lookup"><span data-stu-id="ef357-403">closed constructed method</span></span>|<span data-ttu-id="ef357-404">La propriété <xref:System.Reflection.MethodBase.ContainsGenericParameters> a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="ef357-404">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="ef357-405">Lorsque examinées de manière récursive, la méthode n’a aucun paramètre générique non assignés.</span><span class="sxs-lookup"><span data-stu-id="ef357-405">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="ef357-406">Le type conteneur n’a aucun paramètre de type générique, et aucun des arguments de type ne possède de paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="ef357-406">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="ef357-407">La méthode peut être appelée.</span><span class="sxs-lookup"><span data-stu-id="ef357-407">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-408">Obtient une valeur indiquant si la méthode est une définition de méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-408">Gets a value indicating whether the method is a generic method definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-409">
            <see langword="true" /> si l’objet <see cref="T:System.Reflection.MethodBase" /> actuel représente la définition d’une méthode générique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-409">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-410">Si le courant <xref:System.Reflection.MethodBase> représente une définition de méthode générique :</span><span class="sxs-lookup"><span data-stu-id="ef357-410">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="ef357-411">La propriété <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="ef357-411">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="ef357-412">Pour chaque <xref:System.Type> objet dans le tableau retourné par la <xref:System.Reflection.MethodBase.GetGenericArguments%2A> méthode :</span><span class="sxs-lookup"><span data-stu-id="ef357-412">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="ef357-413">La propriété <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="ef357-413">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="ef357-414">Le <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> propriété retourne l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="ef357-414">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="ef357-415">Le <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> propriété est identique à la position de la <xref:System.Type> objet dans le tableau.</span><span class="sxs-lookup"><span data-stu-id="ef357-415">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef357-416">Les génériques ne sont pas pris en charge par défaut ; Cette propriété retourne `false` si ne pas substituée dans une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="ef357-416">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="ef357-417">Les constructeurs génériques ne sont pas pris en charge dans le .NET Framework version 2.0, cette propriété retourne `false` si l’instance actuelle est de type <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="ef357-417">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="ef357-418">Pour obtenir la liste des conditions invariantes des termes spécifiques aux méthodes génériques, consultez le <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="ef357-418">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="ef357-419">Pour obtenir la liste des conditions invariantes pour les termes utilisés dans la réflexion générique, consultez la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="ef357-419">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-420">Obtient une valeur indiquant si seul un membre du même type, doté d'une signature identique, est caché dans la classe dérivée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-420">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-421">
            <see langword="true" /> si le membre est caché par signature ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-421">
              <see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-422">Quand un membre dans une classe dérivée est déclaré avec le langage c# `new` modificateur ou Visual Basic `Shadows` modificateur, il peut masquer un membre du même nom dans la classe de base.</span><span class="sxs-lookup"><span data-stu-id="ef357-422">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="ef357-423">C# masque les membres de classe de base par signature.</span><span class="sxs-lookup"><span data-stu-id="ef357-423">C# hides base class members by signature.</span></span> <span data-ttu-id="ef357-424">Autrement dit, si le membre de classe de base possède plusieurs surcharges, la seule qui est masquée est celle qui a la même signature.</span><span class="sxs-lookup"><span data-stu-id="ef357-424">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="ef357-425">En revanche, Visual Basic masque toutes les surcharges de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="ef357-425">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="ef357-426">Par conséquent, <xref:System.Reflection.MethodBase.IsHideBySig%2A> retourne `false` sur un membre déclaré avec Visual Basic `Shadows` modificateur, et `true` sur un membre déclaré avec le langage c# `new` modificateur.</span><span class="sxs-lookup"><span data-stu-id="ef357-426">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ef357-427">Cette propriété ne détermine pas si une méthode a le <xref:System.Reflection.MethodAttributes.NewSlot> attribut.</span><span class="sxs-lookup"><span data-stu-id="ef357-427">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="ef357-428">Une méthode déclarée avec le `new` ou le `Shadows` modificateur aura le <xref:System.Reflection.MethodAttributes.NewSlot> attribut, mais seules les méthodes déclarées avec `new` (autrement dit, seuls les méthodes c#) aura le <xref:System.Reflection.MethodBase.IsHideBySig%2A> lavaleurdepropriété`true`.</span><span class="sxs-lookup"><span data-stu-id="ef357-428">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="ef357-429">Pour déterminer si une méthode a le <xref:System.Reflection.MethodAttributes.NewSlot> d’attribut, d’utiliser un code semblable au suivant : `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` en c# ou `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ef357-429">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="ef357-430">Notez, toutefois, que bien que toutes les méthodes déclarées avec `new` ou `Shadows` ont le <xref:System.Reflection.MethodAttributes.NewSlot> d’attribut, toutes les méthodes qui ont le <xref:System.Reflection.MethodAttributes.NewSlot> attribut sont déclarées avec `new` ou `Shadows`.</span><span class="sxs-lookup"><span data-stu-id="ef357-430">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-431">L’exemple de code suivant contient une classe de base avec une méthode surchargée et une classe dérivée qui masque l’une des surcharges.</span><span class="sxs-lookup"><span data-stu-id="ef357-431">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="ef357-432">Dans la version Visual Basic de l’exemple de code, la <xref:System.Reflection.MethodBase.IsHideBySig%2A> retourne de la propriété `false` pour le membre dans la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="ef357-432">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="ef357-433">Dans la version c# de l’exemple de code, la propriété retourne `true` pour le membre dans la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="ef357-433">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-434">Obtient une valeur indiquant si ce membre est privé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-434">Gets a value indicating whether this member is private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-435">
            <see langword="true" /> si l'accès à la classe est limité aux autres membres de la classe proprement dite ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-435">
              <see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-436">Si un membre de type a `Private` niveau de visibilité, il peut être appelé à partir de n’importe quel membre dans la même classe et aucun autre.</span><span class="sxs-lookup"><span data-stu-id="ef357-436">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-437">Obtient une valeur indiquant s'il s'agit d'une méthode publique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-437">Gets a value indicating whether this is a public method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-438">
            <see langword="true" /> si cette méthode est publique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-438">
              <see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-439">Pour obtenir le <xref:System.Reflection.MethodBase>, tout d’abord obtenir le type.</span><span class="sxs-lookup"><span data-stu-id="ef357-439">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="ef357-440">À partir du type, obtenez la méthode.</span><span class="sxs-lookup"><span data-stu-id="ef357-440">From the type, get the method.</span></span> <span data-ttu-id="ef357-441">À partir de la méthode, obtenez le `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="ef357-441">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="ef357-442">Si le `MethodBase` ou constructeur n’est pas public, il est protégé et ne peut pas être facilement accessibles.</span><span class="sxs-lookup"><span data-stu-id="ef357-442">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="ef357-443">Pour accéder à une méthode non publique, définissez la <xref:System.Reflection.BindingFlags> au masque `NonPublic` dans `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="ef357-443">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-444">L’exemple suivant utilise le <xref:System.Reflection.MethodBase.IsPublic%2A> propriété pour afficher un message qui indique si la méthode spécifiée est publique.</span><span class="sxs-lookup"><span data-stu-id="ef357-444">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-445">Obtient une valeur qui indique si la méthode ou le constructeur actuel est critique de sécurité (security-critical) ou critique sécurisé (security-safe-critical) au niveau de confiance actuel et peut par conséquent exécuter des opérations critiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-445">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-446">
            <see langword="true" /> si la méthode ou le constructeur actuel est critique de sécurité ou critique sécurisé au niveau de confiance actuel ; <see langword="false" /> si la méthode ou le constructeur est transparent de sécurité (security-transparent).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-446">
              <see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-447">Le <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence de la méthode ou le constructeur à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="ef357-447">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="ef357-448">Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :</span><span class="sxs-lookup"><span data-stu-id="ef357-448">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="ef357-449">Niveau de sécurité</span><span class="sxs-lookup"><span data-stu-id="ef357-449">Security level</span></span>|<span data-ttu-id="ef357-450">EstCritiqueDeSécurité</span><span class="sxs-lookup"><span data-stu-id="ef357-450">IsSecurityCritical</span></span>|<span data-ttu-id="ef357-451">EstCritiqueSécurisé</span><span class="sxs-lookup"><span data-stu-id="ef357-451">IsSecuritySafeCritical</span></span>|<span data-ttu-id="ef357-452">EstTransparentDeSécurité</span><span class="sxs-lookup"><span data-stu-id="ef357-452">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="ef357-453">Critique</span><span class="sxs-lookup"><span data-stu-id="ef357-453">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="ef357-454">Critique sécurisé</span><span class="sxs-lookup"><span data-stu-id="ef357-454">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="ef357-455">Transparent</span><span class="sxs-lookup"><span data-stu-id="ef357-455">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="ef357-456">L’utilisation de ces propriétés est beaucoup plus simple que d’examiner les annotations de sécurité d’un assembly et de ses types et membres, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="ef357-456">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ef357-457">Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="ef357-457">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="ef357-458">Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="ef357-458">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="ef357-459">L’assembly et tous ses types sont traités comme étant transparent.</span><span class="sxs-lookup"><span data-stu-id="ef357-459">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="ef357-460">Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau).</span><span class="sxs-lookup"><span data-stu-id="ef357-460">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="ef357-461">En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="ef357-461">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="ef357-462">Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.</span><span class="sxs-lookup"><span data-stu-id="ef357-462">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="ef357-463">Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="ef357-463">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="ef357-464">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="ef357-464">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-465">Obtient une valeur qui indique si la méthode ou le constructeur actuel est critique sécurisé au niveau de confiance actuel ; autrement dit, si la méthode ou le constructeur peut exécuter des opérations critiques et être accessible par du code transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-465">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-466">
            <see langword="true" /> si la méthode ou le constructeur est critique sécurisé au niveau de confiance actuel ; <see langword="false" /> si la méthode ou le constructeur est critique de sécurité ou transparent de sécurité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-466">
              <see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-467">Le <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence de la méthode ou le constructeur à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="ef357-467">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="ef357-468">Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :</span><span class="sxs-lookup"><span data-stu-id="ef357-468">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="ef357-469">Niveau de sécurité</span><span class="sxs-lookup"><span data-stu-id="ef357-469">Security level</span></span>|<span data-ttu-id="ef357-470">EstCritiqueDeSécurité</span><span class="sxs-lookup"><span data-stu-id="ef357-470">IsSecurityCritical</span></span>|<span data-ttu-id="ef357-471">EstCritiqueSécurisé</span><span class="sxs-lookup"><span data-stu-id="ef357-471">IsSecuritySafeCritical</span></span>|<span data-ttu-id="ef357-472">EstTransparentDeSécurité</span><span class="sxs-lookup"><span data-stu-id="ef357-472">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="ef357-473">Critique</span><span class="sxs-lookup"><span data-stu-id="ef357-473">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="ef357-474">Critique sécurisé</span><span class="sxs-lookup"><span data-stu-id="ef357-474">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="ef357-475">Transparent</span><span class="sxs-lookup"><span data-stu-id="ef357-475">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="ef357-476">L’utilisation de ces propriétés est beaucoup plus simple que d’examiner les annotations de sécurité d’un assembly et de ses types et membres, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="ef357-476">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ef357-477">Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="ef357-477">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="ef357-478">Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="ef357-478">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="ef357-479">L’assembly et tous ses types sont traités comme étant transparent.</span><span class="sxs-lookup"><span data-stu-id="ef357-479">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="ef357-480">Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau).</span><span class="sxs-lookup"><span data-stu-id="ef357-480">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="ef357-481">En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="ef357-481">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="ef357-482">Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.</span><span class="sxs-lookup"><span data-stu-id="ef357-482">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="ef357-483">Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="ef357-483">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="ef357-484">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="ef357-484">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-485">Obtient une valeur qui indique si la méthode ou le constructeur actuel est transparent au niveau de confiance actuel et ne peut par conséquent pas exécuter d'opérations critiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-485">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-486">
            <see langword="true" /> si la méthode ou le constructeur est transparent de sécurité au niveau de confiance actuel ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-486">
              <see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-487">Si cette propriété retourne `true`, le <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> et <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> propriétés retour `false`.</span><span class="sxs-lookup"><span data-stu-id="ef357-487">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="ef357-488">Le <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence de la méthode ou le constructeur à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="ef357-488">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="ef357-489">L’utilisation de ces propriétés est beaucoup plus simple que d’examiner les annotations de sécurité d’un assembly et de ses types et membres, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="ef357-489">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ef357-490">Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="ef357-490">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="ef357-491">Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="ef357-491">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="ef357-492">L’assembly et tous ses types sont traités comme étant transparent.</span><span class="sxs-lookup"><span data-stu-id="ef357-492">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="ef357-493">Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau).</span><span class="sxs-lookup"><span data-stu-id="ef357-493">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="ef357-494">En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="ef357-494">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="ef357-495">Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.</span><span class="sxs-lookup"><span data-stu-id="ef357-495">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="ef357-496">Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="ef357-496">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="ef357-497">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="ef357-497">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-498">Obtient une valeur indiquant si cette méthode est dotée d'un nom spécial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-498">Gets a value indicating whether this method has a special name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-499">
            <see langword="true" /> si cette méthode est dotée d'un nom spécial ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-499">
              <see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-500">Le <xref:System.Reflection.MethodAttributes.SpecialName> bit est défini pour signaler des membres qui sont traités de manière spécifique par certains compilateurs (par exemple, les accesseurs de propriété et les méthodes de surcharge d’opérateur).</span><span class="sxs-lookup"><span data-stu-id="ef357-500">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef357-501">Cet exemple illustre l’utilisation de <xref:System.Reflection.MethodBase.IsSpecialName%2A> pour filtrer internes ou les membres privés dans une liste.</span><span class="sxs-lookup"><span data-stu-id="ef357-501">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-502">Obtient une valeur indiquant si la méthode est <see langword="static" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-502">Gets a value indicating whether the method is <see langword="static" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-503">
            <see langword="true" /> si cette méthode est <see langword="static" /> ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-503">
              <see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-504">Un membre statique ne peut pas référencer implicitement les données d’instance dans une classe.</span><span class="sxs-lookup"><span data-stu-id="ef357-504">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-505">Obtient une valeur indiquant si la méthode est <see langword="virtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-505">Gets a value indicating whether the method is <see langword="virtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-506">
            <see langword="true" /> si cette méthode est <see langword="virtual" /> ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-506">
              <see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-507">Un membre virtuel peut-être référencer des données d’instance dans une classe et doit être référencé par une instance de la classe.</span><span class="sxs-lookup"><span data-stu-id="ef357-507">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="ef357-508">Pour déterminer si une méthode est substituable, il n’est pas suffisante pour vérifier que `IsVirtual` est `true`.</span><span class="sxs-lookup"><span data-stu-id="ef357-508">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="ef357-509">Pour une méthode soit substituable, `IsVirtual` doit être `true` et <xref:System.Reflection.MethodBase.IsFinal%2A> doit être `false`.</span><span class="sxs-lookup"><span data-stu-id="ef357-509">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="ef357-510">Par exemple, une méthode peut être non virtuelle, mais elle implémente une méthode d’interface.</span><span class="sxs-lookup"><span data-stu-id="ef357-510">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="ef357-511">Le common language runtime nécessite que toutes les méthodes qui implémentent des membres d’interface doivent être marqués comme `virtual`; par conséquent, le compilateur marque la méthode `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="ef357-511">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="ef357-512">Pour les cas où une méthode est marquée comme `virtual` mais n’est pas substituable.</span><span class="sxs-lookup"><span data-stu-id="ef357-512">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="ef357-513">Pour établir avec certitude si une méthode est substituable, utilisez le code tel que :</span><span class="sxs-lookup"><span data-stu-id="ef357-513">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="ef357-514">Si `IsVirtual` est `false` ou `IsFinal` est `true`, puis la méthode ne peut pas être substituée.</span><span class="sxs-lookup"><span data-stu-id="ef357-514">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="ef357-515">Vous pouvez déterminer si la méthode actuelle substitue à une méthode dans une classe de base en appelant le <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ef357-515">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ef357-516">L’exemple suivant implémente un `IsOverride` méthode qui effectue l’opération.</span><span class="sxs-lookup"><span data-stu-id="ef357-516">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="ef357-517">L’exemple suivant affiche `false` pour `IsFinal`, ce qui peut vous amener à penser que `MyMethod` est substituable.</span><span class="sxs-lookup"><span data-stu-id="ef357-517">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="ef357-518">Le code imprime `false` bien `MyMethod` n’est pas marquée `virtual` et ne peut donc pas être substitué.</span><span class="sxs-lookup"><span data-stu-id="ef357-518">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-519">Obtient un handle vers la représentation interne des métadonnées d'une méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-519">Gets a handle to the internal metadata representation of a method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-520">Objet <see cref="T:System.RuntimeMethodHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-520">A <see cref="T:System.RuntimeMethodHandle" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-521">Les poignées sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.</span><span class="sxs-lookup"><span data-stu-id="ef357-521">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-522">Obtient les indicateurs <see cref="T:System.Reflection.MethodImplAttributes" /> qui spécifient les attributs de l'implémentation d'une méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-522">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-523">Indicateurs d’implémentation de méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-523">The method implementation flags.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-524">Pour plus d’informations, consultez la méthode <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A>.</span><span class="sxs-lookup"><span data-stu-id="ef357-524">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ef357-525">Premier objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-525">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ef357-526">Deuxième objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-526">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-527">Indique si deux objets <see cref="T:System.Reflection.MethodBase" /> sont égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-527">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-528">
            <see langword="true" /> si <paramref name="left" /> est égal à <paramref name="right" /> ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-528">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ef357-529">Premier objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-529">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ef357-530">Deuxième objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-530">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-531">Indique si deux objets <see cref="T:System.Reflection.MethodBase" /> ne sont pas égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-531">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-532">
            <see langword="true" /> si <paramref name="left" /> n'est pas égal à <paramref name="right" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-532">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="ef357-533">Réservé à un usage ultérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-533">Reserved for future use.</span>
          </span>
          <span data-ttu-id="ef357-534">Doit être IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-534">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="ef357-535">Tableau passé des noms à mapper.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-535">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="ef357-536">Compte des noms à mapper.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-536">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="ef357-537">Contexte des paramètres régionaux dans lequel interpréter les noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-537">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="ef357-538">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-538">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-539">Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-539">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-540">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="ef357-540">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ef357-541">Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ef357-541">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="ef357-542">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-542">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ef357-543">Pour obtenir une description de ce membre, consultez <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-543">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ef357-544">Pour obtenir une description de ce membre, consultez <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-544">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-545">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-545">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-546">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-546">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="ef357-547">Informations de type à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-547">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="ef357-548">Identificateur des paramètres régionaux pour les informations de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-548">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="ef357-549">Reçoit un pointeur vers l'objet d'informations de type demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-549">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-550">Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-550">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-551">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="ef357-551">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ef357-552">Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ef357-552">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="ef357-553">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-553">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="ef357-554">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-554">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-555">Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-555">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-556">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="ef357-556">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ef357-557">Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ef357-557">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="ef357-558">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-558">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="ef357-559">Identifie le membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-559">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="ef357-560">Réservé à un usage ultérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-560">Reserved for future use.</span>
          </span>
          <span data-ttu-id="ef357-561">Doit être IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-561">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="ef357-562">Contexte des paramètres régionaux dans lequel interpréter les arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-562">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="ef357-563">Indicateurs décrivant le contexte de l'appel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-563">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="ef357-564">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-564">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="ef357-565">Pointeur vers l'emplacement où le résultat doit être stocké.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-565">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="ef357-566">Pointeur vers une structure qui contient les informations sur les exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-566">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="ef357-567">Index du premier argument comportant une erreur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-567">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ef357-568">Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-568">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-569">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="ef357-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ef357-570">Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ef357-570">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="ef357-571">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-572">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-572">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-573">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-573">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-574">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-574">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-575">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-575">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-576">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-576">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-577">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-577">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-578">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-578">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-579">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-579">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-580">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-580">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-581">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-581">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-582">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-582">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-583">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-583">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-584">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-584">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-585">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-585">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-586">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-586">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-587">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-587">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-588">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-588">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-589">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-589">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-590">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-590">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-591">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-591">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-592">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-592">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-593">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-593">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-594">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-594">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-595">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-595">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-596">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-596">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-597">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-597">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-598">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-598">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-599">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-599">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-600">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-600">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-601">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-601">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-602">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-602">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-603">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-603">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-604">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-604">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-605">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-605">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-606">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-606">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-607">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-607">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-608">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-608">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-609">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-609">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-610">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-610">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-611">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-611">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-612">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-612">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-613">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-613">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-614">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-614">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-615">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-615">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-616">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-616">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-617">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-617">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-618">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-618">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-619">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-619">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ef357-620">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-620">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ef357-621">Pour obtenir une description de ce membre, consultez <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ef357-621">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef357-622">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="ef357-622">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ef357-623">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Reflection.MethodBase> est castée en interface <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="ef357-623">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>