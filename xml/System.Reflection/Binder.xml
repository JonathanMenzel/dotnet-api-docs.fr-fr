<Type Name="Binder" FullName="System.Reflection.Binder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8552a20cca449c5e862ef2077f766f62d3f5197b" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52197945" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Binder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Binder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Binder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Binder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binder abstract" />
  <TypeSignature Language="F#" Value="type Binder = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Sélectionne un membre dans une liste de candidats et effectue une conversion de type d'argument réel en type d'argument formel.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les implémentations de la <xref:System.Reflection.Binder> classe sont utilisés par les méthodes telles que <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>, qui permet de sélectionner un jeu de membres possibles pour s’exécuter, selon un ensemble de types de paramètres et valeurs d’argument ; <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, qui permet de sélectionner une méthode basée sur les types de paramètres et ainsi de suite.  
  
 Une implémentation par défaut de la <xref:System.Reflection.Binder> classe est fournie par le <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> propriété.  
  
   
  
## Examples  
 L’exemple suivant implémente et illustre tous les membres de la `Binder` classe. La méthode privée `CanConvertFrom` recherche des types compatibles pour un type donné.  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Lorsque vous héritez de <see cref="T:System.Reflection.Binder" />, vous devez substituer les membres suivants : <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, <see cref="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, <see cref="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />, <see cref="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />, et <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Binder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Binder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé par les constructeurs de classes dérivées pour initialiser l’état dans ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindToField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo BindToField (System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo BindToField(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.FieldInfo[] match, object value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToField (bindingAttr As BindingFlags, match As FieldInfo(), value As Object, culture As CultureInfo) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ BindToField(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ match, System::Object ^ value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member BindToField : System.Reflection.BindingFlags * System.Reflection.FieldInfo[] * obj * System.Globalization.CultureInfo -&gt; System.Reflection.FieldInfo" Usage="binder.BindToField (bindingAttr, match, value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.FieldInfo[]" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinaison d’opérations au niveau du bit de valeurs <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Ensemble des champs qui sont candidats pour une correspondance. Par exemple, lorsqu'un objet <see cref="T:System.Reflection.Binder" /> est utilisé par <see cref="Overload:System.Type.InvokeMember" />, ce paramètre spécifie l'ensemble de champs que la réflexion a déterminés comme étant des correspondances possibles, en général parce qu'ils ont le nom de membre correct. L'implémentation par défaut fournie par <see cref="P:System.Type.DefaultBinder" /> modifie l'ordre de ce tableau.</param>
        <param name="value">Valeur de champ utilisée pour rechercher un champ correspondant.</param>
        <param name="culture">Instance de <see cref="T:System.Globalization.CultureInfo" /> utilisée pour contrôler la contrainte de types de données dans les implémentations de binder qui forcent des types. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.  
  
Remarque   Par exemple, si une implémentation de binder permet la contrainte de valeurs de chaînes en types numériques, ce paramètre est nécessaire à la conversion d’un <see langword="String" /> représentant 1000 en valeur <see langword="Double" />, car 1000 est représenté de différentes manières, selon la culture. Le binder par défaut ne fait pas de telles contraintes de chaînes.</param>
        <summary>Sélectionne un champ à partir d'un ensemble de champs donné, en tenant compte des critères spécifiés.</summary>
        <returns>Champ correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `bindingAttr` n’inclut pas <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, l’implémentation du binder par défaut fournie par <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> renvoie simplement le premier élément du `match`. Aucune sélection n’est effectuée.  
  
 Cette méthode contrôle la liaison fournie par <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Pour le binder par défaut, <paramref name="bindingAttr" /> inclut <see cref="F:System.Reflection.BindingFlags.SetField" /> et <paramref name="match" /> contient plusieurs champs qui sont des correspondances également correctes pour <paramref name="value" />. Par exemple, <paramref name="value" /> contient un objet <c>MyClass</c> qui implémente l’interface <c>IMyClass</c>, et <paramref name="match" /> contient un champ de type <c>MyClass</c> et un champ de type <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingFieldException">Pour le binder par défaut, <paramref name="bindingAttr" /> inclut <see cref="F:System.Reflection.BindingFlags.SetField" /> et <paramref name="match" /> ne contient aucun champ pouvant accepter <paramref name="value" />.</exception>
        <exception cref="T:System.NullReferenceException">Pour le binder par défaut, <paramref name="bindingAttr" /> inclut <see cref="F:System.Reflection.BindingFlags.SetField" /> et <paramref name="match" /> est <see langword="null" /> ou un tableau vide.  
  
- ou - 
 <paramref name="bindingAttr" /> inclut <see cref="F:System.Reflection.BindingFlags.SetField" /> et <paramref name="value" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
      </Docs>
    </Member>
    <Member MemberName="BindToMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase BindToMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase BindToMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, object[]&amp; args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] names, [out] object&amp; state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToMethod (bindingAttr As BindingFlags, match As MethodBase(), ByRef args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, names As String(), ByRef state As Object) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ BindToMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;System::Object ^&gt; ^ % args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ names, [Runtime::InteropServices::Out] System::Object ^ % state);" />
      <MemberSignature Language="F#" Value="abstract member BindToMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] *  * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] *  -&gt; System.Reflection.MethodBase" Usage="binder.BindToMethod (bindingAttr, match, args, modifiers, culture, names, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="names" Type="System.String[]" />
        <Parameter Name="state" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinaison d’opérations au niveau du bit de valeurs <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Ensemble des méthodes qui sont candidates pour une correspondance. Par exemple, lorsqu'un objet <see cref="T:System.Reflection.Binder" /> est utilisé par <see cref="Overload:System.Type.InvokeMember" />, ce paramètre spécifie l'ensemble de méthodes que la réflexion a déterminées comme étant des correspondances possibles, en général parce qu'elles ont le nom de membre correct. L'implémentation par défaut fournie par <see cref="P:System.Type.DefaultBinder" /> modifie l'ordre de ce tableau.</param>
        <param name="args">Arguments qui sont passés. Le binder peut modifier l'ordre des arguments dans ce tableau ; par exemple, le binder par défaut modifie l'ordre des arguments si le paramètre <paramref name="names" /> est utilisé pour spécifier un ordre autre que l'ordre positionnel. Si une implémentation de binder force des types d'arguments, les types et les valeurs des arguments peuvent également être modifiés.</param>
        <param name="modifiers">Tableau de modificateurs de paramètres permettant des liaisons avec des signatures de paramètres dans lesquelles les types ont été modifiés. L'implémentation du binder par défaut n'utilise pas ce paramètre.</param>
        <param name="culture">Instance de <see cref="T:System.Globalization.CultureInfo" /> utilisée pour contrôler la contrainte de types de données dans les implémentations de binder qui forcent des types. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.  
  
Remarque   Par exemple, si une implémentation de binder permet la contrainte de valeurs de chaînes en types numériques, ce paramètre est nécessaire à la conversion d’un <see langword="String" /> représentant 1000 en valeur <see langword="Double" />, car 1000 est représenté de différentes manières, selon la culture. Le binder par défaut ne fait pas de telles contraintes de chaînes.</param>
        <param name="names">Noms des paramètres, si les noms des paramètres doivent être pris en considération en cas de correspondance, ou <see langword="null" /> si les arguments doivent être traités comme purement positionnels. Par exemple, les noms des paramètres doivent être utilisés si les arguments ne sont pas fournis en ordre positionnel.</param>
        <param name="state">Après le retour de la méthode, <paramref name="state" /> contient un objet fourni par un binder qui assure le suivi de la réorganisation des arguments. Le binder crée cet objet et représente le seul consommateur de ce dernier. Si <paramref name="state" /> n'est pas <see langword="null" /> lors du retour de <see langword="BindToMethod" />, vous devez passer <paramref name="state" /> à la méthode <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" /> si vous voulez restaurer l'ordre d'origine de <paramref name="args" />, par exemple, pour pouvoir récupérer les valeurs de paramètres <see langword="ref" /> (paramètres <see langword="ByRef" /> en Visual Basic).</param>
        <summary>Sélectionne une méthode à appeler à partir de l'ensemble de méthodes donné, en fonction des arguments fournis.</summary>
        <returns>La méthode correspondante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le binder par défaut prend en compte les deux paramètres qui ont des valeurs et `params` tableaux (`ParamArray` tableaux en Visual Basic). Par conséquent, il est possible de rechercher une correspondance dans les cas où `args` et `match` ne contiennent pas le même nombre d’éléments.  
  
 Le binder permet à un client à mapper le tableau des arguments vers sa forme d’origine si le tableau d’arguments a été manipulé par <xref:System.Reflection.Binder.BindToMethod%2A>. Utiliser cette fonctionnalité de remappage pour obtenir les arguments par référence lorsque ces arguments sont présents. Quand vous passez des arguments par nom, le binder réorganise le tableau d’arguments. Le `state` paramètre effectue le suivi de réorganisation des arguments, permettant ainsi le binder <xref:System.Reflection.Binder.ReorderArgumentArray%2A> méthode pour réorganiser le tableau d’arguments vers sa forme d’origine.  
  
 Le <xref:System.Reflection.Binder.BindToMethod%2A> méthode est utilisée par le <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Pour le binder par défaut, <paramref name="match" /> contient plusieurs méthodes qui sont des correspondances également correctes pour <paramref name="args" />. Par exemple, <paramref name="args" /> contient un objet <c>MyClass</c> qui implémente l’interface <c>IMyClass</c>, et <paramref name="match" /> contient une méthode qui prend <c>MyClass</c> et une méthode qui prend <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingMethodException">Pour le binder par défaut, <paramref name="match" /> ne contient aucune méthode pouvant accepter les arguments fournis dans <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentException">Pour le binder par défaut, <paramref name="match" /> est <see langword="null" /> ou un tableau vide.</exception>
        <altmember cref="T:System.Reflection.MethodBase" />
      </Docs>
    </Member>
    <Member MemberName="CanChangeType">
      <MemberSignature Language="C#" Value="public virtual bool CanChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.CanChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool&#xA;override this.CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool" Usage="binder.CanChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="type">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public abstract object ChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ ChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member ChangeType : obj * Type * System.Globalization.CultureInfo -&gt; obj" Usage="binder.ChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Objet à changer en nouveau <see langword="Type" />.</param>
        <param name="type">Le nouveau <see langword="Type" /> que <paramref name="value" /> deviendra.</param>
        <param name="culture">Instance de <see cref="T:System.Globalization.CultureInfo" /> utilisée pour contrôler la contrainte des types de données. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.  
  
Remarque   Par exemple, ce paramètre est nécessaire pour convertir <see langword="String" /> représentant 1000 en une valeur <see langword="Double" />, car 1000 est représenté de différentes manières selon la culture.</param>
        <summary>Convertit le type du <see langword="Object" /> donné en <see langword="Type" /> donné.</summary>
        <returns>Objet qui contient la valeur donnée comme type nouveau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La réflexion modélise les règles d’accessibilité du système de type commun. Par exemple, si l’appelant est dans le même assembly, l’appelant n’a besoin pas des autorisations spéciales pour les membres internes. Sinon, l’appelant doit <xref:System.Security.Permissions.ReflectionPermission>. Cela est cohérent avec la recherche de membres qui sont protégées, privées et ainsi de suite.  
  
 Le principe général est que `ChangeType` doit effectuer que des contraintes étendues, qui ne perdent jamais de données. La conversion forcée d’une valeur qui est un entier signé 32 bits à une valeur qui est un entier signé 64 bits est un exemple de contrainte étendue. Elle se distingue d’une contrainte restrictive, ce qui peut perdre des données. La conversion forcée d’un entier signé 64 bits à un entier signé 32 bits est un exemple de contrainte restrictive.  
  
 Le tableau suivant répertorie les contraintes effectuées par la valeur par défaut `ChangeType`.  
  
|Type source|Type cible|  
|-----------------|-----------------|  
|Tout type|Son type de base.|  
|Tout type|L’interface qu’elle implémente.|  
|Char|UInt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Non-reference|Par référence.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReorderArgumentArray">
      <MemberSignature Language="C#" Value="public abstract void ReorderArgumentArray (ref object[] args, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReorderArgumentArray(object[]&amp; args, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ReorderArgumentArray (ByRef args As Object(), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ReorderArgumentArray(cli::array &lt;System::Object ^&gt; ^ % args, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member ReorderArgumentArray :  * obj -&gt; unit" Usage="binder.ReorderArgumentArray (args, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="args">Arguments réels qui sont passés. Les types et les valeurs des arguments peuvent être modifiés.</param>
        <param name="state">Objet fourni par un binder assurant le suivi de la réorganisation des arguments.</param>
        <summary>Après le retour de la méthode <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, rétablit l'argument <paramref name="args" /> à la valeur qu'il avait lorsqu'il était issu de <see langword="BindToMethod" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le common language runtime appelle cette méthode si `state` n’est pas `null` après le retour de `BindToMethod`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase SelectMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase SelectMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectMethod (bindingAttr As BindingFlags, match As MethodBase(), types As Type(), modifiers As ParameterModifier()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ SelectMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodBase" Usage="binder.SelectMethod (bindingAttr, match, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinaison d’opérations au niveau du bit de valeurs <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Ensemble des méthodes qui sont candidates pour une correspondance. Par exemple, lorsqu'un objet <see cref="T:System.Reflection.Binder" /> est utilisé par <see cref="Overload:System.Type.InvokeMember" />, ce paramètre spécifie l'ensemble de méthodes que la réflexion a déterminées comme étant des correspondances possibles, en général parce qu'elles ont le nom de membre correct. L'implémentation par défaut fournie par <see cref="P:System.Type.DefaultBinder" /> modifie l'ordre de ce tableau.</param>
        <param name="types">Types de paramètres utilisés pour rechercher une méthode correspondante.</param>
        <param name="modifiers">Tableau de modificateurs de paramètres permettant des liaisons avec des signatures de paramètres dans lesquelles les types ont été modifiés.</param>
        <summary>Sélectionne une méthode dans l'ensemble de méthodes donné, en fonction du type de l'argument.</summary>
        <returns>Méthode correspondante, si elle existe ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit retourner `null` si aucune méthode ne correspond aux critères. Cette méthode contrôle la sélection fournie par le `GetConstructor` et `GetMethod` méthodes sur `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Pour le binder par défaut, <paramref name="match" /> contient plusieurs méthodes qui sont des correspondances également correctes pour les types de paramètres décrits par <paramref name="types" />. Par exemple, le tableau dans <paramref name="types" /> contient un objet <see cref="T:System.Type" /> pour <c>MyClass</c> et le tableau dans <paramref name="match" /> contient une méthode qui prend une classe de base de <c>MyClass</c> et une méthode qui prend une interface implémentée par <c>MyClass</c>.</exception>
        <exception cref="T:System.ArgumentException">Pour le binder par défaut, <paramref name="match" /> est <see langword="null" /> ou un tableau vide.  
  
- ou - 
Un élément de <paramref name="types" /> dérive de <see cref="T:System.Type" />, mais n'est pas de type <see langword="RuntimeType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectProperty">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo SelectProperty (System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, Type returnType, Type[] indexes, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo SelectProperty(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.PropertyInfo[] match, class System.Type returnType, class System.Type[] indexes, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectProperty (bindingAttr As BindingFlags, match As PropertyInfo(), returnType As Type, indexes As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::PropertyInfo ^ SelectProperty(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ match, Type ^ returnType, cli::array &lt;Type ^&gt; ^ indexes, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectProperty : System.Reflection.BindingFlags * System.Reflection.PropertyInfo[] * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="binder.SelectProperty (bindingAttr, match, returnType, indexes, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.PropertyInfo[]" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="indexes" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinaison d’opérations au niveau du bit de valeurs <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Ensemble des propriétés qui sont candidates pour une correspondance. Par exemple, lorsqu'un objet <see cref="T:System.Reflection.Binder" /> est utilisé par <see cref="Overload:System.Type.InvokeMember" />, ce paramètre spécifie l'ensemble de propriétés que la réflexion a déterminées comme étant des correspondances possibles, en général parce qu'elles ont le nom de membre correct. L'implémentation par défaut fournie par <see cref="P:System.Type.DefaultBinder" /> modifie l'ordre de ce tableau.</param>
        <param name="returnType">La valeur de retour que la propriété correspondante doit avoir.</param>
        <param name="indexes">Types d'index de la propriété recherchée. À utiliser pour les propriétés d'index, tel l'indexeur d'une classe.</param>
        <param name="modifiers">Tableau de modificateurs de paramètres permettant des liaisons avec des signatures de paramètres dans lesquelles les types ont été modifiés.</param>
        <summary>Sélectionne une propriété dans un ensemble de propriétés donné, en tenant compte des critères spécifiés.</summary>
        <returns>Propriété correspondante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode contrôle la sélection fournie par le `GetProperty` méthode sur `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Pour le binder par défaut, <paramref name="match" /> contient plusieurs propriétés qui sont des correspondances également correctes pour <paramref name="returnType" /> et <paramref name="indexes" />.</exception>
        <exception cref="T:System.ArgumentException">Pour le binder par défaut, <paramref name="match" /> est <see langword="null" /> ou un tableau vide.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>