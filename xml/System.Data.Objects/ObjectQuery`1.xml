<Type Name="ObjectQuery&lt;T&gt;" FullName="System.Data.Objects.ObjectQuery&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="020d5a22af28a5020c9db9d5510fae6719d86487" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57919284" /></Metadata><TypeSignature Language="C#" Value="public class ObjectQuery&lt;T&gt; : System.Data.Objects.ObjectQuery, System.Collections.Generic.IEnumerable&lt;T&gt;, System.ComponentModel.IListSource, System.Linq.IOrderedQueryable&lt;T&gt;, System.Linq.IQueryable&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectQuery`1&lt;T&gt; extends System.Data.Objects.ObjectQuery implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource, class System.Linq.IOrderedQueryable, class System.Linq.IOrderedQueryable`1&lt;!T&gt;, class System.Linq.IQueryable, class System.Linq.IQueryable`1&lt;!T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectQuery`1" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectQuery(Of T)&#xA;Inherits ObjectQuery&#xA;Implements IEnumerable(Of T), IListSource, IOrderedQueryable(Of T), IQueryable(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ObjectQuery : System::Data::Objects::ObjectQuery, System::Collections::Generic::IEnumerable&lt;T&gt;, System::ComponentModel::IListSource, System::Linq::IOrderedQueryable&lt;T&gt;, System::Linq::IQueryable&lt;T&gt;" />
  <TypeSignature Language="F#" Value="type ObjectQuery&lt;'T&gt; = class&#xA;    inherit ObjectQuery&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IQueryable&lt;'T&gt;&#xA;    interface IQueryable&#xA;    interface IOrderedQueryable&lt;'T&gt;&#xA;    interface IOrderedQueryable&#xA;    interface IListSource" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Data.Objects.ObjectQuery</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IOrderedQueryable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IOrderedQueryable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryable&lt;T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">Type d'entité de la requête.</typeparam>
    <summary>Représente une requête typée par rapport à un modèle conceptuel dans un contexte d’objet donné.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe générique <xref:System.Data.Objects.ObjectQuery%601> représente une requête qui retourne une collection de zéro ou plusieurs objets d’un type spécifique. L'objet <xref:System.Data.Objects.ObjectContext> doit être défini avant qu'une requête d'objet puisse être exécutée. Ce contexte fournit les informations relatives à la connexion et aux métadonnées qui sont requises pour composer et exécuter la requête. Une requête d'objet est exécutée dans les scénarios suivants :  
  
-   Lorsqu'une action est réalisée sur celle-ci, comme au cours d'une énumération `foreach` (en C#) ou `For Each` (en Visual Basic).  
  
-   Lorsqu’elle est assignée pour remplir une collection <xref:System.Collections.Generic.List%601>.  
  
-   Lorsque la méthode <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> est explicitement appelée.  
  
 La requête elle-même peut être créée en utilisant une instruction [!INCLUDE[esql](~/includes/esql-md.md)] ou une requête LINQ, ou elle peut être construite de façon incrémentielle en utilisant les méthodes de générateur de requêtes incluses dans la classe. Dans tous les cas, le résultat est une nouvelle instance <xref:System.Data.Objects.ObjectQuery%601> qui, en cas d'énumération ou d'exécution explicite, envoie la requête vers la source de données pour exécution et retourne les résultats.  
  
 Un objet <xref:System.Data.Objects.ObjectQuery%601> est fréquemment d'un type d'entité, mais il peut également être de type <xref:System.Data.Common.DbDataRecord>, pour les projections vers un type anonyme, ou d'un type primitif, tel qu'un entier ou une chaîne. Pour plus d’informations, consultez [requêtes d’objet](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 L'exemple montre comment construire une instance de la classe <xref:System.Data.Objects.ObjectQuery%601>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/9e7d8837-28c5-429d-a824-7bafb59724cf">Langage d'Entity SQL</related>
    <related type="Article" href="https://msdn.microsoft.com/library/641f9b68-9046-47a1-abb0-1c8eaeda0e2d">LINQ to Entities</related>
    <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.Objects.ObjectQuery`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objet <xref:System.Data.Objects.ObjectQuery%601> peut être initialisé de telle façon qu'il représente un résultat scalaire unique et non une collection de résultats scalaires. Certaines méthodes d’extension requièrent des résultats sous forme de collection comme entrée. Dans ce cas, une exception <xref:System.ArgumentException> est levée lorsque l'une de ces méthodes est appelée. Pour plus d’informations, consultez [requêtes d’objet](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Lorsque votre application génère des requêtes Entity SQL pendant l’exécution, vous devez connaître les limitations de longueur de commande de la source de données. Entity SQL n’applique pas de limitations sur la longueur du texte de commande dans les requêtes.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d’objets et mise en forme des résultats (Entity Framework)</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectQuery (string commandText, System.Data.Objects.ObjectContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string commandText, class System.Data.Objects.ObjectContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.#ctor(System.String,System.Data.Objects.ObjectContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (commandText As String, context As ObjectContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectQuery(System::String ^ commandText, System::Data::Objects::ObjectContext ^ context);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectQuery&lt;'T&gt; : string * System.Data.Objects.ObjectContext -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="new System.Data.Objects.ObjectQuery&lt;'T&gt; (commandText, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="context" Type="System.Data.Objects.ObjectContext" />
      </Parameters>
      <Docs>
        <param name="commandText">Requête [!INCLUDE[esql](~/includes/esql-md.md)].</param>
        <param name="context">Objet <see cref="T:System.Data.Objects.ObjectContext" /> sur lequel exécuter la requête.</param>
        <summary>Crée une nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> avec la commande [!INCLUDE[esql](~/includes/esql-md.md)] spécifiée comme requête initiale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque votre application génère des requêtes Entity SQL pendant l’exécution, vous devez connaître les limitations de longueur de commande de la source de données. Entity SQL n’applique pas de limitations sur la longueur du texte de commande dans les requêtes.  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple montre comment construire une instance de la classe <xref:System.Data.Objects.ObjectQuery%601>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectQuery (string commandText, System.Data.Objects.ObjectContext context, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string commandText, class System.Data.Objects.ObjectContext context, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.#ctor(System.String,System.Data.Objects.ObjectContext,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectQuery(System::String ^ commandText, System::Data::Objects::ObjectContext ^ context, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectQuery&lt;'T&gt; : string * System.Data.Objects.ObjectContext * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="new System.Data.Objects.ObjectQuery&lt;'T&gt; (commandText, context, mergeOption)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="context" Type="System.Data.Objects.ObjectContext" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="commandText">Requête [!INCLUDE[esql](~/includes/esql-md.md)].</param>
        <param name="context">Objet <see cref="T:System.Data.Objects.ObjectContext" /> sur lequel exécuter la requête.</param>
        <param name="mergeOption">Spécifie comment les entités récupérées par le biais de cette requête doivent être fusionnées avec les entités retournées à partir des requêtes précédentes contre le même objet <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Crée une nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> avec la commande [!INCLUDE[esql](~/includes/esql-md.md)] spécifiée comme requête initiale et l'option de fusion spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque votre application génère des requêtes Entity SQL pendant l’exécution, vous devez connaître les limitations de longueur de commande de la source de données. Entity SQL n’applique pas de limitations sur la longueur du texte de commande dans les requêtes.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'objet <xref:System.Data.Objects.ObjectQuery%601> est initialisé avec la requête spécifiée, <xref:System.Data.Objects.ObjectContext> et <xref:System.Data.Objects.MergeOption>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Select](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_select)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Select](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_select)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Distinct">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; Distinct ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; Distinct() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Distinct" />
      <MemberSignature Language="VB.NET" Value="Public Function Distinct () As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ Distinct();" />
      <MemberSignature Language="F#" Value="member this.Distinct : unit -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.Distinct " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limite la requête aux résultats uniques.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/select-entity-sql">SELECT DISTINCT</see> appliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode de générateur de requêtes retourne une <xref:System.Data.Objects.ObjectQuery%601> instance qui est équivalente à la requête d’origine avec [SELECT DISTINCT](~/docs/framework/data/adonet/ef/language-reference/select-entity-sql.md) appliqué.  
  
 Le `DISTINCT` opérateur ne peut pas être appliqué à un objet qui inclut un mappage à une colonne non comparable dans la source de données (tel que ntext).  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple utilise la méthode <xref:System.Data.Objects.ObjectQuery%601.UnionAll%2A> pour créer un nouvel objet <xref:System.Data.Objects.ObjectQuery%601>. Ensuite, il appelle <xref:System.Data.Objects.ObjectQuery%601.Distinct%2A> sur le nouvel objet <xref:System.Data.Objects.ObjectQuery%601> afin d'obtenir les résultats uniques de cette requête.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Distinct_UnionAll](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_distinct_unionall)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Distinct_UnionAll](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_distinct_unionall)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; Except (System.Data.Objects.ObjectQuery&lt;T&gt; query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; Except(class System.Data.Objects.ObjectQuery`1&lt;!T&gt; query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Except(System.Data.Objects.ObjectQuery{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Except (query As ObjectQuery(Of T)) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ Except(System::Data::Objects::ObjectQuery&lt;T&gt; ^ query);" />
      <MemberSignature Language="F#" Value="member this.Except : System.Data.Objects.ObjectQuery&lt;'T&gt; -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.Except query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Data.Objects.ObjectQuery&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="query">Objet <see cref="T:System.Data.Objects.ObjectQuery`1" /> qui représente les résultats à exclure de la requête.</param>
        <summary>Limite les résultats de la requête en excluant les résultats basés sur les résultats d'une autre requête d'objet.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/except-entity-sql">EXCEPT</see> appliqué selon le <paramref name="query" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fourni `query` qui définit les résultats à exclure doit être du même type ou d’un type qui est compatible avec le <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Les paramètres définis dans la liste fournie `query` sont fusionnés avec les paramètres qui sont définis dans le <xref:System.Data.Objects.ObjectQuery%601> instance. Les paramètres doivent être uniques dans l'objet <xref:System.Data.Objects.ObjectParameterCollection> combiné. La collection combinée ne peut pas contenir deux paramètres du même nom. Pour plus d’informations, consultez [méthodes du Générateur de requête](https://msdn.microsoft.com/library/05685434-05e6-41c2-8d5e-8933b88a40b0).  
  
 La requête résultante hérite de la connexion de l'instance <xref:System.Data.Objects.ObjectQuery%601> sur laquelle la méthode <xref:System.Data.Objects.ObjectQuery%601.Except%2A> a été appelée.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple utilise la méthode <xref:System.Data.Objects.ObjectQuery%601.Except%2A> pour créer un nouvel objet <xref:System.Data.Objects.ObjectQuery%601>, puis il itère au sein du résultat de la nouvelle requête.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Except](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_except)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Except](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_except)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="query" /> est <see langword="null" /> ou une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d’objets et mise en forme des résultats (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;T&gt; Execute (System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!T&gt; Execute(valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Execute(System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectResult&lt;T&gt; ^ Execute(System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="override this.Execute : System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'T&gt;" Usage="objectQuery.Execute mergeOption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="mergeOption"><see cref="T:System.Data.Objects.MergeOption" /> à utiliser lors de l'exécution de la requête. La valeur par défaut est <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Exécute la requête d'objet avec l'option de fusion spécifiée.</summary>
        <returns>Objet <see cref="T:System.Data.Objects.ObjectResult`1" /> qui contient une collection d'objets d'entité retournés par la requête.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’option de fusion par défaut pour les requêtes d’objets est <xref:System.Data.Objects.MergeOption.AppendOnly>. Pour plus d’informations, consultez [résolution d’identité, la gestion de l’état et le suivi des modifications](https://msdn.microsoft.com/library/3bd49311-0e72-4ea4-8355-38fe57036ba0).  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple retourne un objet <xref:System.Data.Objects.ObjectResult%601> à partir de la méthode <xref:System.Data.Objects.ObjectQuery.Execute%2A>. Ensuite, il obtient un énumérateur et itère au sein des résultats de la requête. À la fin, il libère l’énumérateur et l’objet <xref:System.Data.Objects.ObjectResult%601>.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryResult](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#queryresult)]
 [!code-vb[DP ObjectServices Concepts#QueryResult](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#queryresult)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;System.Data.Common.DbDataRecord&gt; GroupBy (string keys, string projection, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;class System.Data.Common.DbDataRecord&gt; GroupBy(string keys, string projection, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.GroupBy(System.String,System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupBy (keys As String, projection As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of DbDataRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;System::Data::Common::DbDataRecord ^&gt; ^ GroupBy(System::String ^ keys, System::String ^ projection, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.GroupBy : string * string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;System.Data.Common.DbDataRecord&gt;" Usage="objectQuery.GroupBy (keys, projection, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;System.Data.Common.DbDataRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.String" />
        <Parameter Name="projection" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="keys">Colonnes clés par lesquelles grouper les résultats.</param>
        <param name="projection">Liste des propriétés sélectionnées qui définit la projection.</param>
        <param name="parameters">Zéro ou plusieurs paramètres utilisés dans cette méthode.</param>
        <summary>Groupe les résultats de la requête en fonction des critères spécifiés.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> de type <see cref="T:System.Data.Common.DbDataRecord" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/group-by-entity-sql">GROUP BY</see> appliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectQuery%601.GroupBy%2A> applique la projection spécifiée par le `projection` paramètre. Cela signifie que l'objet <xref:System.Data.Objects.ObjectQuery%601> retourné par la méthode <xref:System.Data.Objects.ObjectQuery%601.GroupBy%2A> est toujours de type <xref:System.Data.Common.DbDataRecord>. Pour plus d’informations, consultez [requêtes d’objet](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Cet exemple crée un nouvel objet <xref:System.Data.Objects.ObjectQuery%601> qui contient les résultats de la requête existante groupés par nom de produit.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_GroupBy](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_groupby)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_GroupBy](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_groupby)]  
  
 Cet exemple retourne un jeu d’enregistrements de données imbriqués qui contiennent la `Contact.LastName` colonne, regroupés et triés par ordre alphabétique selon la première lettre de `Contact.LastName`.  
  
 [!code-csharp[DP ObjectServices Concepts#Projection_GroupBy](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#projection_groupby)]
 [!code-vb[DP ObjectServices Concepts#Projection_GroupBy](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#projection_groupby)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="query" /> est <see langword="null" /> ou une chaîne vide.  
  
ou 
Le paramètre <paramref name="projection" /> est <see langword="null" /> ou une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Include">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; Include (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; Include(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Include(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Include (path As String) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ Include(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Include : string -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.Include path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Liste d'objets connexes, séparés par des points, à retourner dans les résultats de la requête.</param>
        <summary>Spécifie les objets connexes à inclure dans les résultats de la requête.</summary>
        <returns>Nouvel objet <see cref="T:System.Data.Objects.ObjectQuery`1" /> avec le chemin d'accès de requête défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les chemins d’accès de requête peuvent être utilisés avec les requêtes Entity SQL et LINQ.  
  
 Les chemins d’accès sont entièrement inclusifs. Par exemple, si un appel d’inclusion indique `Include("Orders.OrderLines")`, non seulement seront `OrderLines` sera inclus, mais également `Orders`. Pour plus d’informations, consultez [le chargement des objets connexes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).  
  
 Lorsque vous appelez la méthode <xref:System.Data.Objects.ObjectQuery%601.Include%2A>, le chemin d’accès de la requête est valide uniquement sur l’instance retournée de l’objet <xref:System.Data.Objects.ObjectQuery%601>. Les autres instances de <xref:System.Data.Objects.ObjectQuery%601> et le contexte d'objet lui-même ne sont pas affectés.  
  
 Étant donné que la méthode <xref:System.Data.Objects.ObjectQuery%601.Include%2A> retourne l’objet de requête, vous pouvez appeler cette méthode à plusieurs reprises sur un objet <xref:System.Data.Objects.ObjectQuery%601> afin de spécifier plusieurs chemins d’accès pour la requête, comme dans l’exemple suivant :  
  
 [!code-csharp[DP ObjectServices Concepts#SpanOnlyWithMultiplePaths](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#spanonlywithmultiplepaths)]
 [!code-vb[DP ObjectServices Concepts#SpanOnlyWithMultiplePaths](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#spanonlywithmultiplepaths)]  
  
   
  
## Examples  
 [!code-csharp[DP ObjectServices Concepts#QueryWithSpan](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querywithspan)]
 [!code-vb[DP ObjectServices Concepts#QueryWithSpan](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querywithspan)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est <see langword="empty" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; Intersect (System.Data.Objects.ObjectQuery&lt;T&gt; query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; Intersect(class System.Data.Objects.ObjectQuery`1&lt;!T&gt; query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Intersect(System.Data.Objects.ObjectQuery{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (query As ObjectQuery(Of T)) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ Intersect(System::Data::Objects::ObjectQuery&lt;T&gt; ^ query);" />
      <MemberSignature Language="F#" Value="member this.Intersect : System.Data.Objects.ObjectQuery&lt;'T&gt; -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.Intersect query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Data.Objects.ObjectQuery&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="query">Objet <see cref="T:System.Data.Objects.ObjectQuery`1" /> qui représente les résultats à inclure dans la requête.</param>
        <summary>Limite les résultats de la requête en incluant uniquement les résultats qui existent dans une autre requête d'objet.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/intersect-entity-sql">INTERSECT</see> appliqué selon l’élément <paramref name="query" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fourni `query` qui définit les résultats à inclure doit être du même type ou d’un type qui est compatible avec le <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Les paramètres définis dans la liste fournie `query` sont fusionnés avec les paramètres qui sont définis dans le <xref:System.Data.Objects.ObjectQuery%601> instance. Les paramètres doivent être uniques dans l'objet <xref:System.Data.Objects.ObjectParameterCollection> combiné. La collection combinée ne peut pas contenir deux paramètres du même nom. Pour plus d’informations, consultez [méthodes du Générateur de requête](https://msdn.microsoft.com/library/05685434-05e6-41c2-8d5e-8933b88a40b0).  
  
 La requête résultante hérite de la connexion de l'instance <xref:System.Data.Objects.ObjectQuery%601> sur laquelle la méthode <xref:System.Data.Objects.ObjectQuery%601.Intersect%2A> a été appelée.  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Cet exemple crée un nouvel objet <xref:System.Data.Objects.ObjectQuery%601> qui contient les résultats de deux autres requêtes.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Intersect](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_intersect)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Intersect](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_intersect)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="query" /> est <see langword="null" /> ou une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectQuery`1.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Data.Objects.ObjectQuery&lt;'T&gt;.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de la requête d'objet.</summary>
        <value>Valeur <see langword="string" /> qui nomme <see cref="T:System.Data.Objects.ObjectQuery`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nom de la requête d'objet identifie la requête d'objet actuelle dans la séquence par nom lors de la construction des méthodes de générateur de requêtes. Par défaut, le nom de la requête est `it`. Cela peut être utile lorsque l'on fait référence à la séquence actuelle dans des jointures à l'intérieur de la méthode <xref:System.Data.Objects.ObjectQuery`1.Where*> ou dans la méthode <xref:System.Data.Objects.ObjectQuery`1.SelectValue*>. Pour plus d’informations, consultez [méthodes du Générateur de requête](https://msdn.microsoft.com/library/05685434-05e6-41c2-8d5e-8933b88a40b0).  
  
 Lorsque vous définissez la propriété <xref:System.Data.Objects.ObjectQuery%601.Name%2A> d'un objet <xref:System.Data.Objects.ObjectQuery%601>, cette valeur devient l'alias dans les méthodes suivantes.  
  
 La valeur de la propriété <xref:System.Data.Objects.ObjectQuery%601.Name%2A> doit commencer par une lettre et peut contenir des lettres, des chiffres et des traits de soulignement.  
  
   
  
## Examples  
 Cet exemple affecte la valeur « product » au nom du premier objet <xref:System.Data.Objects.ObjectQuery%601>, puis il utilise cet alias dans la méthode <xref:System.Data.Objects.ObjectQuery%601.OrderBy%2A> suivante. L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 [!code-csharp[DP ObjectServices Concepts#QueryWithAliasNamed](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querywithaliasnamed)]
 [!code-vb[DP ObjectServices Concepts#QueryWithAliasNamed](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querywithaliasnamed)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée sur le jeu n'est pas valide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResultType&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TResultType&gt; OfType&lt;TResultType&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!TResultType&gt; OfType&lt;TResultType&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.OfType``1" />
      <MemberSignature Language="VB.NET" Value="Public Function OfType(Of TResultType) () As ObjectQuery(Of TResultType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResultType&gt;&#xA; System::Data::Objects::ObjectQuery&lt;TResultType&gt; ^ OfType();" />
      <MemberSignature Language="F#" Value="member this.OfType : unit -&gt; System.Data.Objects.ObjectQuery&lt;'ResultType&gt;" Usage="objectQuery.OfType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TResultType&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResultType" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResultType">Type du <see cref="T:System.Data.Objects.ObjectResult`1" /> retourné lorsque la requête est exécutée avec le filtre appliqué.</typeparam>
        <summary>Limite la requête uniquement aux résultats d'un type spécifique.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/oftype-entity-sql">OFTYPE</see> appliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
La méthode <xref:System.Data.Objects.ObjectQuery`1.OfType*> est utilisée pour filtrer les résultats de la requête par un type complexe ou d'entité spécifique. Cela prend en charge un modèle conceptuel avec héritage d’objet. Pour plus d’informations, consultez [Entity Data Model : L’héritage](~/docs/framework/data/adonet/entity-data-model-inheritance.md).

Le <xref:System.Data.Objects.ObjectQuery`1.OfType*> méthode peut uniquement être appliquée à un <xref:System.Data.Objects.ObjectQuery%601> d’un type d’entité ou un type complexe qui est défini dans le modèle EDM.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.EntitySqlException">Le type spécifié n'est pas valide.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/be01614e-070e-41be-9746-bb674b41e488(v=vs.90)">Procédure : Créer et objet de l’exécution des requêtes à l’aide de l’héritage Table par hiérarchie (Entity Framework)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; OrderBy (string keys, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; OrderBy(string keys, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.OrderBy(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OrderBy (keys As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ OrderBy(System::String ^ keys, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.OrderBy : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.OrderBy (keys, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="keys">Colonnes clés par lesquelles ordonner les résultats.</param>
        <param name="parameters">Zéro ou plusieurs paramètres utilisés dans cette méthode.</param>
        <summary>Ordonne les résultats de la requête en fonction des critères spécifiés.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/order-by-entity-sql">ORDER BY</see>appliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classement des résultats dans une requête imbriquée ne peut pas être garanti.  
  
 <xref:System.Data.Objects.ObjectQuery%601.OrderBy%2A> doit toujours être la dernière méthode de générateur de requêtes dans la séquence.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L’exemple crée un nouveau <xref:System.Data.Objects.ObjectQuery%601> objet qui contient les résultats de l’ordre de requête existant par `ProductID`.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_OrderBy](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_orderby)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_OrderBy](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_orderby)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="keys" /> ou <paramref name="parameters" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="key" /> est une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;System.Data.Common.DbDataRecord&gt; Select (string projection, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;class System.Data.Common.DbDataRecord&gt; Select(string projection, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Select(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (projection As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of DbDataRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;System::Data::Common::DbDataRecord ^&gt; ^ Select(System::String ^ projection, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.Select : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;System.Data.Common.DbDataRecord&gt;" Usage="objectQuery.Select (projection, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;System.Data.Common.DbDataRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="projection" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="projection">Liste des propriétés sélectionnées qui définit la projection.</param>
        <param name="parameters">Zéro ou plusieurs paramètres utilisés dans cette méthode.</param>
        <summary>Limite les résultats de la requête uniquement aux propriétés définies dans la projection spécifiée.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> de type <see cref="T:System.Data.Common.DbDataRecord" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/select-entity-sql">SELECT</see> appliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectQuery%601.Select%2A> applique la projection spécifiée par le `projection` paramètre. L'objet <xref:System.Data.Objects.ObjectQuery%601> retourné par la méthode <xref:System.Data.Objects.ObjectQuery%601.Select%2A> est toujours un type de ligne de <xref:System.Data.Common.DbDataRecord>. Utilisez la méthode <xref:System.Data.Objects.ObjectQuery`1.SelectValue*> pour retourner des valeurs qui sont des types simples, des types d'entité ou des types complexes. Pour plus d’informations, consultez [LINQ to Entities](~/docs/framework/data/adonet/ef/language-reference/linq-to-entities.md).  
  
 Lorsqu’une propriété de navigation est incluse dans la projection, les résultats de la requête incluent une collection d’objets <xref:System.Data.Common.DbDataRecord> imbriqués. Pour plus d'informations, voir [Procédure : Naviguer parmi les relations à l’aide des propriétés de Navigation](https://msdn.microsoft.com/library/b1d71c7d-16a7-4b46-96ac-690176bd5057).  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L’exemple crée un nouveau <xref:System.Data.Objects.ObjectQuery%601> dont les résultats sont des enregistrements de données qui contiennent le `ProductID` champs des résultats de cette requête.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Select](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_select)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Select](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_select)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="projection" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="parameters" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="projection" /> est une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectValue&lt;TResultType&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TResultType&gt; SelectValue&lt;TResultType&gt; (string projection, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!TResultType&gt; SelectValue&lt;TResultType&gt;(string projection, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.SelectValue``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectValue(Of TResultType) (projection As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of TResultType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResultType&gt;&#xA; System::Data::Objects::ObjectQuery&lt;TResultType&gt; ^ SelectValue(System::String ^ projection, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.SelectValue : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'ResultType&gt;" Usage="objectQuery.SelectValue (projection, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TResultType&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResultType" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResultType">Type de <see cref="T:System.Data.Objects.ObjectQuery`1" /> retourné par la méthode <see cref="M:System.Data.Objects.ObjectQuery`1.SelectValue``1(System.String,System.Data.Objects.ObjectParameter[])" />.</typeparam>
        <param name="projection">Liste de projections.</param>
        <param name="parameters">Jeu facultatif de paramètres de requête qui doivent être dans l'étendue lors de l'analyse.</param>
        <summary>Limite les résultats de la requête uniquement à la propriété spécifiée dans la projection.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> d'un type compatible avec la projection spécifique. L’objet <see cref="T:System.Data.Objects.ObjectQuery`1" /> retourné est équivalent à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/select-entity-sql">SELECT VALUE</see> appliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.ObjectQuery`1.SelectValue*> est utilisée pour retourner des valeurs qui sont des types simples, des types d'entité ou des types complexes. Utilisez la méthode <xref:System.Data.Objects.ObjectQuery%601.Select%2A> pour les projections qui requièrent un type de ligne plutôt qu'un type valeur. Pour plus d’informations, consultez [requêtes d’objet](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Le <xref:System.Data.Objects.ObjectQuery`1.SelectValue*> méthode s’applique la projection spécifiée par le `projection` paramètre. L'objet <xref:System.Data.Objects.ObjectQuery%601> retourné par la méthode <xref:System.Data.Objects.ObjectQuery`1.SelectValue*> doit être d'un type de valeur compatible avec la projection et doit être du même type que le type de <xref:System.Data.Objects.ObjectQuery`1.SelectValue*>.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L’exemple crée un nouveau <xref:System.Data.Objects.ObjectQuery%601> qui contient les résultats qui sont une séquence de `ProductID` valeurs projetées à partir des résultats de la requête existante.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_SelectValue](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_selectvalue)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_SelectValue](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_selectvalue)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="projection" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="parameters" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="projection" /> est une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; Skip (string keys, string count, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; Skip(string keys, string count, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Skip(System.String,System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Skip (keys As String, count As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ Skip(System::String ^ keys, System::String ^ count, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.Skip : string * string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.Skip (keys, count, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.String" />
        <Parameter Name="count" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="keys">Colonnes clés par lesquelles ordonner les résultats.</param>
        <param name="count">Nombre de résultats à ignorer. Ce nombre doit être une constante ou une référence de paramètre.</param>
        <param name="parameters">Jeu facultatif de paramètres de requête qui doivent être dans l'étendue lors de l'analyse.</param>
        <summary>Classe les résultats de la requête selon les critères spécifiés et ignore un nombre spécifié de résultats.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/order-by-entity-sql">ORDER BY</see> et [SKIP](~/docs/framework/data/adonet/ef/language-reference/skip-entity-sql.md) appliqués.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.ObjectQuery%601.Skip%2A> ne peut pas être utilisée après la méthode <xref:System.Data.Objects.ObjectQuery%601.Top%2A>. Lorsque vous utilisez <xref:System.Data.Objects.ObjectQuery%601.Top%2A> après <xref:System.Data.Objects.ObjectQuery%601.Skip%2A>, elle fonctionne comme le [limite](~/docs/framework/data/adonet/ef/language-reference/limit-entity-sql.md) instruction d’une clause.  
  
   
  
## Examples  
 Cet exemple obtient cinq `Product` objets après avoir ignoré les trois premiers du résultat de requête, trié par `Product.ListPrice`.  
  
 [!code-csharp[DP ObjectServices Concepts#Projection_SkipLimit](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#projection_skiplimit)]
 [!code-vb[DP ObjectServices Concepts#Projection_SkipLimit](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#projection_skiplimit)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Tous les arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keys" /> est une chaîne vide.  
  
ou 
 <paramref name="count" /> est une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein des résultats de la requête.</summary>
        <returns>Objet <see cref="T:System.Collections.Generic.IEnumerator`1" /> qui peut être utilisé pour itérer au sein des résultats.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'appel de <xref:System.Data.Objects.ObjectQuery%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A> exécute la requête.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; Top (string count, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; Top(string count, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Top(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Top (count As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ Top(System::String ^ count, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.Top : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.Top (count, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="count">Nombre d'éléments du résultat sous la forme d'une chaîne.</param>
        <param name="parameters">Jeu facultatif de paramètres de requête qui doivent être dans l'étendue lors de l'analyse.</param>
        <summary>Limite les résultats de la requête à un nombre d'éléments spécifié.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/top-entity-sql">TOP</see> appliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectQuery%601.Top%2A> est non déterministe, à moins que la requête soit triée.  
  
 Lorsque vous utilisez le <xref:System.Data.Objects.ObjectQuery%601.Top%2A> méthode après le <xref:System.Data.Objects.ObjectQuery%601.Skip%2A> (méthode), elle fonctionne comme le [limite](~/docs/framework/data/adonet/ef/language-reference/limit-entity-sql.md) déclaration d’un [ORDER BY](~/docs/framework/data/adonet/ef/language-reference/order-by-entity-sql.md) clause.  
  
   
  
## Examples  
 Ces exemples sont basés sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Cet exemple crée un nouvel objet <xref:System.Data.Objects.ObjectQuery%601> qui contient les deux premiers résultats de la requête existante.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Top](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_top)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Top](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_top)]  
  
 Cet exemple obtient cinq `Product` objets après avoir ignoré les trois premiers du résultat de requête, trié par `Product.ListPrice`. <xref:System.Data.Objects.ObjectQuery%601.Top%2A> est utilisé au lieu de [limite](~/docs/framework/data/adonet/ef/language-reference/limit-entity-sql.md) pour la pagination.  
  
 [!code-csharp[DP ObjectServices Concepts#Projection_SkipLimit](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#projection_skiplimit)]
 [!code-vb[DP ObjectServices Concepts#Projection_SkipLimit](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#projection_skiplimit)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="count" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="count" /> est une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; Union (System.Data.Objects.ObjectQuery&lt;T&gt; query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; Union(class System.Data.Objects.ObjectQuery`1&lt;!T&gt; query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Union(System.Data.Objects.ObjectQuery{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (query As ObjectQuery(Of T)) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ Union(System::Data::Objects::ObjectQuery&lt;T&gt; ^ query);" />
      <MemberSignature Language="F#" Value="member this.Union : System.Data.Objects.ObjectQuery&lt;'T&gt; -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.Union query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Data.Objects.ObjectQuery&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="query"><see cref="T:System.Data.Objects.ObjectQuery`1" /> qui représente les résultats à ajouter.</param>
        <summary>Combine les résultats de la requête avec les résultats d'une autre requête d'objet, sans doublon.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/union-entity-sql">UNION</see> appliqué pour ajouter les résultats du <paramref name="query" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectQuery%601.Union%2A> Ajoute les résultats de l’élément `query` sans doublon.  
  
 Fourni `query` qui définit les résultats à ajouter doit être du même type ou d’un type qui peut être promu au type de ce <xref:System.Data.Objects.ObjectQuery%601>. Par exemple, ce qui suit est valide, car `DiscontinuedProducts` peut être promue en `Products`:  
  
```  
ObjectQuery<Product>.Union(ObjectQuery<DiscontinuedProduct>)  
```  
  
 Ce qui suit lèvera une exception car `Products` ne peut pas être promu en `DiscontinuedProducts`.  
  
```  
ObjectQuery <DiscontinuedProduct>.Union(ObjectQuery<Product>)   
```  
  
 Pour un <xref:System.Data.Objects.ObjectQuery%601> de type <xref:System.Data.Common.DbDataRecord>, les enregistrements dans les deux requêtes doivent avoir le même nombre de colonnes et les types dans les colonnes de la <xref:System.Data.Common.DbDataRecord> des éléments transmis `query` doivent pouvoir être promus aux types des colonnes dans le <xref:System.Data.Common.DbDataRecord> de la <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Les paramètres définis dans la liste fournie `query` sont fusionnés avec les paramètres qui sont définis dans le <xref:System.Data.Objects.ObjectQuery%601> instance. Les paramètres doivent être uniques dans l'objet <xref:System.Data.Objects.ObjectParameterCollection> combiné. La collection combinée ne peut pas contenir deux paramètres du même nom. Pour plus d’informations, consultez [méthodes du Générateur de requête](https://msdn.microsoft.com/library/05685434-05e6-41c2-8d5e-8933b88a40b0).  
  
 La requête résultante hérite de la connexion de l'instance <xref:System.Data.Objects.ObjectQuery%601> sur laquelle la méthode <xref:System.Data.Objects.ObjectQuery%601.Union%2A> a été appelée.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple utilise la méthode <xref:System.Data.Objects.ObjectQuery%601.Union%2A> pour créer un nouvel objet <xref:System.Data.Objects.ObjectQuery%601>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Distinct_Union](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_distinct_union)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Distinct_Union](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_distinct_union)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="query" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="UnionAll">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; UnionAll (System.Data.Objects.ObjectQuery&lt;T&gt; query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; UnionAll(class System.Data.Objects.ObjectQuery`1&lt;!T&gt; query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.UnionAll(System.Data.Objects.ObjectQuery{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function UnionAll (query As ObjectQuery(Of T)) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ UnionAll(System::Data::Objects::ObjectQuery&lt;T&gt; ^ query);" />
      <MemberSignature Language="F#" Value="member this.UnionAll : System.Data.Objects.ObjectQuery&lt;'T&gt; -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.UnionAll query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Data.Objects.ObjectQuery&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="query"><see cref="T:System.Data.Objects.ObjectQuery`1" /> qui représente les résultats à ajouter.</param>
        <summary>Combine les résultats de la requête avec les résultats d'une autre requête d'objet, y compris tous les doublons.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/union-entity-sql">UNION ALL</see> appliqué pour ajouter les résultats du <paramref name="query" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectQuery%601.UnionAll%2A> Ajoute les résultats de l’élément `query` , y compris tous les doublons.  
  
 Fourni `query` qui définit les résultats à ajouter doit être du même type ou d’un type qui peut être promu au type de ce <xref:System.Data.Objects.ObjectQuery%601>. Par exemple, ce qui suit est valide, car `DiscontinuedProducts` peut être promue en `Products`:  
  
```  
ObjectQuery<Product>.Union(ObjectQuery<DiscontinuedProduct>)  
```  
  
 Ce qui suit lèvera une exception car `Products` ne peut pas être promu en `DiscontinuedProducts`.  
  
```  
ObjectQuery <DiscontinuedProduct>.Union(ObjectQuery<Product>)   
```  
  
 Pour un <xref:System.Data.Objects.ObjectQuery%601> de type <xref:System.Data.Common.DbDataRecord>, les enregistrements dans les deux requêtes doivent avoir le même nombre de colonnes et les types dans les colonnes de la <xref:System.Data.Common.DbDataRecord> des éléments transmis `query` doivent pouvoir être promus aux types des colonnes dans le <xref:System.Data.Common.DbDataRecord> de la <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Les paramètres définis dans la liste fournie `query` sont fusionnés avec les paramètres qui sont définis dans le <xref:System.Data.Objects.ObjectQuery%601> instance. Les paramètres doivent être uniques dans l'objet <xref:System.Data.Objects.ObjectParameterCollection> combiné. La collection combinée ne peut pas contenir deux paramètres du même nom. Pour plus d’informations, consultez [méthodes du Générateur de requête](https://msdn.microsoft.com/library/05685434-05e6-41c2-8d5e-8933b88a40b0).  
  
 La requête résultante hérite de la connexion de l'instance <xref:System.Data.Objects.ObjectQuery%601> sur laquelle la méthode <xref:System.Data.Objects.ObjectQuery%601.UnionAll%2A> a été appelée.  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple utilise la méthode <xref:System.Data.Objects.ObjectQuery%601.UnionAll%2A> pour créer un nouvel objet <xref:System.Data.Objects.ObjectQuery%601>. Ensuite, il appelle la méthode <xref:System.Data.Objects.ObjectQuery%601.Distinct%2A> sur le nouvel objet <xref:System.Data.Objects.ObjectQuery%601> afin d'obtenir les résultats uniques de cette requête.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Distinct_UnionAll](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_distinct_unionall)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Distinct_UnionAll](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_distinct_unionall)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="query" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; Where (string predicate, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!T&gt; Where(string predicate, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectQuery`1.Where(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Where (predicate As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ Where(System::String ^ predicate, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.Where : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectQuery.Where (predicate, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="predicate" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="predicate">Prédicat de filtrage.</param>
        <param name="parameters">Zéro ou plusieurs paramètres utilisés dans cette méthode.</param>
        <summary>Limite la requête aux résultats qui correspondent aux critères de filtrage spécifiés.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectQuery`1" /> équivalente à l’instance d’origine avec <see href="https://docs.microsoft.com/dotnet/framework/data/adonet/ef/language-reference/where-entity-sql">WHERE</see> appliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L’exemple crée un nouveau <xref:System.Data.Objects.ObjectQuery%601> qui contient les résultats de la requête existante filtrés selon les critères suivants : `"it.ProductID = 900"`.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectQuery_Where](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectquery_where)]
 [!code-vb[DP ObjectServices Concepts#ObjectQuery_Where](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectquery_where)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="predicate" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="parameters" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="predicate" /> est une chaîne vide.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
      </Docs>
    </Member>
  </Members>
</Type>