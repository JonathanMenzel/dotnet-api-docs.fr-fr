<Type Name="ArrayPool&lt;T&gt;" FullName="System.Buffers.ArrayPool&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c365ab2f2412036b41ba89388ab6a1187f6696d2" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="36647247" /></Metadata><TypeSignature Language="C#" Value="public abstract class ArrayPool&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ArrayPool`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.ArrayPool`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ArrayPool(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ArrayPool abstract" />
  <TypeSignature Language="F#" Value="type ArrayPool&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Buffers</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="T">Le type des objets qui se trouvent dans le pool de ressources.</typeparam>
    <summary>Fournit un pool de ressources qui permet la réutilisation des instances de type <see cref="T:T[]" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 À l’aide de la <xref:System.Buffers.ArrayPool%601> classe à louer et retourner des mémoires tampons (à l’aide de la <xref:System.Buffers.ArrayPool%601.Rent%2A> et <xref:System.Buffers.ArrayPool%601.Return%2A> méthodes) peut améliorer les performances dans les situations où les tableaux sont créés et détruits fréquemment, ce qui entraîne la pression de mémoire importante sur le garbage collecteur.
  
 ]]></format>
    </remarks>
    <threadsafe>Cette classe est thread-safe. Tous les membres peuvent être utilisés simultanément par plusieurs threads.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ArrayPool ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ArrayPool();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Notez que ce constructeur est protégé ; elle peut uniquement être appelée par les classes dérivées de la <xref:System.Buffers.ArrayPool%601> classe. 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <returns>Nouvelle instance de la classe <see cref="T:System.Buffers.ArrayPool`1" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create (int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create(int32 maxArrayLength, int32 maxArraysPerBucket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (maxArrayLength As Integer, maxArraysPerBucket As Integer) As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create(int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="F#" Value="static member Create : int * int -&gt; System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Create (maxArrayLength, maxArraysPerBucket)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxArrayLength" Type="System.Int32" />
        <Parameter Name="maxArraysPerBucket" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxArrayLength">Longueur maximale d’une instance de tableau qui peut être stockée dans le pool.</param>
        <param name="maxArraysPerBucket">Nombre maximal d’instances de tableau qui peuvent être stockées dans chaque compartiment du pool. Le pool regroupe les tableaux de mêmes longueurs dans des compartiments pour un accès plus rapide.</param>
        <summary>Crée une instance de la classe <see cref="T:System.Buffers.ArrayPool`1" /> en utilisant la configuration spécifiée.</summary>
        <returns>Nouvelle instance de la classe <see cref="T:System.Buffers.ArrayPool`1" /> avec la configuration spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
L’instance de la <xref:System.Buffers.ArrayPool%601> classe créée par cette méthode regroupe les tableaux en compartiments, sans nécessiter plus de `maxArraysPerBucket` dans chaque compartiment et avec ces baies ne dépassant ne pas `maxArrayLength` longueur.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rent">
      <MemberSignature Language="C#" Value="public abstract T[] Rent (int minimumLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T[] Rent(int32 minimumLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Rent (minimumLength As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;T&gt; ^ Rent(int minimumLength);" />
      <MemberSignature Language="F#" Value="abstract member Rent : int -&gt; 'T[]" Usage="arrayPool.Rent minimumLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minimumLength">Longueur minimale du tableau.</param>
        <summary>Récupère une mémoire tampon qui est au moins de la longueur demandée.</summary>
        <returns>Tableau de type <see cref="T:T[]" /> dont la longueur est au moins <paramref name="minimumLength" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Cette mémoire tampon est emprunté à l’appelant et doit être retourné pour le même pool en utilisant le <xref:System.Buffers.ArrayPool%601.Return%2A> (méthode), afin qu’il peut être réutilisé dans les appels suivants à la <xref:System.Buffers.ArrayPool%601.Rent%2A> (méthode). Échec pour retourner une mémoire tampon louée n’est pas une erreur irrécupérable. Toutefois, il peut entraîner application une diminution des performances, comme le pool devrez peut-être créer une nouvelle mémoire tampon pour remplacer celui qui est perdu.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public abstract void Return (T[] array, bool clearArray = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Return(!T[] array, bool clearArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Return (array As T(), Optional clearArray As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member Return : 'T[] * bool -&gt; unit" Usage="arrayPool.Return (array, clearArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="clearArray" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="array">Mémoire tampon à retourner au pool préalablement obtenu à l’aide de la méthode <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />.</param>
        <param name="clearArray">Indique si le contenu de la mémoire tampon doit être effacé avant une réutilisation. Si <paramref name="clearArray" /> est défini sur <see langword="true" />, et si le pool stockera la mémoire tampon pour permettre une réutilisation ultérieure, la méthode <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" /> efface <paramref name="array" /> de son contenu afin qu’un appelant suivant utilisant la méthode <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" /> ne voit pas le contenu de l’appelant précédent. Si <paramref name="clearArray" /> a la valeur <see langword="false" /> ou si le pool libère la mémoire tampon, le contenu du tableau reste inchangé.</param>
        <summary>Retourne un tableau dans le pool préalablement obtenu à l’aide de la méthode <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" /> sur la même instance <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Une fois une mémoire tampon a été retournée au pool, l’appelant abandonne tous la propriété de la mémoire tampon et elle ne doit pas utiliser. La référence retournée à partir d’un appel donné à la <xref:System.Buffers.ArrayPool%601.Rent%2A> méthode doit uniquement être renvoyée à l’aide de la <xref:System.Buffers.ArrayPool%601.Return%2A> méthode une seule fois. La valeur par défaut <xref:System.Buffers.ArrayPool%601> peut conserver la mémoire tampon retournée pour louer à nouveau, soit la version de mai la mémoire tampon retournée s’il est déterminé que le pool possède déjà un tampon insuffisante stocké.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shared">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Shared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Buffers.ArrayPool`1&lt;!T&gt; Shared" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.ArrayPool`1.Shared" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Shared As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Buffers::ArrayPool&lt;T&gt; ^ Shared { System::Buffers::ArrayPool&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Shared : System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Shared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une instance <see cref="T:System.Buffers.ArrayPool`1" /> partagée.</summary>
        <value>Partagé <see cref="T:System.Buffers.ArrayPool`1" /> instance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Le pool partagé fournit une implémentation par défaut de la <xref:System.Buffers.ArrayPool%601> classe est destinée à l’application générale. Une classe partagée gère des tableaux de plusieurs tailles et peut obtenir un plus grand tableau qu’a été demandée, mais il jamais restituent un tableau plus petit qu’a été demandée. Location d’une mémoire tampon à partir d’une classe partagée à l’aide de la <xref:System.Buffers.ArrayPool%601.Rent%2A> méthode entraîne un tampon existant qui est extraite du pool si un mémoire tampon appropriée est disponible ou dans une nouvelle mémoire tampon allouée s’il n’est pas disponible.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>