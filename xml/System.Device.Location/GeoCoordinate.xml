<Type Name="GeoCoordinate" FullName="System.Device.Location.GeoCoordinate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9306ada8544dc2948dc7a238c9b93b729458f0ec" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39725947" /></Metadata><TypeSignature Language="C#" Value="public class GeoCoordinate : IEquatable&lt;System.Device.Location.GeoCoordinate&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GeoCoordinate extends System.Object implements class System.IEquatable`1&lt;class System.Device.Location.GeoCoordinate&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Device.Location.GeoCoordinate" />
  <TypeSignature Language="VB.NET" Value="Public Class GeoCoordinate&#xA;Implements IEquatable(Of GeoCoordinate)" />
  <TypeSignature Language="C++ CLI" Value="public ref class GeoCoordinate : IEquatable&lt;System::Device::Location::GeoCoordinate ^&gt;" />
  <TypeSignature Language="F#" Value="type GeoCoordinate = class&#xA;    interface IEquatable&lt;GeoCoordinate&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Device</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Device.Location.GeoCoordinate&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente une localisation géographique déterminée par des coordonnées de latitude et de longitude. Peut également inclure des informations d'altitude, de précision, de vitesse et de trajet.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Device.Location.GeoCoordinate." />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de <see cref="T:System.Device.Location.GeoCoordinate" /> sans aucun champ de données défini.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les champs de données sont définies sur <xref:System.Double.NaN>.  La nouvelle instance de <xref:System.Device.Location.GeoCoordinate> équivaut à <xref:System.Device.Location.GeoCoordinate.Unknown>.  
  
 Ce constructeur doit être utilisé pour la sérialisation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Latitude de la localisation. Les valeurs peuvent être comprises entre -90,0 et 90,0.</param>
        <param name="longitude">Longitude de la localisation. Les valeurs peuvent être comprises entre -180,0 et 180,0.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Device.Location.GeoCoordinate" /> à partir des données de latitude et de longitude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs de latitude et longitude doivent correspondre à un emplacement réel sur le monde entier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La latitude ou la longitude est hors limites.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude, double altitude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude, float64 altitude) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double, altitude As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude, double altitude);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude, altitude)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
        <Parameter Name="altitude" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Latitude. Les valeurs peuvent être comprises entre -90,0 et 90,0.</param>
        <param name="longitude">Longitude. Les valeurs peuvent être comprises entre -180,0 et 180,0.</param>
        <param name="altitude">Altitude en mètres. Peut être négative, égale à 0, positive ou <see cref="F:System.Double.NaN" />, si inconnue.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Device.Location.GeoCoordinate" /> à partir des données de latitude, longitude et altitude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs de latitude et longitude doivent correspondre à un emplacement réel sur le monde entier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="latitude" />, <paramref name="longitude" />, or <paramref name="altitude" /> est hors limites.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy, double speed, double course);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude, float64 altitude, float64 horizontalAccuracy, float64 verticalAccuracy, float64 speed, float64 course) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double, altitude As Double, horizontalAccuracy As Double, verticalAccuracy As Double, speed As Double, course As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy, double speed, double course);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double * double * double * double * double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude, altitude, horizontalAccuracy, verticalAccuracy, speed, course)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
        <Parameter Name="altitude" Type="System.Double" />
        <Parameter Name="horizontalAccuracy" Type="System.Double" />
        <Parameter Name="verticalAccuracy" Type="System.Double" />
        <Parameter Name="speed" Type="System.Double" />
        <Parameter Name="course" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Latitude de la localisation. Les valeurs peuvent être comprises entre -90,0 et 90,0.</param>
        <param name="longitude">Longitude de la localisation. Les valeurs peuvent être comprises entre -180,0 et 180,0.</param>
        <param name="altitude">Altitude en mètres. Peut être négative, égale à 0, positive ou <see cref="F:System.Double.NaN" />, si inconnue.</param>
        <param name="horizontalAccuracy">Précision des coordonnées de longitude et de latitude, en mètres. Doit être supérieure ou égale à 0. Si une valeur égale à 0 est fournie à ce constructeur, la propriété <see cref="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" /> prend la valeur <see cref="F:System.Double.NaN" />.</param>
        <param name="verticalAccuracy">Précision de l'altitude, en mètres. Doit être supérieure ou égale à 0. Si une valeur égale à 0 est fournie à ce constructeur, la propriété <see cref="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" /> prend la valeur <see cref="F:System.Double.NaN" />.</param>
        <param name="speed">Vitesse mesurée en mètres par seconde. Peut être négative, égale à 0, positive ou <see cref="F:System.Double.NaN" />, si inconnue.  Une vitesse négative peut indiquer un déplacement en sens inverse.</param>
        <param name="course">Direction du déplacement, à distinguer de l'orientation. Ce paramètre est mesuré en degrés par rapport au nord géographique. Sa valeur doit être comprise entre 0 et 360,0 ou être égale à <see cref="F:System.Double.NaN" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Device.Location.GeoCoordinate" /> à partir des données de latitude, longitude, altitude, précision horizontale, précision verticale, vitesse et trajet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="latitude" />, <paramref name="longitude" />, <paramref name="horizontalAccuracy" />, <paramref name="verticalAccuracy," /> ou <paramref name="course" /> est hors limites.</exception>
      </Docs>
    </Member>
    <Member MemberName="Altitude">
      <MemberSignature Language="C#" Value="public double Altitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Altitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Altitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Altitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Altitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Altitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Altitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'altitude de <see cref="T:System.Device.Location.GeoCoordinate" />, en mètres.</summary>
        <value>Altitude en mètres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’altitude est donnée par rapport au niveau de la mer.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Course">
      <MemberSignature Language="C#" Value="public double Course { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Course" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Course" />
      <MemberSignature Language="VB.NET" Value="Public Property Course As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Course { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Course : double with get, set" Usage="System.Device.Location.GeoCoordinate.Course" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la direction en degrés par rapport au nord géographique.</summary>
        <value>Direction en degrés par rapport au nord géographique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plage valide inclut les valeurs comprises entre 0,0 et 360,0, et `Double.NaN` si l’en-tête n’est pas défini.  
  
   
  
## Examples  
 L’exemple suivant imprime le <xref:System.Device.Location.GeoCoordinate.Course%2A> et <xref:System.Device.Location.GeoCoordinate.Speed%2A> propriétés de l’emplacement actuel <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.courseandspeed/cs/courseandspeed.cs#2)]
 [!code-vb[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.courseandspeed/vb/courseandspeed.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Course" /> se trouve en dehors de la plage valide.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si deux objets <see cref="T:System.Device.Location.GeoCoordinate" /> sont équivalents d'après uniquement la latitude et la longitude.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Device.Location.GeoCoordinate other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Device.Location.GeoCoordinate other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.Equals(System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Device::Location::GeoCoordinate ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Device.Location.GeoCoordinate -&gt; bool" Usage="geoCoordinate.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="other">Objet <see cref="T:System.Device.Location.GeoCoordinate" /> à comparer à l'objet appelant.</param>
        <summary>Détermine si l'objet <see cref="T:System.Device.Location.GeoCoordinate" /> est équivalent au paramètre d'après uniquement la latitude et la longitude.</summary>
        <returns><see langword="true" /> si les objets <see cref="T:System.Device.Location.GeoCoordinate" /> sont égaux ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Équivalent <xref:System.Device.Location.GeoCoordinate> objets ont les mêmes <xref:System.Device.Location.GeoCoordinate.Latitude%2A> et <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propriétés. Le <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, et <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propriétés ne sont pas utilisées pour déterminer l’équivalence.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="geoCoordinate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet auquel comparer <see cref="T:System.Device.Location.GeoCoordinate" />.</param>
        <summary>Détermine si un objet <see cref="T:System.Device.Location.GeoCoordinate" /> spécifié est égal à l'objet <see cref="T:System.Device.Location.GeoCoordinate" />actif d'après uniquement la latitude et la longitude.</summary>
        <returns><see langword="true" /> si les objets <see cref="T:System.Device.Location.GeoCoordinate" /> sont égaux ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Équivalent <xref:System.Device.Location.GeoCoordinate> objets ont les mêmes <xref:System.Device.Location.GeoCoordinate.Latitude%2A> et <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propriétés. Le <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, et <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propriétés ne sont pas utilisées pour déterminer l’équivalence.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDistanceTo">
      <MemberSignature Language="C#" Value="public double GetDistanceTo (System.Device.Location.GeoCoordinate other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDistanceTo(class System.Device.Location.GeoCoordinate other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.GetDistanceTo(System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDistanceTo (other As GeoCoordinate) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDistanceTo(System::Device::Location::GeoCoordinate ^ other);" />
      <MemberSignature Language="F#" Value="member this.GetDistanceTo : System.Device.Location.GeoCoordinate -&gt; double" Usage="geoCoordinate.GetDistanceTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="other"><see cref="T:System.Device.Location.GeoCoordinate" /> de la localisation à laquelle calculer la distance.</param>
        <summary>Retourne la distance entre les coordonnées de latitude et de longitude spécifiées par ce <see cref="T:System.Device.Location.GeoCoordinate" /> et un autre <see cref="T:System.Device.Location.GeoCoordinate" /> spécifié.</summary>
        <returns>Distance entre les deux coordonnées, en mètres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La formule de Haversine est utilisée pour calculer la distance.  La formule de Haversine la courbure de la terre, mais part du principe que la terre est sphérique, et non une ellipsoïde. Pour les longues distances, la formule de Haversine présente une erreur de moins de 0,1 %.  
  
 Altitude n’est pas utilisé pour calculer la distance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="geoCoordinate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sert de fonction de hachage pour <see cref="T:System.Device.Location.GeoCoordinate" />.</summary>
        <returns>Code de hachage du <see cref="T:System.Device.Location.GeoCoordinate" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Device.Location.GeoCoordinate> les objets sont équivalents ont le même code de hachage. Équivalent <xref:System.Device.Location.GeoCoordinate> objets ont les mêmes <xref:System.Device.Location.GeoCoordinate.Latitude%2A> et <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propriétés. Le <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, et <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propriétés ne sont pas utilisées pour déterminer l’équivalence.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAccuracy">
      <MemberSignature Language="C#" Value="public double HorizontalAccuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HorizontalAccuracy" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAccuracy As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double HorizontalAccuracy { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAccuracy : double with get, set" Usage="System.Device.Location.GeoCoordinate.HorizontalAccuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la précision de la latitude et de la longitude fournies par <see cref="T:System.Device.Location.GeoCoordinate" />, en mètres.</summary>
        <value>Précision de la longitude et de la latitude, en mètres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La précision peut être considéré comme le rayon de certitude des données de latitude et longitude.  Une zone circulaire est formée avec la précision que les coordonnées de radius et de la latitude et longitude en tant que le centre contient l’emplacement réel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" /> se trouve en dehors de la plage valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Device.Location.GeoCoordinate.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'objet <see cref="T:System.Device.Location.GeoCoordinate" /> ne contient pas de données de latitude ou de longitude.</summary>
        <value><see langword="true" /> si l'objet <see cref="T:System.Device.Location.GeoCoordinate" /> ne contient pas de données de latitude ou de longitude ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Device.Location.GeoCoordinate> qui ne contient pas de latitude ou de données de longitude sont égales à <xref:System.Device.Location.GeoCoordinate.Unknown>.  
  
   
  
## Examples  
 L’exemple de code suivant vérifie si le <xref:System.Device.Location.GeoCoordinate> qui correspond à un emplacement est <xref:System.Device.Location.GeoCoordinate.Unknown> avant d’imprimer sa latitude et longitude.  
  
 [!code-csharp[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/cs/getlocationdatasynchandleunknown.cs#1)]
 [!code-vb[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/vb/GetLocationDataSyncHandleUnknown.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Latitude">
      <MemberSignature Language="C#" Value="public double Latitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Latitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Latitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Latitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Latitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Latitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Latitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la latitude de <see cref="T:System.Device.Location.GeoCoordinate" />.</summary>
        <value>Latitude de la localisation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Latitude peut comprise entre -90.0 et 90.0. Latitude est mesurée en degrés nord ou sud de l’Équateur. Les valeurs positives sont au nord de l’Équateur et les valeurs négatives sont au sud de l’Équateur.  
  
   
  
## Examples  
 L’exemple suivant imprime les valeurs de latitude et longitude sont obtenues à partir d’un <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.LocationEvent1#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.locationevent1/cs/locationevent.cs#1)]
 [!code-vb[System.Device.Location.LocationEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.locationevent1/vb/locationevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Latitude" /> se trouve en dehors de la plage valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Longitude">
      <MemberSignature Language="C#" Value="public double Longitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Longitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Longitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Longitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Longitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Longitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Longitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la longitude de <see cref="T:System.Device.Location.GeoCoordinate" />.</summary>
        <value>Longitude.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitude peut comprise entre -180.0 et 180.0. Longitude est mesurée en degrés est ou ouest du premier méridien. Les valeurs négatives sont à l’ouest du premier méridien et sont des valeurs positives à l’est.  
  
   
  
## Examples  
 L’exemple suivant imprime les valeurs de latitude et longitude sont obtenues à partir d’un <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.LocationEvent1#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.locationevent1/cs/locationevent.cs#1)]
 [!code-vb[System.Device.Location.LocationEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.locationevent1/vb/locationevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Longitude" /> se trouve en dehors de la plage valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Device.Location.GeoCoordinate left, System.Device.Location.GeoCoordinate right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Device.Location.GeoCoordinate left, class System.Device.Location.GeoCoordinate right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.op_Equality(System.Device.Location.GeoCoordinate,System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As GeoCoordinate, right As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Device::Location::GeoCoordinate ^ left, System::Device::Location::GeoCoordinate ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Device.Location.GeoCoordinate * System.Device.Location.GeoCoordinate -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Device.Location.GeoCoordinate" />
        <Parameter Name="right" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="left">Premier <see cref="T:System.Device.Location.GeoCoordinate" /> à comparer.</param>
        <param name="right">Deuxième <see cref="T:System.Device.Location.GeoCoordinate" /> à comparer.</param>
        <summary>Détermine si deux objets <see cref="T:System.Device.Location.GeoCoordinate" /> font référence à la même localisation.</summary>
        <returns><see langword="true" />, s'il est déterminé que les objets <see cref="T:System.Device.Location.GeoCoordinate" /> sont équivalents ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Équivalent <xref:System.Device.Location.GeoCoordinate> objets ont les mêmes <xref:System.Device.Location.GeoCoordinate.Latitude%2A> et <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propriétés. Le <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, et <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propriétés ne sont pas utilisées pour déterminer l’équivalence.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Device.Location.GeoCoordinate left, System.Device.Location.GeoCoordinate right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Device.Location.GeoCoordinate left, class System.Device.Location.GeoCoordinate right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.op_Inequality(System.Device.Location.GeoCoordinate,System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As GeoCoordinate, right As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Device::Location::GeoCoordinate ^ left, System::Device::Location::GeoCoordinate ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Device.Location.GeoCoordinate * System.Device.Location.GeoCoordinate -&gt; bool" Usage="System.Device.Location.GeoCoordinate.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Device.Location.GeoCoordinate" />
        <Parameter Name="right" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="left">Premier <see cref="T:System.Device.Location.GeoCoordinate" /> à comparer.</param>
        <param name="right">Deuxième <see cref="T:System.Device.Location.GeoCoordinate" /> à comparer.</param>
        <summary>Détermine si deux objets <see cref="T:System.Device.Location.GeoCoordinate" /> correspondent à des localisations différentes.</summary>
        <returns><see langword="true" />, s'il est déterminé que les objets <see cref="T:System.Device.Location.GeoCoordinate" /> sont différents ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Équivalent <xref:System.Device.Location.GeoCoordinate> objets ont les mêmes <xref:System.Device.Location.GeoCoordinate.Latitude%2A> et <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propriétés. Le <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, et <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propriétés ne sont pas utilisées pour déterminer l’équivalence.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Speed">
      <MemberSignature Language="C#" Value="public double Speed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Speed" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Speed" />
      <MemberSignature Language="VB.NET" Value="Public Property Speed As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Speed { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Speed : double with get, set" Usage="System.Device.Location.GeoCoordinate.Speed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la vitesse en mètres par seconde.</summary>
        <value>Vitesse en mètres par seconde. La vitesse doit être supérieure ou égale à zéro ou être égale à <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant imprime le <xref:System.Device.Location.GeoCoordinate.Course%2A> et <xref:System.Device.Location.GeoCoordinate.Speed%2A> propriétés de l’emplacement actuel <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.courseandspeed/cs/courseandspeed.cs#2)]
 [!code-vb[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.courseandspeed/vb/courseandspeed.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Speed" /> se trouve en dehors de la plage valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="geoCoordinate.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne qui contient la latitude et la longitude.</summary>
        <returns>Chaîne qui contient la latitude et la longitude, séparées par une virgule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation sous forme de chaîne retournée par cette méthode est destinée uniquement au débogage. Cette méthode ne retourne pas de toute mise en forme spécifique aux paramètres régionaux pour la latitude et longitude.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unknown">
      <MemberSignature Language="C#" Value="public static readonly System.Device.Location.GeoCoordinate Unknown;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Device.Location.GeoCoordinate Unknown" />
      <MemberSignature Language="DocId" Value="F:System.Device.Location.GeoCoordinate.Unknown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unknown As GeoCoordinate " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Device::Location::GeoCoordinate ^ Unknown;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unknown : System.Device.Location.GeoCoordinate" Usage="System.Device.Location.GeoCoordinate.Unknown" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Device.Location.GeoCoordinate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente un objet <see cref="T:System.Device.Location.GeoCoordinate" /> avec des champs de latitude et de longitude inconnus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Device.Location.GeoCoordinate.IsUnknown%2A> propriété peut être utilisée pour vérifier si un <xref:System.Device.Location.GeoCoordinate> ne contient aucune donnée.  
  
   
  
## Examples  
 L’exemple de code suivant vérifie si le <xref:System.Device.Location.GeoCoordinate> qui correspond à un emplacement est <xref:System.Device.Location.GeoCoordinate.Unknown> avant printingout sa latitude et longitude.  
  
 [!code-csharp[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/cs/getlocationdatasynchandleunknown.cs#1)]
 [!code-vb[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/vb/GetLocationDataSyncHandleUnknown.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAccuracy">
      <MemberSignature Language="C#" Value="public double VerticalAccuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VerticalAccuracy" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAccuracy As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double VerticalAccuracy { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAccuracy : double with get, set" Usage="System.Device.Location.GeoCoordinate.VerticalAccuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la précision de l'altitude fournie par <see cref="T:System.Device.Location.GeoCoordinate" />, en mètres.</summary>
        <value>Précision de l'altitude, en mètres.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" /> se trouve en dehors de la plage valide.</exception>
      </Docs>
    </Member>
  </Members>
</Type>