<Type Name="MemoryMappedFile" FullName="System.IO.MemoryMappedFiles.MemoryMappedFile">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5794f41f678729fe3a0e5151b4d902f5da9b9863" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57919986" /></Metadata><TypeSignature Language="C#" Value="public class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryMappedFile extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMappedFile&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryMappedFile = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="40e56-101">Représente un fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-101">Represents a memory-mapped file.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-102">Un fichier mappé en mémoire mappe le contenu d’un fichier à l’espace d’adressage logique d’une application.</span><span class="sxs-lookup"><span data-stu-id="40e56-102">A memory-mapped file maps the contents of a file to an application's logical address space.</span></span> <span data-ttu-id="40e56-103">Fichiers mappés en mémoire permettent aux programmeurs de travailler avec des fichiers extrêmement volumineux parce que la mémoire peut être gérée simultanément, et ils permettent un accès aléatoire dans un fichier sans avoir besoin pour la recherche terminé.</span><span class="sxs-lookup"><span data-stu-id="40e56-103">Memory-mapped files enable programmers to work with extremely large files because memory can be managed concurrently, and they allow complete, random access to a file without the need for seeking.</span></span> <span data-ttu-id="40e56-104">Fichiers mappés en mémoire peuvent également être partagés entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-104">Memory-mapped files can also be shared across multiple processes.</span></span>  
  
 <span data-ttu-id="40e56-105">Le <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> méthodes créent un fichier mappé en mémoire à partir d’un chemin d’accès spécifié ou un <xref:System.IO.FileStream> d’un fichier existant sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-105">The <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> methods create a memory-mapped file from a specified path or a <xref:System.IO.FileStream> of an existing file on disk.</span></span> <span data-ttu-id="40e56-106">Modifications sont propagées automatiquement disque lorsque le fichier n’est pas mappé.</span><span class="sxs-lookup"><span data-stu-id="40e56-106">Changes are automatically propagated to disk when the file is unmapped.</span></span>  
  
 <span data-ttu-id="40e56-107">Le <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> méthodes, créez un fichier mappé en mémoire qui n’est pas mappé à un fichier existant sur le disque ; et conviennent pour la création d’une mémoire partagée pour la communication interprocessus (IPC).</span><span class="sxs-lookup"><span data-stu-id="40e56-107">The <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> methods create a memory-mapped file that is not mapped to an existing file on disk; and are suitable for creating shared memory for interprocess communication (IPC).</span></span>  
  
 <span data-ttu-id="40e56-108">Un fichier mappé en mémoire peut être associé à un nom facultatif qui permet au fichier mappé en mémoire à partager avec d’autres processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-108">A memory-mapped file can be associated with an optional name that allows the memory-mapped file to be shared with other processes.</span></span> 
  
 <span data-ttu-id="40e56-109">Vous pouvez créer plusieurs vues du fichier mappé en mémoire, y compris les affichages des parties du fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-109">You can create multiple views of the memory-mapped file, including views of parts of the file.</span></span> <span data-ttu-id="40e56-110">Vous pouvez mapper la même partie d’un fichier à plusieurs adresses pour créer une mémoire simultanée.</span><span class="sxs-lookup"><span data-stu-id="40e56-110">You can map the same part of a file to more than one address to create concurrent memory.</span></span> <span data-ttu-id="40e56-111">Pour que deux vues restent simultanées, elles doivent être créées à partir du même fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-111">For two views to remain concurrent, they have to be created from the same memory-mapped file.</span></span> <span data-ttu-id="40e56-112">Création des deux mappages de fichier du même fichier avec deux vues ne fournit pas d’accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="40e56-112">Creating two file mappings of the same file with two views does not provide concurrency.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="40e56-113">L’exemple suivant crée une vue mappée en mémoire d’une partie d’un fichier très volumineux et manipule une partie de ce dernier.</span><span class="sxs-lookup"><span data-stu-id="40e56-113">The following example creates a memory-mapped view of a part of an extremely large file and manipulates a portion of it.</span></span>  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-114">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-114">Memory-Mapped Files</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateFromFile">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="40e56-115">Crée un fichier mappé en mémoire à partir d'un fichier existant.</span><span class="sxs-lookup"><span data-stu-id="40e56-115">Creates a memory-mapped file from an existing file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="40e56-116">Chemin d'accès au fichier à mapper.</span><span class="sxs-lookup"><span data-stu-id="40e56-116">The path to file to map.</span></span></param>
        <summary><span data-ttu-id="40e56-117">Crée un fichier mappé en mémoire à partir d'un fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-117">Creates a memory-mapped file from a file on disk.</span></span></summary>
        <returns><span data-ttu-id="40e56-118">Fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-118">A memory-mapped file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="40e56-119">L’exemple suivant utilise la <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> méthode pour créer un fichier mappé en mémoire, puis crée une vue mappée en mémoire à une partie d’un fichier très volumineux.</span><span class="sxs-lookup"><span data-stu-id="40e56-119">The following example uses the <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> method to create a memory-mapped file, and then creates a memory-mapped view to a portion of an extremely large file.</span></span>  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-120"><paramref name="path" /> est une chaîne vide, ne contient que des espaces blancs ou contient des caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-120"><paramref name="path" /> is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> method.</span></span>  
  
<span data-ttu-id="40e56-121">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-121">-or-</span></span> 
 <span data-ttu-id="40e56-122"><paramref name="path" /> fait référence à un appareil non valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-122"><paramref name="path" /> refers to an invalid device.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-123"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-123"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-124">Une erreur d'E/S s'est produite.</span><span class="sxs-lookup"><span data-stu-id="40e56-124">An I/O error occurred.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="40e56-125"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="40e56-125"><paramref name="path" /> exceeds the maximum length defined by the operating system.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="40e56-126">L’appelant n’a pas les autorisations obligatoires pour le fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-126">The caller does not have the required permissions for the file.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-127">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-127">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="40e56-128">Chemin d'accès au fichier à mapper.</span><span class="sxs-lookup"><span data-stu-id="40e56-128">The path to the file to map.</span></span></param>
        <param name="mode"><span data-ttu-id="40e56-129">Mode d’accès : doit être <see cref="F:System.IO.FileMode.Open" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-129">Access mode; must be <see cref="F:System.IO.FileMode.Open" />.</span></span></param>
        <summary><span data-ttu-id="40e56-130">Crée un fichier mappé en mémoire qui a le mode d’accès spécifié d’un fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-130">Creates a memory-mapped file that has the specified access mode from a file on disk.</span></span></summary>
        <returns><span data-ttu-id="40e56-131">Fichier mappé en mémoire qui a le mode d'accès spécifié.</span><span class="sxs-lookup"><span data-stu-id="40e56-131">A memory-mapped file that has the specified access mode.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-132">Le `mode` paramètre se rapporte au fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-132">The `mode` parameter pertains to the source file on disk.</span></span> <span data-ttu-id="40e56-133">Vous pouvez utiliser uniquement le <xref:System.IO.FileMode.Open> valeur d’énumération pour créer le fichier mappé en mémoire à partir du fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-133">You can use only the <xref:System.IO.FileMode.Open> enumeration value to create the memory-mapped file from the source file on disk.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-134"><paramref name="path" /> est une chaîne vide, ne contient que des espaces blancs ou contient des caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-134"><paramref name="path" /> is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> method.</span></span>  
  
<span data-ttu-id="40e56-135">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-135">-or-</span></span> 
 <span data-ttu-id="40e56-136"><paramref name="path" /> fait référence à un appareil non valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-136"><paramref name="path" /> refers to an invalid device.</span></span>  
  
<span data-ttu-id="40e56-137">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-137">-or-</span></span> 
 <span data-ttu-id="40e56-138"><paramref name="mode" /> est <see cref="F:System.IO.FileMode.Append" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-138"><paramref name="mode" /> is <see cref="F:System.IO.FileMode.Append" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-139"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-139"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-140"><paramref name="mode" /> a la valeur <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> ou <see cref="F:System.IO.FileMode.Truncate" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-140"><paramref name="mode" /> is <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, or <see cref="F:System.IO.FileMode.Truncate" />.</span></span>  
  
<span data-ttu-id="40e56-141">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-141">-or-</span></span> 
 <span data-ttu-id="40e56-142"><paramref name="mode" /> a la valeur <see cref="F:System.IO.FileMode.OpenOrCreate" /> et le fichier sur disque n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="40e56-142"><paramref name="mode" /> is <see cref="F:System.IO.FileMode.OpenOrCreate" /> and the file on disk does not exist.</span></span>  
  
<span data-ttu-id="40e56-143">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-143">-or-</span></span> 
<span data-ttu-id="40e56-144">Une erreur d'E/S s'est produite.</span><span class="sxs-lookup"><span data-stu-id="40e56-144">An I/O error occurred.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="40e56-145"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="40e56-145"><paramref name="path" /> exceeds the maximum length defined by the operating system.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="40e56-146">L’appelant n’a pas les autorisations obligatoires pour le fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-146">The caller does not have the required permissions for the file.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-147">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-147">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="40e56-148">Chemin d'accès au fichier à mapper.</span><span class="sxs-lookup"><span data-stu-id="40e56-148">The path to the file to map.</span></span></param>
        <param name="mode"><span data-ttu-id="40e56-149">Mode d’accès : doit être <see cref="F:System.IO.FileMode.Open" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-149">Access mode; must be <see cref="F:System.IO.FileMode.Open" />.</span></span></param>
        <param name="mapName"><span data-ttu-id="40e56-150">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-150">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <summary><span data-ttu-id="40e56-151">Crée un fichier mappé en mémoire qui a le mode d'accès et le nom spécifiés d'un fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-151">Creates a memory-mapped file that has the specified access mode and name from a file on disk.</span></span></summary>
        <returns><span data-ttu-id="40e56-152">Fichier mappé en mémoire qui a le nom et le mode d'accès spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-152">A memory-mapped file that has the specified name and access mode.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-153">Le `mode` paramètre se rapporte au fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-153">The `mode` parameter pertains to the source file on disk.</span></span> <span data-ttu-id="40e56-154">Vous pouvez utiliser uniquement le <xref:System.IO.FileMode.Open> valeur d’énumération pour créer le fichier mappé en mémoire à partir du fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-154">You can use only the <xref:System.IO.FileMode.Open> enumeration value to create the memory-mapped file from the source file on disk.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-155"><paramref name="path" /> est une chaîne vide, ne contient que des espaces blancs ou contient des caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-155"><paramref name="path" /> is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> method.</span></span>  
  
<span data-ttu-id="40e56-156">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-156">-or-</span></span> 
 <span data-ttu-id="40e56-157"><paramref name="path" /> fait référence à un appareil non valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-157"><paramref name="path" /> refers to an invalid device.</span></span>  
  
<span data-ttu-id="40e56-158">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-158">-or-</span></span> 
 <span data-ttu-id="40e56-159"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-159"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-160">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-160">-or-</span></span> 
 <span data-ttu-id="40e56-161"><paramref name="mode" /> est <see cref="F:System.IO.FileMode.Append" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-161"><paramref name="mode" /> is <see cref="F:System.IO.FileMode.Append" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-162"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-162"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-163"><paramref name="mode" /> a la valeur <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> ou <see cref="F:System.IO.FileMode.Truncate" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-163"><paramref name="mode" /> is <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, or <see cref="F:System.IO.FileMode.Truncate" />.</span></span>  
  
<span data-ttu-id="40e56-164">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-164">-or-</span></span> 
 <span data-ttu-id="40e56-165"><paramref name="mode" /> a la valeur <see cref="F:System.IO.FileMode.OpenOrCreate" /> et le fichier sur disque n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="40e56-165"><paramref name="mode" /> is <see cref="F:System.IO.FileMode.OpenOrCreate" /> and the file on disk does not exist.</span></span>  
  
<span data-ttu-id="40e56-166">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-166">-or-</span></span> 
<span data-ttu-id="40e56-167">Une erreur d'E/S s'est produite.</span><span class="sxs-lookup"><span data-stu-id="40e56-167">An I/O error occurred.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="40e56-168"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="40e56-168"><paramref name="path" /> exceeds the maximum length defined by the operating system.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="40e56-169">L’appelant n’a pas les autorisations obligatoires pour le fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-169">The caller does not have the required permissions for the file.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="40e56-170">Chemin d'accès au fichier à mapper.</span><span class="sxs-lookup"><span data-stu-id="40e56-170">The path to the file to map.</span></span></param>
        <param name="mode"><span data-ttu-id="40e56-171">Le mode d’accès peut avoir n’importe quelle valeur d’énumération <see cref="T:System.IO.FileMode" /> sauf <see cref="F:System.IO.FileMode.Append" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-171">Access mode; can be any of the <see cref="T:System.IO.FileMode" /> enumeration values except <see cref="F:System.IO.FileMode.Append" />.</span></span></param>
        <param name="mapName"><span data-ttu-id="40e56-172">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-172">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-173">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-173">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span> <span data-ttu-id="40e56-174">Spécifiez 0 pour affecter à la capacité la taille du fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-174">Specify 0 to set the capacity to the size of the file on disk.</span></span></param>
        <summary><span data-ttu-id="40e56-175">Crée un fichier mappé en mémoire qui a le mode d'accès, le nom et la capacité spécifiés d'un fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-175">Creates a memory-mapped file that has the specified access mode, name, and capacity from a file on disk.</span></span></summary>
        <returns><span data-ttu-id="40e56-176">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-176">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-177">Le `mode` paramètre se rapporte au fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-177">The `mode` parameter pertains to the source file on disk.</span></span>  
  
 <span data-ttu-id="40e56-178">Si `capacity` est supérieure à la taille du fichier sur disque, le fichier sur le disque est augmentée pour correspondre à la capacité spécifiée, même si aucune donnée n’est écrite dans le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-178">If `capacity` is larger than the size of the file on disk, the file on disk is increased to match the specified capacity even if no data is written to the memory-mapped file.</span></span> <span data-ttu-id="40e56-179">Pour éviter ce problème, spécifiez 0 (zéro) pour la capacité par défaut, qui sera définie en interne `capacity` à la taille du fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-179">To prevent this from occurring, specify 0 (zero) for the default capacity, which will internally set `capacity` to the size of the file on disk.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-180"><paramref name="path" /> est une chaîne vide, ne contient que des espaces blancs ou contient des caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-180"><paramref name="path" /> is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> method.</span></span>  
  
<span data-ttu-id="40e56-181">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-181">-or-</span></span> 
 <span data-ttu-id="40e56-182"><paramref name="path" /> fait référence à un appareil non valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-182"><paramref name="path" /> refers to an invalid device.</span></span>  
  
<span data-ttu-id="40e56-183">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-183">-or-</span></span> 
 <span data-ttu-id="40e56-184"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-184"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-185">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-185">-or-</span></span> 
 <span data-ttu-id="40e56-186"><paramref name="mode" /> est <see cref="F:System.IO.FileMode.Append" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-186"><paramref name="mode" /> is <see cref="F:System.IO.FileMode.Append" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-187"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-187"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-188"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-188"><paramref name="capacity" /> is greater than the size of the logical address space.</span></span>  
  
<span data-ttu-id="40e56-189">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-189">-or-</span></span> 
 <span data-ttu-id="40e56-190"><paramref name="capacity" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-190"><paramref name="capacity" /> is less than zero.</span></span>  
  
<span data-ttu-id="40e56-191">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-191">-or-</span></span> 
 <span data-ttu-id="40e56-192"><paramref name="capacity" /> est inférieur à la taille de fichier (mais est différent de zéro).</span><span class="sxs-lookup"><span data-stu-id="40e56-192"><paramref name="capacity" /> is less than the file size (but not zero).</span></span>  
  
<span data-ttu-id="40e56-193">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-193">-or-</span></span> 
 <span data-ttu-id="40e56-194"><paramref name="capacity" /> est égal à zéro, et la taille du fichier sur le disque est aussi égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-194"><paramref name="capacity" /> is zero, and the size of the file on disk is also zero.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-195">Une erreur d'E/S s'est produite.</span><span class="sxs-lookup"><span data-stu-id="40e56-195">An I/O error occurred.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="40e56-196"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="40e56-196"><paramref name="path" /> exceeds the maximum length defined by the operating system.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="40e56-197">L’appelant n’a pas les autorisations obligatoires pour le fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-197">The caller does not have the required permissions for the file.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="40e56-198">Chemin d'accès au fichier à mapper.</span><span class="sxs-lookup"><span data-stu-id="40e56-198">The path to the file to map.</span></span></param>
        <param name="mode"><span data-ttu-id="40e56-199">Le mode d’accès peut avoir n’importe quelle valeur d’énumération <see cref="T:System.IO.FileMode" /> sauf <see cref="F:System.IO.FileMode.Append" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-199">Access mode; can be any of the <see cref="T:System.IO.FileMode" /> enumeration values except <see cref="F:System.IO.FileMode.Append" />.</span></span></param>
        <param name="mapName"><span data-ttu-id="40e56-200">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-200">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-201">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-201">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span> <span data-ttu-id="40e56-202">Spécifiez 0 pour affecter à la capacité la taille du fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-202">Specify 0 to set the capacity to the size of the file on disk.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-203">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-203">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span></param>
        <summary><span data-ttu-id="40e56-204">Crée un fichier mappé en mémoire qui a le mode d'accès, le nom, la capacité et le type d'accès spécifiés d'un fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-204">Creates a memory-mapped file that has the specified access mode, name, capacity, and access type from a file on disk.</span></span></summary>
        <returns><span data-ttu-id="40e56-205">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-205">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-206">Le `mode` paramètre se rapporte au fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-206">The `mode` parameter pertains to the source file on disk.</span></span>  
  
 <span data-ttu-id="40e56-207">Si `capacity` est supérieure à la taille du fichier sur disque, le fichier sur le disque est augmentée pour correspondre à la capacité spécifiée, même si aucune donnée n’est écrite dans le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-207">If `capacity` is larger than the size of the file on disk, the file on disk is increased to match the specified capacity even if no data is written to the memory-mapped file.</span></span> <span data-ttu-id="40e56-208">Pour éviter ce problème, spécifiez 0 (zéro) pour la capacité par défaut, qui sera définie en interne `capacity` à la taille du fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-208">To prevent this from occurring, specify 0 (zero) for the default capacity, which will internally set `capacity` to the size of the file on disk.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-209"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-209"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-210">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-210">-or-</span></span> 
 <span data-ttu-id="40e56-211"><paramref name="access" /> n’est pas une valeur autorisée.</span><span class="sxs-lookup"><span data-stu-id="40e56-211"><paramref name="access" /> is not an allowed value.</span></span>  
  
<span data-ttu-id="40e56-212">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-212">-or-</span></span> 
 <span data-ttu-id="40e56-213"><paramref name="path" /> spécifie un fichier vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-213"><paramref name="path" /> specifies an empty file.</span></span>  
  
<span data-ttu-id="40e56-214">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-214">-or-</span></span> 
 <span data-ttu-id="40e56-215"><paramref name="access" /> est spécifié comme <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> et la capacité est supérieure à la taille du fichier indiquée par <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-215"><paramref name="access" /> is specified as <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> and capacity is greater than the size of the file indicated by <paramref name="path" />.</span></span>  
  
<span data-ttu-id="40e56-216">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-216">-or-</span></span> 
 <span data-ttu-id="40e56-217"><paramref name="mode" /> est <see cref="F:System.IO.FileMode.Append" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-217"><paramref name="mode" /> is <see cref="F:System.IO.FileMode.Append" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-218"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-218"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-219"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-219"><paramref name="capacity" /> is greater than the size of the logical address space.</span></span>  
  
<span data-ttu-id="40e56-220">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-220">-or-</span></span> 
 <span data-ttu-id="40e56-221"><paramref name="capacity" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-221"><paramref name="capacity" /> is less than zero.</span></span>  
  
<span data-ttu-id="40e56-222">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-222">-or-</span></span> 
 <span data-ttu-id="40e56-223"><paramref name="capacity" /> est inférieur à la taille de fichier (mais est différent de zéro).</span><span class="sxs-lookup"><span data-stu-id="40e56-223"><paramref name="capacity" /> is less than the file size (but not zero).</span></span>  
  
<span data-ttu-id="40e56-224">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-224">-or-</span></span> 
 <span data-ttu-id="40e56-225"><paramref name="capacity" /> est égal à zéro, et la taille du fichier sur le disque est aussi égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-225"><paramref name="capacity" /> is zero, and the size of the file on disk is also zero.</span></span>  
  
<span data-ttu-id="40e56-226">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-226">-or-</span></span> 
 <span data-ttu-id="40e56-227"><paramref name="access" /> n’est pas une valeur <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> définie.</span><span class="sxs-lookup"><span data-stu-id="40e56-227"><paramref name="access" /> is not a defined <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> value.</span></span>  
  
<span data-ttu-id="40e56-228">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-228">-or-</span></span> 
<span data-ttu-id="40e56-229">La taille du fichier indiqué par <paramref name="path" /> est supérieure à <paramref name="capacity" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-229">The size of the file indicated by <paramref name="path" /> is greater than <paramref name="capacity" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-230">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-230">-or-</span></span> 
<span data-ttu-id="40e56-231">Une erreur d'E/S s'est produite.</span><span class="sxs-lookup"><span data-stu-id="40e56-231">An I/O error occurred.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="40e56-232"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="40e56-232"><paramref name="path" /> exceeds the maximum length defined by the operating system.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="40e56-233">L’appelant n’a pas les autorisations obligatoires pour le fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-233">The caller does not have the required permissions for the file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="40e56-234">Pour accéder au code non managé.</span><span class="sxs-lookup"><span data-stu-id="40e56-234">for access to unmanaged code.</span></span> <span data-ttu-id="40e56-235">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-235">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-236">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-236">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mapName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileStream"><span data-ttu-id="40e56-237">Flux de fichier du fichier existant.</span><span class="sxs-lookup"><span data-stu-id="40e56-237">The file stream of the existing file.</span></span></param>
        <param name="mapName"><span data-ttu-id="40e56-238">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-238">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-239">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-239">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span> <span data-ttu-id="40e56-240">Spécifiez 0 pour affecter à la capacité la taille de <c>filestream</c>.</span><span class="sxs-lookup"><span data-stu-id="40e56-240">Specify 0 to set the capacity to the size of <c>filestream</c>.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-241">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-241">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span>  
  
<span data-ttu-id="40e56-242">Ce paramètre ne peut pas avoir la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-242">This parameter can't be set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span></span></param>
        <param name="inheritability"><span data-ttu-id="40e56-243">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-243">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process.</span></span> <span data-ttu-id="40e56-244">La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-244">The default is <see cref="F:System.IO.HandleInheritability.None" />.</span></span></param>
        <param name="leaveOpen"><span data-ttu-id="40e56-245">Valeur qui indique s’il faut fermer le flux de fichier source quand le <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> est supprimé.</span><span class="sxs-lookup"><span data-stu-id="40e56-245">A value that indicates whether to close the source file stream when the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> is disposed.</span></span></param>
        <summary><span data-ttu-id="40e56-246">Crée un fichier mappé en mémoire à partir d’un fichier existant avec le mode d’accès, le nom, les règles d’héritage et la capacité spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-246">Creates a memory-mapped file from an existing file with the specified access mode, name, inheritability, and capacity.</span></span></summary>
        <returns><span data-ttu-id="40e56-247">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-247">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-248"><paramref name="mapName" /> est <see langword="null" /> ou est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-248"><paramref name="mapName" /> is <see langword="null" /> or an empty string.</span></span>  
  
<span data-ttu-id="40e56-249">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-249">-or-</span></span> 
 <span data-ttu-id="40e56-250"><paramref name="capacity" /> et la longueur du fichier ont une valeur égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-250"><paramref name="capacity" /> and the length of the file are zero.</span></span>  
  
<span data-ttu-id="40e56-251">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-251">-or-</span></span> 
 <span data-ttu-id="40e56-252"><paramref name="access" /> a une valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />, qui n’est pas autorisée.</span><span class="sxs-lookup"><span data-stu-id="40e56-252"><paramref name="access" /> is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value, which is not allowed.</span></span>  
  
<span data-ttu-id="40e56-253">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-253">-or-</span></span> 
 <span data-ttu-id="40e56-254"><paramref name="access" /> a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> et <paramref name="capacity" /> est supérieur à la longueur de <see langword="filestream" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-254"><paramref name="access" /> is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> and <paramref name="capacity" /> is larger than the length of <see langword="filestream" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-255"><paramref name="fileStream" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-255"><paramref name="fileStream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-256"><paramref name="capacity" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-256"><paramref name="capacity" /> is less than zero.</span></span>  
  
<span data-ttu-id="40e56-257">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-257">-or-</span></span> 
 <span data-ttu-id="40e56-258"><paramref name="capacity" /> est inférieur à la taille du fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-258"><paramref name="capacity" /> is less than the file size.</span></span>  
  
<span data-ttu-id="40e56-259">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-259">-or-</span></span> 
 <span data-ttu-id="40e56-260"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-260"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span>  
  
<span data-ttu-id="40e56-261">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-261">-or-</span></span> 
 <span data-ttu-id="40e56-262"><paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-262"><paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, memoryMappedFileSecurity, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mapName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileStream"><span data-ttu-id="40e56-263"><paramref name="fileStream" /> du fichier à mapper.</span><span class="sxs-lookup"><span data-stu-id="40e56-263">The <paramref name="fileStream" /> to the file to map.</span></span></param>
        <param name="mapName"><span data-ttu-id="40e56-264">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-264">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-265">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-265">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span> <span data-ttu-id="40e56-266">Spécifiez 0 pour affecter à la capacité la taille du fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-266">Specify 0 to set the capacity to the size of the file on disk.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-267">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-267">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span>  
  
<span data-ttu-id="40e56-268">Ce paramètre ne peut pas avoir la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-268">This parameter can't be set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span></span></param>
        <param name="memoryMappedFileSecurity"><span data-ttu-id="40e56-269">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-269">The permissions that can be granted for file access and operations on memory-mapped files.</span></span>  
  
<span data-ttu-id="40e56-270">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-270">This parameter can be <see langword="null" />.</span></span></param>
        <param name="inheritability"><span data-ttu-id="40e56-271">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-271">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process.</span></span> <span data-ttu-id="40e56-272">La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-272">The default is <see cref="F:System.IO.HandleInheritability.None" />.</span></span></param>
        <param name="leaveOpen"><span data-ttu-id="40e56-273"><see langword="true" /> pour ne pas supprimer <paramref name="fileStream" /> après la fermeture de <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> ; <see langword="false" /> pour supprimer <paramref name="fileStream" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-273"><see langword="true" /> to not dispose <paramref name="fileStream" /> after the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> is closed; <see langword="false" /> to dispose <paramref name="fileStream" />.</span></span></param>
        <summary><span data-ttu-id="40e56-274">Crée un fichier mappé en mémoire qui a le nom, la capacité, le type d’accès, les autorisations de sécurité, les règles d’héritage et les spécifications de suppression spécifiés d’un fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-274">Creates a memory-mapped file that has the specified name, capacity, access type, security permissions, inheritability, and disposal requirement from a file on disk.</span></span></summary>
        <returns><span data-ttu-id="40e56-275">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-275">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-276">Si `capacity` est supérieure à la taille du fichier sur disque, le fichier sur le disque est augmentée pour correspondre à la capacité spécifiée, même si aucune donnée n’est écrite dans le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-276">If `capacity` is larger than the size of the file on disk, the file on disk is increased to match the specified capacity even if no data is written to the memory-mapped file.</span></span> <span data-ttu-id="40e56-277">Pour éviter ce problème, spécifiez 0 (zéro) pour la capacité par défaut, qui sera définie en interne `capacity` à la taille du fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-277">To prevent this from occurring, specify 0 (zero) for the default capacity, which will internally set `capacity` to the size of the file on disk.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-278"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-278"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-279">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-279">-or-</span></span> 
 <span data-ttu-id="40e56-280"><paramref name="capacity" /> et la longueur du fichier ont une valeur égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-280"><paramref name="capacity" /> and the length of the file are zero.</span></span>  
  
<span data-ttu-id="40e56-281">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-281">-or-</span></span> 
 <span data-ttu-id="40e56-282"><paramref name="access" /> a la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />, qui n’est pas autorisée.</span><span class="sxs-lookup"><span data-stu-id="40e56-282"><paramref name="access" /> is set to the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value, which is not allowed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-283"><paramref name="fileStream" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-283"><paramref name="fileStream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-284"><paramref name="capacity" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-284"><paramref name="capacity" /> is less than zero.</span></span>  
  
<span data-ttu-id="40e56-285">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-285">-or-</span></span> 
 <span data-ttu-id="40e56-286"><paramref name="capacity" /> est inférieur à la taille du fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-286"><paramref name="capacity" /> is less than the file size.</span></span>  
  
<span data-ttu-id="40e56-287">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-287">-or-</span></span> 
 <span data-ttu-id="40e56-288"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-288"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span>  
  
<span data-ttu-id="40e56-289">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-289">-or-</span></span> 
 <span data-ttu-id="40e56-290"><paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-290"><paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="40e56-291"><paramref name="fileStream" /> a été fermé.</span><span class="sxs-lookup"><span data-stu-id="40e56-291"><paramref name="fileStream" /> was closed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-292"><paramref name="access" /> a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> quand l’accès à <paramref name="fileStream" /> a la valeur <see cref="F:System.IO.FileAccess.Read" /> ou <see cref="F:System.IO.FileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-292"><paramref name="access" /> is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> when <paramref name="fileStream" />'s access is set to <see cref="F:System.IO.FileAccess.Read" /> or <see cref="F:System.IO.FileAccess.Write" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-293"><paramref name="mapName" /> existe déjà.</span><span class="sxs-lookup"><span data-stu-id="40e56-293"><paramref name="mapName" /> already exists.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="40e56-294">Pour accéder au code non managé.</span><span class="sxs-lookup"><span data-stu-id="40e56-294">for access to unmanaged code.</span></span> <span data-ttu-id="40e56-295">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-295">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-296">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-296">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNew">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="40e56-297">Crée un fichier mappé en mémoire dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-297">Creates a memory-mapped file in system memory.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-298">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-298">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-299">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-299">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span></param>
        <summary><span data-ttu-id="40e56-300">Crée un fichier mappé en mémoire qui a la capacité spécifiée dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-300">Creates a memory-mapped file that has the specified capacity in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-301">Fichier mappé en mémoire qui a le nom et la capacité spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-301">A memory-mapped file that has the specified name and capacity.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-302">Utilisez cette méthode pour créer un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-302">Use this method to create a memory-mapped file that is not persisted (that is, not associated with a file on disk), which you can use to share data between processes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="40e56-303">L’exemple suivant est composé de trois processus distincts (applications console) qui écrivent `Boolean` valeurs dans un fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-303">The following example is composed of three separate processes (console applications) that write `Boolean` values to a memory-mapped file.</span></span> <span data-ttu-id="40e56-304">La séquence d’actions suivante se produit :</span><span class="sxs-lookup"><span data-stu-id="40e56-304">The following sequence of actions occur:</span></span>  
  
1.  <span data-ttu-id="40e56-305">Le processus A crée le fichier mappé en mémoire et écrit une valeur.</span><span class="sxs-lookup"><span data-stu-id="40e56-305">Process A creates the memory-mapped file and writes a value to it.</span></span>  
  
2.  <span data-ttu-id="40e56-306">Processus B ouvre le fichier mappé en mémoire et écrit une valeur.</span><span class="sxs-lookup"><span data-stu-id="40e56-306">Process B opens the memory-mapped file and writes a value to it.</span></span>  
  
3.  <span data-ttu-id="40e56-307">Processus C ouvre le fichier mappé en mémoire et écrit une valeur.</span><span class="sxs-lookup"><span data-stu-id="40e56-307">Process C opens the memory-mapped file and writes a value to it.</span></span>  
  
4.  <span data-ttu-id="40e56-308">Processus A lit et affiche les valeurs à partir du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-308">Process A reads and displays the values from the memory-mapped file.</span></span>  
  
5.  <span data-ttu-id="40e56-309">Une fois que le processus a terminé avec le fichier mappé en mémoire, le fichier est immédiatement récupéré par le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="40e56-309">After Process A is finished with the memory-mapped file, the file is immediately reclaimed by garbage collection.</span></span>  
  
 <span data-ttu-id="40e56-310">Pour exécuter cet exemple, procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="40e56-310">To run this example, do the following:</span></span>  
  
1.  <span data-ttu-id="40e56-311">Compilez les applications et ouvrez trois fenêtres de commande.</span><span class="sxs-lookup"><span data-stu-id="40e56-311">Compile the applications and open three Command windows.</span></span>  
  
2.  <span data-ttu-id="40e56-312">Dans la première fenêtre de commande, exécutez le processus A.</span><span class="sxs-lookup"><span data-stu-id="40e56-312">In the first Command window, run Process A.</span></span>  
  
3.  <span data-ttu-id="40e56-313">Dans la deuxième fenêtre de commande, exécutez le processus B.</span><span class="sxs-lookup"><span data-stu-id="40e56-313">In the second Command window, run Process B.</span></span>  
  
4.  <span data-ttu-id="40e56-314">Retournez au processus A et appuyez sur ENTRÉE.</span><span class="sxs-lookup"><span data-stu-id="40e56-314">Return to Process A and press ENTER.</span></span>  
  
5.  <span data-ttu-id="40e56-315">Dans la troisième fenêtre de commande, exécutez le processus C.</span><span class="sxs-lookup"><span data-stu-id="40e56-315">In the third Command window, run Process C.</span></span>  
  
6.  <span data-ttu-id="40e56-316">Retournez au processus A et appuyez sur ENTRÉE.</span><span class="sxs-lookup"><span data-stu-id="40e56-316">Return to Process A and press ENTER.</span></span>  
  
 <span data-ttu-id="40e56-317">La sortie du processus A est la suivante :</span><span class="sxs-lookup"><span data-stu-id="40e56-317">The output of Process A is as follows:</span></span>  
  
```  
Start Process B and press ENTER to continue.  
Start Process C and press ENTER to continue.  
Process A says: True  
Process B says: False  
Process C says: True  
```  
  
 <span data-ttu-id="40e56-318">**Processus A**</span><span class="sxs-lookup"><span data-stu-id="40e56-318">**Process A**</span></span>  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#1)]  
  
 <span data-ttu-id="40e56-319">**Processus B**</span><span class="sxs-lookup"><span data-stu-id="40e56-319">**Process B**</span></span>  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/vb/program.vb#1)]  
  
 <span data-ttu-id="40e56-320">**Processus C**</span><span class="sxs-lookup"><span data-stu-id="40e56-320">**Process C**</span></span>  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-321"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-321"><paramref name="mapName" /> is an empty string.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-322"><paramref name="capacity" /> est inférieur ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-322"><paramref name="capacity" /> is less than or equal to zero.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-323">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-323">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-324">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-324">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-325">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-325">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-326">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-326">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span> <span data-ttu-id="40e56-327">La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-327">The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span></span></param>
        <summary><span data-ttu-id="40e56-328">Crée un fichier mappé en mémoire qui a la capacité et le type d’accès spécifiés dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-328">Creates a memory-mapped file that has the specified capacity and access type in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-329">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-329">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-330">Utilisez cette méthode pour créer un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-330">Use this method to create a memory-mapped file that is not persisted (that is, not associated with a file on disk), which you can use to share data between processes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-331"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-331"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-332">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-332">-or-</span></span> 
 <span data-ttu-id="40e56-333"><paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-333"><paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-334"><paramref name="capacity" /> est inférieur ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-334"><paramref name="capacity" /> is less than or equal to zero.</span></span>  
  
<span data-ttu-id="40e56-335">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-335">-or-</span></span> 
 <span data-ttu-id="40e56-336"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-336"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-337">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-337">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-338">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-338">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-339">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-339">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-340">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-340">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span> <span data-ttu-id="40e56-341">La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-341">The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span></span></param>
        <param name="options"><span data-ttu-id="40e56-342">Combinaison d'opérations de bits de valeurs d'énumération qui spécifie des options d'allocation de mémoire pour le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-342">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</span></span></param>
        <param name="inheritability"><span data-ttu-id="40e56-343">Valeur qui spécifie si un processus enfant peut hériter d’un handle au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-343">A value that specifies whether a handle to the memory-mapped file can be inherited by a child process.</span></span> <span data-ttu-id="40e56-344">La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-344">The default is <see cref="F:System.IO.HandleInheritability.None" />.</span></span></param>
        <summary><span data-ttu-id="40e56-345">Crée un fichier mappé en mémoire qui a le nom, la capacité, le type d’accès, les options d’allocation mémoire et les règles d’héritage spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-345">Creates a memory-mapped file that has the specified name, capacity, access type, memory allocation options and inheritability.</span></span></summary>
        <returns><span data-ttu-id="40e56-346">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-346">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-347"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-347"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-348">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-348">-or-</span></span> 
 <span data-ttu-id="40e56-349"><paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-349"><paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-350"><paramref name="capacity" /> est inférieur ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-350"><paramref name="capacity" /> is less than or equal to zero.</span></span>  
  
<span data-ttu-id="40e56-351">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-351">-or-</span></span> 
 <span data-ttu-id="40e56-352"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-352"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span>  
  
<span data-ttu-id="40e56-353">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-353">-or-</span></span> 
 <span data-ttu-id="40e56-354"><paramref name="inheritability" /> n’est pas une valeur de <see cref="T:System.IO.HandleInheritability" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-354"><paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-355">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-355">A name to assign to the memory-mapped file, or <see langword="null" /> for a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> that you do not intend to share across processes.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-356">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-356">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-357">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-357">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span> <span data-ttu-id="40e56-358">La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-358">The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span></span></param>
        <param name="options"><span data-ttu-id="40e56-359">Combinaison d'opérations de bits de valeurs d'énumération qui spécifie des options d'allocation de mémoire pour le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-359">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</span></span></param>
        <param name="memoryMappedFileSecurity"><span data-ttu-id="40e56-360">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-360">The permissions that can be granted for file access and operations on memory-mapped files.</span></span>  
  
<span data-ttu-id="40e56-361">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-361">This parameter can be <see langword="null" />.</span></span></param>
        <param name="inheritability"><span data-ttu-id="40e56-362">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-362">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process.</span></span> <span data-ttu-id="40e56-363">La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-363">The default is <see cref="F:System.IO.HandleInheritability.None" />.</span></span></param>
        <summary><span data-ttu-id="40e56-364">Crée un fichier mappé en mémoire qui a la capacité, le type d'accès, l'allocation de mémoire, les autorisations de sécurité et les règles d'héritage spécifiés dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-364">Creates a memory-mapped file that has the specified capacity, access type, memory allocation, security permissions, and inheritability in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-365">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-365">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-366">Utilisez cette méthode pour créer un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-366">Use this method to create a memory-mapped file that is not persisted (that is, not associated with a file on disk), which you can use to share data between processes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-367"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-367"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-368">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-368">-or-</span></span> 
 <span data-ttu-id="40e56-369"><paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-369"><paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-370"><paramref name="capacity" /> est inférieur ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-370"><paramref name="capacity" /> is less than or equal to zero.</span></span>  
  
<span data-ttu-id="40e56-371">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-371">-or-</span></span> 
 <span data-ttu-id="40e56-372"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-372"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span>  
  
<span data-ttu-id="40e56-373">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-373">-or-</span></span> 
 <span data-ttu-id="40e56-374"><paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-374"><paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="40e56-375">Pour accéder au code non managé.</span><span class="sxs-lookup"><span data-stu-id="40e56-375">for access to unmanaged code.</span></span> <span data-ttu-id="40e56-376">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-376">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-377">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-377">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateOrOpen">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="40e56-378">Crée ou ouvre un fichier mappé en mémoire dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-378">Creates or opens a memory-mapped file in system memory.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-379">Nom du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-379">The name of the memory-mapped file.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-380">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-380">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span></param>
        <summary><span data-ttu-id="40e56-381">Crée ou ouvre un fichier mappé en mémoire qui a la capacité et le nom spécifiés dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-381">Creates or opens a memory-mapped file that has the specified name and capacity in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-382">Fichier mappé en mémoire qui possède le nom et la taille spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-382">A memory-mapped file that has the specified name and size.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-383">Utilisez cette méthode pour créer ou ouvrir un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-383">Use this method to create or open a memory-mapped file that is not persisted (that is, not associated with a file on disk), which you can use to share data between processes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-384"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-384"><paramref name="mapName" /> is an empty string.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-385"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-385"><paramref name="capacity" /> is greater than the size of the logical address space.</span></span>  
  
<span data-ttu-id="40e56-386">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-386">-or-</span></span> 
 <span data-ttu-id="40e56-387"><paramref name="capacity" /> est inférieur ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-387"><paramref name="capacity" /> is less than or equal to zero.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-388">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-388">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-389">Nom du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-389">The name of the memory-mapped file.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-390">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-390">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-391">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-391">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span> <span data-ttu-id="40e56-392">La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-392">The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span></span></param>
        <summary><span data-ttu-id="40e56-393">Crée ou ouvre un fichier mappé en mémoire qui a la capacité, le nom et le type d’accès spécifiés dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-393">Creates or opens a memory-mapped file that has the specified name, capacity and access type in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-394">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-394">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-395">Utilisez cette méthode pour créer ou ouvrir un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-395">Use this method to create or open a memory-mapped file that is not persisted (that is, not associated with a file on disk), which you can use to share data between processes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-396"><paramref name="mapName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-396"><paramref name="mapName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-397"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-397"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-398">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-398">-or-</span></span> 
 <span data-ttu-id="40e56-399"><paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-399"><paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-400"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-400"><paramref name="capacity" /> is greater than the size of the logical address space.</span></span>  
  
<span data-ttu-id="40e56-401">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-401">-or-</span></span> 
 <span data-ttu-id="40e56-402"><paramref name="capacity" /> est inférieur ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-402"><paramref name="capacity" /> is less than or equal to zero.</span></span>  
  
<span data-ttu-id="40e56-403">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-403">-or-</span></span> 
 <span data-ttu-id="40e56-404"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-404"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-405">Le système d’exploitation a refusé l’accès spécifié au fichier ; par exemple, l’accès a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, mais le fichier ou le répertoire est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="40e56-405">The operating system denied the specified access to the file; for example, access is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, but the file or directory is read-only.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-406">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-406">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-407">Nom du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-407">The name of the memory-mapped file.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-408">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-408">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-409">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-409">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span> <span data-ttu-id="40e56-410">La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-410">The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span></span></param>
        <param name="options"><span data-ttu-id="40e56-411">Combinaison d’opérations de bits de valeurs qui indique les options d’allocation de mémoire à appliquer au fichier.</span><span class="sxs-lookup"><span data-stu-id="40e56-411">A bitwise combination of values that indicate the memory allocation options to apply to the file.</span></span></param>
        <param name="inheritability"><span data-ttu-id="40e56-412">Valeur qui spécifie si un processus enfant peut hériter d’un handle au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-412">A value that specifies whether a handle to the memory-mapped file can be inherited by a child process.</span></span> <span data-ttu-id="40e56-413">La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-413">The default is <see cref="F:System.IO.HandleInheritability.None" />.</span></span></param>
        <summary><span data-ttu-id="40e56-414">Crée un fichier mappé en mémoire vide ou ouvre un fichier mappé en mémoire existant s’il en existe un du même nom.</span><span class="sxs-lookup"><span data-stu-id="40e56-414">Creates a new empty memory mapped file or opens an existing memory mapped file if one exists with the same name.</span></span> <span data-ttu-id="40e56-415">En cas d’ouverture d’un fichier existant, la capacité, les options et les arguments de mémoire sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="40e56-415">If opening an existing file, the capacity, options, and memory arguments will be ignored.</span></span></summary>
        <returns><span data-ttu-id="40e56-416">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-416">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-417"><paramref name="mapName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-417"><paramref name="mapName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-418"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-418"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-419">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-419">-or-</span></span> 
 <span data-ttu-id="40e56-420"><paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-420"><paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-421"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-421"><paramref name="capacity" /> is greater than the size of the logical address space.</span></span>  
  
<span data-ttu-id="40e56-422">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-422">-or-</span></span> 
 <span data-ttu-id="40e56-423"><paramref name="capacity" /> est inférieur ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-423"><paramref name="capacity" /> is less than or equal to zero.</span></span>  
  
<span data-ttu-id="40e56-424">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-424">-or-</span></span> 
 <span data-ttu-id="40e56-425"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-425"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span>  
  
<span data-ttu-id="40e56-426">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-426">-or-</span></span> 
 <span data-ttu-id="40e56-427"><paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-427"><paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-428">Le système d’exploitation a refusé l’accès spécifié au fichier ; par exemple, l’accès a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, mais le fichier ou le répertoire est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="40e56-428">The operating system denied the specified access to the file; for example, access is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, but the file or directory is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-429">Nom du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-429">The name of the memory-mapped file.</span></span></param>
        <param name="capacity"><span data-ttu-id="40e56-430">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-430">The maximum size, in bytes, to allocate to the memory-mapped file.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-431">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-431">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span> <span data-ttu-id="40e56-432">La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-432">The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span></span></param>
        <param name="options"><span data-ttu-id="40e56-433">Combinaison d'opérations de bits de valeurs d'énumération qui spécifie des options d'allocation de mémoire pour le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-433">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</span></span></param>
        <param name="memoryMappedFileSecurity"><span data-ttu-id="40e56-434">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-434">The permissions that can be granted for file access and operations on memory-mapped files.</span></span>  
  
<span data-ttu-id="40e56-435">Ce paramètre peut être <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-435">This parameter can be <see langword="null" />.</span></span></param>
        <param name="inheritability"><span data-ttu-id="40e56-436">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-436">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process.</span></span> <span data-ttu-id="40e56-437">La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-437">The default is <see cref="F:System.IO.HandleInheritability.None" />.</span></span></param>
        <summary><span data-ttu-id="40e56-438">Crée ou ouvre un fichier mappé en mémoire qui a la capacité, le nom, le type d’accès, l’allocation de mémoire, les autorisations de sécurité et les règles d’héritage spécifiés dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-438">Creates or opens a memory-mapped file that has the specified name, capacity, access type, memory allocation, security permissions, and inheritability in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-439">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-439">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-440">Utilisez cette méthode pour créer ou ouvrir un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-440">Use this method to create or open a memory-mapped file that is not persisted (that is, not associated with a file on disk), which you can use to share data between processes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-441"><paramref name="mapName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-441"><paramref name="mapName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-442"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-442"><paramref name="mapName" /> is an empty string.</span></span>  
  
<span data-ttu-id="40e56-443">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-443">-or-</span></span> 
 <span data-ttu-id="40e56-444"><paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-444"><paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-445"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-445"><paramref name="capacity" /> is greater than the size of the logical address space.</span></span>  
  
<span data-ttu-id="40e56-446">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-446">-or-</span></span> 
 <span data-ttu-id="40e56-447"><paramref name="capacity" /> est inférieur ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="40e56-447"><paramref name="capacity" /> is less than or equal to zero.</span></span>  
  
<span data-ttu-id="40e56-448">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-448">-or-</span></span> 
 <span data-ttu-id="40e56-449"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-449"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span>  
  
<span data-ttu-id="40e56-450">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-450">-or-</span></span> 
 <span data-ttu-id="40e56-451"><paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-451"><paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-452">Le système d’exploitation a refusé l’<paramref name="access" /> spécifié au fichier ; par exemple, <paramref name="access" /> a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, mais le fichier ou le répertoire est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="40e56-452">The operating system denied the specified <paramref name="access" /> to the file; for example, <paramref name="access" /> is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, but the file or directory is read-only.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="40e56-453">Pour accéder au code non managé.</span><span class="sxs-lookup"><span data-stu-id="40e56-453">for access to unmanaged code.</span></span> <span data-ttu-id="40e56-454">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-454">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-455">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-455">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewAccessor">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="40e56-456">Crée un objet <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappé à un affichage du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-456">Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> that maps to a view of the memory-mapped file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor () As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor();" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="40e56-457">Crée un objet <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappé à un affichage du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-457">Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> that maps to a view of the memory-mapped file.</span></span></summary>
        <returns><span data-ttu-id="40e56-458">Bloc de mémoire accessible de manière aléatoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-458">A randomly accessible block of memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-459">Vous pouvez utiliser la vue retournée par cette méthode pour l’accès aléatoire dans un fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-459">You can use the view returned by this method for random access to a memory-mapped file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-460">L’accès au fichier mappé en mémoire n’est pas autorisé.</span><span class="sxs-lookup"><span data-stu-id="40e56-460">Access to the memory-mapped file is unauthorized.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-461">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-461">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="40e56-462">Octet à partir duquel commencer l'affichage.</span><span class="sxs-lookup"><span data-stu-id="40e56-462">The byte at which to start the view.</span></span></param>
        <param name="size"><span data-ttu-id="40e56-463">Indique la taille de l'affichage.</span><span class="sxs-lookup"><span data-stu-id="40e56-463">The size of the view.</span></span> <span data-ttu-id="40e56-464">Spécifiez 0 (zéro) pour créer une vue qui commence à <paramref name="offset" /> et se termine vers la fin du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-464">Specify 0 (zero) to create a view that starts at <paramref name="offset" /> and ends approximately at the end of the memory-mapped file.</span></span></param>
        <summary><span data-ttu-id="40e56-465">Crée un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappé à une vue du fichier mappé en mémoire et ayant le décalage et la taille spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-465">Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> that maps to a view of the memory-mapped file, and that has the specified offset and size.</span></span></summary>
        <returns><span data-ttu-id="40e56-466">Bloc de mémoire accessible de manière aléatoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-466">A randomly accessible block of memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-467">Vous pouvez utiliser la vue retournée par cette méthode pour l’accès aléatoire dans un fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-467">You can use the view returned by this method for random access to a memory-mapped file.</span></span>  
  
 <span data-ttu-id="40e56-468">Pour créer une vue complète du fichier mappé en mémoire, spécifiez 0 (zéro) pour le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="40e56-468">To create a complete view of the memory-mapped file, specify 0 (zero) for the `size` parameter.</span></span> <span data-ttu-id="40e56-469">Si vous procédez ainsi, la taille de la vue peut être inférieure ou supérieure à la taille du fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-469">If you do this, the size of the view might be smaller or larger than the size of the source file on disk.</span></span> <span data-ttu-id="40e56-470">Il s’agit, car les vues sont fournies dans les unités de pages système, et la taille de la vue est arrondie à la taille de page système suivante.</span><span class="sxs-lookup"><span data-stu-id="40e56-470">This is because views are provided in units of system pages, and the size of the view is rounded up to the next system page size.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="40e56-471">L’exemple suivant crée une vue d’un fichier mappé en mémoire et la modifie.</span><span class="sxs-lookup"><span data-stu-id="40e56-471">The following example creates a view of a memory-mapped file and edits it.</span></span> <span data-ttu-id="40e56-472">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> classe.</span><span class="sxs-lookup"><span data-stu-id="40e56-472">This code example is part of a larger example provided for the <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> class.</span></span>  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#2)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-473"><paramref name="offset" /> ou <paramref name="size" /> est une valeur négative.</span><span class="sxs-lookup"><span data-stu-id="40e56-473"><paramref name="offset" /> or <paramref name="size" /> is a negative value.</span></span>  
  
<span data-ttu-id="40e56-474">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-474">-or-</span></span> 
 <span data-ttu-id="40e56-475"><paramref name="size" /> est supérieur à l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-475"><paramref name="size" /> is greater than the logical address space.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-476">L’accès au fichier mappé en mémoire n’est pas autorisé.</span><span class="sxs-lookup"><span data-stu-id="40e56-476">Access to the memory-mapped file is unauthorized.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-477">Une erreur d'E/S s'est produite.</span><span class="sxs-lookup"><span data-stu-id="40e56-477">An I/O error occurred.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-478">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-478">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="40e56-479">Octet à partir duquel commencer l'affichage.</span><span class="sxs-lookup"><span data-stu-id="40e56-479">The byte at which to start the view.</span></span></param>
        <param name="size"><span data-ttu-id="40e56-480">Indique la taille de l'affichage.</span><span class="sxs-lookup"><span data-stu-id="40e56-480">The size of the view.</span></span> <span data-ttu-id="40e56-481">Spécifiez 0 (zéro) pour créer une vue qui commence à <paramref name="offset" /> et se termine vers la fin du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-481">Specify 0 (zero) to create a view that starts at <paramref name="offset" /> and ends approximately at the end of the memory-mapped file.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-482">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-482">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span> <span data-ttu-id="40e56-483">La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-483">The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span></span></param>
        <summary><span data-ttu-id="40e56-484">Crée un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappé à une vue du fichier mappé en mémoire et ayant le décalage, la taille et les restrictions d’accès spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-484">Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> that maps to a view of the memory-mapped file, and that has the specified offset, size, and access restrictions.</span></span></summary>
        <returns><span data-ttu-id="40e56-485">Bloc de mémoire accessible de manière aléatoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-485">A randomly accessible block of memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-486">Vous pouvez utiliser la vue retournée par cette méthode pour l’accès aléatoire dans un fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-486">You can use the view returned by this method for random access to a memory-mapped file.</span></span>  
  
 <span data-ttu-id="40e56-487">Pour créer une vue complète du fichier mappé en mémoire, spécifiez 0 (zéro) pour le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="40e56-487">To create a complete view of the memory-mapped file, specify 0 (zero) for the `size` parameter.</span></span> <span data-ttu-id="40e56-488">Si vous procédez ainsi, la taille de la vue peut être inférieure ou supérieure à la taille du fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-488">If you do this, the size of the view might be smaller or larger than the size of the source file on disk.</span></span> <span data-ttu-id="40e56-489">Il s’agit, car les vues sont fournies dans les unités de pages système, et la taille de la vue est arrondie à la taille de page système suivante.</span><span class="sxs-lookup"><span data-stu-id="40e56-489">This is because views are provided in units of system pages, and the size of the view is rounded up to the next system page size.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-490"><paramref name="offset" /> ou <paramref name="size" /> est une valeur négative.</span><span class="sxs-lookup"><span data-stu-id="40e56-490"><paramref name="offset" /> or <paramref name="size" /> is a negative value.</span></span>  
  
<span data-ttu-id="40e56-491">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-491">-or-</span></span> 
 <span data-ttu-id="40e56-492"><paramref name="size" /> est supérieur à l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-492"><paramref name="size" /> is greater than the logical address space.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-493"><paramref name="access" /> n’est pas valide pour le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-493"><paramref name="access" /> is invalid for the memory-mapped file.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-494">Une erreur d'E/S s'est produite.</span><span class="sxs-lookup"><span data-stu-id="40e56-494">An I/O error occurred.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="40e56-495">Pour accéder au code non managé.</span><span class="sxs-lookup"><span data-stu-id="40e56-495">for access to unmanaged code.</span></span> <span data-ttu-id="40e56-496">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-496">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-497">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-497">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="40e56-498">Crée un flux mappé à un affichage du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-498">Creates a stream that maps to a view of the memory-mapped file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream () As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream();" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="40e56-499">Crée un flux mappé à un affichage du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-499">Creates a stream that maps to a view of the memory-mapped file.</span></span></summary>
        <returns><span data-ttu-id="40e56-500">Flux de mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-500">A stream of memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-501">Vous pouvez utiliser le flux retourné par cette méthode pour un accès séquentiel à un fichier mappé en mémoire, comme pour les communications entre processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-501">You can use the stream returned by this method for sequential access to a memory-mapped file, such as for inter-process communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="40e56-502">L’exemple suivant crée un flux et écrit une valeur.</span><span class="sxs-lookup"><span data-stu-id="40e56-502">The following example creates a stream and writes a value to it.</span></span> <span data-ttu-id="40e56-503">Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="40e56-503">This code example is part of a larger example provided for the <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> method.</span></span>  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#2)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-504">L’accès au fichier mappé en mémoire n’est pas autorisé.</span><span class="sxs-lookup"><span data-stu-id="40e56-504">Access to the memory-mapped file is unauthorized.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-505">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-505">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="40e56-506">Octet à partir duquel commencer l'affichage.</span><span class="sxs-lookup"><span data-stu-id="40e56-506">The byte at which to start the view.</span></span></param>
        <param name="size"><span data-ttu-id="40e56-507">Indique la taille de l'affichage.</span><span class="sxs-lookup"><span data-stu-id="40e56-507">The size of the view.</span></span> <span data-ttu-id="40e56-508">Spécifiez 0 (zéro) pour créer une vue qui commence à <paramref name="offset" /> et se termine vers la fin du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-508">Specify 0 (zero) to create a view that starts at <paramref name="offset" /> and ends approximately at the end of the memory-mapped file.</span></span></param>
        <summary><span data-ttu-id="40e56-509">Crée un flux mappé à une vue du fichier mappé en mémoire et ayant le décalage et la taille spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-509">Creates a stream that maps to a view of the memory-mapped file, and that has the specified offset and size.</span></span></summary>
        <returns><span data-ttu-id="40e56-510">Flux de mémoire qui le décalage et la taille spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-510">A stream of memory that has the specified offset and size.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-511">Vous pouvez utiliser le flux retourné par cette méthode pour un accès séquentiel à un fichier mappé en mémoire, comme pour les communications entre processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-511">You can use the stream returned by this method for sequential access to a memory-mapped file, such as for inter-process communications.</span></span>  
  
 <span data-ttu-id="40e56-512">Pour créer une vue complète du fichier mappé en mémoire, spécifiez 0 (zéro) pour le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="40e56-512">To create a complete view of the memory-mapped file, specify 0 (zero) for the `size` parameter.</span></span> <span data-ttu-id="40e56-513">Si vous procédez ainsi, la taille de la vue peut être inférieure ou supérieure à la taille du fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-513">If you do this, the size of the view might be smaller or larger than the size of the source file on disk.</span></span> <span data-ttu-id="40e56-514">Il s’agit, car les vues sont fournies dans les unités de pages système, et la taille de la vue est arrondie à la taille de page système suivante.</span><span class="sxs-lookup"><span data-stu-id="40e56-514">This is because views are provided in units of system pages, and the size of the view is rounded up to the next system page size.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-515"><paramref name="offset" /> ou <paramref name="size" /> est une valeur négative.</span><span class="sxs-lookup"><span data-stu-id="40e56-515"><paramref name="offset" /> or <paramref name="size" /> is a negative value.</span></span>  
  
<span data-ttu-id="40e56-516">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-516">-or-</span></span> 
 <span data-ttu-id="40e56-517"><paramref name="size" /> est supérieur à l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-517"><paramref name="size" /> is greater than the logical address space.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-518">L’accès au fichier mappé en mémoire n’est pas autorisé.</span><span class="sxs-lookup"><span data-stu-id="40e56-518">Access to the memory-mapped file is unauthorized.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-519"><paramref name="size" /> est supérieur à la mémoire virtuelle totale.</span><span class="sxs-lookup"><span data-stu-id="40e56-519"><paramref name="size" /> is greater than the total virtual memory.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-520">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-520">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="40e56-521">Octet à partir duquel commencer l'affichage.</span><span class="sxs-lookup"><span data-stu-id="40e56-521">The byte at which to start the view.</span></span></param>
        <param name="size"><span data-ttu-id="40e56-522">Indique la taille de l'affichage.</span><span class="sxs-lookup"><span data-stu-id="40e56-522">The size of the view.</span></span> <span data-ttu-id="40e56-523">Spécifiez 0 (zéro) pour créer une vue qui commence à <paramref name="offset" /> et se termine vers la fin du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-523">Specify 0 (zero) to create a view that starts at <paramref name="offset" /> and ends approximately at the end of the memory-mapped file.</span></span></param>
        <param name="access"><span data-ttu-id="40e56-524">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-524">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</span></span> <span data-ttu-id="40e56-525">La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-525">The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</span></span></param>
        <summary><span data-ttu-id="40e56-526">Crée un flux mappé à une vue du fichier mappé en mémoire et ayant le décalage, la taille et le type d'accès spécifiés.</span><span class="sxs-lookup"><span data-stu-id="40e56-526">Creates a stream that maps to a view of the memory-mapped file, and that has the specified offset, size, and access type.</span></span></summary>
        <returns><span data-ttu-id="40e56-527">Flux de mémoire qui a les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-527">A stream of memory that has the specified characteristics.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-528">Vous pouvez utiliser le flux retourné par cette méthode pour un accès séquentiel à un fichier mappé en mémoire, comme pour les communications entre processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-528">You can use the stream returned by this method for sequential access to a memory-mapped file, such as for inter-process communications.</span></span>  
  
 <span data-ttu-id="40e56-529">Pour créer une vue complète du fichier mappé en mémoire, spécifiez 0 (zéro) pour le `size` paramètre.</span><span class="sxs-lookup"><span data-stu-id="40e56-529">To create a complete view of the memory-mapped file, specify 0 (zero) for the `size` parameter.</span></span> <span data-ttu-id="40e56-530">Si vous procédez ainsi, la taille de la vue peut être inférieure ou supérieure à la taille du fichier source sur le disque.</span><span class="sxs-lookup"><span data-stu-id="40e56-530">If you do this, the size of the view might be smaller or larger than the size of the source file on disk.</span></span> <span data-ttu-id="40e56-531">Il s’agit, car les vues sont fournies dans les unités de pages système, et la taille de la vue est arrondie à la taille de page système suivante.</span><span class="sxs-lookup"><span data-stu-id="40e56-531">This is because views are provided in units of system pages, and the size of the view is rounded up to the next system page size.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-532"><paramref name="offset" /> ou <paramref name="size" /> est une valeur négative.</span><span class="sxs-lookup"><span data-stu-id="40e56-532"><paramref name="offset" /> or <paramref name="size" /> is a negative value.</span></span>  
  
<span data-ttu-id="40e56-533">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-533">-or-</span></span> 
 <span data-ttu-id="40e56-534"><paramref name="size" /> est supérieur à l’espace d’adressage logique.</span><span class="sxs-lookup"><span data-stu-id="40e56-534"><paramref name="size" /> is greater than the logical address space.</span></span>  
  
<span data-ttu-id="40e56-535">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-535">-or-</span></span> 
 <span data-ttu-id="40e56-536"><paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-536"><paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-537"><paramref name="access" /> n’est pas valide pour le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-537"><paramref name="access" /> is invalid for the memory-mapped file.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="40e56-538"><paramref name="size" /> est supérieur à la mémoire virtuelle totale.</span><span class="sxs-lookup"><span data-stu-id="40e56-538"><paramref name="size" /> is greater than the total virtual memory.</span></span>  
  
<span data-ttu-id="40e56-539">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-539">-or-</span></span> 
 <span data-ttu-id="40e56-540"><paramref name="access" /> n’est pas valide pour le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-540"><paramref name="access" /> is invalid for the memory-mapped file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="40e56-541">Pour accéder au code non managé.</span><span class="sxs-lookup"><span data-stu-id="40e56-541">for access to unmanaged code.</span></span> <span data-ttu-id="40e56-542">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-542">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-543">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-543">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="40e56-544">Libère les ressources utilisées par le <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-544">Releases the resources used by the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryMappedFile.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="40e56-545">Libère toutes les ressources utilisées par <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-545">Releases all resources used by the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="memoryMappedFile.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="40e56-546"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="40e56-546"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="40e56-547">Libère les ressources non managées utilisées par <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> et libère éventuellement les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="40e56-547">Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MemoryMappedFileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Usage="memoryMappedFile.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="40e56-548">Obtient le contrôle d'accès à la ressource du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-548">Gets the access control to the memory-mapped file resource.</span></span></summary>
        <returns><span data-ttu-id="40e56-549">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-549">The permissions that can be granted for file access and operations on memory-mapped files.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="40e56-550">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</span><span class="sxs-lookup"><span data-stu-id="40e56-550">An underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="40e56-551">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</span><span class="sxs-lookup"><span data-stu-id="40e56-551">An underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="40e56-552">Le fichier mappé en mémoire est fermé.</span><span class="sxs-lookup"><span data-stu-id="40e56-552">The memory-mapped file is closed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="40e56-553">La plateforme actuelle est Windows 98 ou version antérieure.</span><span class="sxs-lookup"><span data-stu-id="40e56-553">The current platform is Windows 98 or earlier.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-554">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</span><span class="sxs-lookup"><span data-stu-id="40e56-554">An underlying call to set security information failed.</span></span>  
  
<span data-ttu-id="40e56-555">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-555">-or-</span></span> 
<span data-ttu-id="40e56-556">Le fichier mappé en mémoire a été ouvert avec les droits <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> uniquement.</span><span class="sxs-lookup"><span data-stu-id="40e56-556">The memory-mapped file was opened as <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> only.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-557">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-557">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="40e56-558">Ouvre un fichier nommé existant mappé en mémoire dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-558">Opens an existing named memory-mapped file in system memory.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting mapName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-559">Nom du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-559">The name of the memory-mapped file.</span></span></param>
        <summary><span data-ttu-id="40e56-560">Ouvre un fichier mappé en mémoire existant qui a le nom spécifié dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-560">Opens an existing memory-mapped file that has the specified name in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-561">Fichier mappé en mémoire qui porte le nom spécifié.</span><span class="sxs-lookup"><span data-stu-id="40e56-561">A memory-mapped file that has the specified name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40e56-562">Le fichier mappé en mémoire peut être soit un persistant fichier mappé en mémoire (associé à un fichier sur disque) ou non persistant.</span><span class="sxs-lookup"><span data-stu-id="40e56-562">The memory-mapped file can be either a persisted memory-mapped file (associated with a file on disk) or non-persisted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="40e56-563">**Ouverture d’un fichier mappé en mémoire persistant**</span><span class="sxs-lookup"><span data-stu-id="40e56-563">**Opening a Persisted Memory-Mapped File**</span></span>  
  
 <span data-ttu-id="40e56-564">L’exemple suivant ouvre un fichier mappé en mémoire nommé `ImgA` qui a déjà été créé à partir d’un fichier sur disque (comme indiqué dans l’exemple pour la <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%28System.String%29> méthode).</span><span class="sxs-lookup"><span data-stu-id="40e56-564">The following example opens a memory-mapped file named `ImgA` that has already been created from a file on disk (as shown in the example for the <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%28System.String%29> method).</span></span>  
  
 [!code-csharp[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/cs/program.cs#1)]
 [!code-vb[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/vb/program.vb#1)]  
  
 <span data-ttu-id="40e56-565">**Ouverture d’un fichier mappé en mémoire Non persistant**</span><span class="sxs-lookup"><span data-stu-id="40e56-565">**Opening a Non-Persisted Memory-Mapped File**</span></span>  
  
 <span data-ttu-id="40e56-566">L’exemple suivant ouvre un fichier mappé en mémoire utilisé pour la communication entre processus.</span><span class="sxs-lookup"><span data-stu-id="40e56-566">The following example opens a memory-mapped file used for inter-process communication.</span></span> <span data-ttu-id="40e56-567">Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%28System.String%2CSystem.Int64%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="40e56-567">This code example is part of a larger example provided for the <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%28System.String%2CSystem.Int64%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-568"><paramref name="mapName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-568"><paramref name="mapName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-569"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-569"><paramref name="mapName" /> is an empty string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="40e56-570">Le fichier spécifié pour <paramref name="mapName" /> n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="40e56-570">The file specified for <paramref name="mapName" /> does not exist.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-571">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-571">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-572">Nom du fichier mappé en mémoire à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="40e56-572">The name of the memory-mapped file to open.</span></span></param>
        <param name="desiredAccessRights"><span data-ttu-id="40e56-573">Une des valeurs d'énumération qui spécifie les droits d'accès à appliquer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-573">One of the enumeration values that specifies the access rights to apply to the memory-mapped file.</span></span></param>
        <summary><span data-ttu-id="40e56-574">Ouvre un fichier mappé en mémoire existant qui a le nom et les droits d'accès spécifiés dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-574">Opens an existing memory-mapped file that has the specified name and access rights in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-575">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-575">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-576"><paramref name="mapName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-576"><paramref name="mapName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-577"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-577"><paramref name="mapName" /> is an empty string.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-578"><paramref name="desiredAccessRights" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-578"><paramref name="desiredAccessRights" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> enumeration value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="40e56-579">Le fichier spécifié pour <paramref name="mapName" /> n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="40e56-579">The file specified for <paramref name="mapName" /> does not exist.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-580">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-580">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName"><span data-ttu-id="40e56-581">Nom du fichier mappé en mémoire à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="40e56-581">The name of the memory-mapped file to open.</span></span></param>
        <param name="desiredAccessRights"><span data-ttu-id="40e56-582">Une des valeurs d'énumération qui spécifie les droits d'accès à appliquer au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-582">One of the enumeration values that specifies the access rights to apply to the memory-mapped file.</span></span></param>
        <param name="inheritability"><span data-ttu-id="40e56-583">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-583">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process.</span></span> <span data-ttu-id="40e56-584">La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-584">The default is <see cref="F:System.IO.HandleInheritability.None" />.</span></span></param>
        <summary><span data-ttu-id="40e56-585">Ouvre un fichier mappé en mémoire existant qui a le nom, les droits d'accès et les règles d'héritage spécifiés dans la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="40e56-585">Opens an existing memory-mapped file that has the specified name, access rights, and inheritability in system memory.</span></span></summary>
        <returns><span data-ttu-id="40e56-586">Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</span><span class="sxs-lookup"><span data-stu-id="40e56-586">A memory-mapped file that has the specified characteristics.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-587"><paramref name="mapName" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-587"><paramref name="mapName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="40e56-588"><paramref name="mapName" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="40e56-588"><paramref name="mapName" /> is an empty string.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="40e56-589"><paramref name="desiredAccessRights" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-589"><paramref name="desiredAccessRights" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> enumeration value.</span></span>  
  
<span data-ttu-id="40e56-590">ou</span><span class="sxs-lookup"><span data-stu-id="40e56-590">-or-</span></span> 
 <span data-ttu-id="40e56-591"><paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</span><span class="sxs-lookup"><span data-stu-id="40e56-591"><paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-592">L’accès demandé n’est pas valide pour le fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-592">The requested access is invalid for the memory-mapped file.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="40e56-593">Le fichier spécifié pour <paramref name="mapName" /> n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="40e56-593">The file specified for <paramref name="mapName" /> does not exist.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="40e56-594">Pour accéder au code non managé.</span><span class="sxs-lookup"><span data-stu-id="40e56-594">for access to unmanaged code.</span></span> <span data-ttu-id="40e56-595">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-595">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-596">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-596">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SafeMemoryMappedFileHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeMemoryMappedFileHandle As SafeMemoryMappedFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ SafeMemoryMappedFileHandle { Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeMemoryMappedFileHandle : Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="40e56-597">Obtient le handle de fichier d'un fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-597">Gets the file handle of a memory-mapped file.</span></span></summary>
        <value><span data-ttu-id="40e56-598">Handle du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-598">The handle to the memory-mapped file.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="40e56-599">Pour accéder au code non managé.</span><span class="sxs-lookup"><span data-stu-id="40e56-599">for access to unmanaged code.</span></span> <span data-ttu-id="40e56-600">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-600">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-601">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-601">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.SetAccessControl(System.IO.MemoryMappedFiles.MemoryMappedFileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.MemoryMappedFiles.MemoryMappedFileSecurity -&gt; unit" Usage="memoryMappedFile.SetAccessControl memoryMappedFileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="memoryMappedFileSecurity"><span data-ttu-id="40e56-602">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-602">The permissions that can be granted for file access and operations on memory-mapped files.</span></span></param>
        <summary><span data-ttu-id="40e56-603">Définit le contrôle d'accès à la ressource du fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="40e56-603">Sets the access control to the memory-mapped file resource.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="40e56-604"><paramref name="memoryMappedFileSecurity" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="40e56-604"><paramref name="memoryMappedFileSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="40e56-605">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</span><span class="sxs-lookup"><span data-stu-id="40e56-605">An underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="40e56-606">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</span><span class="sxs-lookup"><span data-stu-id="40e56-606">An underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="40e56-607">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</span><span class="sxs-lookup"><span data-stu-id="40e56-607">An underlying call to set security information failed.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e"><span data-ttu-id="40e56-608">Fichiers mappés en mémoire</span><span class="sxs-lookup"><span data-stu-id="40e56-608">Memory-Mapped Files</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>