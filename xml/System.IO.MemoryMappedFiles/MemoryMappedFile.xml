<Type Name="MemoryMappedFile" FullName="System.IO.MemoryMappedFiles.MemoryMappedFile">
  <Metadata><Meta Name="ms.openlocfilehash" Value="443cc691ad8b1f823a11c81a804d413190455aee" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58742754" /></Metadata><TypeSignature Language="C#" Value="public class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryMappedFile extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMappedFile&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryMappedFile = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente un fichier mappé en mémoire.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un fichier mappé en mémoire mappe le contenu d’un fichier à l’espace d’adressage logique d’une application. Fichiers mappés en mémoire permettent aux programmeurs de travailler avec des fichiers extrêmement volumineux parce que la mémoire peut être gérée simultanément, et ils permettent un accès aléatoire dans un fichier sans avoir besoin pour la recherche terminé. Fichiers mappés en mémoire peuvent également être partagés entre plusieurs processus.  
  
 Le <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> méthodes créent un fichier mappé en mémoire à partir d’un chemin d’accès spécifié ou un <xref:System.IO.FileStream> d’un fichier existant sur le disque. Modifications sont propagées automatiquement disque lorsque le fichier n’est pas mappé.  
  
 Le <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> méthodes, créez un fichier mappé en mémoire qui n’est pas mappé à un fichier existant sur le disque ; et conviennent pour la création d’une mémoire partagée pour la communication interprocessus (IPC).  
  
 Un fichier mappé en mémoire peut être associé à un nom facultatif qui permet au fichier mappé en mémoire à partager avec d’autres processus. 
  
 Vous pouvez créer plusieurs vues du fichier mappé en mémoire, y compris les affichages des parties du fichier. Vous pouvez mapper la même partie d’un fichier à plusieurs adresses pour créer une mémoire simultanée. Pour que deux vues restent simultanées, elles doivent être créées à partir du même fichier mappé en mémoire. Création des deux mappages de fichier du même fichier avec deux vues ne fournit pas d’accès concurrentiel.  
  
   
  
## Examples  
 L’exemple suivant crée une vue mappée en mémoire d’une partie d’un fichier très volumineux et manipule une partie de ce dernier.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateFromFile">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un fichier mappé en mémoire à partir d'un fichier existant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès au fichier à mapper.</param>
        <summary>Crée un fichier mappé en mémoire à partir d'un fichier sur le disque.</summary>
        <returns>Fichier mappé en mémoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise la <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> méthode pour créer un fichier mappé en mémoire, puis crée une vue mappée en mémoire à une partie d’un fichier très volumineux.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne vide, ne contient que des espaces blancs ou contient des caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  
  
ou 
 <paramref name="path" /> fait référence à un appareil non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations obligatoires pour le fichier.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès au fichier à mapper.</param>
        <param name="mode">Mode d’accès : doit être <see cref="F:System.IO.FileMode.Open" />.</param>
        <summary>Crée un fichier mappé en mémoire qui a le mode d’accès spécifié d’un fichier sur le disque.</summary>
        <returns>Fichier mappé en mémoire qui a le mode d'accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `mode` paramètre se rapporte au fichier source sur le disque. Vous pouvez utiliser uniquement le <xref:System.IO.FileMode.Open> valeur d’énumération pour créer le fichier mappé en mémoire à partir du fichier source sur le disque.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne vide, ne contient que des espaces blancs ou contient des caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  
  
ou 
 <paramref name="path" /> fait référence à un appareil non valide.  
  
ou 
 <paramref name="mode" /> est <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> a la valeur <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> ou <see cref="F:System.IO.FileMode.Truncate" />.  
  
ou 
 <paramref name="mode" /> a la valeur <see cref="F:System.IO.FileMode.OpenOrCreate" /> et le fichier sur disque n’existe pas.  
  
ou 
Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations obligatoires pour le fichier.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès au fichier à mapper.</param>
        <param name="mode">Mode d’accès : doit être <see cref="F:System.IO.FileMode.Open" />.</param>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <summary>Crée un fichier mappé en mémoire qui a le mode d'accès et le nom spécifiés d'un fichier sur le disque.</summary>
        <returns>Fichier mappé en mémoire qui a le nom et le mode d'accès spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `mode` paramètre se rapporte au fichier source sur le disque. Vous pouvez utiliser uniquement le <xref:System.IO.FileMode.Open> valeur d’énumération pour créer le fichier mappé en mémoire à partir du fichier source sur le disque.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne vide, ne contient que des espaces blancs ou contient des caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  
  
ou 
 <paramref name="path" /> fait référence à un appareil non valide.  
  
ou 
 <paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="mode" /> est <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> a la valeur <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> ou <see cref="F:System.IO.FileMode.Truncate" />.  
  
ou 
 <paramref name="mode" /> a la valeur <see cref="F:System.IO.FileMode.OpenOrCreate" /> et le fichier sur disque n’existe pas.  
  
ou 
Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations obligatoires pour le fichier.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès au fichier à mapper.</param>
        <param name="mode">Le mode d’accès peut avoir n’importe quelle valeur d’énumération <see cref="T:System.IO.FileMode" /> sauf <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire. Spécifiez 0 pour affecter à la capacité la taille du fichier sur le disque.</param>
        <summary>Crée un fichier mappé en mémoire qui a le mode d'accès, le nom et la capacité spécifiés d'un fichier sur le disque.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `mode` paramètre se rapporte au fichier source sur le disque.  
  
 Si `capacity` est supérieure à la taille du fichier sur disque, le fichier sur le disque est augmentée pour correspondre à la capacité spécifiée, même si aucune donnée n’est écrite dans le fichier mappé en mémoire. Pour éviter ce problème, spécifiez 0 (zéro) pour la capacité par défaut, qui sera définie en interne `capacity` à la taille du fichier sur disque.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne vide, ne contient que des espaces blancs ou contient des caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  
  
ou 
 <paramref name="path" /> fait référence à un appareil non valide.  
  
ou 
 <paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="mode" /> est <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.  
  
ou 
 <paramref name="capacity" /> est inférieur à zéro.  
  
ou 
 <paramref name="capacity" /> est inférieur à la taille de fichier (mais est différent de zéro).  
  
ou 
 <paramref name="capacity" /> est égal à zéro, et la taille du fichier sur le disque est aussi égale à zéro.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations obligatoires pour le fichier.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès au fichier à mapper.</param>
        <param name="mode">Le mode d’accès peut avoir n’importe quelle valeur d’énumération <see cref="T:System.IO.FileMode" /> sauf <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire. Spécifiez 0 pour affecter à la capacité la taille du fichier sur le disque.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.</param>
        <summary>Crée un fichier mappé en mémoire qui a le mode d'accès, le nom, la capacité et le type d'accès spécifiés d'un fichier sur le disque.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `mode` paramètre se rapporte au fichier source sur le disque.  
  
 Si `capacity` est supérieure à la taille du fichier sur disque, le fichier sur le disque est augmentée pour correspondre à la capacité spécifiée, même si aucune donnée n’est écrite dans le fichier mappé en mémoire. Pour éviter ce problème, spécifiez 0 (zéro) pour la capacité par défaut, qui sera définie en interne `capacity` à la taille du fichier sur disque.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="access" /> n’est pas une valeur autorisée.  
  
ou 
 <paramref name="path" /> spécifie un fichier vide.  
  
ou 
 <paramref name="access" /> est spécifié comme <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> et la capacité est supérieure à la taille du fichier indiquée par <paramref name="path" />.  
  
ou 
 <paramref name="mode" /> est <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.  
  
ou 
 <paramref name="capacity" /> est inférieur à zéro.  
  
ou 
 <paramref name="capacity" /> est inférieur à la taille de fichier (mais est différent de zéro).  
  
ou 
 <paramref name="capacity" /> est égal à zéro, et la taille du fichier sur le disque est aussi égale à zéro.  
  
ou 
 <paramref name="access" /> n’est pas une valeur <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> définie.  
  
ou 
La taille du fichier indiqué par <paramref name="path" /> est supérieure à <paramref name="capacity" />.</exception>
        <exception cref="T:System.IO.IOException">ou 
Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système d’exploitation.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations obligatoires pour le fichier.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mapName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileStream">Flux de fichier du fichier existant.</param>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire. Spécifiez 0 pour affecter à la capacité la taille de <c>filestream</c>.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.  
  
Ce paramètre ne peut pas avoir la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="inheritability">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">Valeur qui indique s’il faut fermer le flux de fichier source quand le <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> est supprimé.</param>
        <summary>Crée un fichier mappé en mémoire à partir d’un fichier existant avec le mode d’accès, le nom, les règles d’héritage et la capacité spécifiés.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est <see langword="null" /> ou est une chaîne vide.  
  
ou 
 <paramref name="capacity" /> et la longueur du fichier ont une valeur égale à zéro.  
  
ou 
 <paramref name="access" /> a une valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />, qui n’est pas autorisée.  
  
ou 
 <paramref name="access" /> a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> et <paramref name="capacity" /> est supérieur à la longueur de <see langword="filestream" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileStream" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.  
  
ou 
 <paramref name="capacity" /> est inférieur à la taille du fichier.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.  
  
ou 
 <paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, memoryMappedFileSecurity, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mapName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileStream"><paramref name="fileStream" /> du fichier à mapper.</param>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire. Spécifiez 0 pour affecter à la capacité la taille du fichier sur le disque.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire.  
  
Ce paramètre ne peut pas avoir la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="memoryMappedFileSecurity">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.  
  
Ce paramètre peut être <see langword="null" />.</param>
        <param name="inheritability">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen"><see langword="true" /> pour ne pas supprimer <paramref name="fileStream" /> après la fermeture de <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> ; <see langword="false" /> pour supprimer <paramref name="fileStream" />.</param>
        <summary>Crée un fichier mappé en mémoire qui a le nom, la capacité, le type d’accès, les autorisations de sécurité, les règles d’héritage et les spécifications de suppression spécifiés d’un fichier sur le disque.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `capacity` est supérieure à la taille du fichier sur disque, le fichier sur le disque est augmentée pour correspondre à la capacité spécifiée, même si aucune donnée n’est écrite dans le fichier mappé en mémoire. Pour éviter ce problème, spécifiez 0 (zéro) pour la capacité par défaut, qui sera définie en interne `capacity` à la taille du fichier sur disque.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="capacity" /> et la longueur du fichier ont une valeur égale à zéro.  
  
ou 
 <paramref name="access" /> a la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />, qui n’est pas autorisée.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileStream" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.  
  
ou 
 <paramref name="capacity" /> est inférieur à la taille du fichier.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.  
  
ou 
 <paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="fileStream" /> a été fermé.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> quand l’accès à <paramref name="fileStream" /> a la valeur <see cref="F:System.IO.FileAccess.Read" /> ou <see cref="F:System.IO.FileAccess.Write" />.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mapName" /> existe déjà.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNew">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un fichier mappé en mémoire dans la mémoire système.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</param>
        <summary>Crée un fichier mappé en mémoire qui a la capacité spécifiée dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui a le nom et la capacité spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.  
  
   
  
## Examples  
 L’exemple suivant est composé de trois processus distincts (applications console) qui écrivent `Boolean` valeurs dans un fichier mappé en mémoire. La séquence d’actions suivante se produit :  
  
1.  Le processus A crée le fichier mappé en mémoire et écrit une valeur.  
  
2.  Processus B ouvre le fichier mappé en mémoire et écrit une valeur.  
  
3.  Processus C ouvre le fichier mappé en mémoire et écrit une valeur.  
  
4.  Processus A lit et affiche les valeurs à partir du fichier mappé en mémoire.  
  
5.  Une fois que le processus a terminé avec le fichier mappé en mémoire, le fichier est immédiatement récupéré par le garbage collection.  
  
 Pour exécuter cet exemple, procédez comme suit :  
  
1.  Compilez les applications et ouvrez trois fenêtres de commande.  
  
2.  Dans la première fenêtre de commande, exécutez le processus A.  
  
3.  Dans la deuxième fenêtre de commande, exécutez le processus B.  
  
4.  Retournez au processus A et appuyez sur ENTRÉE.  
  
5.  Dans la troisième fenêtre de commande, exécutez le processus C.  
  
6.  Retournez au processus A et appuyez sur ENTRÉE.  
  
 La sortie du processus A est la suivante :  
  
```  
Start Process B and press ENTER to continue.  
Start Process C and press ENTER to continue.  
Process A says: True  
Process B says: False  
Process C says: True  
```  
  
 **Processus A**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#1)]  
  
 **Processus B**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/vb/program.vb#1)]  
  
 **Processus C**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur ou égal à zéro.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crée un fichier mappé en mémoire qui a la capacité et le type d’accès spécifiés dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur ou égal à zéro.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinaison d'opérations de bits de valeurs d'énumération qui spécifie des options d'allocation de mémoire pour le fichier mappé en mémoire.</param>
        <param name="inheritability">Valeur qui spécifie si un processus enfant peut hériter d’un handle au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crée un fichier mappé en mémoire qui a le nom, la capacité, le type d’accès, les options d’allocation mémoire et les règles d’héritage spécifiés.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur ou égal à zéro.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.  
  
ou 
 <paramref name="inheritability" /> n’est pas une valeur de <see cref="T:System.IO.HandleInheritability" /> valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom à attribuer au fichier mappé en mémoire, ou <see langword="null" /> pour un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que vous ne souhaitez pas partager entre plusieurs processus.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinaison d'opérations de bits de valeurs d'énumération qui spécifie des options d'allocation de mémoire pour le fichier mappé en mémoire.</param>
        <param name="memoryMappedFileSecurity">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.  
  
Ce paramètre peut être <see langword="null" />.</param>
        <param name="inheritability">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crée un fichier mappé en mémoire qui a la capacité, le type d'accès, l'allocation de mémoire, les autorisations de sécurité et les règles d'héritage spécifiés dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur ou égal à zéro.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.  
  
ou 
 <paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateOrOpen">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée ou ouvre un fichier mappé en mémoire dans la mémoire système.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom du fichier mappé en mémoire.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</param>
        <summary>Crée ou ouvre un fichier mappé en mémoire qui a la capacité et le nom spécifiés dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui possède le nom et la taille spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer ou ouvrir un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.  
  
ou 
 <paramref name="capacity" /> est inférieur ou égal à zéro.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom du fichier mappé en mémoire.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crée ou ouvre un fichier mappé en mémoire qui a la capacité, le nom et le type d’accès spécifiés dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer ou ouvrir un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.  
  
ou 
 <paramref name="capacity" /> est inférieur ou égal à zéro.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le système d’exploitation a refusé l’accès spécifié au fichier ; par exemple, l’accès a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, mais le fichier ou le répertoire est en lecture seule.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom du fichier mappé en mémoire.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinaison d’opérations de bits de valeurs qui indique les options d’allocation de mémoire à appliquer au fichier.</param>
        <param name="inheritability">Valeur qui spécifie si un processus enfant peut hériter d’un handle au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crée un fichier mappé en mémoire vide ou ouvre un fichier mappé en mémoire existant s’il en existe un du même nom. En cas d’ouverture d’un fichier existant, la capacité, les options et les arguments de mémoire sont ignorés.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.  
  
ou 
 <paramref name="capacity" /> est inférieur ou égal à zéro.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.  
  
ou 
 <paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le système d’exploitation a refusé l’accès spécifié au fichier ; par exemple, l’accès a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, mais le fichier ou le répertoire est en lecture seule.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom du fichier mappé en mémoire.</param>
        <param name="capacity">Taille maximale (en octets) à allouer au fichier mappé en mémoire.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinaison d'opérations de bits de valeurs d'énumération qui spécifie des options d'allocation de mémoire pour le fichier mappé en mémoire.</param>
        <param name="memoryMappedFileSecurity">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.  
  
Ce paramètre peut être <see langword="null" />.</param>
        <param name="inheritability">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crée ou ouvre un fichier mappé en mémoire qui a la capacité, le nom, le type d’accès, l’allocation de mémoire, les autorisations de sécurité et les règles d’héritage spécifiés dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer ou ouvrir un fichier mappé en mémoire qui n’est pas rendue persistante (autrement dit, pas associé à un fichier sur disque), qui vous permet de partager des données entre les processus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.  
  
ou 
 <paramref name="access" /> est défini en écriture seule avec la valeur d’énumération <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est supérieur à la taille de l’espace d’adressage logique.  
  
ou 
 <paramref name="capacity" /> est inférieur ou égal à zéro.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.  
  
ou 
 <paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le système d’exploitation a refusé l’<paramref name="access" /> spécifié au fichier ; par exemple, <paramref name="access" /> a la valeur <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> ou <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, mais le fichier ou le répertoire est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewAccessor">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappé à un affichage du fichier mappé en mémoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor () As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor();" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappé à un affichage du fichier mappé en mémoire.</summary>
        <returns>Bloc de mémoire accessible de manière aléatoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la vue retournée par cette méthode pour l’accès aléatoire dans un fichier mappé en mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L’accès au fichier mappé en mémoire n’est pas autorisé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Octet à partir duquel commencer l'affichage.</param>
        <param name="size">Indique la taille de l'affichage. Spécifiez 0 (zéro) pour créer une vue qui commence à <paramref name="offset" /> et se termine vers la fin du fichier mappé en mémoire.</param>
        <summary>Crée un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappé à une vue du fichier mappé en mémoire et ayant le décalage et la taille spécifiés.</summary>
        <returns>Bloc de mémoire accessible de manière aléatoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la vue retournée par cette méthode pour l’accès aléatoire dans un fichier mappé en mémoire.  
  
 Pour créer une vue complète du fichier mappé en mémoire, spécifiez 0 (zéro) pour le `size` paramètre. Si vous procédez ainsi, la taille de la vue peut être inférieure ou supérieure à la taille du fichier source sur le disque. Il s’agit, car les vues sont fournies dans les unités de pages système, et la taille de la vue est arrondie à la taille de page système suivante.  
  
   
  
## Examples  
 L’exemple suivant crée une vue d’un fichier mappé en mémoire et la modifie. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> classe.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#2)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="size" /> est une valeur négative.  
  
ou 
 <paramref name="size" /> est supérieur à l’espace d’adressage logique.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’accès au fichier mappé en mémoire n’est pas autorisé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Octet à partir duquel commencer l'affichage.</param>
        <param name="size">Indique la taille de l'affichage. Spécifiez 0 (zéro) pour créer une vue qui commence à <paramref name="offset" /> et se termine vers la fin du fichier mappé en mémoire.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crée un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappé à une vue du fichier mappé en mémoire et ayant le décalage, la taille et les restrictions d’accès spécifiés.</summary>
        <returns>Bloc de mémoire accessible de manière aléatoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la vue retournée par cette méthode pour l’accès aléatoire dans un fichier mappé en mémoire.  
  
 Pour créer une vue complète du fichier mappé en mémoire, spécifiez 0 (zéro) pour le `size` paramètre. Si vous procédez ainsi, la taille de la vue peut être inférieure ou supérieure à la taille du fichier source sur le disque. Il s’agit, car les vues sont fournies dans les unités de pages système, et la taille de la vue est arrondie à la taille de page système suivante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="size" /> est une valeur négative.  
  
ou 
 <paramref name="size" /> est supérieur à l’espace d’adressage logique.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> n’est pas valide pour le fichier mappé en mémoire.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un flux mappé à un affichage du fichier mappé en mémoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream () As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream();" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un flux mappé à un affichage du fichier mappé en mémoire.</summary>
        <returns>Flux de mémoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le flux retourné par cette méthode pour un accès séquentiel à un fichier mappé en mémoire, comme pour les communications entre processus.  
  
   
  
## Examples  
 L’exemple suivant crée un flux et écrit une valeur. Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> (méthode).  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#2)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L’accès au fichier mappé en mémoire n’est pas autorisé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Octet à partir duquel commencer l'affichage.</param>
        <param name="size">Indique la taille de l'affichage. Spécifiez 0 (zéro) pour créer une vue qui commence à <paramref name="offset" /> et se termine vers la fin du fichier mappé en mémoire.</param>
        <summary>Crée un flux mappé à une vue du fichier mappé en mémoire et ayant le décalage et la taille spécifiés.</summary>
        <returns>Flux de mémoire qui le décalage et la taille spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le flux retourné par cette méthode pour un accès séquentiel à un fichier mappé en mémoire, comme pour les communications entre processus.  
  
 Pour créer une vue complète du fichier mappé en mémoire, spécifiez 0 (zéro) pour le `size` paramètre. Si vous procédez ainsi, la taille de la vue peut être inférieure ou supérieure à la taille du fichier source sur le disque. Il s’agit, car les vues sont fournies dans les unités de pages système, et la taille de la vue est arrondie à la taille de page système suivante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="size" /> est une valeur négative.  
  
ou 
 <paramref name="size" /> est supérieur à l’espace d’adressage logique.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’accès au fichier mappé en mémoire n’est pas autorisé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="size" /> est supérieur à la mémoire virtuelle totale.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Octet à partir duquel commencer l'affichage.</param>
        <param name="size">Indique la taille de l'affichage. Spécifiez 0 (zéro) pour créer une vue qui commence à <paramref name="offset" /> et se termine vers la fin du fichier mappé en mémoire.</param>
        <param name="access">L'une des valeurs d'énumération qui spécifie le type d'accès autorisé au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crée un flux mappé à une vue du fichier mappé en mémoire et ayant le décalage, la taille et le type d'accès spécifiés.</summary>
        <returns>Flux de mémoire qui a les caractéristiques spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le flux retourné par cette méthode pour un accès séquentiel à un fichier mappé en mémoire, comme pour les communications entre processus.  
  
 Pour créer une vue complète du fichier mappé en mémoire, spécifiez 0 (zéro) pour le `size` paramètre. Si vous procédez ainsi, la taille de la vue peut être inférieure ou supérieure à la taille du fichier source sur le disque. Il s’agit, car les vues sont fournies dans les unités de pages système, et la taille de la vue est arrondie à la taille de page système suivante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="size" /> est une valeur négative.  
  
ou 
 <paramref name="size" /> est supérieur à l’espace d’adressage logique.  
  
ou 
 <paramref name="access" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> n’est pas valide pour le fichier mappé en mémoire.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="size" /> est supérieur à la mémoire virtuelle totale.  
  
ou 
 <paramref name="access" /> n’est pas valide pour le fichier mappé en mémoire.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryMappedFile.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="memoryMappedFile.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> et libère éventuellement les ressources managées.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MemoryMappedFileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Usage="memoryMappedFile.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le contrôle d'accès à la ressource du fichier mappé en mémoire.</summary>
        <returns>Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</exception>
        <exception cref="T:System.NotSupportedException">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</exception>
        <exception cref="T:System.ObjectDisposedException">Le fichier mappé en mémoire est fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle est Windows 98 ou version antérieure.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.  
  
ou 
Le fichier mappé en mémoire a été ouvert avec les droits <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> uniquement.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un fichier nommé existant mappé en mémoire dans la mémoire système.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting mapName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom du fichier mappé en mémoire.</param>
        <summary>Ouvre un fichier mappé en mémoire existant qui a le nom spécifié dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui porte le nom spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le fichier mappé en mémoire peut être soit un persistant fichier mappé en mémoire (associé à un fichier sur disque) ou non persistant.  
  
   
  
## Examples  
 **Ouverture d’un fichier mappé en mémoire persistant**  
  
 L’exemple suivant ouvre un fichier mappé en mémoire nommé `ImgA` qui a déjà été créé à partir d’un fichier sur disque (comme indiqué dans l’exemple pour la <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%28System.String%29> méthode).  
  
 [!code-csharp[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/cs/program.cs#1)]
 [!code-vb[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/vb/program.vb#1)]  
  
 **Ouverture d’un fichier mappé en mémoire Non persistant**  
  
 L’exemple suivant ouvre un fichier mappé en mémoire utilisé pour la communication entre processus. Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%28System.String%2CSystem.Int64%29> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié pour <paramref name="mapName" /> n’existe pas.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom du fichier mappé en mémoire à ouvrir.</param>
        <param name="desiredAccessRights">Une des valeurs d'énumération qui spécifie les droits d'accès à appliquer au fichier mappé en mémoire.</param>
        <summary>Ouvre un fichier mappé en mémoire existant qui a le nom et les droits d'accès spécifiés dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="desiredAccessRights" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié pour <paramref name="mapName" /> n’existe pas.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nom du fichier mappé en mémoire à ouvrir.</param>
        <param name="desiredAccessRights">Une des valeurs d'énumération qui spécifie les droits d'accès à appliquer au fichier mappé en mémoire.</param>
        <param name="inheritability">L'une des valeurs d'énumération qui spécifie si un processus enfant peut hériter d'un handle au fichier mappé en mémoire. La valeur par défaut est <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Ouvre un fichier mappé en mémoire existant qui a le nom, les droits d'accès et les règles d'héritage spécifiés dans la mémoire système.</summary>
        <returns>Fichier mappé en mémoire qui possède les caractéristiques spécifiées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> est une chaîne vide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="desiredAccessRights" /> n’est pas une valeur d’énumération <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> valide.  
  
ou 
 <paramref name="inheritability" /> n’est pas une valeur d’énumération <see cref="T:System.IO.HandleInheritability" /> valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’accès demandé n’est pas valide pour le fichier mappé en mémoire.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié pour <paramref name="mapName" /> n’existe pas.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="SafeMemoryMappedFileHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeMemoryMappedFileHandle As SafeMemoryMappedFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ SafeMemoryMappedFileHandle { Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeMemoryMappedFileHandle : Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle de fichier d'un fichier mappé en mémoire.</summary>
        <value>Handle du fichier mappé en mémoire.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.SetAccessControl(System.IO.MemoryMappedFiles.MemoryMappedFileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.MemoryMappedFiles.MemoryMappedFileSecurity -&gt; unit" Usage="memoryMappedFile.SetAccessControl memoryMappedFileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="memoryMappedFileSecurity">Autorisations qui peuvent être accordées pour l'accès aux fichiers et aux opérations sur les fichiers mappés en mémoire.</param>
        <summary>Définit le contrôle d'accès à la ressource du fichier mappé en mémoire.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="memoryMappedFileSecurity" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</exception>
        <exception cref="T:System.NotSupportedException">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Échec d’un appel sous-jacent servant à définir les informations sur la sécurité.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Fichiers mappés en mémoire</related>
      </Docs>
    </Member>
  </Members>
</Type>