<Type Name="AsyncOperationManager" FullName="System.ComponentModel.AsyncOperationManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="606bfa8ffd9f758de42817a0e4e7eaf9e11c8260" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30368673" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class AsyncOperationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit AsyncOperationManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.AsyncOperationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class AsyncOperationManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsyncOperationManager abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit la gestion de l'accès concurrentiel pour les classes qui prennent en charge des appels de méthode asynchrone. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si votre classe doit fournir un comportement asynchrone en fonction de la [Event-based Asynchronous Pattern Overview](~/docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md), vous rencontrerez un nombre de problèmes de gestion d’accès concurrentiel. Parmi celles-ci est la nécessité de garantir que les gestionnaires d’événements sont appelés sur un thread ou le contexte approprié pour le modèle d’application (par exemple, les applications Windows Forms, [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] applications, les applications console, etc.). Le <xref:System.ComponentModel.AsyncOperationManager> fournit un moyen pratique de créer une classe qui s’exécute correctement sur tous les modèles d’application pris en charge par le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
 Le <xref:System.ComponentModel.AsyncOperationManager> classe possède une méthode, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, qui retourne un <xref:System.ComponentModel.AsyncOperation?displayProperty=nameWithType> qui peut être utilisé pour suivre la durée d’une tâche asynchrone particulière. Le <xref:System.ComponentModel.AsyncOperation?displayProperty=nameWithType> pour une tâche peut être utilisé pour alerter des clients lorsqu’une tâche se termine. Il peut également être utilisé pour publier des mises à jour de progression et des résultats incrémentiels sans terminer l’opération.  
  
 Pour plus d’informations sur l’implémentation de classes asynchrones, consultez [implémentation du modèle asynchrone basé sur événement](~/docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser la <xref:System.ComponentModel.AsyncOperationManager> classe pour créer une classe qui prend en charge des opérations asynchrones pour tout modèle d’application. Il montre comment implémenter une classe qui teste un nombre pour déterminer s’il est le premier. Ce calcul peut prendre beaucoup de temps, par conséquent, elle est effectuée sur un thread distinct. Rapports de progression, les résultats incrémentiels et les notifications de fin sont gérées par le <xref:System.ComponentModel.AsyncOperation> (classe), ce qui garantit que les gestionnaires d’événements du client sont appelés sur le thread ou contexte adéquat.  
  
 Pour une liste de code complet, consultez [Comment : implémenter un composant qui prend en charge le modèle asynchrone basé sur événement](http://msdn.microsoft.com/library/3c1aa4d4-da87-4a03-b812-3d167b8c57cf). Pour une liste de code complet d’un formulaire client, consultez [Comment : implémenter un Client du modèle asynchrone basé sur événement](~/docs/standard/asynchronous-programming-patterns/how-to-implement-a-client-of-the-event-based-asynchronous-pattern.md).  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#3)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.AsyncOperation" />
  </Docs>
  <Members>
    <Member MemberName="CreateOperation">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AsyncOperation CreateOperation (object userSuppliedState);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AsyncOperation CreateOperation(object userSuppliedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AsyncOperationManager.CreateOperation(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOperation (userSuppliedState As Object) As AsyncOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AsyncOperation ^ CreateOperation(System::Object ^ userSuppliedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userSuppliedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userSuppliedState">Objet utilisé pour associer une portion d'état client, telle qu'un identificateur de tâche, à une opération asynchrone particulière.</param>
        <summary>Retourne <see cref="T:System.ComponentModel.AsyncOperation" /> permettant de suivre la durée d'une opération asynchrone particulière.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AsyncOperation" /> que vous pouvez utiliser pour suivre la durée d'un appel de méthode asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> méthode retourne un <xref:System.ComponentModel.AsyncOperation?displayProperty=nameWithType> que vous pouvez utiliser pour suivre la durée d’une opération asynchrone particulière et pour alerter le modèle d’application lorsque l’opération se termine. Vous pouvez également l’utiliser pour publier des mises à jour de progression et des résultats incrémentiels sans terminer l’opération. Le <xref:System.ComponentModel.AsyncOperation?displayProperty=nameWithType> marshale correctement ces appels vers le thread approprié ou le contexte pour le modèle d’application.  
  
 Si vous implémentez une classe qui prend en charge le modèle asynchrone basé sur des événements, votre classe doit appeler <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> chaque fois que votre *MethodName* `Async` méthode est appelée. L’application cliente qui effectue des appels à la méthode peut utiliser le `userSuppliedState` paramètre pour identifier de façon unique chaque appel, afin de distinguer les événements déclenchés lors de l’exécution de l’opération asynchrone.  
  
> [!CAUTION]
>  Le code client doit fournir une valeur unique pour le `userSuppliedState` paramètre. ID de tâche non uniques peuvent entraîner votre implémentation à signaler la progression et autres événements incorrectement. Votre code doit vérifier un ID de tâche non unique et lever une <xref:System.ArgumentException?displayProperty=nameWithType> si celle-ci est détectée.  
  
 Votre code doit suivre chaque <xref:System.ComponentModel.AsyncOperation?displayProperty=nameWithType> retourné par <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> et utiliser l’objet dans l’opération asynchrone sous-jacente correspondante pour publier des mises à jour et de terminer l’opération. Ce suivi peut être aussi simple que le passage de le <xref:System.ComponentModel.AsyncOperation?displayProperty=nameWithType> en tant que paramètre entre des délégués. Dans les conceptions plus sophistiquées, votre classe peut gérer une collection de <xref:System.ComponentModel.AsyncOperation?displayProperty=nameWithType> objets, en ajoutant des objets lorsque des tâches sont démarrées et en les supprimant lorsque des tâches sont terminées ou annulées. Cette approche vous permet de vérifier pour unique `userSuppliedState` paramètre et la méthode à utiliser lors de l’utilisation des classes qui prennent en charge plusieurs appels simultanés.  
  
 Pour plus d’informations sur l’implémentation de classes asynchrones, consultez [implémentation du modèle asynchrone basé sur événement](~/docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> méthode pour créer un <xref:System.ComponentModel.AsyncOperation?displayProperty=nameWithType> pour le suivi de la durée des opérations asynchrones. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.AsyncOperationManager> classe.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#3)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncOperation" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.SynchronizationContext SynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.SynchronizationContext SynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.AsyncOperationManager.SynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SynchronizationContext As SynchronizationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::SynchronizationContext ^ SynchronizationContext { System::Threading::SynchronizationContext ^ get(); void set(System::Threading::SynchronizationContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.SynchronizationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contexte de synchronisation pour l'opération asynchrone.</summary>
        <value>Contexte de synchronisation pour l'opération asynchrone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut est l’implémentation libre de threads.  
  
 Un thread doit affecter la <xref:System.ComponentModel.AsyncOperationManager.SynchronizationContext%2A> propriété `null` pour libérer la fabrique libre de threads lorsqu’il est fait, sinon sa fabrique ne sera jamais supprimée.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.NamedPermissionSet">Pour définir le contexte de synchronisation. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
      </Docs>
    </Member>
  </Members>
</Type>