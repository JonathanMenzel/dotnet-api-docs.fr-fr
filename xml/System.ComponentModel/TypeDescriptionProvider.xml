<Type Name="TypeDescriptionProvider" FullName="System.ComponentModel.TypeDescriptionProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="23912b55bce31e7aec4da3c275f573b11b991f8d" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57931231" /></Metadata><TypeSignature Language="C#" Value="public abstract class TypeDescriptionProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TypeDescriptionProvider extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptionProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TypeDescriptionProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDescriptionProvider abstract" />
  <TypeSignature Language="F#" Value="type TypeDescriptionProvider = class" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit les métadonnées supplémentaires au <see cref="T:System.ComponentModel.TypeDescriptor" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptionProvider> classe étend dynamiquement les informations de type associées à un type ou un objet en ajoutant, en modifiant ou en masquant les caractéristiques telles que les attributs, propriétés et événements. Il peut y avoir plusieurs classes de fournisseur de description type qui offrent des métadonnées à un seul <xref:System.ComponentModel.TypeDescriptor>.  
  
 Il existe deux façons d’associer un <xref:System.ComponentModel.TypeDescriptionProvider> avec un <xref:System.ComponentModel.TypeDescriptor>:  
  
-   Au moment du design, lorsque la classe cible peut être affectée à approprié <xref:System.ComponentModel.TypeDescriptionProviderAttribute> balise.  
  
-   Au moment de l’exécution, lorsque l’une de le <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> méthodes de la <xref:System.ComponentModel.TypeDescriptor> classe peut être appelée. Ces méthodes surchargées requièrent l’objet cible ou son type de classe.  
  
 Le <xref:System.ComponentModel.TypeDescriptionProvider> classe s’appuie sur un objet parent du même type, fourni pendant la construction. Cela permet aux classes qui dérivent de <xref:System.ComponentModel.CustomTypeDescriptor> substituer les méthodes de manière sélective.  
  
 Instances de <xref:System.ComponentModel.TypeDescriptionProvider> sont créés uniquement à la demande, en limitant l’impact des informations de type personnalisées sur les performances.  
  
 Cette classe ne peut pas être héritée.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Votre type dérivé peut être marqué en tant que <see langword="internal" /> ou <see langword="private" />, mais une instance de votre type peut être créée avec la <see cref="T:System.ComponentModel.TypeDescriptor" /> classe. Ne pas écrire de code non sécurisé en supposant que l’appelant est approuvé. Supposez plutôt que les appelants peuvent créer des instances de votre type en confiance partielle.</para></block>
    <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
    <altmember cref="T:System.ComponentModel.TypeDescriptionProviderAttribute" />
    <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.TypeDescriptionProvider" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDescriptionProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDescriptionProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.TypeDescriptionProvider" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est équivalent à l’appel de l’autre <xref:System.ComponentModel.TypeDescriptionProvider.%23ctor%28System.ComponentModel.TypeDescriptionProvider%29> constructeur avec une valeur de paramètre est `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.#ctor(System.ComponentModel.TypeDescriptionProvider)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDescriptionProvider (System.ComponentModel.TypeDescriptionProvider parent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.TypeDescriptionProvider parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.#ctor(System.ComponentModel.TypeDescriptionProvider)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (parent As TypeDescriptionProvider)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDescriptionProvider(System::ComponentModel::TypeDescriptionProvider ^ parent);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.TypeDescriptionProvider : System.ComponentModel.TypeDescriptionProvider -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="new System.ComponentModel.TypeDescriptionProvider parent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="parent" Type="System.ComponentModel.TypeDescriptionProvider" />
      </Parameters>
      <Docs>
        <param name="parent">Fournisseur de description de type parent.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à l'aide d'un fournisseur de description de type parent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `parent` paramètre est `null`, tous les <xref:System.ComponentModel.TypeDescriptionProvider> méthodes retournent des valeurs par défaut. Sinon, tous les <xref:System.ComponentModel.TypeDescriptionProvider> méthodes délèguent aux méthodes de `parent`.  
  
 Le tableau suivant présente les valeurs de retour par défaut <xref:System.ComponentModel.TypeDescriptionProvider> méthodes.  
  
|Méthode|Valeur de retour par défaut|  
|------------|--------------------------|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A>|`null`|  
|<xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A>|Un objet nouvellement créé via un appel à la <xref:System.Activator.CreateInstance%2A> (méthode).|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A>|Une instance par défaut d’un <xref:System.ComponentModel.CustomTypeDescriptor> classe.|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A>|Une instance par défaut d’un <xref:System.ComponentModel.CustomTypeDescriptor> classe.|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A>|Le `objectType` premier paramètre.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.CustomTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateInstance (provider As IServiceProvider, objectType As Type, argTypes As Type(), args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(IServiceProvider ^ provider, Type ^ objectType, cli::array &lt;Type ^&gt; ^ argTypes, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj&#xA;override this.CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj" Usage="typeDescriptionProvider.CreateInstance (provider, objectType, argTypes, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">Fournisseur de services facultatif.</param>
        <param name="objectType">Type de l'objet à créer. Ce paramètre n'est jamais <see langword="null" />.</param>
        <param name="argTypes">Tableau facultatif des types qui représentent les types de paramètres à passer au constructeur de l'objet. Ce tableau peut être <see langword="null" /> ou de longueur nulle.</param>
        <param name="args">Tableau facultatif de valeurs de paramètre à passer au constructeur de l’objet.</param>
        <summary>Crée un objet qui peut remplacer un autre type de données.</summary>
        <returns><see cref="T:System.Object" /> de substitution.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IServiceProvider> spécifié par le `provider` paramètre est transmis par le <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A?displayProperty=nameWithType> méthode de la <xref:System.ComponentModel.TypeDescriptor> classe. Si `provider` n’est pas `null`, le fournisseur de services peut être utilisé par le fournisseur de description de type pour obtenir le contexte supplémentaire relatif à l’appel de création.  
  
 Le <xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A> méthode est `virtual` et, par défaut, retourne le résultat de la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> méthode si `provider` est `null`. Si `provider` est `null`, cette méthode appelle la <xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A> méthode du fournisseur parent.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si la classe dérivée ne s’intéresse pas à fournir une instance de substitution, il doit simplement appeler l’implémentation de base.</para></block>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetCache">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary GetCache (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary GetCache(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetCache(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCache (instance As Object) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ GetCache(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetCache : obj -&gt; System.Collections.IDictionary&#xA;override this.GetCache : obj -&gt; System.Collections.IDictionary" Usage="typeDescriptionProvider.GetCache instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Objet pour lequel obtenir le cache.</param>
        <summary>Obtient un cache par objet accessible en tant que <see cref="T:System.Collections.IDictionary" /> de paires clé/valeur.</summary>
        <returns><see cref="T:System.Collections.IDictionary" /> si l'objet fournit prend en charge la mise en cache ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.ComponentModel.TypeDescriptor> devra peut-être effectuer des opérations complexes sur les collections de métadonnées. Étant donné que les types ne sont pas déchargés pendant la durée de vie d’un domaine, le <xref:System.ComponentModel.TypeDescriptor> classe met automatiquement en cache les résultats de ces opérations en fonction de type. Toutefois, certaines opérations utilisent des instances de l’objet actif. Ces opérations ne peuvent pas être mis en cache dans le <xref:System.ComponentModel.TypeDescriptor> classe, car leur mise en cache empêcherait l’objet d’une garbage collecté. Au lieu de cela, le <xref:System.ComponentModel.TypeDescriptor> permet de classe pour un cache par objet accédé en tant qu’un <xref:System.Collections.IDictionary> de paires clé/valeur, se trouver sur un objet. Le <xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A> méthode retourne une instance de ce cache. Le <xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A> méthode retournera `null` s’il n’existe aucun cache pris en charge pour un objet.  
  
 La valeur par défaut <xref:System.ComponentModel.TypeDescriptionProvider> utilisé par <xref:System.ComponentModel.TypeDescriptor> examine l’objet pour voir si elle est un composant installé qui implémente le <xref:System.ComponentModel.Design.IDictionaryService> interface. Si l’objet est, il utilise le service de dictionnaire pour stocker cache l’objet. Sinon, l’objet retourne `null`. Autres fournisseurs de description de type peuvent fournir leur propre implémentation ici. Par exemple, les objets de dépendance peuvent simplement joindre une propriété de type <xref:System.Collections.IDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.ComponentModel.Design.IDictionaryService" />
      </Docs>
    </Member>
    <Member MemberName="GetExtendedTypeDescriptor">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ICustomTypeDescriptor GetExtendedTypeDescriptor (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExtendedTypeDescriptor (instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::ICustomTypeDescriptor ^ GetExtendedTypeDescriptor(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetExtendedTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor&#xA;override this.GetExtendedTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetExtendedTypeDescriptor instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Objet pour lequel obtenir le descripteur de type étendu.</param>
        <summary>Obtient un descripteur de type personnalisé étendu pour l'objet donné.</summary>
        <returns><see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> qui peut fournir des métadonnées étendues pour l'objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un descripteur de type étendu est un descripteur de type personnalisé qui offres propriétés autres objets ont ajouté à cet objet, mais qui ne sont pas réellement définies sur l’objet. Par exemple, dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] modèle de composant, des objets qui implémentent le <xref:System.ComponentModel.IExtenderProvider> interface peut joindre des propriétés à d’autres objets qui résident dans le même conteneur logique. Surchargées <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> méthodes ne retournent pas un descripteur de type qui fournit ces propriétés étendues supplémentaires. Le <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> méthode retourne l’ensemble de ces propriétés étendues. Le <xref:System.ComponentModel.TypeDescriptor> fusionne automatiquement les résultats de ces deux collections de propriétés. Bien que le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] modèle de composant prend en charge uniquement les propriétés étendues, <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> peut être utilisé pour les attributs étendus ainsi que les événements, si le fournisseur de description de type le prend en charge.  
  
 <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> est `virtual` et, par défaut, retourne un descripteur de type personnalisé qui retourne des résultats vides si aucun fournisseur parent a été passé. Si un fournisseur parent a été passé, cette méthode appelle le fournisseur parent <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetExtenderProviders">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IExtenderProvider[] GetExtenderProviders (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IExtenderProvider[] GetExtenderProviders(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetExtenderProviders(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetExtenderProviders (instance As Object) As IExtenderProvider()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual cli::array &lt;System::ComponentModel::IExtenderProvider ^&gt; ^ GetExtenderProviders(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetExtenderProviders : obj -&gt; System.ComponentModel.IExtenderProvider[]&#xA;override this.GetExtenderProviders : obj -&gt; System.ComponentModel.IExtenderProvider[]" Usage="typeDescriptionProvider.GetExtenderProviders instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IExtenderProvider[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance">Objet pour lequel obtenir des fournisseurs d'extendeurs.</param>
        <summary>Obtient les fournisseurs d'extendeurs pour l'objet spécifié.</summary>
        <returns>Tableau de fournisseurs d'extendeurs pour <paramref name="instance" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public virtual string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetFullComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFullComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetFullComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member GetFullComponentName : obj -&gt; string&#xA;override this.GetFullComponentName : obj -&gt; string" Usage="typeDescriptionProvider.GetFullComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Le composant spécifié.</param>
        <summary>Obtient le nom du composant spécifié ou <see langword="null" /> si le composant ne possède pas de nom.</summary>
        <returns>Nom du composant spécifié.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="component" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetReflectionType">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Effectue la réflexion normale par rapport à un objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReflectionType (instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetReflectionType(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetReflectionType : obj -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instance du type (ne doit pas être <see langword="null" />).</param>
        <summary>Effectue la réflexion normale par rapport à l'objet donné.</summary>
        <returns>Type de réflexion pour ce <paramref name="instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> méthode est une version de niveau inférieur de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> (méthode). Si aucun descripteur de type personnalisé ne peut être localisé pour un objet, <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> est appelée pour effectuer la réflexion normale par rapport à l’objet.  
  
 Utilisez cette surcharge de méthode si vous avez appelé un membre du descripteur de type qui utilise une instance au lieu d’un type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> est <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public Type GetReflectionType (Type objectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetReflectionType(class System.Type objectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReflectionType (objectType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetReflectionType(Type ^ objectType);" />
      <MemberSignature Language="F#" Value="member this.GetReflectionType : Type -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType objectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Type d'objet pour lequel récupérer <see cref="T:System.Reflection.IReflect" />.</param>
        <summary>Effectue la réflexion normale par rapport à un type.</summary>
        <returns>Type de réflexion pour ce <paramref name="objectType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> méthode est une version de niveau inférieur de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> (méthode). Si aucun descripteur de type personnalisé ne peut être localisé pour un objet, <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> est appelée pour effectuer la réflexion normale par rapport à l’objet.  
  
 Utilisez cette surcharge de méthode si vous avez appelé un membre du descripteur de type qui utilise un type plutôt qu’une instance.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="objectType" /> est <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public virtual Type GetReflectionType (Type objectType, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetReflectionType(class System.Type objectType, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReflectionType (objectType As Type, instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetReflectionType(Type ^ objectType, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetReflectionType : Type * obj -&gt; Type&#xA;override this.GetReflectionType : Type * obj -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType (objectType, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objectType">Type d'objet pour lequel récupérer <see cref="T:System.Reflection.IReflect" />.</param>
        <param name="instance">Instance du type. Peut être <see langword="null" />.</param>
        <summary>Effectue la réflexion normale par rapport à l'objet donné à l'aide du type donné.</summary>
        <returns>Type de réflexion pour ce <paramref name="objectType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> méthode est une version de niveau inférieur de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> (méthode). Si aucun descripteur de type personnalisé ne peut être localisé pour un objet, <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> est appelée pour effectuer la réflexion normale par rapport à l’objet.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cette méthode est prototypée comme <see langword="virtual" />et par défaut retourne <paramref name="objectType" /> si aucun fournisseur parent a été passé. Si un fournisseur parent a été passé, cette méthode appelle le fournisseur parent <see cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetReflectionType" /> (méthode).</para></block>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeType">
      <MemberSignature Language="C#" Value="public virtual Type GetRuntimeType (Type reflectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetRuntimeType(class System.Type reflectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeType (reflectionType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetRuntimeType(Type ^ reflectionType);" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeType : Type -&gt; Type&#xA;override this.GetRuntimeType : Type -&gt; Type" Usage="typeDescriptionProvider.GetRuntimeType reflectionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reflectionType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reflectionType">Type à convertir en son équivalent au moment de l'exécution.</param>
        <summary>Convertit un type de réflexion en un type au moment de l'exécution.</summary>
        <returns><see cref="T:System.Type" /> qui représente l'équivalent au moment de l'exécution de <paramref name="reflectionType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType%2A> méthode inverse la <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> méthode pour convertir un type de réflexion de nouveau un type de runtime. À l’aide de la <xref:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType%2A> méthode est préférable à l’aide de la <xref:System.Type.UnderlyingSystemType%2A> propriété, qui a été utilisée dans les versions antérieures pour retourner le type de runtime.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reflectionType" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeDescriptor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un descripteur de type personnalisé pour le type ou l'objet donné.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeDescriptor (instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instance du type. Peut être <see langword="null" /> si aucune instance n'est passée au <see cref="T:System.ComponentModel.TypeDescriptor" />.</param>
        <summary>Obtient un descripteur de type personnalisé pour l'objet donné.</summary>
        <returns><see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> qui peut fournir les métadonnées pour le type.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (Type objectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(class System.Type objectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeDescriptor (objectType As Type) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(Type ^ objectType);" />
      <MemberSignature Language="F#" Value="member this.GetTypeDescriptor : Type -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor objectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Type d'objet pour lequel récupérer le descripteur de type.</param>
        <summary>Obtient un descripteur de type personnalisé pour le type donné.</summary>
        <returns><see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> qui peut fournir les métadonnées pour le type.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (Type objectType, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(class System.Type objectType, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeDescriptor (objectType As Type, instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(Type ^ objectType, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeDescriptor : Type * obj -&gt; System.ComponentModel.ICustomTypeDescriptor&#xA;override this.GetTypeDescriptor : Type * obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor (objectType, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objectType">Type d'objet pour lequel récupérer le descripteur de type.</param>
        <param name="instance">Instance du type. Peut être <see langword="null" /> si aucune instance n'est passée au <see cref="T:System.ComponentModel.TypeDescriptor" />.</param>
        <summary>Obtient un descripteur de type personnalisé pour le type et l'objet donné.</summary>
        <returns><see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> qui peut fournir les métadonnées pour le type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est prototypée comme `virtual` et, par défaut, retourne un descripteur vide si aucun fournisseur parent a été passé. Si un fournisseur parent a été passé, cette méthode appelle le fournisseur parent <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Le <see cref="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type,System.Object)" /> méthode doit retourner un descripteur de type personnalisé pour l’objet. Si la méthode ne fournit pas les informations de type pour l’objet, elle doit retourner <see langword="null" />.</para></block>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsSupportedType">
      <MemberSignature Language="C#" Value="public virtual bool IsSupportedType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupportedType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.IsSupportedType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupportedType(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member IsSupportedType : Type -&gt; bool&#xA;override this.IsSupportedType : Type -&gt; bool" Usage="typeDescriptionProvider.IsSupportedType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Type dont la compatibilité doit être testée.</param>
        <summary>Obtient une valeur qui indique si le type spécifié est compatible avec la description de type et sa chaîne de fournisseurs de descriptions de types.</summary>
        <returns><see langword="true" /> si <paramref name="type" /> est compatible avec la description de type et sa chaîne de fournisseurs de descriptions de types, sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>