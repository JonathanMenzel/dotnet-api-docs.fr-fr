<Type Name="TypeDescriptor" FullName="System.ComponentModel.TypeDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5cc7c2b11839423f9394648fb17fab237632987c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39908906" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit TypeDescriptor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDescriptor sealed" />
  <TypeSignature Language="F#" Value="type TypeDescriptor = class" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des informations relatives aux caractéristiques d’un composant, telles que ses attributs, ses propriétés et ses événements. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework fournit deux façons d’accéder aux métadonnées sur un type : la réflexion API fournie dans le <xref:System.Reflection?displayProperty=nameWithType> espace de noms et la <xref:System.ComponentModel.TypeDescriptor> classe. La réflexion est un mécanisme général disponible pour tous les types, car sa fondation est établie dans le <xref:System.Object.GetType%2A> méthode de la racine <xref:System.Object> classe. Les informations qu’elle retourne pour un type ne sont pas extensibles, car elle ne peut pas être modifiée après la compilation du type cible. Pour plus d’informations, consultez les rubriques de [réflexion](~/docs/framework/reflection-and-codedom/reflection.md).  
  
 En revanche, <xref:System.ComponentModel.TypeDescriptor> est un mécanisme d’inspection extensible pour les composants : les classes qui implémentent le <xref:System.ComponentModel.IComponent> interface. Contrairement à la réflexion, il n’inspecte pas les méthodes. <xref:System.ComponentModel.TypeDescriptor> peuvent être étendus dynamiquement par plusieurs services disponibles via le composant cible <xref:System.ComponentModel.Component.Site%2A>. Le tableau suivant présente ces services.  
  
|Nom du service|Description |  
|------------------|-----------------|  
|<xref:System.ComponentModel.IExtenderProvider>|Active une autre classe, tels que <xref:System.Windows.Forms.ToolTip>, pour fournir des propriétés supplémentaires à un composant.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Permet à un autre objet modifier les métadonnées standard qui sont exposée par un composant.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor>|Permet à une classe complète et dynamique spécifier ses propres métadonnées, en remplaçant le mécanisme d’inspection standard de <xref:System.ComponentModel.TypeDescriptor>.|  
  
 L’extensibilité fournie par <xref:System.ComponentModel.TypeDescriptor> permet à la représentation au moment du design d’un composant de différer de sa représentation à l’exécution, ce qui rend <xref:System.ComponentModel.TypeDescriptor> utiles pour la création de l’infrastructure de conception.  
  
 Toutes les méthodes dans <xref:System.ComponentModel.TypeDescriptor> sont `static`. Vous ne pouvez pas créer une instance de cette classe, et cette classe ne peut pas être héritée.  
  
 Vous pouvez définir la propriété et l’événement valeurs de deux façons différentes : les spécifier dans la classe de composant ou de les modifier au moment du design. Étant donné que vous pouvez définir ces valeurs de deux manières, les méthodes surchargées de <xref:System.ComponentModel.TypeDescriptor> prendre deux types de paramètres différents : un type de classe ou une instance d’objet.  
  
 Lorsque vous souhaitez accéder <xref:System.ComponentModel.TypeDescriptor> informations et que vous disposez d’une instance de l’objet, utilisez la méthode qui appelle un composant. Utilisez la méthode qui appelle pour le type de classe uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Propriétés et événements sont mis en cache par <xref:System.ComponentModel.TypeDescriptor> pour aller plus vite. En règle générale, ils sont constants pendant la durée de vie d’un objet. Toutefois, les concepteurs et les fournisseurs d’extendeurs peuvent modifier le jeu de propriétés sur un objet. Si c’est le cas, le <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> méthode doit être appelée pour mettre à jour le cache.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.EventDescriptor" />
    <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.ComponentModel.IComponent" />
    <altmember cref="T:System.ComponentModel.ISite" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute des attributs de niveau de classe au composant cible.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (object instance, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(object instance, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAttributes (instance As Object, ParamArray attributes As Attribute()) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(System::Object ^ instance, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member AddAttributes : obj * Attribute[] -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.AddAttributes (instance, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Instance du composant cible.</param>
        <param name="attributes">Tableau d’objets <see cref="T:System.Attribute" /> à ajouter à la classe du composant.</param>
        <summary>Ajoute des attributs de niveau classe à l’instance du composant cible.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> récemment créé qui a été utilisé pour ajouter les attributs spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Object%2CSystem.Attribute%5B%5D%29> méthode ajoute des attributs de niveau classe à l’instance spécifiée d’un composant. Comme il s’agit d’une exigence courante pour les applications à l’aide du Concepteur de formulaires de Visual Studio Windows et la fenêtre Propriétés, cette méthode fournit un raccourci en créant un fournisseur de description de type qui fusionne les attributs fournis avec les attributs déjà existe dans la classe. La valeur de retour est le fournisseur de description de type qui a été utilisé pour ajouter les attributs. Ce fournisseur peut ensuite être passé à la <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> méthode lorsque les attributs ajoutés ne sont plus nécessaires.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member AddAttributes : Type * Attribute[] -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.AddAttributes (type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <param name="attributes">Tableau d’objets <see cref="T:System.Attribute" /> à ajouter à la classe du composant.</param>
        <summary>Ajoute des attributs de classe au type du composant cible.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> récemment créé qui a été utilisé pour ajouter les attributs spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Type%2CSystem.Attribute%5B%5D%29> méthode ajoute des attributs de niveau classe vers le type spécifié d’un composant. Comme il s’agit d’une exigence courante pour les applications à l’aide du Concepteur de formulaires de Visual Studio Windows et la fenêtre Propriétés, cette méthode fournit un raccourci en créant un fournisseur de description de type qui fusionne les attributs fournis avec les attributs déjà existe dans la classe. La valeur de retour est le fournisseur de description de type qui a été utilisé pour ajouter les attributs. Ce fournisseur peut ensuite être passé à la <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> méthode lorsque les attributs ajoutés ne sont plus nécessaires.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddEditorTable">
      <MemberSignature Language="C#" Value="public static void AddEditorTable (Type editorBaseType, System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddEditorTable(class System.Type editorBaseType, class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddEditorTable (editorBaseType As Type, table As Hashtable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddEditorTable(Type ^ editorBaseType, System::Collections::Hashtable ^ table);" />
      <MemberSignature Language="F#" Value="static member AddEditorTable : Type * System.Collections.Hashtable -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddEditorTable (editorBaseType, table)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">Type de base d’éditeur pour lequel ajouter la table d’éditeur. Si une table existe déjà pour ce type, cette méthode n’aura aucun effet.</param>
        <param name="table">
          <see cref="T:System.Collections.Hashtable" /> à ajouter.</param>
        <summary>Ajoute une table d’éditeur pour le type de base d’éditeur donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.AddEditorTable%2A> méthode ajoute une table d’éditeur pour le type de base d’éditeur donné. En règle générale, les éditeurs sont spécifiés en tant que métadonnées sur un composant. Toutefois, si aucune métadonnée pour une base d’éditeur demandé type peut être trouvé sur le composant, associé <xref:System.ComponentModel.TypeDescriptor> recherche une table d’éditeur pour le type d’éditeur, s’il en existe un. Une fois qu’une table d’éditeur a été ajoutée à un descripteur de type, il ne peut pas être supprimé et est détenue par le descripteur de type. Le descripteur de type peut effectuer librement les modifications à cette table.  
  
 Le format pour une table d’éditeur utilise des types de données en tant que clés et des éditeurs en tant que valeurs. La partie de la valeur d’une entrée dans la table représente une instance d’éditeur. Il peut avoir une des trois valeurs. Si elle contient une chaîne, le descripteur de type suppose qu'il s’agit d’un nom qualifié complet d’un type et puis charge le type de l’objet. S’il contient un type, une instance de ce type sera créée pour obtenir un éditeur. Enfin, la partie valeur peut contenir une instance d’éditeur réelle. Si le descripteur de type résout un éditeur à une instance, il stocke l’instance dans la table pour une utilisation ultérieure.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un fournisseur de description de type à la liste des fournisseurs de ce descripteur de type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member AddProvider : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProvider (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à ajouter.</param>
        <param name="instance">Instance du composant cible.</param>
        <summary>Ajoute un fournisseur de description de type pour une instance unique d’un composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> méthode ajoute un fournisseur de description de type qui fournit des informations pour une instance unique d’un composant de type. Si un fournisseur est ajouté par cette méthode, le fournisseur <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> méthode ne sera pas appelée, car l’instance existe déjà.  
  
 Cette méthode ne conserve pas de référence dure au composant, afin qu’il n’empêche pas le composant à partir de la finalisation.  
  
 Il est possible d’ajouter plusieurs fournisseurs de description de type pour le même type ou le même objet. Si cela se produit, le premier type fournisseur de description rencontré qui fournit des informations de type servira exclusivement. Dans la mesure où les fournisseurs d’informations de type sont stockés dans une pile, le dernier fournisseur ajouté sera le premier interrogé. Ce comportement permet la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> et <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> des fournisseurs de description de type de méthodes à utiliser pour les push et pop en fonction des besoins de scénarios particuliers.  
  
 Si la réussite, cette méthode appelle la <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Object%29> méthode sur le `instance` paramètre.  
  
> [!NOTE]
>  Les deux versions de cette méthode produisent des résultats des étendues différentes. Le <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> méthode qui prend un <xref:System.Object> paramètre affecte uniquement cette instance unique du composant spécifié. En revanche, l’autre surcharge qui prend un <xref:System.Type> paramètre, affecte toutes les instances du composant décrit par ce type.  
  
 Utilisez le <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> méthode si vous avez besoin d’appeler à partir du code partiellement fiable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member AddProvider : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProvider (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à ajouter.</param>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Ajoute un fournisseur de description de type pour une classe de composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> méthode ajoute un fournisseur de description de type qui fournit des informations pour la classe spécifiée, les classes dérivées et toutes les instances de ces types de type.  
  
> [!NOTE]
>  Le `type` paramètre peut être n’importe quel type, y compris une interface. Par exemple, pour fournir des informations d’instance pour tous les composants et de type personnalisé, vous devez spécifier `typeof(IComponent)`. En passant `typeof(object)` appelle le fournisseur pour fournir des informations de type pour tous les types.  
  
 Cette méthode ne conserve pas de référence dure à n’importe quel objet, afin qu’il n’empêche pas les objets à partir de la finalisation.  
  
 Il est possible d’ajouter plusieurs fournisseurs de description de type pour le même type ou le même objet. Si cela se produit, le premier type fournisseur de description rencontré qui fournit des informations de type servira exclusivement. Étant donné que les fournisseurs d’informations de type sont stockés dans une pile, le dernier fournisseur ajouté sera le premier interrogé. Ce comportement permet la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> et <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> des fournisseurs de description de type de méthodes à utiliser pour les push et pop en fonction des besoins de scénarios particuliers.  
  
 Si la réussite, cette méthode appelle la <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Type%29> méthode sur le `type` paramètre.  
  
> [!NOTE]
>  Les deux versions de cette méthode produisent des résultats des étendues différentes. Le <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> méthode qui prend un <xref:System.Object> paramètre affecte uniquement cette instance unique du composant spécifié. En revanche, l’autre surcharge qui prend un <xref:System.Type> paramètre, affecte toutes les instances du composant décrit par ce type.  
  
 Utilisez le <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> méthode si vous avez besoin d’appeler à partir du code partiellement fiable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un fournisseur de description de type à la liste des fournisseurs de ce descripteur de type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member AddProviderTransparent : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProviderTransparent (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à ajouter.</param>
        <param name="instance">Instance du composant cible.</param>
        <summary>Ajoute un fournisseur de description de type pour une instance unique d’un composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée depuis du code d’un niveau de confiance partiel. Si <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> est défini, l’appelant peut enregistrer un fournisseur pour l’instance spécifiée si son type est également partiellement de confiance.  
  
 Utilisez le <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> méthode si vous n’avez pas besoin d’appeler à partir du code partiellement fiable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Pour accéder au Registre. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Type associé : le <see cref="T:System.Security.PermissionSet" /> qui est requis par l’assembly qui définit le <paramref name="instance" /> type du paramètre.</permission>
      </Docs>
    </Member>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member AddProviderTransparent : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProviderTransparent (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à ajouter.</param>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Ajoute un fournisseur de description de type pour une classe de composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée depuis du code d’un niveau de confiance partiel. Si <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> est défini, l’appelant peut enregistrer un fournisseur pour le type spécifié s’il est également partiellement approuvé.  
  
 Utilisez le <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> méthode si vous n’avez pas besoin d’appeler à partir du code partiellement fiable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Pour accéder au Registre. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Type associé : le <see cref="T:System.Security.PermissionSet" /> qui est requis par l’assembly qui définit <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ComNativeDescriptorHandler">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ComNativeDescriptorHandler As IComNativeDescriptorHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::ComponentModel::IComNativeDescriptorHandler ^ ComNativeDescriptorHandler { System::ComponentModel::IComNativeDescriptorHandler ^ get(); void set(System::ComponentModel::IComNativeDescriptorHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ComNativeDescriptorHandler : System.ComponentModel.IComNativeDescriptorHandler with get, set" Usage="System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComNativeDescriptorHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le fournisseur pour les informations de type COM (Component Object Model) pour le composant cible.</summary>
        <value>Instance <see cref="T:System.ComponentModel.IComNativeDescriptorHandler" /> représentant le fournisseur d’informations de type COM.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler%2A> propriété et le <xref:System.ComponentModel.IComNativeDescriptorHandler> interface sont obsolètes. Pour plus d'informations, consultez la propriété <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      </Docs>
    </Member>
    <Member MemberName="ComObjectType">
      <MemberSignature Language="C#" Value="public static Type ComObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type ComObjectType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ComObjectType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ ComObjectType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComObjectType : Type" Usage="System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de l’objet COM (Component Object Model) représenté par le composant cible.</summary>
        <value>
          <see cref="T:System.Type" /> de l’objet COM représenté par ce composant, ou <see langword="null" /> pour les objets non-COM.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> propriété retourne un type qui peut être passé à la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> méthode pour définir un fournisseur de description de type pour les types COM.  
  
 Le <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> propriété et autres membres de cette classe remplacent les fonctionnalités dans obsolète <xref:System.ComponentModel.IComNativeDescriptorHandler> interface. Pour implémenter une couche de mappage entre un objet COM et <xref:System.ComponentModel.TypeDescriptor>, ajoutez un <xref:System.ComponentModel.TypeDescriptionProvider> pour gérer le type <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateAssociation">
      <MemberSignature Language="C#" Value="public static void CreateAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberSignature Language="F#" Value="static member CreateAssociation : obj * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.CreateAssociation (primary, secondary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">
          <see cref="T:System.Object" /> principal.</param>
        <param name="secondary">
          <see cref="T:System.Object" /> secondaire.</param>
        <summary>Crée une association de type principal-secondaire entre deux objets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> méthode crée une association entre un objet principal et secondaire. Une fois qu’une association est créée, un concepteur ou un autre mécanisme de filtrage peut ajouter des propriétés qui acheminent vers des objets dans le jeu de propriétés de l’objet principal. Lorsqu’un appel de propriété est effectué sur l’objet principal, le <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> méthode sera appelée pour résoudre l’instance de l’objet réel qui est associé à son paramètre de type.  
  
 Un <xref:System.WeakReference> est utilisé pour maintenir l’association entre l’objet principal et secondaire ; par conséquent, cette méthode n’empêche pas des objets d’être finalisé et récupéré par le garbage collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="primary" /> est égal à <paramref name="secondary" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, Type designerBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, class System.Type designerBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDesigner (component As IComponent, designerBaseType As Type) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, Type ^ designerBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateDesigner : System.ComponentModel.IComponent * Type -&gt; System.ComponentModel.Design.IDesigner" Usage="System.ComponentModel.TypeDescriptor.CreateDesigner (component, designerBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="designerBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.ComponentModel.IComponent" /> qui spécifie le composant à associer au concepteur.</param>
        <param name="designerBaseType">
          <see cref="T:System.Type" /> qui représente le type de concepteur à créer.</param>
        <summary>Crée une instance du concepteur associé au composant spécifié et du type de concepteur spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.Design.IDesigner" /> qui est une instance du concepteur pour le composant, ou <see langword="null" /> si aucun concepteur n’est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode ne peut pas trouver un valide <xref:System.ComponentModel.DesignerAttribute>, il recherche dans la hiérarchie de classe pour un concepteur. Si elle ne peut pas trouver un concepteur dans la hiérarchie de classes, elle retourne `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.IComponent" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un descripteur d’événement identique à un descripteur d’événement existant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, System.ComponentModel.EventDescriptor oldEventDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, class System.ComponentModel.EventDescriptor oldEventDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.ComponentModel.EventDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateEvent (componentType As Type, oldEventDescriptor As EventDescriptor, ParamArray attributes As Attribute()) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::ComponentModel::EventDescriptor ^ oldEventDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateEvent : Type * System.ComponentModel.EventDescriptor * Attribute[] -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateEvent (componentType, oldEventDescriptor, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldEventDescriptor" Type="System.ComponentModel.EventDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">Type du composant pour lequel créer l’événement.</param>
        <param name="oldEventDescriptor">Informations existantes sur l’événement.</param>
        <param name="attributes">Nouveaux attributs.</param>
        <summary>Crée un descripteur d’événement identique à un descripteur d’événement existant, quand le <see cref="T:System.ComponentModel.EventDescriptor" /> existant est passé.</summary>
        <returns>Nouveau <see cref="T:System.ComponentModel.EventDescriptor" /> qui a fusionné les attributs de métadonnées spécifiés avec les attributs de métadonnées existants.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requis pour inspecter des membres non publics du composant. Requis pour l’accès à la demande de lien <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> type <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateEvent : Type * string * Type * Attribute[] -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateEvent (componentType, name, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">Type du composant dans lequel réside l’événement.</param>
        <param name="name">Nom de l'événement.</param>
        <param name="type">Type du délégué qui gère l’événement.</param>
        <param name="attributes">Attributs de cet événement.</param>
        <summary>Crée un nouveau descripteur d’événement qui est identique à un descripteur d’événement existant, en générant des informations de descripteur de façon dynamique à partir d’un événement spécifié sur un type.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> lié à un type.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requis pour inspecter des membres non publics du composant. Requis pour l’accès à la demande de lien <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> type <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (provider As IServiceProvider, objectType As Type, argTypes As Type(), args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(IServiceProvider ^ provider, Type ^ objectType, cli::array &lt;Type ^&gt; ^ argTypes, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.CreateInstance (provider, objectType, argTypes, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">Fournisseur de services qui fournit un service <see cref="T:System.ComponentModel.TypeDescriptionProvider" />. Ce paramètre peut être <see langword="null" />.</param>
        <param name="objectType">
          <see cref="T:System.Type" /> de l’objet à créer.</param>
        <param name="argTypes">Tableau facultatif de types de paramètre à passer au constructeur de l’objet. Ce paramètre peut avoir la valeur <see langword="null" /> ou correspondre à un tableau de longueur égale à zéro.</param>
        <param name="args">Tableau facultatif de valeurs de paramètre à passer au constructeur de l’objet. Si la valeur n’est pas <see langword="null" />, le nombre d’éléments doit être le même que <c>argTypes</c>.</param>
        <summary>Crée un objet qui peut remplacer un autre type de données.</summary>
        <returns>Instance du type de données de remplacement si un <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associé est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> méthode recherchera un <xref:System.ComponentModel.TypeDescriptionProvider> associé spécifié `objectType` type de données. Cette méthode tente d’abord d’obtenir un fournisseur de description de type à partir de la `provider` paramètre. En cas d’échec, elle recherche ses propres tables internes pour un fournisseur (ces entrées ont été créées via des appels précédents à <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>). S’il trouve un fournisseur, cette méthode délègue l’appel de la création de cet objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> a la valeur <see langword="null" /> ou <paramref name="args" /> a la valeur <see langword="null" /> quand <paramref name="argTypes" /> n’a pas la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argTypes" /> et <paramref name="args" /> ont un nombre différent d’éléments.</exception>
        <block subset="none" type="overrides">
          <para>Si la classe dérivée ne fournit pas une instance de substitution, cette méthode doit appeler l’implémentation de base.</para>
        </block>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nouveau descripteur de propriété pour une propriété de composant existante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, class System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.ComponentModel.PropertyDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProperty (componentType As Type, oldPropertyDescriptor As PropertyDescriptor, ParamArray attributes As Attribute()) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::ComponentModel::PropertyDescriptor ^ oldPropertyDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateProperty : Type * System.ComponentModel.PropertyDescriptor * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateProperty (componentType, oldPropertyDescriptor, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldPropertyDescriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> du composant dont la propriété est membre.</param>
        <param name="oldPropertyDescriptor">Descripteur de propriété existant.</param>
        <param name="attributes">Nouveaux attributs de cette propriété.</param>
        <summary>Crée un descripteur de propriété à partir d’un descripteur de propriété existant, à l’aide du <see cref="T:System.ComponentModel.PropertyDescriptor" /> et du tableau d’attributs existants spécifiés.</summary>
        <returns>Nouveau <see cref="T:System.ComponentModel.PropertyDescriptor" /> qui possède les attributs de métadonnées spécifiés fusionnés avec les attributs de métadonnées existants.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requis pour inspecter des membres non publics du composant. Requis pour l’accès à la demande de lien <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> type <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateProperty : Type * string * Type * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateProperty (componentType, name, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> du composant dont la propriété est membre.</param>
        <param name="name">Nom de la propriété.</param>
        <param name="type">
          <see cref="T:System.Type" /> de la propriété.</param>
        <param name="attributes">Nouveaux attributs de cette propriété.</param>
        <summary>Crée et lie dynamiquement un descripteur de propriété à un type, en utilisant le nom, le type et le tableau d’attributs de la propriété spécifiée.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> qui est lié au type spécifié et dont les attributs de métadonnées spécifiés sont fusionnés avec les attributs de métadonnées existants.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requis pour inspecter des membres non publics du composant. Requis pour l’accès à la demande de lien <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> type <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetAssociation">
      <MemberSignature Language="C#" Value="public static object GetAssociation (Type type, object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAssociation(class System.Type type, object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAssociation(Type ^ type, System::Object ^ primary);" />
      <MemberSignature Language="F#" Value="static member GetAssociation : Type * obj -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetAssociation (type, primary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <param name="primary">Objet principal de l’association.</param>
        <summary>Retourne une instance du type associé à l’objet principal spécifié.</summary>
        <returns>Instance du type secondaire associée à l'objet principal si une association existe ; sinon, <paramref name="primary" /> si aucune association spécifiée n'existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une association antérieure a été effectuée le `type` à l’aide du paramètre le <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> (méthode), puis le <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> méthode retourne l’objet secondaire correct à appeler pour le type demandé. Sinon, <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> recherche un concepteur compatible pour `type` et retourne le concepteur s’il en existe. Cette méthode ne retourne jamais `null`.  
  
 Un <xref:System.WeakReference> est utilisé pour maintenir l’association entre l’objet principal et secondaire ; par conséquent, cette méthode n’empêche pas l’objet principal ou secondaire d’être finalisé et récupéré par le garbage collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.IDesignerHost.GetDesigner(System.ComponentModel.IComponent)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la collection d’attributs pour un composant ou un type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : obj -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel vous souhaitez obtenir les attributs.</param>
        <summary>Retourne la collection d’attributs pour le composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AttributeCollection" /> qui contient les attributs pour le composant. Si <paramref name="component" /> a la valeur <see langword="null" />, cette méthode retourne une collection vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les attributs retournés par la <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> méthode peut-être être modifiée de manière dynamique à partir liste source du composant d’origine par les fournisseurs d’extendeurs (<xref:System.ComponentModel.IExtenderProvider>), filtrer les services (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) et les filtres d’attribut.  
  
 Lorsque vous définissez un attribut personnalisé avec <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> définie sur `true`, vous devez substituer la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété pour le rendre unique. Si toutes les instances de votre attribut sont uniques, substituez <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> pour renvoyer l’identité de l’objet de votre attribut. Si seules quelques instances de votre attribut sont uniques, retourner une valeur à partir de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> qui retournerait une égalité dans ces cas. Par exemple, certains attributs ont un paramètre de constructeur qui agit comme une clé unique. Pour ces attributs, retournez la valeur du paramètre de constructeur à partir de la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété.  
  
> [!NOTE]
>  L’implémentation par défaut de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retourne l’identité de type, quel que soit la valeur de la <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriété. Pour retourner plusieurs instances d’un <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> attribut à partir de la <xref:System.ComponentModel.AttributeCollection>, votre attribut doit substituer la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété.  
  
   
  
## Examples  
 Pour obtenir un exemple de cette méthode, consultez la <xref:System.ComponentModel.AttributeCollection.Matches%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (componentType As Type) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : Type -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Retourne une collection d’attributs pour le type de composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AttributeCollection" /> avec les attributs pour le type de composant. Si le composant est <see langword="null" />, cette méthode retourne une collection vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Pour les attributs avec <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> défini sur `true`, la collection d’attributs supprime les instances dupliquées. Il s’agit d’instances dans lesquelles le <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété retourne des valeurs égales.  
  
 Lorsque vous définissez un attribut personnalisé avec <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> définie sur `true`, vous devez substituer la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété pour le rendre unique. Si toutes les instances de votre attribut sont uniques, substituez <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> pour renvoyer l’identité de l’objet de votre attribut. Si seules quelques instances de votre attribut sont uniques, retourner une valeur à partir de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> qui retournerait une égalité dans ces cas. Par exemple, certains attributs ont un paramètre de constructeur qui agit comme une clé unique. Pour ces attributs, retournez la valeur du paramètre de constructeur à partir de la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété.  
  
> [!NOTE]
>  L’implémentation par défaut de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retourne l’identité de type, quel que soit la valeur de la <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriété. Pour retourner plusieurs instances d’un <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> attribut à partir de la <xref:System.ComponentModel.AttributeCollection>, votre attribut doit substituer la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object, noCustomTypeDesc As Boolean) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : obj * bool -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel vous souhaitez obtenir les attributs.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour utiliser un ensemble d’attributs de base de référence à partir du descripteur de type personnalisé si <c>component</c> est de type <see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> ; sinon, <see langword="false" />.</param>
        <summary>Retourne une collection d’attributs pour le composant spécifié et une valeur booléenne indiquant qu’un descripteur de type personnalisé a été créé.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AttributeCollection" /> avec les attributs du composant. Si le composant est <see langword="null" />, cette méthode retourne une collection vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les attributs retournés par la <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> méthode peut-être être modifiée de manière dynamique à partir de la source d’origine de composants répertoriant par les fournisseurs d’extendeurs (<xref:System.ComponentModel.IExtenderProvider>), filtrer les services (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) et les filtres d’attribut.  
  
 Lorsque vous définissez un attribut personnalisé avec <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> définie sur `true`, vous devez substituer la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété pour le rendre unique. Si toutes les instances de votre attribut sont uniques, substituez <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> pour renvoyer l’identité de l’objet de votre attribut. Si seules quelques instances de votre attribut sont uniques, retourner une valeur à partir de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> qui retournerait une égalité dans ces cas. Par exemple, certains attributs ont un paramètre de constructeur qui agit comme une clé unique. Pour ces attributs, retournez la valeur du paramètre de constructeur à partir de la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété.  
  
> [!NOTE]
>  L’implémentation par défaut de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retourne l’identité de type, quel que soit la valeur de la <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriété. Pour retourner plusieurs instances d’un <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> attribut à partir de la <xref:System.ComponentModel.AttributeCollection>, votre attribut doit substituer la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetClassName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le nom de la classe pour le composant spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetClassName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> dont vous souhaitez obtenir le nom de la classe.</param>
        <summary>Retourne le nom de la classe pour le composant spécifié en utilisant le descripteur de type par défaut.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient le nom de la classe pour le composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, cette méthode retourne la version complète <xref:System.Type> nom pour le `component` type de paramètre. Par exemple, le nom de classe pour un bouton est « System.Windows.Forms.Button ». Si `component` implémente <xref:System.ComponentModel.ICustomTypeDescriptor>, elle peut retourner un autre nom.  
  
 Cette méthode est équivalente à surchargées <xref:System.ComponentModel.TypeDescriptor.GetClassName%28System.Object%2CSystem.Boolean%29> méthode avec un second paramètre de `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (componentType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetClassName : Type -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Retourne le nom de la classe pour le type spécifié.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient le nom de la classe pour le type de composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise le descripteur de type personnalisé mis en cache pour le type spécifié pour découvrir le nom de la classe associée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetClassName : obj * bool -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> dont vous souhaitez obtenir le nom de la classe.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour prendre en compte les informations de description de type personnalisées ; sinon, <see langword="false" />.</param>
        <summary>Retourne le nom de la classe pour le composant spécifié en utilisant un descripteur de type personnalisé.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient le nom de la classe pour le composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, cette méthode retourne la version complète <xref:System.Type> nom pour le `component` type de paramètre. Par exemple, le nom de classe pour un bouton est « System.Windows.Forms.Button ». Si le `component` paramètre implémente <xref:System.ComponentModel.ICustomTypeDescriptor>, elle peut retourner un autre nom.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComponentName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le nom du composant spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetComponentName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> dont vous souhaitez obtenir le nom de la classe.</param>
        <summary>Retourne le nom du composant spécifié en utilisant le descripteur de type par défaut.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient le nom du composant spécifié, ou <see langword="null" /> s'il n'y a aucun nom de composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, cette méthode retourne le nom du site du composant, s’il en existe. Par exemple, le nom de classe pour un bouton est « System.Windows.Forms.Button ».  
  
 Cette méthode est équivalente à surchargées <xref:System.ComponentModel.TypeDescriptor.GetComponentName%28System.Object%2CSystem.Boolean%29> méthode avec un second paramètre de `false`.  
  
 Cette méthode est utilisée au moment du design pour récupérer le nom d’une instance d’un composant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetComponentName : obj * bool -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetComponentName (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> dont vous souhaitez obtenir le nom de la classe.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour prendre en compte les informations de description de type personnalisées ; sinon, <see langword="false" />.</param>
        <summary>Retourne le nom du composant spécifié en utilisant un descripteur de type personnalisé.</summary>
        <returns>Nom de la classe pour le composant spécifié, ou <see langword="null" /> s'il n'y a aucun nom composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée au moment du design pour récupérer le nom d’une instance d’un composant. En règle générale, cette méthode retourne le nom du site du composant, s’il en existe. Par exemple, le nom de classe pour un bouton est « System.Windows.Forms.Button ». Si le composant implémente le <xref:System.ComponentModel.ICustomTypeDescriptor> interface, elle peut retourner un autre nom.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConverter">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un convertisseur de type pour un composant ou un type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetConverter : obj -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir le convertisseur.</param>
        <summary>Retourne un convertisseur de type pour le type du composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeConverter" /> pour le composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode localise un convertisseur de type approprié en recherchant un <xref:System.ComponentModel.TypeConverterAttribute>. Si elle ne peut pas trouver un <xref:System.ComponentModel.TypeConverterAttribute>, elle parcourt la hiérarchie de classe de base de la classe jusqu'à ce qu’il trouve un type primitif.  
  
 Cette méthode est équivalente à surchargées <xref:System.ComponentModel.TypeDescriptor.GetConverter%2A> méthode avec un second paramètre de `false`.  
  
   
  
## Examples  
 Pour obtenir un exemple d’utilisation de cette méthode, consultez la <xref:System.ComponentModel.TypeConverter> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Retourne un convertisseur de type pour le type spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeConverter" /> pour le type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Cette méthode recherche le convertisseur de type approprié en recherchant un <xref:System.ComponentModel.TypeConverterAttribute>. Si elle ne peut pas trouver un <xref:System.ComponentModel.TypeConverterAttribute>, elle parcourt la hiérarchie de classe de base de la classe jusqu'à ce qu’il trouve un type primitif.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object, noCustomTypeDesc As Boolean) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetConverter : obj * bool -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir le convertisseur.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour prendre en compte les informations de description de type personnalisées ; sinon, <see langword="false" />.</param>
        <summary>Retourne un convertisseur de type pour le type du composant spécifié avec un descripteur de type personnalisé.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeConverter" /> pour le composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche le convertisseur de type approprié en essayant de trouver un <xref:System.ComponentModel.TypeConverterAttribute>. Si elle ne peut pas trouver un <xref:System.ComponentModel.TypeConverterAttribute>, elle parcourt la hiérarchie de classe de base de la classe jusqu'à ce qu’il trouve un type primitif.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne l’événement par défaut d’un composant ou type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : obj -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir l’événement.</param>
        <summary>Retourne l’événement par défaut du composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> avec l'événement par défaut, ou <see langword="null" /> s'il n'existe aucun événement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à surchargées <xref:System.ComponentModel.TypeDescriptor.GetDefaultEvent%28System.Object%2CSystem.Boolean%29> méthode avec un second paramètre de `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (componentType As Type) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : Type -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Retourne l’événement par défaut du type de composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> avec l'événement par défaut, ou <see langword="null" /> s'il n'existe aucun événement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object, noCustomTypeDesc As Boolean) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : obj * bool -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir l’événement.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour prendre en compte les informations de description de type personnalisées ; sinon, <see langword="false" />.</param>
        <summary>Retourne l’événement par défaut pour un composant avec un descripteur de type personnalisé.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> avec l'événement par défaut, ou <see langword="null" /> s'il n'existe aucun événement.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la propriété par défaut d’un composant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : obj -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir la propriété par défaut.</param>
        <summary>Retourne la propriété par défaut du composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> avec la propriété par défaut, ou <see langword="null" /> s'il n'existe aucune propriété.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `component` paramètre est `null`, cette méthode retourne `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (componentType As Type) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : Type -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> représentant la classe dont la propriété doit être obtenue.</param>
        <summary>Retourne la propriété par défaut du type de composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> avec la propriété par défaut, ou <see langword="null" /> s'il n'existe aucune propriété.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Si le `componentType` paramètre est `null`, cette méthode retourne `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : obj * bool -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir la propriété par défaut.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour prendre en compte les informations de description de type personnalisées ; sinon, <see langword="false" />.</param>
        <summary>Retourne la propriété par défaut du composant spécifié avec un descripteur de type personnalisé.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> avec la propriété par défaut, ou <see langword="null" /> s'il n'existe aucune propriété.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `component` paramètre est `null`, cette méthode retourne `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEditor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un éditeur avec le type de base spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="static member GetEditor : obj * Type -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (component, editorBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir l’éditeur.</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" /> représentant le type de base de l'éditeur à rechercher.</param>
        <summary>Obtient un éditeur avec le type de base spécifié pour le composant spécifié.</summary>
        <returns>Instance de l'éditeur qui peut faire l'objet d'un cast en un type d'éditeur spécifié ou <see langword="null" /> si aucun éditeur du type demandé n'est disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de `editorBaseType` est généralement <xref:System.Drawing.Design.UITypeEditor>, mais vous pouvez également utiliser d’autres types (par exemple, <xref:System.ComponentModel.ComponentEditor> et <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Vous pouvez définir plusieurs éditeurs pour une propriété. Cette méthode vous permet de sélectionner l’éditeur que vous souhaitez utiliser.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> ou <paramref name="editorBaseType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (Type type, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(class System.Type type, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Type,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(Type ^ type, Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="static member GetEditor : Type * Type -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (type, editorBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" /> représentant le type de base de l'éditeur que vous recherchez.</param>
        <summary>Retourne un éditeur avec le type de base spécifié pour le type spécifié.</summary>
        <returns>Instance de l'objet d'éditeur qui peut faire l'objet d'un cast en un type de base donné ou <see langword="null" /> si aucun éditeur du type demandé n'est disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de `editorBaseType` est généralement <xref:System.Drawing.Design.UITypeEditor>, mais vous pouvez également utiliser d’autres types (par exemple <xref:System.ComponentModel.ComponentEditor> et <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Vous pouvez définir plusieurs éditeurs pour un type. Cette méthode vous permet de sélectionner celui que vous souhaitez utiliser.  
  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="editorBaseType" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type, noCustomTypeDesc As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEditor : obj * Type * bool -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (component, editorBaseType, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir l’éditeur.</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" /> représentant le type de base de l'éditeur à rechercher.</param>
        <param name="noCustomTypeDesc">Indicateur qui détermine si les informations de description de type personnalisé doivent être considérées.</param>
        <summary>Retourne un éditeur avec le type de base spécifié et avec un descripteur de type personnalisé pour le composant spécifié.</summary>
        <returns>Instance de l'éditeur qui peut faire l'objet d'un cast en un type d'éditeur spécifié ou <see langword="null" /> si aucun éditeur du type demandé n'est disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de `editorBaseType` est généralement <xref:System.Drawing.Design.UITypeEditor>, mais vous pouvez également utiliser d’autres types (par exemple <xref:System.ComponentModel.ComponentEditor> et <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Vous pouvez définir plusieurs éditeurs pour une propriété. Cette méthode vous permet de sélectionner l’éditeur que vous souhaitez utiliser.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> ou <paramref name="editorBaseType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la collection d’événements d’un composant ou type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir les événements.</param>
        <summary>Retourne la collection d’événements pour le composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> avec les événements de ce composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupère une collection d’événements qui la donnée `component` fournit de l’instance de paramètre. Cette collection peut différer de l’ensemble d’événements que fournit la classe. Si le `component` paramètre dépend, le site peut ajouter ou supprimer des événements supplémentaires.  
  
 Si `component` est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
   
  
## Examples  
 Pour obtenir un exemple de cette méthode, consultez le <xref:System.ComponentModel.EventDescriptorCollection.Count%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetEvents : Type -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Retourne la collection d’événements pour un type de composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> avec les événements de ce composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Si le `componentType` paramètre est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * Attribute[] -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir les événements.</param>
        <param name="attributes">Tableau de type <see cref="T:System.Attribute" /> que vous pouvez utiliser comme filtre.</param>
        <summary>Retourne la collection d’événements d’un composant spécifié en utilisant comme filtre un tableau d’attributs spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> avec les événements qui correspondent aux attributs spécifiés pour ce composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les événements pour le `component` paramètre permettre différer des événements d’une classe, car le site peut ajouter ou supprimer des événements si le `component` paramètre dépend.  
  
 Le `attributes` tableau peut avoir un mélange de <xref:System.Type> et <xref:System.Attribute> objets. De filtrage est défini par les règles suivantes :  
  
-   Un <xref:System.Type> est traité comme un caractère générique ; il correspond à n’importe quel événement qui a le <xref:System.Type> dans son ensemble d’attributs.  
  
-   Si un événement n’a pas un <xref:System.Attribute> de la même classe, l’événement n’est pas inclus dans le tableau retourné.  
  
-   Si l’attribut est une instance de la <xref:System.Attribute> (classe), l’événement doit être une correspondance exacte ou il n’est pas inclus dans le tableau retourné.  
  
-   Si un <xref:System.Attribute> instance est spécifiée et il est l’événement par défaut, il est inclus dans le tableau retourné, même s’il n’existe aucune instance de la <xref:System.Attribute> dans l’événement.  
  
 Si `component` est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * bool -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir les événements.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour prendre en compte les informations de description de type personnalisées ; sinon, <see langword="false" />.</param>
        <summary>Retourne la collection d’événements pour un composant spécifié avec un descripteur de type personnalisé.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> avec les événements de ce composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode récupère une collection d’événements qui la donnée `component` fournit de l’instance de paramètre. Il peut être différent de l’ensemble de la classe fournit des événements. Si le `component` paramètre dépend, le site peut ajouter ou supprimer des événements supplémentaires.  
  
 Si `component` est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetEvents : Type * Attribute[] -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (componentType, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> du composant cible.</param>
        <param name="attributes">Tableau de type <see cref="T:System.Attribute" /> que vous pouvez utiliser comme filtre.</param>
        <summary>Retourne la collection d’événements d’un type spécifié de composant en utilisant comme filtre le tableau d’attributs spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> avec les événements qui correspondent aux attributs spécifiés pour ce composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Le `attributes` tableau de paramètres peut comporter un mélange de <xref:System.Type> et <xref:System.Attribute> objets. De filtrage est défini par les règles suivantes :  
  
-   Un <xref:System.Type> est traité comme un caractère générique ; il correspond à n’importe quel événement qui a le <xref:System.Type> dans son ensemble d’attributs.  
  
-   Si un événement n’a pas un <xref:System.Attribute> de la même classe, l’événement n’est pas inclus dans le tableau retourné.  
  
-   Si l’attribut est une instance de la <xref:System.Attribute> (classe), l’événement doit être une correspondance exacte ou il n’est pas inclus dans le tableau retourné.  
  
-   Si un <xref:System.Attribute> instance est spécifiée et il est l’événement par défaut, il est inclus dans le tableau retourné, même s’il n’existe aucune instance de la <xref:System.Attribute> dans l’événement.  
  
 Si le `componentType` paramètre est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * Attribute[] * bool -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, attributes, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel obtenir les événements.</param>
        <param name="attributes">Tableau de type <see cref="T:System.Attribute" /> à utiliser comme filtre.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour prendre en compte les informations de description de type personnalisées ; sinon, <see langword="false" />.</param>
        <summary>Retourne la collection d’événements d’un composant spécifié en utilisant comme filtre un tableau d’attributs spécifié, et en utilisant un descripteur de type personnalisé.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> avec les événements qui correspondent aux attributs spécifiés pour ce composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les événements pour le `component` paramètre permettre différer des événements d’une classe, car le site peut ajouter ou supprimer des événements si le `component` paramètre dépend.  
  
 Le `attributes` tableau de paramètres peut comporter un mélange de <xref:System.Type> et <xref:System.Attribute> objets. De filtrage est défini par les règles suivantes :  
  
-   Un <xref:System.Type> est traité comme un caractère générique ; il correspond à n’importe quel événement qui a le <xref:System.Type> dans son ensemble d’attributs.  
  
-   Si un événement n’a pas un <xref:System.Attribute> de la même classe, l’événement n’est pas inclus dans le tableau retourné.  
  
-   Si l’attribut est une instance de la <xref:System.Attribute> (classe), l’événement doit être une correspondance exacte ou il n’est pas inclus dans le tableau retourné.  
  
-   Si un <xref:System.Attribute> instance est spécifiée et il est l’événement par défaut, il est inclus dans le tableau retourné, même s’il n’existe aucune instance de la <xref:System.Attribute> dans l’événement.  
  
 Si `component` est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public static string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetFullComponentName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetFullComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.ComponentModel.Component" /> dont le nom est à rechercher.</param>
        <summary>Retourne le nom complet du composant.</summary>
        <returns>Nom qualifié complet du composant spécifié ou <see langword="null" /> si le composant ne possède pas de nom.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans de nombreux cas, le <xref:System.ComponentModel.TypeDescriptor.GetFullComponentName%2A> méthode retournera la même valeur que le <xref:System.ComponentModel.TypeDescriptor.GetComponentName%2A> (méthode). Toutefois, si le composant se trouve dans un conteneur imbriqué ou a d’autres sémantiques imbriquées, elle peut retourner un autre nom qualifié complet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetFullComponentName(System.Object)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la collection de propriétés pour un composant ou un type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Composant dont les propriétés doivent être obtenues.</param>
        <summary>Retourne la collection de propriétés pour un composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> avec les propriétés pour le composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les propriétés d’un composant peuvent différer des propriétés d’une classe, car le site peut ajouter ou supprimer des propriétés si le composant est installé.  
  
 Si le `component` paramètre est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> méthode pour accéder aux propriétés d’un contrôle. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.Design.ComponentDesigner> classe.  
  
 [!code-csharp[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/CS/Form1.cs#8)]
 [!code-vb[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetProperties : Type -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> représentant le composant pour lequel obtenir les propriétés.</param>
        <summary>Retourne la collection de propriétés pour un type de composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> avec les propriétés pour un type de composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Si le `componentType` paramètre est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Composant dont les propriétés doivent être obtenues.</param>
        <param name="attributes">Tableau de type <see cref="T:System.Attribute" /> à utiliser comme filtre.</param>
        <summary>Retourne la collection de propriétés d’un composant spécifié en utilisant comme filtre le tableau d’attributs spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> avec les propriétés qui correspondent aux attributs spécifiés pour le composant indiqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les propriétés de la `component` paramètre permettre différer des propriétés d’une classe, car le site peut ajouter ou supprimer des propriétés si le `component` paramètre dépend.  
  
 Le `attributes` tableau de paramètres est utilisé pour filtrer le tableau. De filtrage est défini par les règles suivantes :  
  
-   Si une propriété n’a pas un <xref:System.Attribute> de la même classe, la propriété n’est pas incluse dans le tableau retourné.  
  
-   Si l’attribut est une instance de la <xref:System.Attribute> (classe), la propriété doit être une correspondance exacte ou il n’est pas inclus dans le tableau retourné.  
  
-   Si un <xref:System.Attribute> instance est spécifiée et il est la propriété par défaut, il est inclus dans le tableau retourné, même s’il n’existe aucune instance de la <xref:System.Attribute> dans la propriété.  
  
-   Si `attributes` a un attribut par défaut, le <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> méthode respecte la casse lorsque la propriété n’a pas l’attribut appliqué.  
  
 Si `component` est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment implémenter la <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Windows.Forms.Design.PropertyTab> classe.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * bool -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant dont les propriétés doivent être obtenues.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour ne pas prendre en compte les informations de description de type personnalisé ; sinon, <see langword="false" />.</param>
        <summary>Retourne la collection de propriétés pour un composant spécifié en utilisant le descripteur de type par défaut.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> avec les propriétés pour un composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les propriétés de la `component` paramètre permettre différer des propriétés d’une classe, car le site peut ajouter ou supprimer des propriétés si le `component` paramètre dépend.  
  
 Si `component` est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetProperties : Type * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (componentType, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> du composant cible.</param>
        <param name="attributes">Tableau de type <see cref="T:System.Attribute" /> à utiliser comme filtre.</param>
        <summary>Retourne la collection de propriétés d’un type de composant spécifié en utilisant comme filtre le tableau d’attributs spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> avec les propriétés qui correspondent aux attributs spécifiés pour ce type de composant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Le `attributes` tableau de paramètres est utilisé pour filtrer le tableau. De filtrage est défini par les règles suivantes :  
  
-   Si une propriété n’a pas un <xref:System.Attribute> de la même classe, la propriété n’est pas incluse dans le tableau retourné.  
  
-   Si l’attribut est une instance de la <xref:System.Attribute> (classe), la propriété doit être une correspondance exacte ou il n’est pas inclus dans le tableau retourné.  
  
-   Si un <xref:System.Attribute> instance est spécifiée et il est la propriété par défaut, il est inclus dans le tableau retourné, même s’il n’existe aucune instance de la <xref:System.Attribute> dans la propriété.  
  
-   Si `attributes` a un attribut par défaut, le <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> méthode respecte la casse lorsque la propriété n’a pas l’attribut appliqué.  
  
 Si le `componentType` paramètre est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment implémenter la <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Windows.Forms.Design.PropertyTab> classe.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * Attribute[] * bool -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, attributes, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant dont les propriétés doivent être obtenues.</param>
        <param name="attributes">Tableau de type <see cref="T:System.Attribute" /> à utiliser comme filtre.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> pour prendre en compte les informations de description de type personnalisées ; sinon, <see langword="false" />.</param>
        <summary>Retourne la collection de propriétés d’un composant spécifié en utilisant comme filtre un tableau d’attributs spécifié, et en utilisant un descripteur de type personnalisé.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> avec les événements qui correspondent aux attributs spécifiés pour le composant déterminé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les propriétés d’un `component` peuvent différer des propriétés d’une classe, car le site peut ajouter ou supprimer des propriétés si le `component` est placé.  
  
 Le `attributes` tableau de paramètres est utilisé pour filtrer le tableau. De filtrage est défini par les règles suivantes :  
  
-   Si une propriété n’a pas un <xref:System.Attribute> de la même classe, la propriété n’est pas incluse dans le tableau retourné.  
  
-   Si l’attribut est une instance de la <xref:System.Attribute> (classe), la propriété doit être une correspondance exacte ou il n’est pas inclus dans le tableau retourné.  
  
-   Si un <xref:System.Attribute> instance est spécifiée et il est la propriété par défaut, il est inclus dans le tableau retourné, même s’il n’existe aucune instance de la <xref:System.Attribute> dans la propriété.  
  
-   Si `attributes` a un attribut par défaut, le <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> méthode respecte la casse lorsque la propriété n’a pas l’attribut appliqué.  
  
 Si le `component` paramètre est `null`, une collection vide est retournée.  
  
 L’ordre de la collection retournée n’est pas garanti pour être identique entre les appels, donc toujours l’ordre avant utilisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> est un objet distant interprocessus.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le fournisseur de description de type pour le composant ou type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProvider (instance As Object) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member GetProvider : obj -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.GetProvider instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instance du composant cible.</param>
        <summary>Retourne le fournisseur de description de type pour le composant spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associé au composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> méthode retourne toujours un fournisseur de description de type. Même la valeur par défaut <xref:System.ComponentModel.TypeDescriptor> implémentation repose sur un <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetProvider : Type -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.GetProvider type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Retourne le fournisseur de description de type pour le type spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associé au type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> méthode retourne toujours un fournisseur de description de type. Même la valeur par défaut <xref:System.ComponentModel.TypeDescriptor> implémentation repose sur un <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetReflectionType">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne <see cref="T:System.Type" /> qui peut être utilisé pour effectuer la réflexion.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReflectionType (instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member GetReflectionType : obj -&gt; Type" Usage="System.ComponentModel.TypeDescriptor.GetReflectionType instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instance du composant cible.</param>
        <summary>Retourne <see cref="T:System.Type" /> qui peut être utilisé pour effectuer la réflexion en fonction d'un objet.</summary>
        <returns>
          <see cref="T:System.Type" /> pour l'objet spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> méthode est une version de bas niveau de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> (méthode). <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> est généralement utilisé pour effectuer la réflexion standard par rapport à un objet lorsqu’aucun descripteur de type personnalisé ne peut être localisé pour celui-ci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> est <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetReflectionType : Type -&gt; Type" Usage="System.ComponentModel.TypeDescriptor.GetReflectionType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Retourne <see cref="T:System.Type" /> qui peut être utilisé pour effectuer la réflexion en fonction d'un type de classe.</summary>
        <returns>
          <see cref="T:System.Type" /> de la classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> méthode est une version de bas niveau de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> (méthode). <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> est généralement utilisé pour effectuer la réflexion standard par rapport à une classe si aucun descripteur de type personnalisé ne peut être localisé pour celui-ci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="InterfaceType">
      <MemberSignature Language="C#" Value="public static Type InterfaceType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type InterfaceType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InterfaceType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ InterfaceType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InterfaceType : Type" Usage="System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un type qui représente un fournisseur de description de type pour tous les types d’interface.</summary>
        <value>
          <see cref="T:System.Type" /> qui représente un fournisseur de description de type personnalisé pour tous les types d'interface.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.InterfaceType%2A> propriété obtient un <xref:System.Type> objet que vous pouvez passer à la <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> méthodes pour définir un fournisseur de description de type pour les types d’interface.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Efface du cache les propriétés et événements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Refresh (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member Refresh : obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Composant dont les propriétés ou les événements ont changé.</param>
        <summary>Efface du cache les propriétés et événements du composant spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés et événements sont mis en cache par <xref:System.ComponentModel.TypeDescriptor> pour aller plus vite. En règle générale, ils sont constants pendant la durée de vie d’un objet. Toutefois, les concepteurs et les fournisseurs d’extendeurs peuvent modifier le jeu de propriétés sur un objet. S’ils le font, ils doivent appeler cette méthode pour effacer les descripteurs de propriété et d’événement de l’objet. Cette méthode est utilisée uniquement au moment du design. Il n’est pas utilisé pendant l’exécution.  
  
 Cette méthode déclenche également un <xref:System.ComponentModel.TypeDescriptor.Refreshed> événement lorsque les propriétés ou les événements d’un composant changent. Cet événement est déclenché uniquement s’il y avait un appel antérieur à la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> ou <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> méthode que les informations mises en cache.  
  
   
  
## Examples  
 Pour obtenir un exemple d’utilisation de cette méthode, consultez la <xref:System.ComponentModel.RefreshEventHandler> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member Refresh : System.Reflection.Assembly -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">
          <see cref="T:System.Reflection.Assembly" /> représentant l'assembly à actualiser. Chaque <see cref="T:System.Type" /> de cet assembly est actualisé.</param>
        <summary>Efface du cache les propriétés et événements de l’assembly spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés et événements sont mis en cache par <xref:System.ComponentModel.TypeDescriptor> pour aller plus vite. En règle générale, ils sont constants pendant la durée de vie d’un objet. Toutefois, les concepteurs et les fournisseurs d’extendeurs peuvent modifier le jeu de propriétés sur un objet. S’ils le font, elles peuvent appeler cette méthode pour effacer les descripteurs de propriété et d’événement de l’objet. Cette méthode est utilisée uniquement au moment du design. Il n’est pas utilisé pendant l’exécution.  
  
 Avant d’effectuer un appel à la <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> méthode pour effacer le cache, vous devez appeler la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> méthode pour l’assembly spécifique à mettre en cache tout d’abord les informations.  
  
 Cette méthode déclenche également un <xref:System.ComponentModel.TypeDescriptor.Refreshed> événement pour avertir toutes les classes que vous souhaitez être averti lorsque la valeur de la propriété de composant change.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Assembly" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Module module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Module module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Module ^ module);" />
      <MemberSignature Language="F#" Value="static member Refresh : System.Reflection.Module -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh module" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="module">
          <see cref="T:System.Reflection.Module" /> représentant le module à actualiser. Chaque <see cref="T:System.Type" /> de ce module est actualisé.</param>
        <summary>Efface du cache les propriétés et événements du module spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés et événements sont mis en cache par <xref:System.ComponentModel.TypeDescriptor> pour aller plus vite. En règle générale, ils sont constants pendant la durée de vie d’un objet. Toutefois, les concepteurs et les fournisseurs d’extendeurs peuvent modifier le jeu de propriétés sur un objet. S’ils le font, elles peuvent appeler cette méthode pour effacer les descripteurs de propriété et d’événement de l’objet. Cette méthode est utilisée uniquement au moment du design. Il n’est pas utilisé pendant l’exécution.  
  
 Avant d’effectuer un appel à la <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> méthode pour effacer le cache, vous devez appeler la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> méthode pour le module spécifique à mettre en cache tout d’abord les informations.  
  
 Cette méthode déclenche également un <xref:System.ComponentModel.TypeDescriptor.Refreshed> événement pour avertir toutes les classes que vous souhaitez être averti lorsque la valeur de la propriété de composant change.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Refresh : Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Efface du cache les propriétés et les événements du type de composant spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette version de cette méthode uniquement lorsque vous n’avez pas une instance de l’objet.  
  
 Propriétés et événements sont mis en cache par <xref:System.ComponentModel.TypeDescriptor> pour aller plus vite. En règle générale, ils sont constants pendant la durée de vie d’un objet. Toutefois, les concepteurs et les fournisseurs d’extendeurs peuvent modifier le jeu de propriétés sur un objet. S’ils le font, elles peuvent appeler cette méthode pour effacer les descripteurs de propriété et d’événement de l’objet. Cette méthode est utilisée uniquement au moment du design. Il n’est pas utilisé pendant l’exécution.  
  
 Cette méthode déclenche également un <xref:System.ComponentModel.TypeDescriptor.Refreshed> événement lorsque les propriétés ou les événements d’un composant changent. Cet événement est déclenché uniquement s’il y avait un appel antérieur à la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> ou <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> méthode que les informations mises en cache.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refreshed">
      <MemberSignature Language="C#" Value="public static event System.ComponentModel.RefreshEventHandler Refreshed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RefreshEventHandler Refreshed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Refreshed As RefreshEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::ComponentModel::RefreshEventHandler ^ Refreshed;" />
      <MemberSignature Language="F#" Value="member this.Refreshed : System.ComponentModel.RefreshEventHandler " Usage="member this.Refreshed : System.ComponentModel.RefreshEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RefreshEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand le cache d’un composant est vidé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des événements, consultez [NIB : consommation d’événements](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 Pour obtenir un exemple d’utilisation de cet événement, consultez la <xref:System.ComponentModel.RefreshEventHandler> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociation">
      <MemberSignature Language="C#" Value="public static void RemoveAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberSignature Language="F#" Value="static member RemoveAssociation : obj * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveAssociation (primary, secondary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">
          <see cref="T:System.Object" /> principal.</param>
        <param name="secondary">
          <see cref="T:System.Object" /> secondaire.</param>
        <summary>Supprime une association entre deux objets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.RemoveAssociation%2A> méthode supprime une association entre deux objets formés par la <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> (méthode).  
  
 Un <xref:System.WeakReference> est utilisé pour maintenir l’association entre l’objet principal et secondaire ; par conséquent, cette méthode n’influence pas lorsque l’objet est finalisé ou récupéré par le garbage collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociations">
      <MemberSignature Language="C#" Value="public static void RemoveAssociations (object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociations(object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociations(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociations (primary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociations(System::Object ^ primary);" />
      <MemberSignature Language="F#" Value="static member RemoveAssociations : obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveAssociations primary" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">
          <see cref="T:System.Object" /> principal dans une association.</param>
        <summary>Supprime toutes les associations pour un objet principal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.TypeDescriptor.RemoveAssociations%2A> méthode supprime toutes les associations entre un objet principal et tous ses objets secondaires, créés par des appels à la <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> (méthode).  
  
 Un <xref:System.WeakReference> est utilisé pour maintenir l’association entre l’objet principal et secondaire ; par conséquent, cette méthode n’influence pas quand principal objets secondaires sont finalisées ou récupérée par le garbage collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="primary" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un fournisseur de description de type précédemment ajouté.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member RemoveProvider : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProvider (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à supprimer.</param>
        <param name="instance">Instance du composant cible.</param>
        <summary>Supprime un fournisseur de description de type précédemment ajouté qui est associé à l’objet spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime un fournisseur de description de type précédemment ajouté avec la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> (méthode). La suppression d’un fournisseur provoque un <xref:System.ComponentModel.TypeDescriptor.Refreshed> événement déclenché pour l’objet associé.  
  
 Utilisez le <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> méthode si vous avez besoin d’appeler à partir du code partiellement fiable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RemoveProvider : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProvider (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à supprimer.</param>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Supprime un fournisseur de description de type précédemment ajouté qui est associé au type spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime un fournisseur de description de type précédemment ajouté avec la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> (méthode). La suppression d’un fournisseur provoque un <xref:System.ComponentModel.TypeDescriptor.Refreshed> événement déclenché pour le type associé.  
  
 Utilisez le <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> méthode si vous avez besoin d’appeler à partir du code partiellement fiable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un fournisseur de description de type précédemment ajouté.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member RemoveProviderTransparent : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProviderTransparent (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à supprimer.</param>
        <param name="instance">Instance du composant cible.</param>
        <summary>Supprime un fournisseur de description de type précédemment ajouté qui est associé à l’objet spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime un fournisseur de description de type précédemment ajouté avec la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> (méthode). La suppression d’un fournisseur provoque un <xref:System.ComponentModel.TypeDescriptor.Refreshed> événement déclenché pour l’objet associé.  
  
 Cette méthode peut être appelée depuis du code d’un niveau de confiance partiel. Si <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> est défini, l’appelant peut enregistrer un fournisseur pour l’instance spécifiée si son type est également partiellement de confiance.  
  
 Utilisez le <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> méthode si vous n’avez pas besoin d’appeler à partir du code partiellement fiable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Pour accéder au Registre. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Type associé : le <see cref="T:System.Security.PermissionSet" /> qui est requis par l’assembly qui définit le <paramref name="instance" /> type du paramètre.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RemoveProviderTransparent : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProviderTransparent (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> à supprimer.</param>
        <param name="type">
          <see cref="T:System.Type" /> du composant cible.</param>
        <summary>Supprime un fournisseur de description de type précédemment ajouté qui est associé au type spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime un fournisseur de description de type précédemment ajouté avec la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> (méthode). La suppression d’un fournisseur provoque un <xref:System.ComponentModel.TypeDescriptor.Refreshed> événement déclenché pour le type associé.  
  
 Cette méthode peut être appelée depuis du code d’un niveau de confiance partiel. Si <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> est défini, l’appelant peut annuler l’inscription d’un fournisseur pour le type spécifié s’il est également partiellement approuvé.  
  
 Utilisez le <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> méthode si vous n’avez pas besoin d’appeler à partir du code partiellement fiable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins l’un des deux paramètres a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Pour accéder au Registre. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Type associé : le <see cref="T:System.Security.PermissionSet" /> qui est requis par l’assembly qui définit <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptorArray">
      <MemberSignature Language="C#" Value="public static void SortDescriptorArray (System.Collections.IList infos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SortDescriptorArray(class System.Collections.IList infos) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.SortDescriptorArray(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SortDescriptorArray (infos As IList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SortDescriptorArray(System::Collections::IList ^ infos);" />
      <MemberSignature Language="F#" Value="static member SortDescriptorArray : System.Collections.IList -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.SortDescriptorArray infos" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="infos" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="infos">
          <see cref="T:System.Collections.IList" /> qui contient les descripteurs à trier.</param>
        <summary>Trie les descripteurs à l’aide du nom du descripteur.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="infos" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
  </Members>
</Type>