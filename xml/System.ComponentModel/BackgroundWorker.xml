<Type Name="BackgroundWorker" FullName="System.ComponentModel.BackgroundWorker">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="053b0518e8cc183ffa09c4955d3ee95189700f76" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36705019" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BackgroundWorker : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BackgroundWorker extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.BackgroundWorker" />
  <TypeSignature Language="VB.NET" Value="Public Class BackgroundWorker&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class BackgroundWorker : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type BackgroundWorker = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("DoWork")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Exécute une opération sur un thread séparé.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.ComponentModel.BackgroundWorker> classe vous permet d’exécuter une opération sur un thread séparé et dédié. Les opérations longues comme les téléchargements et les transactions de base de données peuvent entraîner de votre interface utilisateur (IU) semblent comme s’il a cessé de répondre pendant leur exécution. Lorsque vous souhaitez une interface utilisateur réactive et êtes confronté à de longs délais associés à ces opérations, la <xref:System.ComponentModel.BackgroundWorker> classe fournit une solution pratique.  
  
 Pour exécuter une longue opération en arrière-plan, créez un <xref:System.ComponentModel.BackgroundWorker> et écouter les événements qui indiquent la progression de votre opération et lorsque celle-ci se termine. Vous pouvez créer le <xref:System.ComponentModel.BackgroundWorker> par programme ou vous pouvez faire glisser vers votre formulaire à partir de la **composants** onglet de la **boîte à outils**. Si vous créez le <xref:System.ComponentModel.BackgroundWorker> dans le Concepteur Windows Forms, il apparaît dans la barre d’état du composant et ses propriétés seront affichera dans la fenêtre Propriétés.  
  
 Pour définir une opération en arrière-plan, ajoutez un gestionnaire d’événements pour le <xref:System.ComponentModel.BackgroundWorker.DoWork> événement. Appelez votre opération de longue durée dans ce gestionnaire d’événements. Pour démarrer l’opération, appelez <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>. Pour recevoir des notifications des mises à jour de progression, gérez le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement. Pour recevoir une notification lorsque l’opération est terminée, gérez le <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> événement.  
  
> [!NOTE]
>  Vous devez être prudent ne pas manipuler les objets d’interface utilisateur dans votre <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements. À la place, communiquez à l’interface utilisateur via la <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> et <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> les événements.  
>   
>  <xref:System.ComponentModel.BackgroundWorker> les événements ne sont pas marshalés entre <xref:System.AppDomain> des limites. N’utilisez pas un <xref:System.ComponentModel.BackgroundWorker> composant d’effectuer les opérations multithread dans plusieurs <xref:System.AppDomain>.  
  
 Si votre opération en arrière-plan requiert un paramètre, appelez <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> avec votre paramètre. À l’intérieur de la <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements, vous pouvez extraire le paramètre de la <xref:System.ComponentModel.DoWorkEventArgs.Argument%2A?displayProperty=nameWithType> propriété.  
  
 Pour plus d’informations sur <xref:System.ComponentModel.BackgroundWorker>, consultez la page [Guide pratique pour exécuter une opération en arrière-plan](~/docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre les principes fondamentaux de la <xref:System.ComponentModel.BackgroundWorker> classe pour exécuter une opération longue de façon asynchrone. L’illustration suivante montre un exemple de sortie.  
  
 ![Exemple simple BackgroundWorker](~/add/media/backgroundworker-simple.png "exemple simple BackgroundWorker")  
  
 Pour tester ce code, créez une application Windows Forms. Ajouter un <xref:System.Windows.Forms.Label> contrôle nommé `resultLabel` et ajouter deux <xref:System.Windows.Forms.Button> contrôles nommés `startAsyncButton` et `cancelAsyncButton`. Créer <xref:System.Windows.Forms.Control.Click> gestionnaires d’événements pour les deux boutons. À partir de la **composants** onglet de la boîte à outils, ajoutez un <xref:System.ComponentModel.BackgroundWorker> composant nommé `backgroundWorker1`. Créer <xref:System.ComponentModel.BackgroundWorker.DoWork>, <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>, et <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> gestionnaires d’événements pour le <xref:System.ComponentModel.BackgroundWorker>. Dans le code du formulaire, remplacez le code existant par le code suivant.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/cs/form1.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/vb/form1.vb#1)]  
  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker> classe pour exécuter une opération longue de façon asynchrone. L’illustration suivante montre un exemple de sortie.  
  
 ![Exemple BackgroundWorker Fibonacci](~/add/media/backgroundworker-fibonacci.png "exemple BackgroundWorker Fibonacci")  
  
 L’opération calcule le nombre Fibonacci sélectionné, signale les mises à jour de progression comme les frais de calcul et permet un calcul en attente d’être annulée.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#1)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BackgroundWorker ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BackgroundWorker();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.BackgroundWorker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise un <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="backgroundWorker.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Demande l'annulation d'une opération d'arrière-plan en attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> envoie une demande pour terminer l’opération d’arrière-plan en attente et affecte le <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriété `true`.  
  
 Lorsque vous appelez <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>, votre méthode de travail a la possibilité d’arrêter son exécution et quitter. Le code de travail doit vérifier périodiquement la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriété pour voir si elle a été définie `true`.  
  
> [!CAUTION]
>  N’oubliez pas que votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements peut terminer son travail comme une demande d’annulation, et votre boucle d’interrogation peut manquer <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> définie sur `true`. Dans ce cas, le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> dans votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements ne sera pas défini `true`, même si une demande d’annulation a été effectuée. Cette situation est appelée un *condition de concurrence* , un problème courant dans la programmation multithread. Pour plus d’informations sur la conception multithread des problèmes, consultez [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> méthode pour annuler une opération asynchrone (« en arrière-plan »). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#4)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#4)]
 [!code-vb[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" /> est <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancellationPending">
      <MemberSignature Language="C#" Value="public bool CancellationPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CancellationPending" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationPending As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CancellationPending { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationPending : bool" Usage="System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'application a demandé l'annulation d'une opération d'arrière-plan.</summary>
        <value>
          <see langword="true" /> si l'application a demandé l'annulation d'une opération d'arrière-plan ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> est `true`, puis le <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> méthode a été appelée sur le <xref:System.ComponentModel.BackgroundWorker>.  
  
 Cette propriété est conçue pour une utilisation par le thread de travail qui doit vérifier périodiquement <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> et abandonner l’opération d’arrière-plan lorsqu’il est défini à `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriété pour interroger un <xref:System.ComponentModel.BackgroundWorker> sur son état d’annulation. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="backgroundWorker.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="backgroundWorker.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWork">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.DoWorkEventHandler DoWork;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.DoWorkEventHandler DoWork" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.DoWork" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoWork As DoWorkEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::DoWorkEventHandler ^ DoWork;" />
      <MemberSignature Language="F#" Value="member this.DoWork : System.ComponentModel.DoWorkEventHandler " Usage="member this.DoWork : System.ComponentModel.DoWorkEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DoWorkEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" /> est appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque vous appelez le <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> (méthode). Il s’agit où vous démarrez l’opération qui effectue la tâche potentiellement longue.  
  
 Votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements doit vérifier périodiquement la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> valeur de propriété et d’abandonner l’opération si elle est `true`. Lorsque cela se produit, vous pouvez définir le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> indicateur de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> à `true`et le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> dans votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements est défini sur `true`.  
  
> [!CAUTION]
>  N’oubliez pas que votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements peut terminer son travail comme une demande d’annulation, et votre boucle d’interrogation peut manquer <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> définie sur `true`. Dans ce cas, le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> dans votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements ne sera pas défini `true`, même si une demande d’annulation a été effectuée. Cette situation est appelée un *condition de concurrence* , un problème courant dans la programmation multithread. Pour plus d’informations sur la conception multithread des problèmes, consultez [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Si votre opération produit un résultat, vous pouvez affecter le résultat à la <xref:System.ComponentModel.DoWorkEventArgs.Result%2A?displayProperty=nameWithType> propriété. Il sera disponible pour le <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements dans le <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriété.  
  
 Si l’opération lève une exception que votre code ne gère pas, le <xref:System.ComponentModel.BackgroundWorker> intercepte l’exception et la passe le <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements, où elle est exposée en tant que le <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriété du <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType>. Si vous exécutez le débogueur Visual Studio, le débogueur s’arrête au point dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements où l’exception non gérée a été levée. Si vous avez plusieurs <xref:System.ComponentModel.BackgroundWorker>, vous ne devez pas faire référence un d'entre eux directement, car cette opération associerait votre <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements à une instance spécifique de <xref:System.ComponentModel.BackgroundWorker>. Au lieu de cela, vous devez accéder à votre <xref:System.ComponentModel.BackgroundWorker> en effectuant un cast du `sender` paramètre dans votre <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements.  
  
 Vous devez être prudent ne pas manipuler les objets d’interface utilisateur dans votre <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements. À la place, communiquez à l’interface utilisateur via la <xref:System.ComponentModel.BackgroundWorker> événements.  
  
 Pour plus d’informations sur la gestion des événements, consultez [NIB : consommation d’événements](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.DoWork> événement pour démarrer une opération asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#5)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#5)]
 [!code-vb[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBusy">
      <MemberSignature Language="C#" Value="public bool IsBusy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBusy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBusy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBusy { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBusy : bool" Usage="System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.ComponentModel.BackgroundWorker" /> exécute une opération asynchrone.</summary>
        <value>
          <see langword="true" />, si <see cref="T:System.ComponentModel.BackgroundWorker" /> exécute une opération asynchrone ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.BackgroundWorker> démarre une opération asynchrone lorsque vous appelez <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.ComponentModel.BackgroundWorker.IsBusy%2A> propriété à attendre la fin d’une <xref:System.ComponentModel.BackgroundWorker> opération. Cet exemple de code fait partie d’un exemple plus complet décrit dans [Comment : télécharger un fichier en arrière-plan](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <altmember cref="T:System.EventArgs" />
        <altmember cref="Overload:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      </Docs>
    </Member>
    <Member MemberName="OnDoWork">
      <MemberSignature Language="C#" Value="protected virtual void OnDoWork (System.ComponentModel.DoWorkEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoWork(class System.ComponentModel.DoWorkEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnDoWork(System.ComponentModel.DoWorkEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoWork (e As DoWorkEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoWork(System::ComponentModel::DoWorkEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit&#xA;override this.OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit" Usage="backgroundWorker.OnDoWork e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.DoWorkEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProgressChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnProgressChanged (System.ComponentModel.ProgressChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProgressChanged(class System.ComponentModel.ProgressChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProgressChanged (e As ProgressChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProgressChanged(System::ComponentModel::ProgressChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit&#xA;override this.OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit" Usage="backgroundWorker.OnProgressChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ProgressChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> méthode pour signaler la progression d’une opération asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.AsyncOperationManager> classe.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#24)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#24)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnRunWorkerCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRunWorkerCompleted (System.ComponentModel.RunWorkerCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRunWorkerCompleted(class System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRunWorkerCompleted (e As RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRunWorkerCompleted(System::ComponentModel::RunWorkerCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit&#xA;override this.OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit" Usage="backgroundWorker.OnRunWorkerCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.RunWorkerCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      </Docs>
    </Member>
    <Member MemberName="ProgressChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ProgressChangedEventHandler ProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ProgressChangedEventHandler ProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProgressChanged As ProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ProgressChangedEventHandler ^ ProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " Usage="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" /> est appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque vous appelez le <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> (méthode).  
  
 Pour plus d’informations sur la gestion des événements, consultez [NIB : consommation d’événements](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement pour signaler la progression d’une opération asynchrone à l’utilisateur. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#7)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#7)]
 [!code-vb[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReportProgress">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int -&gt; unit" Usage="backgroundWorker.ReportProgress percentProgress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Pourcentage, de 0 à 100, de l'opération d'arrière-plan qui est terminé.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin de l’opération d’arrière-plan pour signaler la progression, vous pouvez appeler la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour déclencher le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement. Le <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> la valeur de propriété doit être `true`, ou <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> lèvera une <xref:System.InvalidOperationException>.  
  
 C’est à vous permet d’implémenter une façon explicite de mesurer la progression de votre opération d’arrière-plan en pourcentage du total de la tâche s’est terminé.  
  
 L’appel à la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode est asynchrone et retourne immédiatement. Le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Gestionnaire d’événements s’exécute sur le thread qui a créé le <xref:System.ComponentModel.BackgroundWorker>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour signaler la progression d’une opération asynchrone à l’utilisateur. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int * obj -&gt; unit" Usage="backgroundWorker.ReportProgress (percentProgress, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Pourcentage, de 0 à 100, de l'opération d'arrière-plan qui est terminé.</param>
        <param name="userState">L'objet d'état est passé à <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin de l’opération d’arrière-plan pour signaler la progression, vous pouvez appeler la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour déclencher le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement. Le <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> la valeur de propriété doit `true`, ou <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> lèvera une <xref:System.InvalidOperationException>.  
  
 C’est à vous permet d’implémenter une façon explicite de mesurer la progression de votre opération d’arrière-plan en pourcentage du total de la tâche s’est terminé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour signaler la progression d’une opération asynchrone à l’utilisateur. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Windows.Forms.ToolStripProgressBar> classe.  
  
 [!code-csharp[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunWorkerAsync">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre l'exécution d'une opération d'arrière-plan.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync();" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : unit -&gt; unit" Usage="backgroundWorker.RunWorkerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Démarre l'exécution d'une opération d'arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> méthode soumet une demande de démarrage de l’opération en cours d’exécution en mode asynchrone. Lorsque la demande est traitée, le <xref:System.ComponentModel.BackgroundWorker.DoWork> événement est déclenché, ce qui lance ensuite votre opération d’arrière-plan.  
  
 Si l’opération d’arrière-plan est déjà en cours d’exécution, l’appel <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> lève une <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> méthode pour démarrer une opération asynchrone. Il fait partie d’un exemple plus complet décrit dans [Comment : télécharger un fichier en arrière-plan](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> est <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync (object argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync(object argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync (argument As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync(System::Object ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : obj -&gt; unit" Usage="backgroundWorker.RunWorkerAsync argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="argument">Paramètre disponible pour une exécution par l'opération d'arrière-plan dans le gestionnaire d'événements <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</param>
        <summary>Démarre l'exécution d'une opération d'arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> méthode soumet une demande de démarrage de l’opération en cours d’exécution en mode asynchrone. Lorsque la demande est traitée, le <xref:System.ComponentModel.BackgroundWorker.DoWork> événement est déclenché, ce qui lance ensuite votre opération d’arrière-plan.  
  
 Si votre opération requiert un paramètre, vous pouvez fournir en tant que le `argument` paramètre <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
 Si l’opération d’arrière-plan est déjà en cours d’exécution, l’appel <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> lève une <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> méthode pour démarrer une opération asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#3)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#3)]
 [!code-vb[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> est <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
      </Docs>
    </Member>
    <Member MemberName="RunWorkerCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RunWorkerCompleted As RunWorkerCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::RunWorkerCompletedEventHandler ^ RunWorkerCompleted;" />
      <MemberSignature Language="F#" Value="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " Usage="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RunWorkerCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'opération d'arrière-plan est terminée, a été annulée ou a levé une exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque la <xref:System.ComponentModel.BackgroundWorker.DoWork> retourne de gestionnaire d’événements.  
  
 Si l’opération est terminée avec succès et que son résultat est assigné dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements, vous pouvez accéder au résultat via la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriété.  
  
 Le <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriété du <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indique qu’une exception a été levée par l’opération.  
  
 Le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> propriété <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indique si une demande d’annulation a été traitée par l’opération d’arrière-plan. Si votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements détecte une demande d’annulation en vérifiant la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> indicateur et en définissant le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> indicateur de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> à `true`, le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> également sera défini sur `true`.  
  
> [!CAUTION]
>  N’oubliez pas que votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements peut terminer son travail comme une demande d’annulation, et votre boucle d’interrogation peut manquer <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> définie sur `true`. Dans ce cas, le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> dans votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements ne sera pas défini `true`, même si une demande d’annulation a été effectuée. Cette situation est appelée un *condition de concurrence* , un problème courant dans la programmation multithread. Pour plus d’informations sur la conception multithread des problèmes, consultez [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements doit toujours vérifier les <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> et <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A?displayProperty=nameWithType> propriétés avant d’accéder à la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriété. Si une exception a été levée ou si l’opération a été annulée, l’accès à la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriété lève une exception.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> événements pour gérer le résultat d’une opération asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#6)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#6)]
 [!code-vb[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkerReportsProgress">
      <MemberSignature Language="C#" Value="public bool WorkerReportsProgress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerReportsProgress" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerReportsProgress As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerReportsProgress { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerReportsProgress : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si <see cref="T:System.ComponentModel.BackgroundWorker" /> peut signaler des mises à jour de progression.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.ComponentModel.BackgroundWorker" /> prend en charge les mises à jour de progression ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> propriété `true` si vous souhaitez que le <xref:System.ComponentModel.BackgroundWorker> pour prendre en charge les mises à jour de progression. Lorsque cette propriété est `true`, le code utilisateur peut appeler le <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour déclencher le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WorkerSupportsCancellation">
      <MemberSignature Language="C#" Value="public bool WorkerSupportsCancellation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerSupportsCancellation" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerSupportsCancellation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerSupportsCancellation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerSupportsCancellation : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si <see cref="T:System.ComponentModel.BackgroundWorker" /> prend en charge l'annulation asynchrone.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.ComponentModel.BackgroundWorker" /> prend en charge l'annulation ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation%2A> propriété `true` si vous souhaitez que le <xref:System.ComponentModel.BackgroundWorker> pour prendre en charge l’annulation. Lorsque cette propriété est `true`, vous pouvez appeler la <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> méthode pour interrompre une opération d’arrière-plan.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      </Docs>
    </Member>
  </Members>
</Type>