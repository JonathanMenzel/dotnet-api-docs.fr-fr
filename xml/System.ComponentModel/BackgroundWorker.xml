<Type Name="BackgroundWorker" FullName="System.ComponentModel.BackgroundWorker">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c37b5bf96d8aef89f18a2b1937d75a7bef0e121b" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56371808" /></Metadata><TypeSignature Language="C#" Value="public class BackgroundWorker : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BackgroundWorker extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.BackgroundWorker" />
  <TypeSignature Language="VB.NET" Value="Public Class BackgroundWorker&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class BackgroundWorker : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type BackgroundWorker = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("DoWork")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Exécute une opération sur un thread séparé.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.BackgroundWorker> classe vous permet d’exécuter une opération sur un thread séparé et dédié. Les opérations longues telles que des téléchargements et les transactions de base de données peuvent entraîner de votre interface utilisateur (IU) à croire qu’a cessé de répondre pendant leur exécution. Lorsque vous souhaitez une interface utilisateur réactive et êtes confronté à de longs délais associés à ces opérations, la <xref:System.ComponentModel.BackgroundWorker> classe fournit une solution pratique.  
  
 Pour exécuter une longue opération en arrière-plan, créez un <xref:System.ComponentModel.BackgroundWorker> et écouter les événements qui signalent la progression de votre opération et lorsque votre opération est terminée. Vous pouvez créer le <xref:System.ComponentModel.BackgroundWorker> par programme ou vous pouvez faire glisser vers votre formulaire à partir de la **composants** onglet de la **boîte à outils**. Si vous créez le <xref:System.ComponentModel.BackgroundWorker> dans le Concepteur de formulaires Windows, il apparaît dans la barre d’état du composant et ses propriétés seront affichera dans la fenêtre Propriétés.  
  
 Pour définir une opération en arrière-plan, ajoutez un gestionnaire d’événements pour le <xref:System.ComponentModel.BackgroundWorker.DoWork> événement. Appelez votre longue opération dans ce gestionnaire d’événements. Pour démarrer l’opération, appelez <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>. Pour recevoir des notifications des mises à jour de progression, gérez le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement. Pour recevoir une notification lorsque l’opération est terminée, gérez le <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> événement.  
  
> [!NOTE]
>  Vous devez être veiller à ne pas manipuler d’objets interface utilisateur dans votre <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements. Au lieu de cela, communiquer avec l’interface utilisateur via la <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> et <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> événements.  
>   
>  <xref:System.ComponentModel.BackgroundWorker> les événements ne sont pas marshalés entre <xref:System.AppDomain> des limites. N’utilisez pas un <xref:System.ComponentModel.BackgroundWorker> composant pour effectuer des opérations multithreads dans plusieurs <xref:System.AppDomain>.  
  
 Si votre opération en arrière-plan requiert un paramètre, appelez <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> avec votre paramètre. À l’intérieur de la <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements, vous pouvez extraire la valeur du paramètre le <xref:System.ComponentModel.DoWorkEventArgs.Argument%2A?displayProperty=nameWithType> propriété.  
  
 Pour plus d’informations sur <xref:System.ComponentModel.BackgroundWorker>, consultez la page [Guide pratique pour exécuter une opération en arrière-plan](~/docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre les principes fondamentaux de la <xref:System.ComponentModel.BackgroundWorker> classe pour exécuter une opération longue de façon asynchrone. L’illustration suivante montre un exemple de sortie.  
  
 ![Exemple simple BackgroundWorker](~/add/media/backgroundworker-simple.png "exemple simple BackgroundWorker")  
  
 Pour tester ce code, créez une application Windows Forms. Ajouter un <xref:System.Windows.Forms.Label> contrôle nommé `resultLabel` et ajouter deux <xref:System.Windows.Forms.Button> contrôles nommés `startAsyncButton` et `cancelAsyncButton`. Créer <xref:System.Windows.Forms.Control.Click> gestionnaires d’événements pour les deux boutons. À partir de la **composants** onglet de la boîte à outils, ajoutez un <xref:System.ComponentModel.BackgroundWorker> composant nommé `backgroundWorker1`. Créer <xref:System.ComponentModel.BackgroundWorker.DoWork>, <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>, et <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> gestionnaires d’événements pour le <xref:System.ComponentModel.BackgroundWorker>. Dans le code du formulaire, remplacez le code existant par le code suivant.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/cs/form1.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/vb/form1.vb#1)]  
  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker> classe pour exécuter une opération longue de façon asynchrone. L’illustration suivante montre un exemple de sortie.  
  
 ![Exemple BackgroundWorker Fibonacci](~/add/media/backgroundworker-fibonacci.png "exemple BackgroundWorker Fibonacci")  
  
 L’opération calcule le nombre de Fibonacci sélectionné, signale les mises à jour de progression comme le résultat de calcul et permet un calcul en attente doit être annulée.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#1)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
    <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Meilleures pratiques pour le threading managé</related>
    <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BackgroundWorker ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BackgroundWorker();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.BackgroundWorker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise un <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="backgroundWorker.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Demande l'annulation d'une opération d'arrière-plan en attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> envoie une demande pour terminer l’opération d’arrière-plan en attente et affecte le <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriété `true`.  
  
 Lorsque vous appelez <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>, votre méthode de travail a la possibilité d’arrêter son exécution et quitter. Le code de travail doit vérifier périodiquement la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriété pour voir si elle a été définie `true`.  
  
> [!CAUTION]
>  N’oubliez pas que votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements peut terminer son travail comme une demande d’annulation, et votre boucle d’interrogation peut manquer <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> définie sur `true`. Dans ce cas, le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> dans votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements n’est pas défini sur `true`, même si une demande d’annulation a été effectuée. Cette situation est appelée un *condition de concurrence critique* et est un problème courant en programmation multithread. Pour plus d’informations sur la conception multithread problèmes, consultez [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> méthode pour annuler une opération asynchrone (« en arrière-plan »). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#4)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#4)]
 [!code-vb[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" /> est <see langword="false" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationPending">
      <MemberSignature Language="C#" Value="public bool CancellationPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CancellationPending" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationPending As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CancellationPending { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationPending : bool" Usage="System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'application a demandé l'annulation d'une opération d'arrière-plan.</summary>
        <value><see langword="true" /> si l'application a demandé l'annulation d'une opération d'arrière-plan ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> est `true`, puis le <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> méthode a été appelée sur le <xref:System.ComponentModel.BackgroundWorker>.  
  
 Cette propriété est destinée à utiliser par le thread de travail qui doit vérifier périodiquement <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> et abandonner l’opération d’arrière-plan lorsqu’elle est définie sur `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriété à interroger un <xref:System.ComponentModel.BackgroundWorker> sur son état d’annulation. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="backgroundWorker.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="backgroundWorker.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWork">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.DoWorkEventHandler DoWork;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.DoWorkEventHandler DoWork" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.DoWork" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoWork As DoWorkEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::DoWorkEventHandler ^ DoWork;" />
      <MemberSignature Language="F#" Value="member this.DoWork : System.ComponentModel.DoWorkEventHandler " Usage="member this.DoWork : System.ComponentModel.DoWorkEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DoWorkEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" /> est appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque vous appelez le <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> (méthode). Voici où vous démarrez l’opération qui effectue la tâche potentiellement longue.  
  
 Votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements doit vérifier périodiquement la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> valeur de propriété et abandonner l’opération si elle est `true`. Lorsque cela se produit, vous pouvez définir le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> indicateur de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> à `true`et le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> dans votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements est défini sur `true`.  
  
> [!CAUTION]
>  N’oubliez pas que votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements peut terminer son travail comme une demande d’annulation, et votre boucle d’interrogation peut manquer <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> définie sur `true`. Dans ce cas, le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> dans votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements n’est pas défini sur `true`, même si une demande d’annulation a été effectuée. Cette situation est appelée un *condition de concurrence critique* et est un problème courant en programmation multithread. Pour plus d’informations sur la conception multithread problèmes, consultez [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Si votre opération produit un résultat, vous pouvez affecter le résultat à la <xref:System.ComponentModel.DoWorkEventArgs.Result%2A?displayProperty=nameWithType> propriété. Elle sera disponible pour le <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements dans le <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriété.  
  
 Si l’opération lève une exception que votre code ne gère pas, le <xref:System.ComponentModel.BackgroundWorker> intercepte l’exception et la passe le <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements, où elle est exposée en tant que le <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriété du <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType>. Si vous exécutez sous le débogueur Visual Studio, le débogueur s’arrête au point dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements où l’exception non gérée a été levée. Si vous avez plusieurs <xref:System.ComponentModel.BackgroundWorker>, vous ne devez pas référencer une d'entre elles directement, car cela associerait votre <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements à une instance spécifique de <xref:System.ComponentModel.BackgroundWorker>. Au lieu de cela, vous devez accéder à votre <xref:System.ComponentModel.BackgroundWorker> en castant le `sender` paramètre dans votre <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements.  
  
 Vous devez être veiller à ne pas manipuler d’objets interface utilisateur dans votre <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements. Au lieu de cela, communiquer avec l’interface utilisateur via la <xref:System.ComponentModel.BackgroundWorker> événements.  
  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.DoWork> événement pour démarrer une opération asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#5)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#5)]
 [!code-vb[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Meilleures pratiques pour le threading managé</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="IsBusy">
      <MemberSignature Language="C#" Value="public bool IsBusy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBusy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBusy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBusy { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBusy : bool" Usage="System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.ComponentModel.BackgroundWorker" /> exécute une opération asynchrone.</summary>
        <value><see langword="true" />, si <see cref="T:System.ComponentModel.BackgroundWorker" /> exécute une opération asynchrone ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.BackgroundWorker> démarre une opération asynchrone lorsque vous appelez <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.ComponentModel.BackgroundWorker.IsBusy%2A> propriété à attendre la fin d’une <xref:System.ComponentModel.BackgroundWorker> opération. Cet exemple de code fait partie d’un exemple plus complet décrit dans [Comment : Télécharger un fichier en arrière-plan](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <altmember cref="T:System.EventArgs" />
        <altmember cref="Overload:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="OnDoWork">
      <MemberSignature Language="C#" Value="protected virtual void OnDoWork (System.ComponentModel.DoWorkEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoWork(class System.ComponentModel.DoWorkEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnDoWork(System.ComponentModel.DoWorkEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoWork (e As DoWorkEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoWork(System::ComponentModel::DoWorkEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit&#xA;override this.OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit" Usage="backgroundWorker.OnDoWork e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.DoWorkEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProgressChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnProgressChanged (System.ComponentModel.ProgressChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProgressChanged(class System.ComponentModel.ProgressChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProgressChanged (e As ProgressChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProgressChanged(System::ComponentModel::ProgressChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit&#xA;override this.OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit" Usage="backgroundWorker.OnProgressChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ProgressChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> méthode pour signaler la progression d’une opération asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.AsyncOperationManager> classe.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#24)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#24)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="OnRunWorkerCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRunWorkerCompleted (System.ComponentModel.RunWorkerCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRunWorkerCompleted(class System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRunWorkerCompleted (e As RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRunWorkerCompleted(System::ComponentModel::RunWorkerCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit&#xA;override this.OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit" Usage="backgroundWorker.OnRunWorkerCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.RunWorkerCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="ProgressChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ProgressChangedEventHandler ProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ProgressChangedEventHandler ProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProgressChanged As ProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ProgressChangedEventHandler ^ ProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " Usage="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" /> est appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque vous appelez le <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> (méthode).  
  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement pour signaler la progression d’une opération asynchrone à l’utilisateur. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#7)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#7)]
 [!code-vb[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReportProgress">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int -&gt; unit" Usage="backgroundWorker.ReportProgress percentProgress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Pourcentage, de 0 à 100, de l'opération d'arrière-plan qui est terminé.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin de l’opération d’arrière-plan pour signaler la progression, vous pouvez appeler la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour déclencher le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement. Le <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> valeur de propriété doit être `true`, ou <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> lèvera une <xref:System.InvalidOperationException>.  
  
 Il vous incombe d’implémenter une façon explicite de mesurer la progression de votre opération d’arrière-plan sous forme de pourcentage du total de la tâche terminé.  
  
 L’appel à la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode est asynchrone et retourne immédiatement. Le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Gestionnaire d’événements s’exécute sur le thread qui a créé le <xref:System.ComponentModel.BackgroundWorker>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour signaler la progression d’une opération asynchrone à l’utilisateur. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> a la valeur <see langword="false" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int * obj -&gt; unit" Usage="backgroundWorker.ReportProgress (percentProgress, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Pourcentage, de 0 à 100, de l'opération d'arrière-plan qui est terminé.</param>
        <param name="userState">L'objet d'état est passé à <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin de l’opération d’arrière-plan pour signaler la progression, vous pouvez appeler la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour déclencher le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement. Le <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> valeur de propriété doit `true`, ou <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> lèvera une <xref:System.InvalidOperationException>.  
  
 Il vous incombe d’implémenter une façon explicite de mesurer la progression de votre opération d’arrière-plan sous forme de pourcentage du total de la tâche terminé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour signaler la progression d’une opération asynchrone à l’utilisateur. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Windows.Forms.ToolStripProgressBar> classe.  
  
 [!code-csharp[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> a la valeur <see langword="false" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunWorkerAsync">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre l'exécution d'une opération d'arrière-plan.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync();" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : unit -&gt; unit" Usage="backgroundWorker.RunWorkerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Démarre l'exécution d'une opération d'arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> méthode soumet une demande de démarrage de l’opération en cours d’exécution en mode asynchrone. Lorsque la demande est traitée, le <xref:System.ComponentModel.BackgroundWorker.DoWork> événement est déclenché, ce qui lance ensuite votre opération d’arrière-plan.  
  
 Si l’opération d’arrière-plan est déjà en cours d’exécution, l’appel <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> déclenche à nouveau un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> méthode pour démarrer une opération asynchrone. Il fait partie d’un exemple plus complet décrit dans [Comment : Télécharger un fichier en arrière-plan](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> est <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Meilleures pratiques pour le threading managé</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync (object argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync(object argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync (argument As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync(System::Object ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : obj -&gt; unit" Usage="backgroundWorker.RunWorkerAsync argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="argument">Paramètre disponible pour une exécution par l'opération d'arrière-plan dans le gestionnaire d'événements <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</param>
        <summary>Démarre l'exécution d'une opération d'arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> méthode soumet une demande de démarrage de l’opération en cours d’exécution en mode asynchrone. Lorsque la demande est traitée, le <xref:System.ComponentModel.BackgroundWorker.DoWork> événement est déclenché, ce qui lance ensuite votre opération d’arrière-plan.  
  
 Si votre opération requiert un paramètre, vous pouvez fournir en tant que le `argument` paramètre <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
 Si l’opération d’arrière-plan est déjà en cours d’exécution, l’appel <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> déclenche à nouveau un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> méthode pour démarrer une opération asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#3)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#3)]
 [!code-vb[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> est <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Meilleures pratiques pour le threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RunWorkerCompleted As RunWorkerCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::RunWorkerCompletedEventHandler ^ RunWorkerCompleted;" />
      <MemberSignature Language="F#" Value="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " Usage="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RunWorkerCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'opération d'arrière-plan est terminée, a été annulée ou a levé une exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque le <xref:System.ComponentModel.BackgroundWorker.DoWork> retourne de gestionnaire d’événements.  
  
 Si l’opération se termine avec succès et son résultat est assigné dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements, vous pouvez accéder au résultat via la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriété.  
  
 Le <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriété du <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indique qu’une exception a été levée par l’opération.  
  
 Le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> propriété du <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indique si une demande d’annulation a été traitée par l’opération d’arrière-plan. Si votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements détecte une demande d’annulation en vérifiant la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> indicateur et en définissant le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> indicateur de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> à `true`, le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> est également défini sur `true`.  
  
> [!CAUTION]
>  N’oubliez pas que votre code dans le <xref:System.ComponentModel.BackgroundWorker.DoWork> Gestionnaire d’événements peut terminer son travail comme une demande d’annulation, et votre boucle d’interrogation peut manquer <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> définie sur `true`. Dans ce cas, le <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> indicateur de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> dans votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements n’est pas défini sur `true`, même si une demande d’annulation a été effectuée. Cette situation est appelée un *condition de concurrence critique* et est un problème courant en programmation multithread. Pour plus d’informations sur la conception multithread problèmes, consultez [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Votre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Gestionnaire d’événements doit toujours vérifier le <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> et <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A?displayProperty=nameWithType> propriétés avant d’accéder à la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriété. Si une exception a été levée ou si l’opération a été annulée, l’accès à la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriété lève une exception.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> événement à gérer le résultat d’une opération asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#6)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#6)]
 [!code-vb[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerReportsProgress">
      <MemberSignature Language="C#" Value="public bool WorkerReportsProgress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerReportsProgress" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerReportsProgress As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerReportsProgress { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerReportsProgress : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si <see cref="T:System.ComponentModel.BackgroundWorker" /> peut signaler des mises à jour de progression.</summary>
        <value><see langword="true" /> si <see cref="T:System.ComponentModel.BackgroundWorker" /> prend en charge les mises à jour de progression ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> propriété `true` si vous souhaitez que le <xref:System.ComponentModel.BackgroundWorker> pour prendre en charge les mises à jour de progression. Lorsque cette propriété a `true`, le code utilisateur peut appeler le <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> méthode pour déclencher le <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerSupportsCancellation">
      <MemberSignature Language="C#" Value="public bool WorkerSupportsCancellation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerSupportsCancellation" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerSupportsCancellation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerSupportsCancellation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerSupportsCancellation : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si <see cref="T:System.ComponentModel.BackgroundWorker" /> prend en charge l'annulation asynchrone.</summary>
        <value><see langword="true" /> si <see cref="T:System.ComponentModel.BackgroundWorker" /> prend en charge l'annulation ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation%2A> propriété `true` si vous souhaitez que le <xref:System.ComponentModel.BackgroundWorker> pour prendre en charge l’annulation. Lorsque cette propriété a `true`, vous pouvez appeler la <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> méthode interrompre une opération d’arrière-plan.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Comment : exécuter une opération en arrière-plan</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Comment : télécharger un fichier en arrière-plan</related>
      </Docs>
    </Member>
  </Members>
</Type>