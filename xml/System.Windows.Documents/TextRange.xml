<Type Name="TextRange" FullName="System.Windows.Documents.TextRange">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0d0eea67c4771f8c670a456f6f11f4afbee0483b" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39857468" /></Metadata><TypeSignature Language="C#" Value="public class TextRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextRange" />
  <TypeSignature Language="F#" Value="type TextRange = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente une sélection de contenu entre deux positions de <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Documents.TextRange> classe introduit la terminologie suivante.  
  
-   **Sélection** : un <xref:System.Windows.Documents.TextRange> est une sélection de contenu entre deux positions indiquées par **TextPointers**.  Une de ces positions d’un point d’ancrage fixe par rapport à la sélection, tandis que l’autre position est mobile.  Cela est similaire à la manière dont se comporte une sélection effectuée par un utilisateur à l’aide de la souris ou le clavier.  
  
-   **Sélection actuelle** - parce qu’une <xref:System.Windows.Documents.TextRange> indique toujours une sélection dans le contenu, il est judicieux d’appeler la sélection indiquée par un <xref:System.Windows.Documents.TextRange> en tant que le *sélection actuelle*.  
  
-   **Conteneur de texte** : un *conteneur de texte* est l’élément qui constitue l’ultime limite du contenu de flux à portée de main ; la sélection indiquée par un <xref:System.Windows.Documents.TextRange> tombe toujours dans un conteneur de texte.  Actuellement, un conteneur de texte doit être un <xref:System.Windows.Documents.FlowDocument> ou un <xref:System.Windows.Controls.TextBlock>.  
  
-   **Document** -le contenu compris dans un conteneur de texte est appelé un *document*.  
  
 Pour plus d’informations sur les autres liés à des termes tels que *position*, consultez <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Documents.TextRange.Text%2A> propriété d’un <xref:System.Windows.Documents.TextRange> pour retourner la représentation sous forme de texte brut d’un <xref:System.Windows.Documents.FlowDocument>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextRange (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.#ctor(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextRange(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberSignature Language="F#" Value="new System.Windows.Documents.TextRange : System.Windows.Documents.TextPointer * System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="new System.Windows.Documents.TextRange (position1, position2)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Position d'ancrage fixe qui marque une extrémité de la sélection utilisée pour former la nouvelle plage <see cref="T:System.Windows.Documents.TextRange" />.</param>
        <param name="position2">Position mobile qui marque l'autre extrémité de la sélection utilisée pour former la nouvelle plage <see cref="T:System.Windows.Documents.TextRange" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Documents.TextRange" />, en prenant deux positions de <see cref="T:System.Windows.Documents.TextPointer" /> spécifiées en tant que positions de départ et de fin de la nouvelle plage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Documents.TextRange> est formée à partir d’une sélection entre deux positions indiquées par **TextPointers**.  Une de ces positions (indiqué par `position1`) est fixe par rapport à la sélection, lors de l’autre position (indiqué par `position2`) peut être déplacé.  Cela est similaire à la manière dont se comporte une sélection effectuée par un utilisateur à l’aide de la souris ou le clavier.  
  
 Les terminaisons réelles de la nouvelle <xref:System.Windows.Documents.TextRange> peut être ajusté en fonction des paramètres heuristiques de sélection applicables au document qui contient la nouvelle <xref:System.Windows.Documents.TextRange>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Windows.Documents.TextRange> constructeur.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Levée lorsque <paramref name="position1" /> et <paramref name="position2" /> ne se trouvent pas dans le même document.</exception>
        <exception cref="T:System.ArgumentNullException">Levée lorsque <paramref name="position1" /> ou <paramref name="position2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyValue">
      <MemberSignature Language="C#" Value="public void ApplyPropertyValue (System.Windows.DependencyProperty formattingProperty, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyValue(class System.Windows.DependencyProperty formattingProperty, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyValue (formattingProperty As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyValue(System::Windows::DependencyProperty ^ formattingProperty, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="textRange.ApplyPropertyValue (formattingProperty, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Propriété de mise en forme à appliquer.</param>
        <param name="value">Valeur de la propriété de mise en forme.</param>
        <summary>Applique une propriété et une valeur de mise en forme spécifiées à la sélection actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode s’applique la mise en forme en insérant le texte approprié <xref:System.Windows.Documents.Inline> éléments, tels que <xref:System.Windows.Documents.Bold> et <xref:System.Windows.Documents.Italic>, dans la sélection indiquée par ce <xref:System.Windows.Documents.TextRange>.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Windows.Documents.TextRange.ApplyPropertyValue%2A>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Levée lorsque <paramref name="formattingProperty" /> ne spécifie pas de propriété de mise en forme valide, ou lorsque <paramref name="value" /> indique une valeur non valide pour <paramref name="formattingProperty" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se produit quand <paramref name="formattingProperty" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="CanLoad">
      <MemberSignature Language="C#" Value="public bool CanLoad (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanLoad(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanLoad (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanLoad(System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.CanLoad : string -&gt; bool" Usage="textRange.CanLoad dataFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Format de données dont la compatibilité de chargement dans la sélection actuelle doit être vérifiée.  Consultez <see cref="T:System.Windows.DataFormats" /> pour obtenir la liste des formats de données prédéfinis.</param>
        <summary>Vérifie si du contenu peut être chargé dans la sélection actuelle à un format de données spécifié.</summary>
        <returns><see langword="true" /> si du contenu peut être chargé dans la sélection actuelle au format de données spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utiliser le correspondantes <xref:System.Windows.Documents.TextRange.Load%2A> méthode pour charger le contenu dans la sélection actuelle dans un format de données spécifié.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Windows.Documents.TextRange.CanLoad%2A>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CanSave">
      <MemberSignature Language="C#" Value="public bool CanSave (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanSave(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanSave (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanSave(System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.CanSave : string -&gt; bool" Usage="textRange.CanSave dataFormat" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.CanSave(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Format de données dont la compatibilité d'enregistrement avec la sélection actuelle doit être vérifiée.  Consultez <see cref="T:System.Windows.DataFormats" /> pour obtenir la liste des formats de données prédéfinis.</param>
        <summary>Vérifie si la sélection actuelle peut être enregistrée à un format de données spécifié.</summary>
        <returns><see langword="true" /> si la sélection actuelle peut être enregistrée au format de données spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utiliser le correspondantes <xref:System.Windows.Documents.TextRange.Save%2A> méthode pour enregistrer la sélection actuelle au format de données spécifié.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Windows.Documents.TextRange.CanSave%2A>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Documents.TextRange.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.Documents.ITextRange.Changed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la plage est repositionnée de façon à couvrir un nouvel intervalle du contenu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllProperties">
      <MemberSignature Language="C#" Value="public void ClearAllProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearAllProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ClearAllProperties" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearAllProperties ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearAllProperties();" />
      <MemberSignature Language="F#" Value="member this.ClearAllProperties : unit -&gt; unit" Usage="textRange.ClearAllProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime toutes les propriétés de mise en forme (représentées par des éléments <see cref="T:System.Windows.Documents.Inline" />) de la sélection actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode affecte uniquement les <xref:System.Windows.Documents.Inline> mise en forme des éléments, tels que <xref:System.Windows.Documents.Bold> ou <xref:System.Windows.Documents.Italic>. Propriétés définies sur des paragraphes et autres englobante <xref:System.Windows.Documents.Block> éléments ne sont pas modifiés.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Documents.TextPointer textPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Documents.TextPointer textPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Contains(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Documents::TextPointer ^ textPointer);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Documents.TextPointer -&gt; bool" Usage="textRange.Contains textPointer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPointer" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPointer">Position dont l'inclusion dans la sélection actuelle doit être testée.</param>
        <summary>Vérifie si une position (spécifiée par un <see cref="T:System.Windows.Documents.TextPointer" />) est située dans la sélection actuelle.</summary>
        <returns><see langword="true" /> si la position spécifiée est située dans la sélection actuelle ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Positions aux deux extrémités de la sélection actuelle (indiqué par <xref:System.Windows.Documents.TextRange.Start%2A> et <xref:System.Windows.Documents.TextRange.End%2A>) sont considérés comme faisant partie de la sélection actuelle.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Windows.Documents.TextRange.Contains%2A>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produit quand *textPointer* ne se trouve pas dans le même document que la sélection actuelle.</exception>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer End { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer End" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.End" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property End As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ End { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.End : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextRange.End" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la position qui marque l'extrémité de la sélection actuelle.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> qui pointe vers l'extrémité de la sélection actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Windows.Documents.TextRange.End%2A> propriété.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.Start" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public object GetPropertyValue (System.Windows.DependencyProperty formattingProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPropertyValue(class System.Windows.DependencyProperty formattingProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (formattingProperty As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPropertyValue(System::Windows::DependencyProperty ^ formattingProperty);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : System.Windows.DependencyProperty -&gt; obj" Usage="textRange.GetPropertyValue formattingProperty" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.GetPropertyValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Propriété de mise en forme dont la valeur doit être obtenue pour la sélection actuelle.</param>
        <summary>Retourne la valeur effective d'une propriété de mise en forme spécifiée pour la sélection actuelle.</summary>
        <returns>Objet indiquant la valeur de la propriété de mise en forme spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Afin de retourner une valeur de propriété, l’intégralité de <xref:System.Windows.Documents.TextRange> doit s’étendre sur le texte avec une seule valeur pour le `formattingProperty`. Si le <xref:System.Windows.Documents.TextRange> s’étend sur le texte avec deux ou plusieurs des valeurs différentes pour le `formattingProperty`, <xref:System.Windows.DependencyProperty.UnsetValue> est retournée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Levée lorsque <paramref name="formattingProperty" /> ne spécifie pas de propriété de mise en forme valide, ou lorsque <paramref name="value" /> indique une valeur non valide pour <paramref name="formattingProperty" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se produit quand <paramref name="formattingProperty" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Windows.Documents.TextRange.IsEmpty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextRange.IsEmpty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la sélection actuelle est vide.</summary>
        <value><see langword="true" /> si la sélection actuelle est vide ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Documents.TextRange> est considéré comme vide si le <xref:System.Windows.Documents.TextRange.Start%2A> et <xref:System.Windows.Documents.TextRange.End%2A> positions sont égales.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Windows.Documents.TextRange.IsEmpty%2A> propriété.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.Load : System.IO.Stream * string -&gt; unit" Usage="textRange.Load (stream, dataFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Flux accessible en lecture qui contient les données à charger dans la sélection actuelle.</param>
        <param name="dataFormat">Format auquel charger les données.  Les formats de données actuellement pris en charge sont les suivants : <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" /> et <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <summary>Charge la sélection actuelle au format de données spécifié à partir d'un flux de données indiqué.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.IO.Stream.CanSeek%2A> est `true` pour `stream`, contenu sera chargé à partir du début du flux de données à la fin du flux.  Sinon, il est lu à partir du <xref:System.IO.Stream.Position%2A> à la fin du flux.  Lorsque cette méthode est retournée, `stream` est laissé ouvert et la position actuelle dans `stream` n’est pas défini.  
  
 Une opération de chargement remplace la sélection actuelle par le contenu qui vient d’être chargé.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Windows.Documents.TextRange.Load%2A>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Levée lorsque <paramref name="stream" /> ou <paramref name="dataFormat" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Levée lorsque le format de données spécifié n'est pas pris en charge.  Peut également être levée si le contenu chargé à partir de <paramref name="stream" /> n'est pas au format de données indiqué.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Enregistre la sélection actuelle au format de données spécifié dans le flux indiqué.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * string -&gt; unit" Usage="textRange.Save (stream, dataFormat)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données vide accessible en écriture dans lequel enregistrer la sélection actuelle.</param>
        <param name="dataFormat">Format de données auquel enregistrer la sélection actuelle.  Les formats de données actuellement pris en charge sont les suivants : <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" /> et <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <summary>Enregistre la sélection actuelle au format de données spécifié dans le flux indiqué.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est retournée, `stream` est laissé ouvert et la position actuelle dans `stream` n’est pas défini.  
  
 Dans le cadre de l’enregistrement opération, le contenu de la sélection actuelle peut être convertie au format de données spécifié par `dataFormat`.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Windows.Documents.TextRange.Save%2A>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> ou <paramref name="dataFormat" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le format de données spécifié n'est pas pris en charge.  
  
- ou - 
Le contenu chargé à partir de <paramref name="stream" /> n'est pas au format de données indiqué.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat, bool preserveTextElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * string * bool -&gt; unit" Usage="textRange.Save (stream, dataFormat, preserveTextElements)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
        <Parameter Name="preserveTextElements" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données vide accessible en écriture dans lequel enregistrer la sélection actuelle.</param>
        <param name="dataFormat">Format de données auquel enregistrer la sélection actuelle.  Les formats de données actuellement pris en charge sont les suivants : <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" /> et <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <param name="preserveTextElements"><see langword="true" /> pour conserver les objets <see cref="T:System.Windows.Documents.TextElement" /> personnalisés ; sinon, <see langword="false" />.</param>
        <summary>Enregistre la sélection actuelle au format de données spécifié dans le flux indiqué, en conservant éventuellement les objets <see cref="T:System.Windows.Documents.TextElement" /> personnalisés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque `preserveTextElements` est `false`personnalisés <xref:System.Windows.Documents.TextElement> les objets sont enregistrés comme connues <xref:System.Windows.Documents.TextElement> types.  Par exemple, supposons que vous créez un personnalisé <xref:System.Windows.Documents.TextElement> appelé `Heading1`, qui hérite de <xref:System.Windows.Documents.Paragraph>. Lorsque vous appelez cette méthode avec `preserveTextElements` définie sur `false`, `Heading1` est converti en un <xref:System.Windows.Documents.Paragraph> lorsque le <xref:System.Windows.Documents.TextRange> est enregistré.  Lorsque vous appelez cette méthode avec `preserveTextElements` définie sur `true`, `Heading1` est enregistré sans être convertis. Pour conserver les éléments de texte personnalisés, `dataFormat` doit être définie sur <xref:System.Windows.DataFormats.Xaml?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Documents.TextRange.Save%28System.IO.Stream%2CSystem.String%2CSystem.Boolean%29> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Levée lorsque <paramref name="stream" /> ou <paramref name="dataFormat" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Levée lorsque le format de données spécifié n'est pas pris en charge.  Peut également être levée si le contenu chargé à partir de <paramref name="stream" /> n'est pas au format de données indiqué.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Select(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Documents.TextPointer * System.Windows.Documents.TextPointer -&gt; unit" Usage="textRange.Select (position1, position2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Position d’ancrage fixe qui marque une extrémité de la sélection mise à jour.</param>
        <param name="position2">Position mobile qui marque l’autre extrémité de la sélection mise à jour.</param>
        <summary>Met à jour la sélection actuelle et indique la sélection mise à jour à l'aide de deux positions de <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Documents.TextRange> est formée à partir d’une sélection entre deux positions indiquées par **TextPointers**.  Une de ces positions (indiqué par `position1`) est fixe par rapport à la sélection, lors de l’autre position (indiqué par `position2`) peut être déplacé.  Cela est similaire à la manière dont se comporte une sélection effectuée par un utilisateur à l’aide de la souris ou le clavier.  
  
 Les terminaisons réelles de la nouvelle sélection peuvent être ajustés en fonction des paramètres heuristiques de sélection applicables au document qui contient la nouvelle sélection actuelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Levée lorsque <paramref name="position1" /> et <paramref name="position2" /> ne se trouvent pas dans le même document.</exception>
        <exception cref="T:System.ArgumentNullException">Levée lorsque <paramref name="position1" /> ou <paramref name="position2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer Start { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer Start" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Start" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Start As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ Start { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Start : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextRange.Start" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la position qui marque le début de la sélection actuelle.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> qui pointe vers le début de la sélection actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Windows.Documents.TextRange.Start%2A> propriété.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.End" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Documents.TextRange.Text" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextRange.Text</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contenu en texte brut de la sélection actuelle.</summary>
        <value>Chaîne contenant le contenu en texte brut de la sélection actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet d’extraire le contenu de texte brut dans la sélection actuelle, quelle que soit la mise en forme qui peuvent être présents.  
  
 Caractères de nouvelle ligne et les sauts de paragraphe sont traités comme équivalents en ce qui concerne cette propriété.  Tous les types de saut de contenu présent dans la sélection actuelle sont convertis vers les nouvelles lignes lorsque cette propriété est en lecture.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Windows.Documents.TextRange.Text%2A> propriété.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Levée lorsqu'une tentative d'affectation de la valeur <see langword="null" /> à cette propriété est effectuée.</exception>
      </Docs>
    </Member>
  </Members>
</Type>