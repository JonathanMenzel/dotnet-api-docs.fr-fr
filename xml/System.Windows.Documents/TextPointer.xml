<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80ffc4468fcd8385587be234b88e4272ca043528" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37577927" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a position within a <see cref="T:System.Windows.Documents.FlowDocument" /> or <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Documents.TextPointer> classe introduit la terminologie suivante :  
  
-   Position fondamentale - un <xref:System.Windows.Documents.TextPointer> pointe toujours vers un *position* dans le contenu.  De telles positions tombent entre des caractères dans le contenu ou flux de contenu élément balises qui définissent la structure pour le contenu.  
  
-   Position actuelle – comme un <xref:System.Windows.Documents.TextPointer> indique toujours une position et parce qu’un grand nombre des opérations qui peuvent être effectuées via un <xref:System.Windows.Documents.TextPointer> sont par rapport à la position actuellement vers lequel pointée le <xref:System.Windows.Documents.TextPointer>, il est judicieux d’appeler le position indiquée par un <xref:System.Windows.Documents.TextPointer> en tant que le *position actuelle*.  
  
-   Position d’insertion - une *position d’insertion* est une position où le nouveau contenu peut être ajouté sans les règles sémantiques pour le contenu associé.  Dans la pratique, une position d’insertion est n’importe où dans le contenu où un point d’insertion peut être positionné.  Un exemple de valide <xref:System.Windows.Documents.TextPointer> position qui n’est pas une position d’insertion est la position entre deux adjacents <xref:System.Windows.Documents.Paragraph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et de la balise d’ouverture du paragraphe suivant).  
  
-   Symbole - dans le cadre de <xref:System.Windows.Documents.TextPointer> les opérations qui impliquent des symboles, les éléments suivants est considéré comme un *symbole*:  
  
    -   Une ouverture ou la balise de fermeture d’un <xref:System.Windows.Documents.TextElement> élément.  
  
    -   Un <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> est toujours comptabilisé comme un seul symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
    -   Chaque 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
-   Conteneur de texte - A *conteneur de texte* est l’élément qui constitue l’ultime limite du contenu de flux à portée de main ; la position indiquée par un <xref:System.Windows.Documents.TextPointer> tombe toujours dans un conteneur de texte.  Actuellement, un conteneur de texte doit être un <xref:System.Windows.Documents.FlowDocument> ou un <xref:System.Windows.Controls.TextBlock>.  En règle générale, les opérations entre <xref:System.Windows.Documents.TextPointer> instances dans différents conteneurs de texte ne sont pas pris en charge.  
  
-   Document - le contenu dans un conteneur de texte est appelé un *document*, comme dans le <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> (méthode) et le <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> et <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> propriétés.  
  
 Le <xref:System.Windows.Documents.TextPointer> classe est destinée à faciliter le parcours et manipulation de contenu qui est représenté par [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] éléments de flux ; en général, de tels éléments dérivent <xref:System.Windows.Documents.TextElement>.  Certaines opérations qui <xref:System.Windows.Documents.TextPointer> facilite incluent les éléments suivants :  
  
-   Effectuer une comparaison ordinale de la position actuelle avec une seconde position spécifiée.  Consultez le <xref:System.Windows.Documents.TextPointer.CompareTo%2A> (méthode).  
  
-   Déterminer le type de contenu adjacent à la position actuelle dans une direction spécifiée.  Consultez le <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> méthode et <xref:System.Windows.Documents.TextPointerContext> énumération.  
  
-   Obtenir le <xref:System.Windows.Documents.TextElement> portant sur ou adjacent à la position actuelle.  Consultez <xref:System.Windows.Documents.Paragraph> et <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> (méthode).  
  
-   Obtenir le conteneur de texte portant sur le document actif.  Voir la propriété <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Obtenir un nombre spécifié de caractères qui précède ou suit la position actuelle.  Consultez le <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> (méthode).  
  
-   Insérer une chaîne de caractères à la position actuelle.  Consultez le <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> (méthode).  
  
-   Trouver les limites de ligne dans le contenu.  Consultez le <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> méthode et <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriété.  
  
-   Traduire entre <xref:System.Windows.Documents.TextPointer> positions et le symbole offsets dans le contenu.  Consultez le <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> et <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> méthodes.  
  
-   Exécuter des tests de positionnement visuels en traduisant entre un <xref:System.Windows.Documents.TextPointer> position et un <xref:System.Windows.Point> représentant des coordonnées relatives.  
  
-   Rechercher une position d’insertion proche, ou vérifier si la position actuelle est une position d’insertion.  Consultez le <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> et <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> méthodes et les <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> propriété.  
  
 La position et <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indiquée par un <xref:System.Windows.Documents.TextPointer> objet sont immuables.  Lorsque le contenu est modifié ou modifié, la position indiquée par un <xref:System.Windows.Documents.TextPointer> ne change pas par rapport au texte environnant ; au lieu de cela, le décalage de cette position à partir du début du contenu est ajusté en conséquence pour refléter la nouvelle position relative dans contenu.  Par exemple, un <xref:System.Windows.Documents.TextPointer> qui indique une position au début d’un paragraphe donné continue à pointer vers le début de ce paragraphe, même lorsque le contenu est inséré ou supprimé avant ou après le paragraphe.  
  
 Le <xref:System.Windows.Documents.TextPointer> classe ne fournit pas de constructeurs publics.  Une instance de <xref:System.Windows.Documents.TextPointer> est créé à l’aide des propriétés ou méthodes d’autres objets (y compris d’autres <xref:System.Windows.Documents.TextPointer> objets). La liste suivante fournit quelques exemples de méthodes et propriétés qui créent et retournent un <xref:System.Windows.Documents.TextPointer>.  Cette liste n’est pas exhaustive :  
  
-   À partir d’un <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> et <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   À partir d’un <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, et <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   À partir d’un <xref:System.Windows.Controls.TextBlock> (conteneur de texte) : <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, et <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   À partir d’un <xref:System.Windows.Documents.FlowDocument> (conteneur de texte) : <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, et <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   À partir d’un existant <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, et <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Documents.TextPointer> pour rechercher une position dans le premier <xref:System.Windows.Documents.Run> élément dans un conteneur de texte spécifié.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 L’exemple suivant implémente un algorithme de recherche simple à l’aide de <xref:System.Windows.Documents.TextPointer> installations.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to compare to the current position.</param>
        <summary>Performs an ordinal comparison between the positions specified by the current <see cref="T:System.Windows.Documents.TextPointer" /> and a second specified <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>–1 if the current <see cref="T:System.Windows.Documents.TextPointer" /> precedes <paramref name="position" />; 0 if the locations are the same; +1 if the current <see cref="T:System.Windows.Documents.TextPointer" /> follows <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur – 1 indique que la position spécifiée par l’actuel <xref:System.Windows.Documents.TextPointer> précède la position spécifiée par `position`.  La valeur 0 indique que les positions indiquées sont égales.  Une valeur de + 1 positive indique que la position spécifiée par l’actuel <xref:System.Windows.Documents.TextPointer> suit la position spécifiée par `position`.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode.  Dans l’exemple, le <xref:System.Windows.Documents.TextPointer.CompareTo%2A> méthode est utilisée conjointement avec la <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> méthode pour tester si une certaine <xref:System.Windows.Documents.TextElement> est vide.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifies a position outside of the text container associated with the current position.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">The number of characters to delete, starting at the current position. Specify a positive value to delete characters that follow the current position; specify a negative value to delete characters that precede the current position.</param>
        <summary>Deletes the specified number of characters from the position indicated by the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>The number of characters actually deleted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécifiez une valeur positive pour supprimer les caractères qui suivent la position actuelle (comme dans <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) ; spécifiez une valeur négative pour supprimer les caractères qui précèdent la position actuelle (comme dans <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Le nombre de caractères réellement supprimés peut être inférieur au nombre spécifié par `count`.  Cela se produit dans les cas où `count` spécifie plus de caractères qu’il en existe pour être supprimé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The method is called at a position where text is not allowed.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Documents.TextPointer" /> at the end of content in the text container associated with the current position.</summary>
        <value>Un <see cref="T:System.Windows.Documents.TextPointer" /> à la fin du contenu dans le conteneur de texte associé à la position actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Documents.TextPointer.Parent%2A> pour retourné <xref:System.Windows.Documents.TextPointer> est toujours un conteneur de texte (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), au lieu d’un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Documents.TextPointer" /> at the beginning of content in the text container associated with the current position.</summary>
        <value>Un <see cref="T:System.Windows.Documents.TextPointer" /> au début du contenu dans le conteneur de texte associé à la position actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la position retournée par cette propriété comme position de ligne de base à partir de laquelle travailler avec des décalages relatifs pour les autres positions.  Le <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> et <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> méthodes fournissent un moyen de convertir entre les positions et la position des décalages.  
  
 Le <xref:System.Windows.Documents.TextPointer.Parent%2A> pour retourné <xref:System.Windows.Documents.TextPointer> est toujours un conteneur de texte (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), au lieu d’un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for an adjacent element.</param>
        <summary>Returns the element, if any, that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>The adjacent element in the specified <paramref name="direction" />, or <see langword="null" /> if no adjacent element exists.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’élément retourné est généralement un <xref:System.Windows.Documents.TextElement>.  Un <xref:System.Windows.UIElement> peut être retourné lorsque le <xref:System.Windows.Documents.TextPointer> indique une position à l’intérieur d’un <xref:System.Windows.Documents.BlockUIContainer> élément ou un <xref:System.Windows.Documents.InlineUIContainer> élément.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find a content bounding box.</param>
        <summary>Returns a bounding box (<see cref="T:System.Windows.Rect" />) for content that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>A bounding box for content that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified direction, or <see cref="P:System.Windows.Rect.Empty" /> if current, valid layout information is unavailable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> bords ne sont pas considérés comme contenu dans le cadre de cette méthode.  Si le <xref:System.Windows.Documents.TextPointer> est placé avant un <xref:System.Windows.Documents.TextElement> edge, la valeur de retour est un cadre englobant pour le prochain non -<xref:System.Windows.Documents.TextElement> contenu dans la direction spécifiée.  Si aucun contenu n’est dans la direction spécifiée, une largeur nulle <xref:System.Windows.Rect> est retourné avec une hauteur correspondant à celle de n’importe quel précédent contenu.  
  
 L’opération exécutée par cette méthode dépend d’une disposition valide.  Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.  Régénérer une disposition peut être une opération relativement coûteuse.  Utilisez le <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriété à vérifier pour une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.  Pour plus d’informations, consultez [disposition](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the closest insertion position.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the closest insertion position in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the closest insertion position in the specified direction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une position d’insertion est une position où le nouveau contenu peut être ajouté sans les règles sémantiques pour le contenu associé.  Dans la pratique, une position d’insertion est n’importe où dans le contenu où un point d’insertion peut être positionné.  Un exemple de valide <xref:System.Windows.Documents.TextPointer> position qui n’est pas une position d’insertion est la position entre deux adjacents <xref:System.Windows.Documents.Paragraph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et de la balise d’ouverture du paragraphe suivant).  
  
 Si le <xref:System.Windows.Documents.TextPointer> déjà pointe vers une position d’insertion valide, mais que la balise de fermeture pour une séquence de mise en forme non vide suit directement cette position dans la direction donnée, puis le <xref:System.Windows.Documents.TextPointer> retourné par cette méthode est ajustée pour pointer vers l’insertion position juste après la fermeture de la séquence de mise en forme. Par exemple, considérez la séquence de balisage `<Bold>a</Bold>b`. Notez qu’il n’y a deux positions d’insertion entre les lettres `a` et `b` — qui précède la fermeture `Bold` balise et l’autre directement après la fermeture `Bold` balise. Si <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> est appelée sur un <xref:System.Windows.Documents.TextPointer> à la position juste après la lettre `a` et avant la fermeture `Bold` balise et avec un `direction` de <xref:System.Windows.Documents.LogicalDirection.Forward>, retourné <xref:System.Windows.Documents.TextPointer> est ajustée pour pointer vers le position juste avant la lettre `b`, après la fermeture `Bold` balise. Un ajustement similaire est pour la mise en forme de balises d’ouverture lorsque vous travaillez dans la direction logique opposée. Cette méthode est destinée à fournir un moyen de l’ambiguïté entre les positions d’insertion dans des cas similaires.  
  
 Cette méthode peut également servir à sélectionner les points d’insertion lorsqu’une séquence de balises structurelles est impliquée. Par exemple, lors de la position entre les balises de paragraphe d’ouverture et de clôture, le paramètre de direction peut être utilisé pour sélectionner le point d’insertion le plus proche au début du paragraphe suivant (en spécifiant <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) ou à la fin de la précédente du paragraphe ( en spécifiant <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Si le pointeur est déjà à la position d’insertion, et qu’aucune balise de mise en forme adjacente dans spécifié `direction`, retourné <xref:System.Windows.Documents.TextPointer> pointe vers la même position que l’appel <xref:System.Windows.Documents.TextPointer>.  
  
 Il est possible qu’aucune position d’insertion valide n’existe par rapport à l’emplacement vers lequel pointé un <xref:System.Windows.Documents.TextPointer>.  Cela peut se produire si le contenu référencé est structurellement incomplète, comme dans une table vide ou une liste.  Dans ce cas, cette méthode retourne simplement une <xref:System.Windows.Documents.TextPointer> à la même position que le <xref:System.Windows.Documents.TextPointer> à partir duquel cette méthode a été appelée.  Cette méthode retourne toujours valide <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Cet exemple montre comment utiliser le <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> méthode permettant de vérifier si une certaine <xref:System.Windows.Documents.TextElement> est vide de contenu imprimable.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">The number of start-of-line markers to skip when determining the line for which to return the starting position. Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pointing to the beginning of the specified line (with the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> set to <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), or <see langword="null" /> if the specified line is out of range or otherwise cannot be located.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Documents.TextPointer> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> est sélectionné comme ligne de départ relative.  
  
 L’opération exécutée par cette méthode dépend d’une disposition valide.  Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.  Régénérer une disposition peut être une opération relativement coûteuse.  Utilisez <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> pour vérifier une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.  Pour plus d’informations, consultez [disposition](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">The number of start-of-line markers to skip when determining the line for which to return the starting position. Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</param>
        <param name="actualCount">When this method returns, contains the actual number of start-of-line markers that were skipped when determining the line for which to return the starting position.  This value may be less than <c>count</c> if the beginning or end of content is encountered before the specified number of lines are skipped. This parameter is passed uninitialized.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />, and reports how many lines were skipped.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pointing to the beginning of the specified line (with the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> set to <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), or to the beginning of the line closest to the specified line if the specified line is out of range.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Documents.TextPointer> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par le <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriété est sélectionnée comme ligne de départ relative.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the next symbol.</param>
        <summary>Returns a pointer to the next symbol in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the next symbol in the requested direction, or <see langword="null" /> if the current <see cref="T:System.Windows.Documents.TextPointer" /> borders the start or end of content.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une ouverture ou la balise de fermeture d’un <xref:System.Windows.Documents.TextElement> élément.  
  
-   Un <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> est toujours comptabilisé comme un seul symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
 Si le prochain symbole est classé dans la <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, ou <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (tel qu’identifié par le <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> méthode), puis le <xref:System.Windows.Documents.TextPointer> retourné par cette méthode est avancée d’exactement un symbole à partir de la position actuelle.  
  
 Si le prochain symbole est classé dans la <xref:System.Windows.Documents.TextPointerContext.Text>, puis le <xref:System.Windows.Documents.TextPointer> retourné par cette méthode outrepasse le texte vers le prochain symbole de non-texte (autrement dit, la prochaine position où le <xref:System.Windows.Documents.TextPointerContext> n’est pas <xref:System.Windows.Documents.TextPointerContext.Text>).  Le compte exact de symboles rencontrés peut être calculé à l’avance en appelant le <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode.  L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> méthode conjointement avec le <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> méthode pour parcourir et extraire les symboles dans une certaine <xref:System.Windows.Documents.TextElement>.  
  
 Tandis que l’exemple peut être utilisé pour extraire un [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] structure pour le contenu d’une donnée <xref:System.Windows.Documents.TextElement>, il vise uniquement à des fins d’illustration et ne doit pas être utilisé dans le code de production.  Consultez le <xref:System.Xml> espace de noms pour un ensemble complet de types conçus pour travailler avec et de traitement XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the next insertion position.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the next insertion position in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> that identifies the next insertion position in the requested direction, or <see langword="null" /> if no next insertion position can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *position d’insertion* est une position où le nouveau contenu peut être ajouté sans les règles sémantiques pour le contenu associé.  Dans la pratique, une position d’insertion est n’importe où dans le contenu où un point d’insertion peut être positionné.  Un exemple de valide <xref:System.Windows.Documents.TextPointer> position qui n’est pas une position d’insertion est la position entre deux adjacents <xref:System.Windows.Documents.Paragraph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et de la balise d’ouverture du paragraphe suivant).  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> méthode pour parcourir les limites de l’élément de contenu afin de compter le nombre de <xref:System.Windows.Documents.Paragraph> éléments présents entre deux spécifié <xref:System.Windows.Documents.TextPointer> instances.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to find the distance (in symbols) to.</param>
        <summary>Returns the count of symbols between the current <see cref="T:System.Windows.Documents.TextPointer" /> and a second specified <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>The relative number of symbols between the current <see cref="T:System.Windows.Documents.TextPointer" /> and <paramref name="position" />.  A negative value indicates that the current <see cref="T:System.Windows.Documents.TextPointer" /> follows the position specified by <paramref name="position" />, 0 indicates that the positions are equal, and a positive value indicates that the current <see cref="T:System.Windows.Documents.TextPointer" /> precedes the position specified by <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une ouverture ou la balise de fermeture d’un <xref:System.Windows.Documents.TextElement> élément.  
  
-   Un <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> est toujours comptabilisé comme un seul symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> méthode pour rechercher les offsets pour deux <xref:System.Windows.Documents.TextPointer> instances et utilise ensuite ces informations pour enregistrer et restaurer la sélection dans un <xref:System.Windows.Controls.RichTextBox>.  L’exemple suppose que le contenu de la <xref:System.Windows.Controls.RichTextBox> n’ont pas changé entre une sauvegarde de sélection et une restauration de sélection.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifies a position outside of the text container associated with the current position.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to determine the category for adjacent content.</param>
        <summary>Returns a category indicator for the content adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>One of the <see cref="T:System.Windows.Documents.TextPointerContext" /> values that indicates the category for adjacent content in the specified logical direction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> méthode pour implémenter un algorithme pour calculer le solde d’ouverture et fermeture des balises d’élément entre deux spécifié <xref:System.Windows.Documents.TextPointer> positions.  Chaque balise d’élément d’ouverture est comptée comme + 1 et chaque balise d’élément de fermeture est comptée comme – 1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of content.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">An offset, in symbols, for which to calculate and return the position.  If the offset is negative, the position is calculated in the logical direction opposite of that indicated by the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> property.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, or <see langword="null" /> if no corresponding position can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une ouverture ou la balise de fermeture de la <xref:System.Windows.Documents.TextElement> élément.  
  
-   Un <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> est toujours comptabilisé comme un seul symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> méthode pour implémenter une paire de méthodes, une pour calculer l’offset à une position spécifiée par rapport à n’importe quel paragraphe d’hébergement et l’autre pour renvoyer un <xref:System.Windows.Documents.TextPointer> un décalage spécifié dans un paragraphe particulier.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">An offset, in symbols, for which to calculate and return the position.  If the offset is negative, the returned <see cref="T:System.Windows.Documents.TextPointer" /> precedes the current <see cref="T:System.Windows.Documents.TextPointer" />; otherwise, it follows.</param>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction of the returned <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of the current <see cref="T:System.Windows.Documents.TextPointer" /> and in the specified direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, or <see langword="null" /> if the offset extends past the end of the content.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une ouverture ou la balise de fermeture de la <xref:System.Windows.Documents.TextElement> élément.  
  
-   Un <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> est toujours comptabilisé comme un seul symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns text adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find and return any adjacent text.</param>
        <summary>Returns a string containing any text adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>A string containing any adjacent text in the specified logical direction, or <see cref="F:System.String.Empty" /> if no adjacent text can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne uniquement les exécutions de texte ininterrompues.  Rien n’est retourné si un type de symbole autre que <xref:System.Windows.Documents.TextPointerContext.Text> est adjacent à actuel <xref:System.Windows.Documents.TextPointer> dans la direction spécifiée.  De même, le texte est renvoyé uniquement jusqu'à le prochain symbole de non-texte.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> méthode pour implémenter un extracteur de texte simple.  La méthode renvoie une concaténation de chaînes de tout le texte entre deux spécifié <xref:System.Windows.Documents.TextPointer> instances.  
  
 Bien que l’exemple peut être utilisé pour extraire tout texte entre deux <xref:System.Windows.Documents.TextPointer> instances, il est destiné uniquement à des fins d’illustration et ne doit pas être utilisé dans le code de production.  Utilisez la propriété <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> à la place.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find and copy any adjacent text.</param>
        <param name="textBuffer">A buffer into which any text is copied.</param>
        <param name="startIndex">An index into <c>textBuffer</c> at which to begin writing copied text.</param>
        <param name="count">The maximum number of characters to copy.</param>
        <summary>Copies the specified maximum number of characters from any adjacent text in the specified direction into a caller-supplied character array.</summary>
        <returns>The number of characters actually copied into <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne uniquement les exécutions de texte ininterrompues.  Rien n’est retourné si un type de symbole autre que <xref:System.Windows.Documents.TextPointerContext.Text> est adjacent à actuel <xref:System.Windows.Documents.TextPointer> dans la direction spécifiée.  De même, le texte est renvoyé uniquement jusqu'à le prochain symbole de non-texte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> is less than 0 or greater than the <see cref="P:System.Array.Length" /> property of <paramref name="textBuffer" />.  -or-  <paramref name="count" /> is less than 0 or greater than the remaining space in <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> minus <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to count the number of characters.</param>
        <summary>Returns the number of Unicode characters between the current <see cref="T:System.Windows.Documents.TextPointer" /> and the next non-text symbol, in the specified logical direction.</summary>
        <returns>The number of Unicode characters between the current <see cref="T:System.Windows.Documents.TextPointer" /> and the next non-text symbol.  This number may be 0 if there is no adjacent text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une ouverture ou la balise de fermeture de la <xref:System.Windows.Documents.TextElement> élément.  
  
-   Un <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> est toujours comptabilisé comme un seul symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the text container associated with the current position has a valid (up-to-date) layout.</summary>
        <value>
          <see langword="true" /> Si la disposition actuelle est valide ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cela est nécessaire, opérations qui dépendent d’une disposition valide (tel que le <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> (méthode), <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> (méthode), et <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriété) si vous tentez de régénérer automatiquement une disposition valide avant de poursuivre l’opération.  Régénérer une disposition peut être une opération relativement coûteuse.  Cette propriété permet de vérifier une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.  Pour plus d’informations, consultez [disposition](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserts a line break at the current position.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> positioned immediately after the <see cref="T:System.Windows.Documents.LineBreak" /> element inserted by this method.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserts a paragraph break at the current position.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) of the new paragraph.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode est appelée lorsque la position actuelle est à l’intérieur d’un existant <xref:System.Windows.Documents.Paragraph> élément, le paragraphe existant et tout son contenu sont divisées en deux paragraphes à la position actuelle.  Si cette méthode est appelée lorsque la position actuelle n’est pas à l’intérieur d’un paragraphe existant, un nouveau paragraphe vide est inséré.  Si cette méthode est appelée à la position ne sont pas adaptée pour fractionner ou en insérant un paragraphe (par exemple, si la position actuelle est à l’intérieur d’un <xref:System.Windows.Documents.Hyperlink> élément), une exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This method is called on a position that cannot be split to accommodate a new paragraph, such as in the scope of a <see cref="T:System.Windows.Documents.Hyperlink" /> or <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">The text to insert.</param>
        <summary>Inserts the specified text into the text <see cref="T:System.Windows.Documents.Run" /> at the current position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Documents.TextPointer> n’est pas limitée par un <xref:System.Windows.Documents.Run> élément, un <xref:System.Windows.Documents.Run> est inséré avec la `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current position is not within a <see cref="T:System.Windows.Documents.Run" /> element.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current position is an insertion position.</summary>
        <value>
          <see langword="true" /> Si la position actuelle est une position d’insertion ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une position d’insertion est une position où le nouveau contenu peut être ajouté sans les règles sémantiques pour le contenu associé.  Dans la pratique, une position d’insertion est n’importe où dans le contenu où un point d’insertion peut être positionné.  Un exemple de valide <xref:System.Windows.Documents.TextPointer> position qui n’est pas une position d’insertion est la position entre deux adjacents <xref:System.Windows.Documents.Paragraph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et de la balise d’ouverture du paragraphe suivant).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current position is at the beginning of a line.</summary>
        <value>
          <see langword="true" /> Si la position actuelle est au début d’une ligne ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Documents.TextPointer> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par le <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriété est sélectionnée comme ligne de départ relative.  
  
 L’opération exécutée par cette propriété varie selon une disposition valide.  Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.  Régénérer une disposition peut être une opération relativement coûteuse.  Utilisez le <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriété à vérifier pour une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.  Pour plus d’informations, consultez [disposition](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to compare to the current position.</param>
        <summary>Indicates whether the specified position is in the same text container as the current position.</summary>
        <returns>
          <see langword="true" /> if <paramref name="textPosition" /> indicates a position that is in the same text container as the current position; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plupart des opérations qui impliquent plusieurs <xref:System.Windows.Documents.TextPointer> instances sont valides uniquement si les instances en question indiquent des positions qui se trouvent dans la même étendue de conteneur de texte.  Par exemple le <xref:System.Windows.Documents.TextPointer.CompareTo%2A> et <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> méthodes ne peut pas être utilisés avec un <xref:System.Windows.Documents.TextPointer> à une position en dehors du conteneur de texte associé à la position actuelle.  Utilisez cette méthode pour vérifier que spécifié <xref:System.Windows.Documents.TextPointer> est compatible avec la position actuelle pour ces opérations.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode.  L’exemple utilise le <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> méthode permettant de vérifier si une certaine <xref:System.Windows.Documents.TextPointer> est placé entre deux autres spécifié <xref:System.Windows.Documents.TextPointer> instances dans une situation lorsqu’il n’existe aucune garantie que tous les trois positions appartiennent au même conteneur de texte.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the logical direction associated with the current position which is used to disambiguate content associated with the current position.</summary>
        <value>Le <see cref="T:System.Windows.Documents.LogicalDirection" /> valeur associé à la position actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme exemple d’utilisation de cette propriété, le <xref:System.Windows.Documents.LogicalDirection> de la <xref:System.Windows.Documents.TextPointer> retourné par un test de positionnement méthode donne un accès entre deux caractères de texte. La direction logique spécifie lequel des deux caractères a été réellement atteint — gauche ou droite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the paragraph that scopes the current position, if any.</summary>
        <value>Le <see cref="T:System.Windows.Documents.Paragraph" /> portant sur la position actuelle, ou <see langword="null" /> si aucun paragraphe de ce type n’existe.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the logical parent that scopes the current position.</summary>
        <value>Le parent logique portant sur la position actuelle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This type or member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <returns>The string that represents the object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>