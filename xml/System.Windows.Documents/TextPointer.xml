<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TextPointer.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d374acbfa59bece9a23ff4841ba74263d0c6fa42.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d374acbfa59bece9a23ff4841ba74263d0c6fa42</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Documents.TextPointer">
          <source>Represents a position within a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.FlowDocument" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Windows.Controls.TextBlock" /&gt;</ph>.</source>
          <target state="translated">Représente une position dans un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.FlowDocument" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Windows.Controls.TextBlock" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> class introduces the following terminology:</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> classe introduit la terminologie suivante :</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Position - Inherently, a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> always points to a <bpt id="p1">*</bpt>position<ept id="p1">*</ept> in content.</source>
          <target state="translated">Position fondamentale - un <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> pointe toujours vers un <bpt id="p1">*</bpt>position<ept id="p1">*</ept> dans le contenu.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Such positions either fall between characters in the content, or between flow content element tags that define structure for the content.</source>
          <target state="translated">De telles positions tombent entre des caractères dans le contenu ou flux de contenu de balises de l’élément qui définissent la structure pour le contenu.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Current Position - Because a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> always indicates a position, and because many of the operations that can be performed through a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> are relative to the position currently pointed to by the <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>, it makes sense to simply refer to the position indicated by a <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> as the <bpt id="p1">*</bpt>current position<ept id="p1">*</ept>.</source>
          <target state="translated">Position actuelle – comme un <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> indique toujours une position et parce qu’un grand nombre des opérations qui peuvent être effectuées via une <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> sont par rapport à la position actuellement vers lequel pointée le <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>, il est judicieux d’appeler le position indiquée par un <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> comme le <bpt id="p1">*</bpt>position actuelle<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Insertion Position - An <bpt id="p1">*</bpt>insertion position<ept id="p1">*</ept> is a position where new content may be added without breaking any semantic rules for the associated content.</source>
          <target state="translated">Position d’insertion - une <bpt id="p1">*</bpt>d’insertion<ept id="p1">*</ept> est une position où le nouveau contenu peut être ajouté sans les règles sémantiques concernant le contenu associé.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>In practice, an insertion position is anywhere in content where a caret may be positioned.</source>
          <target state="translated">Dans la pratique, une position d’insertion se trouve n’importe où dans le contenu où un point d’insertion peut être positionnée.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>An example of a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position that is not an insertion position is the position between two adjacent <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> tags (that is, between the closing tag of the preceding paragraph and the opening tag of the next paragraph).</source>
          <target state="translated">Un exemple de valide <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position qui n’est pas une position d’insertion est la position entre deux adjacents <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et la balise d’ouverture du paragraphe suivant).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Symbol - For the purposes of <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> operations that involve symbols, any of the following is considered to be a <bpt id="p1">*</bpt>symbol<ept id="p1">*</ept>:</source>
          <target state="translated">Symbole - pour les besoins de <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> les opérations qui impliquent des symboles, les éléments suivants est considéré comme un <bpt id="p1">*</bpt>symbole<ept id="p1">*</ept>:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>An opening or closing tag for a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Une balise d’ouverture ou de fermeture pour un <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained within an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> élément contenu dans un <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Notez que ce un <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ne sont pas comptés comme des symboles.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Each 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">Chaque 16 bits <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> caractère à l’intérieur d’un texte <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Text Container - A <bpt id="p1">*</bpt>text container<ept id="p1">*</ept> is the element that forms the ultimate border for the flow content at hand; the position indicated by a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> always falls within a text container.</source>
          <target state="translated">Conteneur de texte - A <bpt id="p1">*</bpt>conteneur de texte<ept id="p1">*</ept> est l’élément qui forme la bordure ultime pour le contenu de flux à portée de main ; la position indiquée par un <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> tombe toujours dans un conteneur de texte.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Currently, a text container must be either a <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> or a <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>.</source>
          <target state="translated">Actuellement, un conteneur de texte doit être un <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Generally speaking, operations between <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances in different text containers are not supported.</source>
          <target state="translated">En règle générale, les opérations entre <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances dans différents conteneurs de texte ne sont pas pris en charge.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Document - The content in a text container is referred to as a <bpt id="p1">*</bpt>document<ept id="p1">*</ept>, as in the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.DocumentStart%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.DocumentEnd%2A&gt;</ph> properties.</source>
          <target state="translated">Document - le contenu dans un conteneur de texte est appelé un <bpt id="p1">*</bpt>document<ept id="p1">*</ept>, comme dans le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A&gt;</ph> (méthode) et le <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.DocumentStart%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.DocumentEnd%2A&gt;</ph> propriétés.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> class is intended to facilitate traversal and manipulation of content that is represented by <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> flow content elements; in general, such elements derive from <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> classe est destinée à faciliter le parcours et la manipulation du contenu qui est représenté par <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> éléments de flux ; en général, de tels éléments dérivent <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Some of the operations that <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> facilitates include the following:</source>
          <target state="translated">Certaines opérations qui <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> facilite incluent les éléments suivants :</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Perform an ordinal comparison of the current position with a second specified position.</source>
          <target state="translated">Effectuer une comparaison ordinale de la position actuelle avec une seconde position spécifiée.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> method.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Determine the type of content adjacent to the current position in a specified direction.</source>
          <target state="translated">Déterminez le type de contenu adjacent à la position actuelle dans une direction spécifiée.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointerContext&gt;</ph> enumeration.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointerContext&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Get the <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> that scopes or is adjacent to the current position.</source>
          <target state="translated">Obtenir le <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> portant sur ou adjacent à la position actuelle.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> and the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A&gt;</ph> method.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Get the text container that scopes the current document.</source>
          <target state="translated">Obtenir le conteneur de texte portant sur le document actif.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> property.</source>
          <target state="translated">Voir la propriété <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Get a specified number of characters preceding or following the current position.</source>
          <target state="translated">Obtenir un nombre spécifié de caractères précédant ou suivant la position actuelle.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextInRun%2A&gt;</ph> method.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextInRun%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Insert a string of characters at the current position.</source>
          <target state="translated">Insérez une chaîne de caractères à la position actuelle.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A&gt;</ph> method.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Find line boundaries in content.</source>
          <target state="translated">Rechercher les limites de ligne dans le contenu.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A&gt;</ph> property.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Translate between <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> positions and symbol offsets into content.</source>
          <target state="translated">Convertir entre <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> positions et le symbole des offsets dans le contenu.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> methods.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Perform visual hit testing by translating between a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position and a <ph id="ph2">&lt;xref:System.Windows.Point&gt;</ph> representing relative coordinates.</source>
          <target state="translated">Exécuter des tests de positionnement visuels en traduisant entre une <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position et un <ph id="ph2">&lt;xref:System.Windows.Point&gt;</ph> représentant des coordonnées relatives.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Find a nearby insertion position, or check whether the current position is an insertion position.</source>
          <target state="translated">Rechercher une position d’insertion proche, ou vérifier si la position actuelle est une position d’insertion.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph> methods and the <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A&gt;</ph> property.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph> méthodes et <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The position and <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> indicated by a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> object are immutable.</source>
          <target state="translated">La position et <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> indiquée par un <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> objet sont immuables.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>When content is edited or modified, the position indicated by a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> does not change relative to the surrounding text; rather the offset of that position from the beginning of content is adjusted correspondingly to reflect the new relative position in content.</source>
          <target state="translated">Lorsque le contenu est modifié ou modifié, la position indiquée par un <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> ne change pas par rapport à texte qui l’entoure ; au lieu de cela, le décalage de cette position à partir du début du contenu est ajusté en conséquence pour refléter la nouvelle position relative dans contenu.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>For example, a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> that indicates a position at the beginning of a given paragraph continues to point to the beginning of that paragraph even when content is inserted or deleted before or after the paragraph.</source>
          <target state="translated">Par exemple, un <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> qui indique une position au début d’un paragraphe donné continue à pointer vers le début de ce paragraphe, même lorsque le contenu est inséré ou supprimé avant ou après le paragraphe.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> class does not provide any public constructors.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> classe ne fournit pas de constructeurs publics.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>An instance of <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is created by using properties or methods of other objects (including other <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> objects).</source>
          <target state="translated">Une instance de <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> est créé à l’aide des propriétés ou méthodes d’autres objets (y compris d’autres <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> objets).</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The following list provides a few examples of methods and properties that create and return a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</source>
          <target state="translated">La liste suivante fournit quelques exemples de méthodes et propriétés qui créent et renvoient un <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>This list is not exhaustive:</source>
          <target state="translated">Cette liste n’est pas exhaustive :</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From a <ph id="ph1">&lt;xref:System.Windows.Documents.TextRange&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextRange.Start%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Documents.TextRange.End%2A&gt;</ph>.</source>
          <target state="translated">À partir d’un <ph id="ph1">&lt;xref:System.Windows.Documents.TextRange&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextRange.Start%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.Windows.Documents.TextRange.End%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>:  <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.ContentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement.ContentEnd%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Documents.TextElement.ElementStart%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement.ElementEnd%2A&gt;</ph>.</source>
          <target state="translated">À partir d’un <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.ContentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement.ContentEnd%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Documents.TextElement.ElementStart%2A&gt;</ph>, et <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement.ElementEnd%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From a <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> (text container): <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock.ContentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock.ContentEnd%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A&gt;</ph>.</source>
          <target state="translated">À partir d’un <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> (conteneur de texte) : <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock.ContentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock.ContentEnd%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From a <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> (text container): <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument.ContentStart%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Documents.FlowDocument.ContentEnd%2A&gt;</ph></source>
          <target state="translated">À partir d’un <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> (conteneur de texte) : <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument.ContentStart%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Windows.Documents.FlowDocument.ContentEnd%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From an existing <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.DocumentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.DocumentEnd%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph>.</source>
          <target state="translated">À partir d’un fichier <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.DocumentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.DocumentEnd%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph>, et <ph id="ph5">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The following example demonstrates how to use a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to find a position just inside of the first <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element in a specified text container.</source>
          <target state="translated">L’exemple suivant montre comment utiliser un <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> pour rechercher une position dans le premier <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> élément dans un conteneur de texte spécifié.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The following example implements a simplistic find algorithm using <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> facilities.</source>
          <target state="translated">L’exemple suivant implémente un algorithme de recherche simple à l’aide de <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> installations.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> that specifies a position to compare to the current position.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> qui spécifie une position à comparer à la position actuelle.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>Performs an ordinal comparison between the positions specified by the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and a second specified <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Effectuer une comparaison ordinale entre les positions spécifiées par le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel et une seconde spécifié par <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>–1 if the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> precedes <ph id="ph2">&lt;paramref name="position" /&gt;</ph>; 0 if the locations are the same; +1 if the current <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="position" /&gt;</ph>.</source>
          <target state="translated">–1 si le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel précède <ph id="ph2">&lt;paramref name="position" /&gt;</ph>; 0 si les emplacements sont les mêmes ; +1 si le <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel suit <ph id="ph4">&lt;paramref name="position" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>A value of –1 indicates that the position specified by the current <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> precedes the position specified by <ph id="ph2">`position`</ph>.</source>
          <target state="translated">La valeur – 1 indique que la position spécifiée par l’actuel <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> précède la position spécifiée par <ph id="ph2">`position`</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>A value of 0 indicates that the indicated positions are equal.</source>
          <target state="translated">La valeur 0 indique que les positions indiquées sont égales.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>A value of positive +1 indicates that the position specified by the current <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> follows the position specified by <ph id="ph2">`position`</ph>.</source>
          <target state="translated">Une valeur de + 1 positive indique que la position spécifiée par l’actuel <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> suit la position spécifiée par <ph id="ph2">`position`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de cette méthode.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>In the example, the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> method is used in conjunction with the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> method to test whether a specified <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> is empty.</source>
          <target state="translated">Dans l’exemple, le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> méthode est utilisée conjointement avec la <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> méthode pour tester si un <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> specifies a position outside of the text container associated with the current position.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> spécifie une position en dehors du conteneur de texte associé à la position actuelle.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>The number of characters to delete, starting at the current position.</source>
          <target state="translated">Le nombre de caractères à supprimer, en commençant de la position actuelle.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>Specify a positive value to delete characters that follow the current position; specify a negative value to delete characters that precede the current position.</source>
          <target state="translated">Spécifier une valeur positive pour supprimer les caractères suivant la position actuelle ; spécifier une valeur négative pour supprimer les caractères précédant la position actuelle.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>Deletes the specified number of characters from the position indicated by the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Supprime le nombre spécifié de caractères de la position indiquée par le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>actuel.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>The number of characters actually deleted.</source>
          <target state="translated">Le nombre de caractères réellement supprimés.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>Specify a positive value to delete characters that follow the current position (as in <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType&gt;</ph>); specify a negative value to delete characters that precede the current position (as in <ph id="ph2">&lt;xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Spécifiez une valeur positive pour supprimer les caractères qui suivent la position actuelle (comme dans <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType&gt;</ph>) ; spécifiez une valeur négative pour supprimer les caractères qui précèdent la position actuelle (comme dans <ph id="ph2">&lt;xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>The number of characters actually deleted may be less than the number specified by <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Le nombre de caractères réellement supprimés peut être inférieur au nombre spécifié par <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>This happens in cases where <ph id="ph1">`count`</ph> specifies more characters than exist to be deleted.</source>
          <target state="translated">Cela se produit dans les cas où <ph id="ph1">`count`</ph> spécifie plus de caractères qu’existe pour être supprimé.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>The method is called at a position where text is not allowed.</source>
          <target state="translated">La méthode est appelée à une position où le texte n'est pas autorisé.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.DocumentEnd">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> at the end of content in the text container associated with the current position.</source>
          <target state="translated">Obtient un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la fin du contenu dans le conteneur de texte associé à la position actuelle.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentEnd">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> at the end of content in the text container associated with the current position.</source>
          <target state="translated">Obtient un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la fin du contenu dans le conteneur de texte associé à la position actuelle.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentEnd">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> for the returned <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is always a text container (<ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> or <ph id="ph4">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>), rather than a <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> pour retourné <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> est toujours un conteneur de texte (<ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> ou <ph id="ph4">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>), plutôt qu’un <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> at the beginning of content in the text container associated with the current position.</source>
          <target state="translated">Obtient un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> au début du contenu dans le conteneur de texte associé à la position actuelle.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> at the beginning of content in the text container associated with the current position.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> au début du contenu dans le conteneur de texte associé à la position actuelle.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>Use the position returned by this property as a baseline position from which to work with relative offsets to other positions.</source>
          <target state="translated">Utilisez la position retournée par cette propriété comme une position de ligne de base à partir de laquelle travailler avec des offsets relatifs à d’autres positions.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> methods provide a way to translate between positions and position offsets.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> méthodes fournissent un moyen de convertir entre les positions et la position des décalages.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> for the returned <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is always a text container (<ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> or <ph id="ph4">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>), rather than a <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> pour retourné <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> est toujours un conteneur de texte (<ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> ou <ph id="ph4">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>), plutôt qu’un <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to search for an adjacent element.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle rechercher un élément adjacent.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>Returns the element, if any, that borders the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified logical direction.</source>
          <target state="translated">Renvoie l'élément, s'il en est, qui limite le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>The adjacent element in the specified <ph id="ph1">&lt;paramref name="direction" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no adjacent element exists.</source>
          <target state="translated">L'élément adjacent dans la <ph id="ph1">&lt;paramref name="direction" /&gt;</ph>spécifiée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si aucun élément adjacent n'existe.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>The returned element is typically a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">L’élément retourné est généralement un <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> can be returned when the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> indicates a position inside a <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph> element or an <ph id="ph4">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> element.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> peut être retourné lorsque le <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> indique une position à l’intérieur d’un <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph> élément ou un <ph id="ph4">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to find a content bounding box.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle rechercher un cadre englobant de contenu.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>Returns a bounding box (<ph id="ph1">&lt;see cref="T:System.Windows.Rect" /&gt;</ph>) for content that borders the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified logical direction.</source>
          <target state="translated">Renvoie un cadre englobant (<ph id="ph1">&lt;see cref="T:System.Windows.Rect" /&gt;</ph>) pour du contenu en bordure du <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>A bounding box for content that borders the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified direction, or <ph id="ph2">&lt;see cref="P:System.Windows.Rect.Empty" /&gt;</ph> if current, valid layout information is unavailable.</source>
          <target state="translated">Un cadre englobant pour du contenu en bordure du <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel dans la direction spécifiée, ou <ph id="ph2">&lt;see cref="P:System.Windows.Rect.Empty" /&gt;</ph> si des informations valides de disposition sont indisponibles.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source><ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> edges are not considered content for the purposes of this method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> bords ne sont pas considérés comme contenu dans le cadre de cette méthode.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is positioned before a <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> edge, the return value is a bounding box for the next non-<ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> content in the specified direction.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> est placé avant une <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> bord, la valeur de retour est un cadre englobant pour le prochain non -<ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> contenu dans la direction spécifiée.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>If there is no content in the specified direction, a zero-width <ph id="ph1">&lt;xref:System.Windows.Rect&gt;</ph> is returned with a height matching the height of any preceding content.</source>
          <target state="translated">Si aucun contenu n’est dans la direction spécifiée, une largeur nulle <ph id="ph1">&lt;xref:System.Windows.Rect&gt;</ph> est retourné avec une hauteur correspondant à celle de n’importe quel précédents contenu.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>The operation performed by this method depends on a valid layout.</source>
          <target state="translated">L’opération exécutée par cette méthode dépend d’une disposition valide.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>When necessary, this method attempts to automatically regenerate a valid layout before proceeding with the operation.</source>
          <target state="translated">Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>Regenerating a layout can be a relatively expensive operation.</source>
          <target state="translated">Régénérer une disposition peut être une opération relativement coûteuse.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> property to check for a valid layout before performing operations that may regenerate the layout.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> propriété à vérifier pour une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>disposition<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to search for the closest insertion position.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle rechercher la position d'insertion la plus proche.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the closest insertion position in the specified logical direction.</source>
          <target state="translated">Renvoie un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la position d'insertion la plus proche dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the closest insertion position in the specified direction.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> vers la position d'insertion la plus proche dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>An insertion position is a position where new content may be added without breaking any semantic rules for the associated content.</source>
          <target state="translated">Une position d’insertion est une position où le nouveau contenu peut être ajouté sans les règles sémantiques concernant le contenu associé.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>In practice, an insertion position is anywhere in content where a caret may be positioned.</source>
          <target state="translated">Dans la pratique, une position d’insertion se trouve n’importe où dans le contenu où un point d’insertion peut être positionnée.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>An example of a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position that is not an insertion position is the position between two adjacent <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> tags (that is, between the closing tag of the preceding paragraph and the opening tag of the next paragraph).</source>
          <target state="translated">Un exemple de valide <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position qui n’est pas une position d’insertion est la position entre deux adjacents <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et la balise d’ouverture du paragraphe suivant).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> already points to a valid insertion position, but the closing tag for a non-empty formatting sequence directly follows that position in the given direction, then the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> returned by this method is adjusted to point to the insertion position just after the close of the formatting sequence.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> déjà pointe vers une position d’insertion valide, mais la balise de fermeture pour une séquence de mise en forme non vide suit directement cette position dans la direction donnée, puis le <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> retourné par cette méthode est ajustée pour pointer sur l’insertion position juste après la fermeture de la séquence de mise en forme.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>For example, consider the markup sequence <ph id="ph1">`&lt;Bold&gt;a&lt;/Bold&gt;b`</ph>.</source>
          <target state="translated">Par exemple, considérez la séquence de balise <ph id="ph1">`&lt;Bold&gt;a&lt;/Bold&gt;b`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>Note that there are two insertion positions between the letters <ph id="ph1">`a`</ph> and <ph id="ph2">`b`</ph> — one that precedes the closing <ph id="ph3">`Bold`</ph> tag, and one directly following the closing <ph id="ph4">`Bold`</ph> tag.</source>
          <target state="translated">Notez qu’il existe deux positions d’insertion entre les lettres <ph id="ph1">`a`</ph> et <ph id="ph2">`b`</ph> , qui précède le <ph id="ph3">`Bold`</ph> balise et directement après la fermeture de l’autre <ph id="ph4">`Bold`</ph> balise.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>If <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> is called on a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to the position directly after the letter <ph id="ph3">`a`</ph> and before of the closing <ph id="ph4">`Bold`</ph> tag, and with a <ph id="ph5">`direction`</ph> of <ph id="ph6">&lt;xref:System.Windows.Documents.LogicalDirection.Forward&gt;</ph>, the returned <ph id="ph7">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is adjusted to point to the position just before the letter <ph id="ph8">`b`</ph>, after the closing <ph id="ph9">`Bold`</ph> tag.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> est appelée sur une <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> à la position juste après la lettre <ph id="ph3">`a`</ph> et avant la fermeture <ph id="ph4">`Bold`</ph> balise et avec un <ph id="ph5">`direction`</ph> de <ph id="ph6">&lt;xref:System.Windows.Documents.LogicalDirection.Forward&gt;</ph>, retourné <ph id="ph7">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> est ajusté pour pointer sur le position juste avant la lettre <ph id="ph8">`b`</ph>, après la fermeture <ph id="ph9">`Bold`</ph> balise.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>A similar adjustment is made for opening formatting tags when working in the opposite logical direction.</source>
          <target state="translated">Un ajustement similaire est pour la mise en forme de balises d’ouverture lorsque vous travaillez dans l’autre sens logique.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This method is intended to provide a means of disambiguation between insertion positions in similar cases.</source>
          <target state="translated">Cette méthode est destinée à fournir un moyen de l’ambiguïté entre les positions d’insertion dans des cas similaires.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This method can also be used to be selective about insertion points when a sequence of structural tags is involved.</source>
          <target state="translated">Cette méthode peut également servir à sélectionner les points d’insertion lorsqu’une séquence de balises structurelles est impliquée.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>For example, when at a position between closing and opening paragraph tags, the direction parameter can be used to select the closest insertion point at the beginning of the following paragraph (by specifying <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType&gt;</ph>) or at the end of the preceding paragraph (by specifying <ph id="ph2">&lt;xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Par exemple, lorsque placé entre les balises de paragraphe d’ouverture et de clôture, le paramètre de direction peut être utilisé pour sélectionner le point d’insertion le plus proche au début du paragraphe suivant (en spécifiant <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType&gt;</ph>) ou à la fin de la précédente de paragraphe ( en spécifiant <ph id="ph2">&lt;xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>If the pointer is already at insertion position, and there are no adjacent formatting tags in the specified <ph id="ph1">`direction`</ph>, the returned <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> points to the same position as the calling <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</source>
          <target state="translated">Si le pointeur est déjà à la position d’insertion, et aucune balise de mise en forme adjacente spécifié <ph id="ph1">`direction`</ph>, retourné <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> pointe vers la même position que l’appel <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>It is possible that no valid insertion position exists relative to the position pointed to by a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</source>
          <target state="translated">Il est possible qu’aucune position d’insertion valide n’existe par rapport à la position pointée par un <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This can happen if the referenced content is structurally incomplete, as in an empty table or list.</source>
          <target state="translated">Cela peut se produire si le contenu référencé est structurellement incomplète, comme dans une table vide ou une liste.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>In such cases, this method simply returns a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to the same position as the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> from which this method was called.</source>
          <target state="translated">Dans ce cas, cette méthode retourne simplement une <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> à la même position que le <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> à partir de laquelle cette méthode a été appelée.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This method always returns a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</source>
          <target state="translated">Cette méthode retourne toujours une valide <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> method to check whether a specified <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> is empty of printable content.</source>
          <target state="translated">Cet exemple montre comment utiliser le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> méthode permettant de vérifier si un <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> est dépourvu de contenu imprimable.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="T:System.Windows.Documents.TextPointer">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the beginning of a line that is specified relative to the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Renvoie un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> au début d'une ligne spécifiée par rapport au <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>The number of start-of-line markers to skip when determining the line for which to return the starting position.</source>
          <target state="translated">Le nombre de marqueurs début-de-ligne à ignorer pour déterminer la ligne à laquelle renvoyer la position de départ.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</source>
          <target state="translated">Les valeurs négatives spécifient des lignes précédentes, 0 spécifie la ligne actuelle, et les valeurs positives spécifient des lignes suivantes.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the beginning of a line that is specified relative to the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Renvoie un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> au début d'une ligne spécifiée par rapport au <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> pointing to the beginning of the specified line (with the <ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Documents.LogicalDirection.Forward" /&gt;</ph>), or <ph id="ph4">&lt;see langword="null" /&gt;</ph> if the specified line is out of range or otherwise cannot be located.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> pointant vers le début de la ligne spécifiée (avec le <ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> paramétré sur <ph id="ph3">&lt;see cref="F:System.Windows.Documents.LogicalDirection.Forward" /&gt;</ph>), ou <ph id="ph4">&lt;see langword="null" /&gt;</ph> si la ligne spécifiée est hors limites ou  ne peut pas être localisée.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> points to an ambiguous position, for example, between two lines, the line in the direction specified by <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> is selected as the relative starting line.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> est sélectionné comme ligne de départ relative.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>The operation performed by this method depends on a valid layout.</source>
          <target state="translated">L’opération exécutée par cette méthode dépend d’une disposition valide.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>When necessary, this method attempts to automatically regenerate a valid layout before proceeding with the operation.</source>
          <target state="translated">Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>Regenerating a layout can be a relatively expensive operation.</source>
          <target state="translated">Régénérer une disposition peut être une opération relativement coûteuse.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> to check for a valid layout before performing operations that may regenerate the layout.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> pour vérifier une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>disposition<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>The number of start-of-line markers to skip when determining the line for which to return the starting position.</source>
          <target state="translated">Le nombre de marqueurs début-de-ligne à ignorer pour déterminer la ligne à laquelle renvoyer la position de départ.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</source>
          <target state="translated">Les valeurs négatives spécifient des lignes précédentes, 0 spécifie la ligne actuelle, et les valeurs positives spécifient des lignes suivantes.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>When this method returns, contains the actual number of start-of-line markers that were skipped when determining the line for which to return the starting position.</source>
          <target state="translated">Le renvoie de cette méthode contient le nombre réel de marqueurs début-de-ligne ignorés pour déterminer la ligne à laquelle renvoyer la position de départ.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>This value may be less than <bpt id="p1">&lt;c&gt;</bpt>count<ept id="p1">&lt;/c&gt;</ept> if the beginning or end of content is encountered before the specified number of lines are skipped.</source>
          <target state="translated">Cette valeur peut être inférieure à <bpt id="p1">&lt;c&gt;</bpt>count<ept id="p1">&lt;/c&gt;</ept> si le début ou la fin du contenu est trouvé avant que le nombre spécifié de lignes soit ignorées.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the beginning of a line that is specified relative to the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, and reports how many lines were skipped.</source>
          <target state="translated">Renvoie un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> au début d'une ligne spécifiée par rapport au <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>actuel, et renseigne sur le nombre de lignes ignorées.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> pointing to the beginning of the specified line (with the <ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Documents.LogicalDirection.Forward" /&gt;</ph>), or to the beginning of the line closest to the specified line if the specified line is out of range.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> pointant vers le début de la ligne spécifiée (avec le <ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> paramétré sur <ph id="ph3">&lt;see cref="F:System.Windows.Documents.LogicalDirection.Forward" /&gt;</ph>), ou vers le début de la ligne la plus proche de la ligne spécifiée si celle-ci est hors limites.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> points to an ambiguous position, for example, between two lines, the line in the direction specified by the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> property is selected as the relative starting line.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par la <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> propriété est sélectionnée comme ligne de départ relative.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to search for the next symbol.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle rechercher le prochain symbole.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>Returns a pointer to the next symbol in the specified logical direction.</source>
          <target state="translated">Renvoie un pointeur vers le prochain symbole dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the next symbol in the requested direction, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> borders the start or end of content.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> au prochain symbole dans la direction requise, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si le <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel borde le début ou la fin du contenu.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Les éléments suivants est considéré comme un symbole :</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>An opening or closing tag for a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Une balise d’ouverture ou de fermeture pour un <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> élément contenu dans un <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Notez que ce un <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ne sont pas comptés comme des symboles.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">16 bits <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> caractère à l’intérieur d’un texte <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>If the next symbol is categorized as <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.EmbeddedElement&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointerContext.ElementStart&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointerContext.ElementEnd&gt;</ph> (as identified by the <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> method), then the <ph id="ph5">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> returned by this method is advanced by exactly one symbol from the current position.</source>
          <target state="translated">Si le symbole suivant est classé dans la <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.EmbeddedElement&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointerContext.ElementStart&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointerContext.ElementEnd&gt;</ph> (identifié par le <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> (méthode)), puis le <ph id="ph5">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> retourné par cette méthode est avancé d’exactement un symbole à partir de la position actuelle.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>If the next symbol is categorized as <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph>, then the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> returned by this method is advanced past the text to the next non-text symbol (that is, the next position where the <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointerContext&gt;</ph> is not <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph>).</source>
          <target state="translated">Si le symbole suivant est classé <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph>, le <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> retourné par cette méthode outrepasse le texte vers le prochain symbole de non-texte (autrement dit, la prochaine position où le <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointerContext&gt;</ph> n’est pas <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>The exact symbol count crossed can be calculated in advance by calling the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A&gt;</ph> method.</source>
          <target state="translated">Le compte exact de symboles rencontrés peut être calculé à l’avance en appelant le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de cette méthode.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A&gt;</ph> method in conjunction with the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> method to traverse and extract the symbols in a specified <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A&gt;</ph> méthode conjointement avec la <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> méthode pour parcourir et extraire les symboles dans un <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>While the example can be used to extract a <ph id="ph1">[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]</ph> structure for the contents of a given <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>, it is intended for illustrative purposes only, and should not be used in production code.</source>
          <target state="translated">Tandis que l’exemple peut être utilisé pour extraire un <ph id="ph1">[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]</ph> structure pour le contenu d’un donné <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>, il est destiné uniquement à des fins d’illustration et ne doit pas être utilisé dans le code de production.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>See the <ph id="ph1">&lt;xref:System.Xml&gt;</ph> namespace for a rich set of types designed for working with and processing XML.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Xml&gt;</ph> espace de noms pour un ensemble complet de types conçus pour travailler avec et le traitement XML.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to search for the next insertion position.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle rechercher la prochaine position d'insertion.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the next insertion position in the specified logical direction.</source>
          <target state="translated">Renvoie un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la prochaine position d'insertion dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> that identifies the next insertion position in the requested direction, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no next insertion position can be found.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> qui  identifie la prochaine position d'insertion dans la direction requise, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si aucune n'est décelable.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>An <bpt id="p1">*</bpt>insertion position<ept id="p1">*</ept> is a position where new content may be added without breaking any semantic rules for the associated content.</source>
          <target state="translated">Un <bpt id="p1">*</bpt>d’insertion<ept id="p1">*</ept> est une position où le nouveau contenu peut être ajouté sans les règles sémantiques concernant le contenu associé.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>In practice, an insertion position is anywhere in content where a caret may be positioned.</source>
          <target state="translated">Dans la pratique, une position d’insertion se trouve n’importe où dans le contenu où un point d’insertion peut être positionnée.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>An example of a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position that is not an insertion position is the position between two adjacent <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> tags (that is, between the closing tag of the preceding paragraph and the opening tag of the next paragraph).</source>
          <target state="translated">Un exemple de valide <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position qui n’est pas une position d’insertion est la position entre deux adjacents <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et la balise d’ouverture du paragraphe suivant).</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de cette méthode.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph> method to traverse content element boundaries in order to count the number of <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> elements present between two specified <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph> méthode pour parcourir les limites de l’élément de contenu afin de compter le nombre de <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> éléments présents entre deux spécifié <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> that specifies a position to find the distance (in symbols) to.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> qui spécifie une position pour laquelle la distance (en symboles) doit être trouvée.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>Returns the count of symbols between the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and a second specified <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Renvoie le compte de symboles entre le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel et un second <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>spécifié.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>The relative number of symbols between the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and <ph id="ph2">&lt;paramref name="position" /&gt;</ph>.</source>
          <target state="translated">Le nombre relatif de symboles entre le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel et <ph id="ph2">&lt;paramref name="position" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>A negative value indicates that the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> follows the position specified by <ph id="ph2">&lt;paramref name="position" /&gt;</ph>, 0 indicates that the positions are equal, and a positive value indicates that the current <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> precedes the position specified by <ph id="ph4">&lt;paramref name="position" /&gt;</ph>.</source>
          <target state="translated">Une valeur négative indique que le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel suit la position spécifiée par <ph id="ph2">&lt;paramref name="position" /&gt;</ph>, 0 indique que les positions sont égales, et une valeur positive indique que le <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel précède la position spécifiée par <ph id="ph4">&lt;paramref name="position" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Les éléments suivants est considéré comme un symbole :</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>An opening or closing tag for a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Une balise d’ouverture ou de fermeture pour un <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> élément contenu dans un <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Notez que ce un <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ne sont pas comptés comme des symboles.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">16 bits <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> caractère à l’intérieur d’un texte <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de cette méthode.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> method to find the offsets for two <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances, and then uses this information to save and restore the selection in a <ph id="ph3">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph>.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> méthode pour rechercher les offsets pour deux <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances et utilise ensuite ces informations pour enregistrer et restaurer la sélection dans un <ph id="ph3">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>The example assumes that the contents of the <ph id="ph1">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph> have not changed between a selection save and a selection restore.</source>
          <target state="translated">L’exemple suppose que le contenu de la <ph id="ph1">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph> n’ont pas changé entre une sauvegarde de sélection et une restauration de sélection.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> specifies a position outside of the text container associated with the current position.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> spécifie une position en dehors du conteneur de texte associé à la position actuelle.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to determine the category for adjacent content.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle déterminer la catégorie de contenu adjacent.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>Returns a category indicator for the content adjacent to the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified logical direction.</source>
          <target state="translated">Renvoie un indicateur de catégorie pour le contenu adjacent au <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointerContext" /&gt;</ph> values that indicates the category for adjacent content in the specified logical direction.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointerContext" /&gt;</ph> qui indiquent la catégorie pour contenu adjacent dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de cette méthode.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> method to implement an algorithm for calculating the balance of opening and closing element tags between two specified <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> positions.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> méthode pour implémenter un algorithme de calcul de l’équilibre entre les balises d’élément entre deux spécifié <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> positions.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>Each opening element tag is counted as +1, and each closing element tag is counted as –1.</source>
          <target state="translated">Chaque balise d’élément d’ouverture est comptée comme + 1 et chaque balise d’élément de fermeture est comptée comme – 1.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="T:System.Windows.Documents.TextPointer">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, in symbols, from the beginning of content.</source>
          <target state="translated">Renvoie un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la position indiquée par l'offset spécifié, dans les symboles, à partir du début du contenu.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>An offset, in symbols, for which to calculate and return the position.</source>
          <target state="translated">Un offset, dans les symboles, pour lequel calculer et renvoyer la position.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>If the offset is negative, the position is calculated in the logical direction opposite of that indicated by the <ph id="ph1">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> property.</source>
          <target state="translated">Si l'offset est négatif, la position est calculée dans la direction logique opposée de celle indiqué par la propriété <ph id="ph1">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, in symbols, from the beginning of the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Renvoie un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la position indiquée par l'offset spécifié, dans les symboles, à partir du début du <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>actuel.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no corresponding position can be found.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la position indiquée par le décalage spécifié, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si aucune position correspondante n'est trouvée.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Les éléments suivants est considéré comme un symbole :</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>An opening or closing tag for the <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Une balise d’ouverture ou de fermeture pour le <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> élément contenu dans un <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Notez que ce un <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ne sont pas comptés comme des symboles.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">16 bits <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> caractère à l’intérieur d’un texte <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de cette méthode.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> method to implement a pair of methods, one to calculate the offset to a specified position relative to any hosting paragraph, and the other to return a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to a specified offset in a specified paragraph.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> méthode pour implémenter une paire de méthodes, une pour calculer l’offset à une position spécifiée par rapport à tout paragraphe d’hébergement et l’autre pour renvoyer un <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> à un offset spécifié dans un paragraphe particulier.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>An offset, in symbols, for which to calculate and return the position.</source>
          <target state="translated">Un offset, dans les symboles, pour lequel calculer et renvoyer la position.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>If the offset is negative, the returned <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> precedes the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>; otherwise, it follows.</source>
          <target state="translated">Si l'offset est négatif, le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> retourné précède le <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>actuel ; sinon, il suit.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction of the returned <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>qui spécifient la direction logique du <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>retourné.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, in symbols, from the beginning of the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and in the specified direction.</source>
          <target state="translated">Renvoie un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la position indiquée par l'offset spécifié, dans les symboles, à partir du début du <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>actuel et dans la direction spécifiée.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the offset extends past the end of the content.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> à la position indiquée par le décalage spécifié, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si le décalage s’étend au-delà de la fin du contenu.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Les éléments suivants est considéré comme un symbole :</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>An opening or closing tag for the <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Une balise d’ouverture ou de fermeture pour le <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> élément contenu dans un <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Notez que ce un <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ne sont pas comptés comme des symboles.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">16 bits <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> caractère à l’intérieur d’un texte <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="T:System.Windows.Documents.TextPointer">
          <source>Returns text adjacent to the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Renvoie du texte adjacent au <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>actuel.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to find and return any adjacent text.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle trouver et renvoyer tout texte adjacent.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>Returns a string containing any text adjacent to the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified logical direction.</source>
          <target state="translated">Renvoie une chaîne contenant tout texte adjacent au <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>A string containing any adjacent text in the specified logical direction, or <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if no adjacent text can be found.</source>
          <target state="translated">Une chaîne contenant tout texte adjacent dans la direction logique spécifiée, ou <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> si aucun texte adjacent n'est décelable.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>This method returns only uninterrupted runs of text.</source>
          <target state="translated">Cette méthode retourne uniquement les exécutions de texte ininterrompues.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>Nothing is returned if any symbol type other than <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph> is adjacent to the current <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> in the specified direction.</source>
          <target state="translated">Rien n’est retourné si un type de symbole autre que <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph> est adjacent à actuel <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> dans la direction spécifiée.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>Similarly, text is returned only up to the next non-text symbol.</source>
          <target state="translated">De même, le texte est renvoyé uniquement jusqu'à un symbole non textuelles suivant.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de cette méthode.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextInRun%2A&gt;</ph> method to implement a simple text extractor.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextInRun%2A&gt;</ph> méthode pour implémenter un extracteur de texte simple.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>The method returns a string concatenation of all text between two specified <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances.</source>
          <target state="translated">La méthode renvoie une concaténation de chaînes de tout le texte entre deux spécifié <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>While the example can be used to extract any text between two <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances, it is intended for illustrative purposes only, and should not be used in production code.</source>
          <target state="translated">Si l’exemple peut être utilisé pour extraire tout texte entre deux <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances, il est destiné uniquement à des fins d’illustration et ne doit pas être utilisé dans le code de production.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Utilisez la propriété <ph id="ph1">&lt;xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to find and copy any adjacent text.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle trouver et copier tout texte adjacent.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>A buffer into which any text is copied.</source>
          <target state="translated">Une mémoire tampon dans laquelle tout texte est copié.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>An index into <bpt id="p1">&lt;c&gt;</bpt>textBuffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing copied text.</source>
          <target state="translated">Index dans <bpt id="p1">&lt;c&gt;</bpt>textBuffer<ept id="p1">&lt;/c&gt;</ept> auquel commencer l'écriture du texte copié.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>The maximum number of characters to copy.</source>
          <target state="translated">Nombre maximum de caractères à copier.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>Copies the specified maximum number of characters from any adjacent text in the specified direction into a caller-supplied character array.</source>
          <target state="translated">Copie le nombre maximal spécifié de caractères à partir de tout texte adjacent dans la direction spécifiée dans un tableau de caractères fourni par un appelant.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>The number of characters actually copied into <ph id="ph1">&lt;paramref name="textBuffer" /&gt;</ph>.</source>
          <target state="translated">Nombre réel de caractères copiés dans <ph id="ph1">&lt;paramref name="textBuffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>This method returns only uninterrupted runs of text.</source>
          <target state="translated">Cette méthode retourne uniquement les exécutions de texte ininterrompues.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>Nothing is returned if any symbol type other than <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph> is adjacent to the current <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> in the specified direction.</source>
          <target state="translated">Rien n’est retourné si un type de symbole autre que <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph> est adjacent à actuel <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> dans la direction spécifiée.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>Similarly, text is returned only up to the next non-text symbol.</source>
          <target state="translated">De même, le texte est renvoyé uniquement jusqu'à un symbole non textuelles suivant.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 or greater than the <ph id="ph2">&lt;see cref="P:System.Array.Length" /&gt;</ph> property of <ph id="ph3">&lt;paramref name="textBuffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> est inférieur à 0 ou supérieur à la propriété <ph id="ph2">&lt;see cref="P:System.Array.Length" /&gt;</ph> de <ph id="ph3">&lt;paramref name="textBuffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0 or greater than the remaining space in <ph id="ph2">&lt;paramref name="textBuffer" /&gt;</ph> (<ph id="ph3">&lt;paramref name="textBuffer" /&gt;</ph>.<ph id="ph4">&lt;see cref="P:System.Array.Length" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à 0 ou supérieur à l'espace restant dans <ph id="ph2">&lt;paramref name="textBuffer" /&gt;</ph> (<ph id="ph3">&lt;paramref name="textBuffer" /&gt;</ph>.<ph id="ph4">&lt;see cref="P:System.Array.Length" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>minus <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>).</source>
          <target state="translated">moins <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to count the number of characters.</source>
          <target state="translated">L'une des valeurs <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui spécifient la direction logique dans laquelle compter le nombre de caractères.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>Returns the number of Unicode characters between the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and the next non-text symbol, in the specified logical direction.</source>
          <target state="translated">Renvoie le nombre de caractères Unicode entre le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel et le prochain symbole de non-texte, dans la direction logique spécifiée.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>The number of Unicode characters between the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and the next non-text symbol.</source>
          <target state="translated">Le nombre de caractères Unicode entre le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> actuel et le prochain symbole de non-texte.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>This number may be 0 if there is no adjacent text.</source>
          <target state="translated">Ce nombre peut être 0 s'il n'y a aucun texte adjacent.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Les éléments suivants est considéré comme un symbole :</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>An opening or closing tag for the <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Une balise d’ouverture ou de fermeture pour le <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> élément contenu dans un <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Notez que ce un <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ne sont pas comptés comme des symboles.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">16 bits <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> caractère à l’intérieur d’un texte <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> élément.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>Gets a value that indicates whether the text container associated with the current position has a valid (up-to-date) layout.</source>
          <target state="translated">Obtient une valeur indiquant si le conteneur de texte associé à la position actuelle a une disposition valide (mise à jour).</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the layout is current and valid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>si la disposition actuelle est valide ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>When necessary, operations that depend on a valid layout (such as the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A&gt;</ph> method, <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A&gt;</ph> method, and <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A&gt;</ph> property) attempt to automatically regenerate a valid layout before proceeding with the operation.</source>
          <target state="translated">Lorsque cela est nécessaire, les opérations qui dépendent d’une disposition valide (comme le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A&gt;</ph> (méthode), <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A&gt;</ph> (méthode), et <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A&gt;</ph> propriété) essayez de régénérer automatiquement une disposition valide avant de poursuivre l’opération.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>Regenerating a layout can be a relatively expensive operation.</source>
          <target state="translated">Régénérer une disposition peut être une opération relativement coûteuse.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>Use this property to check for a valid layout before performing operations that may regenerate the layout.</source>
          <target state="translated">Utilisez cette propriété pour vérifier une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>disposition<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertLineBreak">
          <source>Inserts a line break at the current position.</source>
          <target state="translated">Insère un saut de ligne à la position actuelle.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertLineBreak">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> positioned immediately after the <ph id="ph2">&lt;see cref="T:System.Windows.Documents.LineBreak" /&gt;</ph> element inserted by this method.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> positionné immédiatement après l'élément <ph id="ph2">&lt;see cref="T:System.Windows.Documents.LineBreak" /&gt;</ph> a inséré par cette méthode.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>Inserts a paragraph break at the current position.</source>
          <target state="translated">Insère un arrêt de paragraphe à la position actuelle.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the beginning (<ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextElement.ContentStart" /&gt;</ph>) of the new paragraph.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> au début (<ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextElement.ContentStart" /&gt;</ph>) du nouveau paragraphe.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>If this method is called when the current position is inside of an existing <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, the existing paragraph and any content it contains are split into two paragraphs at the current position.</source>
          <target state="translated">Si cette méthode est appelée lorsque la position actuelle est à l’intérieur d’un existant <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> élément, le paragraphe existant et tout son contenu sont divisées en deux paragraphes à la position actuelle.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>If this method is called when the current position is not inside of an existing paragraph, a new, empty paragraph is inserted.</source>
          <target state="translated">Si cette méthode est appelée lorsque la position actuelle n’est pas à l’intérieur d’un paragraphe existant, un nouveau paragraphe vide est inséré.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>If this method is called at a position unsuitable for splitting or inserting a paragraph (for example, if the current position is inside of a <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> element), an exception is thrown.</source>
          <target state="translated">Si cette méthode est appelée à une position illisible pour fractionner ou l’insertion d’un paragraphe (par exemple, si la position actuelle est à l’intérieur d’un <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> élément), une exception est levée.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>This method is called on a position that cannot be split to accommodate a new paragraph, such as in the scope of a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Hyperlink" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Windows.Documents.InlineUIContainer" /&gt;</ph>.</source>
          <target state="translated">Cette méthode est appelée sur une position ne pouvant pas être fractionnée pour accommoder un nouveau paragraphe, tel que dans la portée d'un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Hyperlink" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Windows.Documents.InlineUIContainer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source>The text to insert.</source>
          <target state="translated">Texte à insérer.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source>Inserts the specified text into the text <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Run" /&gt;</ph> at the current position.</source>
          <target state="translated">Insère le texte spécifié dans le texte <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Run" /&gt;</ph> à la position actuelle.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is not scoped by a <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element, a <ph id="ph3">&lt;xref:System.Windows.Documents.Run&gt;</ph> is inserted along with the <ph id="ph4">`textData`</ph>.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> n’est pas limité par un <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> élément, un <ph id="ph3">&lt;xref:System.Windows.Documents.Run&gt;</ph> est insérée avec la <ph id="ph4">`textData`</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source>The current position is not within a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Run" /&gt;</ph> element.</source>
          <target state="translated">La position actuelle n'est pas dans un élément <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Run" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source><ph id="ph1">&lt;paramref name="textData" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="textData" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source>Gets a value that indicates whether the current position is an insertion position.</source>
          <target state="translated">Obtient une valeur indiquant si la position actuelle est une position d'insertion.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current position is an insertion position; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la position actuelle est une position d'insertion ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source>An insertion position is a position where new content may be added without breaking any semantic rules for the associated content.</source>
          <target state="translated">Une position d’insertion est une position où le nouveau contenu peut être ajouté sans les règles sémantiques concernant le contenu associé.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source>In practice, an insertion position is anywhere in content where a caret may be positioned.</source>
          <target state="translated">Dans la pratique, une position d’insertion se trouve n’importe où dans le contenu où un point d’insertion peut être positionnée.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source>An example of a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position that is not an insertion position is the position between two adjacent <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> tags (that is, between the closing tag of the preceding paragraph and the opening tag of the next paragraph).</source>
          <target state="translated">Un exemple de valide <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position qui n’est pas une position d’insertion est la position entre deux adjacents <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et la balise d’ouverture du paragraphe suivant).</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>Gets a value that indicates whether the current position is at the beginning of a line.</source>
          <target state="translated">Obtient une valeur indiquant si la position actuelle est au début d'une ligne.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current position is at the beginning of a line; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la position actuelle est au début d'une ligne; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> points to an ambiguous position, for example, between two lines, the line in the direction specified by the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> property is selected as the relative starting line.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par la <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> propriété est sélectionnée comme ligne de départ relative.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>The operation performed by this property depends on a valid layout.</source>
          <target state="translated">L’opération exécutée par cette propriété dépend de la validité de la disposition.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>When necessary, this method attempts to automatically regenerate a valid layout before proceeding with the operation.</source>
          <target state="translated">Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>Regenerating a layout can be a relatively expensive operation.</source>
          <target state="translated">Régénérer une disposition peut être une opération relativement coûteuse.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> property to check for a valid layout before performing operations that may regenerate the layout.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> propriété à vérifier pour une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>disposition<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> that specifies a position to compare to the current position.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> qui spécifie une position à comparer à la position actuelle.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>Indicates whether the specified position is in the same text container as the current position.</source>
          <target state="translated">Indique si la position spécifiée est dans le même conteneur de texte que la  position actuelle.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="textPosition" /&gt;</ph> indicates a position that is in the same text container as the current position; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="textPosition" /&gt;</ph> indique une position qui est dans le même conteneur de texte que la position actuelle ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>Most operations that involve multiple <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances are only valid if the instances in question indicate positions that are in the same text container scope.</source>
          <target state="translated">La plupart des opérations qui impliquent plusieurs <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances ne sont valides que si les instances en question indiquent les positions qui se trouvent dans la même étendue de conteneur de texte.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>For example the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> methods cannot be used with a <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to a position outside of the text container associated with the current position.</source>
          <target state="translated">Par exemple le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> méthodes ne peut pas être utilisés avec un <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> à une position en dehors du conteneur de texte associé à la position actuelle.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>Use this method to verify that a specified <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is compatible with the current position for such operations.</source>
          <target state="translated">Utilisez cette méthode pour vérifier que spécifié <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> est compatible avec la position actuelle pour ces opérations.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de cette méthode.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A&gt;</ph> method to check whether a specified <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is positioned between two other specified <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances in a situation when there is no guarantee that all three positions belong to the same text container.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A&gt;</ph> méthode permettant de vérifier si un <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> placé entre deux autres spécifié <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances dans une situation lorsqu’il n’existe aucune garantie que les trois positions appartiennent au même conteneur de texte.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source><ph id="ph1">&lt;paramref name="textPosition" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="textPosition" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.LogicalDirection">
          <source>Gets the logical direction associated with the current position which is used to disambiguate content associated with the current position.</source>
          <target state="translated">Obtient la direction logique associée à la position actuelle utilisée pour lever l'ambiguïté du contenu associé à la position actuelle.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.LogicalDirection">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> value that is associated with the current position.</source>
          <target state="translated">La valeur <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> qui est associée à la position actuelle.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.LogicalDirection">
          <source>As an example of how this property is used, the <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection&gt;</ph> of the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> returned by a hit test method gives a hit that is between two characters of text.</source>
          <target state="translated">Comme exemple d’utilisation de cette propriété, le <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection&gt;</ph> de la <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> retourné par un test de positionnement méthode donne un accès entre deux caractères de texte.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.LogicalDirection">
          <source>The logical direction specifies which of the two characters was actually hit—the left or the right.</source>
          <target state="translated">La direction logique spécifie lequel des deux caractères a été réellement atteint, la gauche ou la droite.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.Paragraph">
          <source>Gets the paragraph that scopes the current position, if any.</source>
          <target state="translated">Obtient le paragraphe dans la portée de la position actuelle, s'il en est.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.Paragraph">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Paragraph" /&gt;</ph> that scopes the current position, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no such paragraph exists.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Paragraph" /&gt;</ph> portant sur la position actuelle, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si aucun paragraphe de ce type n’existe.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.Parent">
          <source>Gets the logical parent that scopes the current position.</source>
          <target state="translated">Obtient le parent logique portant sur la position actuelle.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.Parent">
          <source>The logical parent that scopes the current position.</source>
          <target state="translated">Le parent logique portant sur la position actuelle.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.ToString">
          <source>This type or member supports the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> infrastructure and is not intended to be used directly from your code.</source>
          <target state="translated">Ce type ou membre prend en charge l’infrastructure <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> et n’est pas destiné à être utilisé directement à partir de votre code.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.ToString">
          <source>The string that represents the object.</source>
          <target state="translated">Chaîne qui représente l'objet.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>