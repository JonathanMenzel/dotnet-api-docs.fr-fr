<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d374acbfa59bece9a23ff4841ba74263d0c6fa42" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30630713" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente une position dans un <see cref="T:System.Windows.Documents.FlowDocument" /> ou <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Documents.TextPointer> classe introduit la terminologie suivante :  
  
-   Position fondamentale - un <xref:System.Windows.Documents.TextPointer> pointe toujours vers un *position* dans le contenu.  De telles positions tombent entre des caractères dans le contenu ou flux de contenu de balises de l’élément qui définissent la structure pour le contenu.  
  
-   Position actuelle – comme un <xref:System.Windows.Documents.TextPointer> indique toujours une position et parce qu’un grand nombre des opérations qui peuvent être effectuées via une <xref:System.Windows.Documents.TextPointer> sont par rapport à la position actuellement vers lequel pointée le <xref:System.Windows.Documents.TextPointer>, il est judicieux d’appeler le position indiquée par un <xref:System.Windows.Documents.TextPointer> comme le *position actuelle*.  
  
-   Position d’insertion - une *d’insertion* est une position où le nouveau contenu peut être ajouté sans les règles sémantiques concernant le contenu associé.  Dans la pratique, une position d’insertion se trouve n’importe où dans le contenu où un point d’insertion peut être positionnée.  Un exemple de valide <xref:System.Windows.Documents.TextPointer> position qui n’est pas une position d’insertion est la position entre deux adjacents <xref:System.Windows.Documents.Paragraph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et la balise d’ouverture du paragraphe suivant).  
  
-   Symbole - pour les besoins de <xref:System.Windows.Documents.TextPointer> les opérations qui impliquent des symboles, les éléments suivants est considéré comme un *symbole*:  
  
    -   Une balise d’ouverture ou de fermeture pour un <xref:System.Windows.Documents.TextElement> élément.  
  
    -   A <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
    -   Chaque 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
-   Conteneur de texte - A *conteneur de texte* est l’élément qui forme la bordure ultime pour le contenu de flux à portée de main ; la position indiquée par un <xref:System.Windows.Documents.TextPointer> tombe toujours dans un conteneur de texte.  Actuellement, un conteneur de texte doit être un <xref:System.Windows.Documents.FlowDocument> ou <xref:System.Windows.Controls.TextBlock>.  En règle générale, les opérations entre <xref:System.Windows.Documents.TextPointer> instances dans différents conteneurs de texte ne sont pas pris en charge.  
  
-   Document - le contenu dans un conteneur de texte est appelé un *document*, comme dans le <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> (méthode) et le <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> et <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> propriétés.  
  
 Le <xref:System.Windows.Documents.TextPointer> classe est destinée à faciliter le parcours et la manipulation du contenu qui est représenté par [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] éléments de flux ; en général, de tels éléments dérivent <xref:System.Windows.Documents.TextElement>.  Certaines opérations qui <xref:System.Windows.Documents.TextPointer> facilite incluent les éléments suivants :  
  
-   Effectuer une comparaison ordinale de la position actuelle avec une seconde position spécifiée.  Consultez le <xref:System.Windows.Documents.TextPointer.CompareTo%2A> (méthode).  
  
-   Déterminez le type de contenu adjacent à la position actuelle dans une direction spécifiée.  Consultez le <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> méthode et <xref:System.Windows.Documents.TextPointerContext> énumération.  
  
-   Obtenir le <xref:System.Windows.Documents.TextElement> portant sur ou adjacent à la position actuelle.  Consultez <xref:System.Windows.Documents.Paragraph> et <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> (méthode).  
  
-   Obtenir le conteneur de texte portant sur le document actif.  Voir la propriété <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Obtenir un nombre spécifié de caractères précédant ou suivant la position actuelle.  Consultez le <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> (méthode).  
  
-   Insérez une chaîne de caractères à la position actuelle.  Consultez le <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> (méthode).  
  
-   Rechercher les limites de ligne dans le contenu.  Consultez le <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> méthode et <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriété.  
  
-   Convertir entre <xref:System.Windows.Documents.TextPointer> positions et le symbole des offsets dans le contenu.  Consultez le <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> et <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> méthodes.  
  
-   Exécuter des tests de positionnement visuels en traduisant entre une <xref:System.Windows.Documents.TextPointer> position et un <xref:System.Windows.Point> représentant des coordonnées relatives.  
  
-   Rechercher une position d’insertion proche, ou vérifier si la position actuelle est une position d’insertion.  Consultez le <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> et <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> méthodes et <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> propriété.  
  
 La position et <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indiquée par un <xref:System.Windows.Documents.TextPointer> objet sont immuables.  Lorsque le contenu est modifié ou modifié, la position indiquée par un <xref:System.Windows.Documents.TextPointer> ne change pas par rapport à texte qui l’entoure ; au lieu de cela, le décalage de cette position à partir du début du contenu est ajusté en conséquence pour refléter la nouvelle position relative dans contenu.  Par exemple, un <xref:System.Windows.Documents.TextPointer> qui indique une position au début d’un paragraphe donné continue à pointer vers le début de ce paragraphe, même lorsque le contenu est inséré ou supprimé avant ou après le paragraphe.  
  
 La <xref:System.Windows.Documents.TextPointer> classe ne fournit pas de constructeurs publics.  Une instance de <xref:System.Windows.Documents.TextPointer> est créé à l’aide des propriétés ou méthodes d’autres objets (y compris d’autres <xref:System.Windows.Documents.TextPointer> objets). La liste suivante fournit quelques exemples de méthodes et propriétés qui créent et renvoient un <xref:System.Windows.Documents.TextPointer>.  Cette liste n’est pas exhaustive :  
  
-   À partir d’un <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> et <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   À partir d’un <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, et <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   À partir d’un <xref:System.Windows.Controls.TextBlock> (conteneur de texte) : <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, et <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   À partir d’un <xref:System.Windows.Documents.FlowDocument> (conteneur de texte) : <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, et <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   À partir d’un fichier <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, et <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Documents.TextPointer> pour rechercher une position dans le premier <xref:System.Windows.Documents.Run> élément dans un conteneur de texte spécifié.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 L’exemple suivant implémente un algorithme de recherche simple à l’aide de <xref:System.Windows.Documents.TextPointer> installations.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Un <see cref="T:System.Windows.Documents.TextPointer" /> qui spécifie une position à comparer à la position actuelle.</param>
        <summary>Effectuer une comparaison ordinale entre les positions spécifiées par le <see cref="T:System.Windows.Documents.TextPointer" /> actuel et une seconde spécifié par <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>–1 si le <see cref="T:System.Windows.Documents.TextPointer" /> actuel précède <paramref name="position" />; 0 si les emplacements sont les mêmes ; +1 si le <see cref="T:System.Windows.Documents.TextPointer" /> actuel suit <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur – 1 indique que la position spécifiée par l’actuel <xref:System.Windows.Documents.TextPointer> précède la position spécifiée par `position`.  La valeur 0 indique que les positions indiquées sont égales.  Une valeur de + 1 positive indique que la position spécifiée par l’actuel <xref:System.Windows.Documents.TextPointer> suit la position spécifiée par `position`.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode.  Dans l’exemple, le <xref:System.Windows.Documents.TextPointer.CompareTo%2A> méthode est utilisée conjointement avec la <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> méthode pour tester si un <xref:System.Windows.Documents.TextElement> est vide.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> spécifie une position en dehors du conteneur de texte associé à la position actuelle.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Le nombre de caractères à supprimer, en commençant de la position actuelle. Spécifier une valeur positive pour supprimer les caractères suivant la position actuelle ; spécifier une valeur négative pour supprimer les caractères précédant la position actuelle.</param>
        <summary>Supprime le nombre spécifié de caractères de la position indiquée par le <see cref="T:System.Windows.Documents.TextPointer" />actuel.</summary>
        <returns>Le nombre de caractères réellement supprimés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécifiez une valeur positive pour supprimer les caractères qui suivent la position actuelle (comme dans <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) ; spécifiez une valeur négative pour supprimer les caractères qui précèdent la position actuelle (comme dans <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Le nombre de caractères réellement supprimés peut être inférieur au nombre spécifié par `count`.  Cela se produit dans les cas où `count` spécifie plus de caractères qu’existe pour être supprimé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode est appelée à une position où le texte n'est pas autorisé.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Windows.Documents.TextPointer" /> à la fin du contenu dans le conteneur de texte associé à la position actuelle.</summary>
        <value>Obtient un <see cref="T:System.Windows.Documents.TextPointer" /> à la fin du contenu dans le conteneur de texte associé à la position actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Documents.TextPointer.Parent%2A> pour retourné <xref:System.Windows.Documents.TextPointer> est toujours un conteneur de texte (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), plutôt qu’un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Windows.Documents.TextPointer" /> au début du contenu dans le conteneur de texte associé à la position actuelle.</summary>
        <value>Un <see cref="T:System.Windows.Documents.TextPointer" /> au début du contenu dans le conteneur de texte associé à la position actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la position retournée par cette propriété comme une position de ligne de base à partir de laquelle travailler avec des offsets relatifs à d’autres positions.  Le <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> et <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> méthodes fournissent un moyen de convertir entre les positions et la position des décalages.  
  
 Le <xref:System.Windows.Documents.TextPointer.Parent%2A> pour retourné <xref:System.Windows.Documents.TextPointer> est toujours un conteneur de texte (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), plutôt qu’un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle rechercher un élément adjacent.</param>
        <summary>Renvoie l'élément, s'il en est, qui limite le <see cref="T:System.Windows.Documents.TextPointer" /> actuel dans la direction logique spécifiée.</summary>
        <returns>L'élément adjacent dans la <paramref name="direction" />spécifiée, ou <see langword="null" /> si aucun élément adjacent n'existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’élément retourné est généralement un <xref:System.Windows.Documents.TextElement>.  A <xref:System.Windows.UIElement> peut être retourné lorsque le <xref:System.Windows.Documents.TextPointer> indique une position à l’intérieur d’un <xref:System.Windows.Documents.BlockUIContainer> élément ou un <xref:System.Windows.Documents.InlineUIContainer> élément.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle rechercher un cadre englobant de contenu.</param>
        <summary>Renvoie un cadre englobant (<see cref="T:System.Windows.Rect" />) pour du contenu en bordure du <see cref="T:System.Windows.Documents.TextPointer" /> actuel dans la direction logique spécifiée.</summary>
        <returns>Un cadre englobant pour du contenu en bordure du <see cref="T:System.Windows.Documents.TextPointer" /> actuel dans la direction spécifiée, ou <see cref="P:System.Windows.Rect.Empty" /> si des informations valides de disposition sont indisponibles.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> bords ne sont pas considérés comme contenu dans le cadre de cette méthode.  Si le <xref:System.Windows.Documents.TextPointer> est placé avant une <xref:System.Windows.Documents.TextElement> bord, la valeur de retour est un cadre englobant pour le prochain non -<xref:System.Windows.Documents.TextElement> contenu dans la direction spécifiée.  Si aucun contenu n’est dans la direction spécifiée, une largeur nulle <xref:System.Windows.Rect> est retourné avec une hauteur correspondant à celle de n’importe quel précédents contenu.  
  
 L’opération exécutée par cette méthode dépend d’une disposition valide.  Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.  Régénérer une disposition peut être une opération relativement coûteuse.  Utilisez le <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriété à vérifier pour une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.  Pour plus d’informations, consultez [disposition](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle rechercher la position d'insertion la plus proche.</param>
        <summary>Renvoie un <see cref="T:System.Windows.Documents.TextPointer" /> à la position d'insertion la plus proche dans la direction logique spécifiée.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> vers la position d'insertion la plus proche dans la direction logique spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une position d’insertion est une position où le nouveau contenu peut être ajouté sans les règles sémantiques concernant le contenu associé.  Dans la pratique, une position d’insertion se trouve n’importe où dans le contenu où un point d’insertion peut être positionnée.  Un exemple de valide <xref:System.Windows.Documents.TextPointer> position qui n’est pas une position d’insertion est la position entre deux adjacents <xref:System.Windows.Documents.Paragraph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et la balise d’ouverture du paragraphe suivant).  
  
 Si le <xref:System.Windows.Documents.TextPointer> déjà pointe vers une position d’insertion valide, mais la balise de fermeture pour une séquence de mise en forme non vide suit directement cette position dans la direction donnée, puis le <xref:System.Windows.Documents.TextPointer> retourné par cette méthode est ajustée pour pointer sur l’insertion position juste après la fermeture de la séquence de mise en forme. Par exemple, considérez la séquence de balise `<Bold>a</Bold>b`. Notez qu’il existe deux positions d’insertion entre les lettres `a` et `b` , qui précède le `Bold` balise et directement après la fermeture de l’autre `Bold` balise. Si <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> est appelée sur une <xref:System.Windows.Documents.TextPointer> à la position juste après la lettre `a` et avant la fermeture `Bold` balise et avec un `direction` de <xref:System.Windows.Documents.LogicalDirection.Forward>, retourné <xref:System.Windows.Documents.TextPointer> est ajusté pour pointer sur le position juste avant la lettre `b`, après la fermeture `Bold` balise. Un ajustement similaire est pour la mise en forme de balises d’ouverture lorsque vous travaillez dans l’autre sens logique. Cette méthode est destinée à fournir un moyen de l’ambiguïté entre les positions d’insertion dans des cas similaires.  
  
 Cette méthode peut également servir à sélectionner les points d’insertion lorsqu’une séquence de balises structurelles est impliquée. Par exemple, lorsque placé entre les balises de paragraphe d’ouverture et de clôture, le paramètre de direction peut être utilisé pour sélectionner le point d’insertion le plus proche au début du paragraphe suivant (en spécifiant <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) ou à la fin de la précédente de paragraphe ( en spécifiant <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Si le pointeur est déjà à la position d’insertion, et aucune balise de mise en forme adjacente spécifié `direction`, retourné <xref:System.Windows.Documents.TextPointer> pointe vers la même position que l’appel <xref:System.Windows.Documents.TextPointer>.  
  
 Il est possible qu’aucune position d’insertion valide n’existe par rapport à la position pointée par un <xref:System.Windows.Documents.TextPointer>.  Cela peut se produire si le contenu référencé est structurellement incomplète, comme dans une table vide ou une liste.  Dans ce cas, cette méthode retourne simplement une <xref:System.Windows.Documents.TextPointer> à la même position que le <xref:System.Windows.Documents.TextPointer> à partir de laquelle cette méthode a été appelée.  Cette méthode retourne toujours une valide <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Cet exemple montre comment utiliser le <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> méthode permettant de vérifier si un <xref:System.Windows.Documents.TextElement> est dépourvu de contenu imprimable.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Renvoie un <see cref="T:System.Windows.Documents.TextPointer" /> au début d'une ligne spécifiée par rapport au <see cref="T:System.Windows.Documents.TextPointer" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Le nombre de marqueurs début-de-ligne à ignorer pour déterminer la ligne à laquelle renvoyer la position de départ. Les valeurs négatives spécifient des lignes précédentes, 0 spécifie la ligne actuelle, et les valeurs positives spécifient des lignes suivantes.</param>
        <summary>Renvoie un <see cref="T:System.Windows.Documents.TextPointer" /> au début d'une ligne spécifiée par rapport au <see cref="T:System.Windows.Documents.TextPointer" /> actuel.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> pointant vers le début de la ligne spécifiée (avec le <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> paramétré sur <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), ou <see langword="null" /> si la ligne spécifiée est hors limites ou  ne peut pas être localisée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Documents.TextPointer> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> est sélectionné comme ligne de départ relative.  
  
 L’opération exécutée par cette méthode dépend d’une disposition valide.  Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.  Régénérer une disposition peut être une opération relativement coûteuse.  Utilisez <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> pour vérifier une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.  Pour plus d’informations, consultez [disposition](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Le nombre de marqueurs début-de-ligne à ignorer pour déterminer la ligne à laquelle renvoyer la position de départ. Les valeurs négatives spécifient des lignes précédentes, 0 spécifie la ligne actuelle, et les valeurs positives spécifient des lignes suivantes.</param>
        <param name="actualCount">Le renvoie de cette méthode contient le nombre réel de marqueurs début-de-ligne ignorés pour déterminer la ligne à laquelle renvoyer la position de départ.  Cette valeur peut être inférieure à <c>count</c> si le début ou la fin du contenu est trouvé avant que le nombre spécifié de lignes soit ignorées. Ce paramètre est passé sans être initialisé.</param>
        <summary>Renvoie un <see cref="T:System.Windows.Documents.TextPointer" /> au début d'une ligne spécifiée par rapport au <see cref="T:System.Windows.Documents.TextPointer" />actuel, et renseigne sur le nombre de lignes ignorées.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> pointant vers le début de la ligne spécifiée (avec le <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> paramétré sur <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), ou vers le début de la ligne la plus proche de la ligne spécifiée si celle-ci est hors limites.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Documents.TextPointer> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par la <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriété est sélectionnée comme ligne de départ relative.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle rechercher le prochain symbole.</param>
        <summary>Renvoie un pointeur vers le prochain symbole dans la direction logique spécifiée.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> au prochain symbole dans la direction requise, ou <see langword="null" /> si le <see cref="T:System.Windows.Documents.TextPointer" /> actuel borde le début ou la fin du contenu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une balise d’ouverture ou de fermeture pour un <xref:System.Windows.Documents.TextElement> élément.  
  
-   A <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
 Si le symbole suivant est classé dans la <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, ou <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (identifié par le <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> (méthode)), puis le <xref:System.Windows.Documents.TextPointer> retourné par cette méthode est avancé d’exactement un symbole à partir de la position actuelle.  
  
 Si le symbole suivant est classé <xref:System.Windows.Documents.TextPointerContext.Text>, le <xref:System.Windows.Documents.TextPointer> retourné par cette méthode outrepasse le texte vers le prochain symbole de non-texte (autrement dit, la prochaine position où le <xref:System.Windows.Documents.TextPointerContext> n’est pas <xref:System.Windows.Documents.TextPointerContext.Text>).  Le compte exact de symboles rencontrés peut être calculé à l’avance en appelant le <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode.  L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> méthode conjointement avec la <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> méthode pour parcourir et extraire les symboles dans un <xref:System.Windows.Documents.TextElement>.  
  
 Tandis que l’exemple peut être utilisé pour extraire un [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] structure pour le contenu d’un donné <xref:System.Windows.Documents.TextElement>, il est destiné uniquement à des fins d’illustration et ne doit pas être utilisé dans le code de production.  Consultez le <xref:System.Xml> espace de noms pour un ensemble complet de types conçus pour travailler avec et le traitement XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle rechercher la prochaine position d'insertion.</param>
        <summary>Renvoie un <see cref="T:System.Windows.Documents.TextPointer" /> à la prochaine position d'insertion dans la direction logique spécifiée.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> qui  identifie la prochaine position d'insertion dans la direction requise, ou <see langword="null" /> si aucune n'est décelable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *d’insertion* est une position où le nouveau contenu peut être ajouté sans les règles sémantiques concernant le contenu associé.  Dans la pratique, une position d’insertion se trouve n’importe où dans le contenu où un point d’insertion peut être positionnée.  Un exemple de valide <xref:System.Windows.Documents.TextPointer> position qui n’est pas une position d’insertion est la position entre deux adjacents <xref:System.Windows.Documents.Paragraph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et la balise d’ouverture du paragraphe suivant).  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> méthode pour parcourir les limites de l’élément de contenu afin de compter le nombre de <xref:System.Windows.Documents.Paragraph> éléments présents entre deux spécifié <xref:System.Windows.Documents.TextPointer> instances.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Un <see cref="T:System.Windows.Documents.TextPointer" /> qui spécifie une position pour laquelle la distance (en symboles) doit être trouvée.</param>
        <summary>Renvoie le compte de symboles entre le <see cref="T:System.Windows.Documents.TextPointer" /> actuel et un second <see cref="T:System.Windows.Documents.TextPointer" />spécifié.</summary>
        <returns>Le nombre relatif de symboles entre le <see cref="T:System.Windows.Documents.TextPointer" /> actuel et <paramref name="position" />.  Une valeur négative indique que le <see cref="T:System.Windows.Documents.TextPointer" /> actuel suit la position spécifiée par <paramref name="position" />, 0 indique que les positions sont égales, et une valeur positive indique que le <see cref="T:System.Windows.Documents.TextPointer" /> actuel précède la position spécifiée par <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une balise d’ouverture ou de fermeture pour un <xref:System.Windows.Documents.TextElement> élément.  
  
-   A <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> méthode pour rechercher les offsets pour deux <xref:System.Windows.Documents.TextPointer> instances et utilise ensuite ces informations pour enregistrer et restaurer la sélection dans un <xref:System.Windows.Controls.RichTextBox>.  L’exemple suppose que le contenu de la <xref:System.Windows.Controls.RichTextBox> n’ont pas changé entre une sauvegarde de sélection et une restauration de sélection.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> spécifie une position en dehors du conteneur de texte associé à la position actuelle.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle déterminer la catégorie de contenu adjacent.</param>
        <summary>Renvoie un indicateur de catégorie pour le contenu adjacent au <see cref="T:System.Windows.Documents.TextPointer" /> actuel dans la direction logique spécifiée.</summary>
        <returns>L'une des valeurs <see cref="T:System.Windows.Documents.TextPointerContext" /> qui indiquent la catégorie pour contenu adjacent dans la direction logique spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> méthode pour implémenter un algorithme de calcul de l’équilibre entre les balises d’élément entre deux spécifié <xref:System.Windows.Documents.TextPointer> positions.  Chaque balise d’élément d’ouverture est comptée comme + 1 et chaque balise d’élément de fermeture est comptée comme – 1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Renvoie un <see cref="T:System.Windows.Documents.TextPointer" /> à la position indiquée par l'offset spécifié, dans les symboles, à partir du début du contenu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Un offset, dans les symboles, pour lequel calculer et renvoyer la position.  Si l'offset est négatif, la position est calculée dans la direction logique opposée de celle indiqué par la propriété <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Renvoie un <see cref="T:System.Windows.Documents.TextPointer" /> à la position indiquée par l'offset spécifié, dans les symboles, à partir du début du <see cref="T:System.Windows.Documents.TextPointer" />actuel.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> à la position indiquée par le décalage spécifié, ou <see langword="null" /> si aucune position correspondante n'est trouvée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une balise d’ouverture ou de fermeture pour le <xref:System.Windows.Documents.TextElement> élément.  
  
-   A <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> méthode pour implémenter une paire de méthodes, une pour calculer l’offset à une position spécifiée par rapport à tout paragraphe d’hébergement et l’autre pour renvoyer un <xref:System.Windows.Documents.TextPointer> à un offset spécifié dans un paragraphe particulier.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Un offset, dans les symboles, pour lequel calculer et renvoyer la position.  Si l'offset est négatif, le <see cref="T:System.Windows.Documents.TextPointer" /> retourné précède le <see cref="T:System.Windows.Documents.TextPointer" />actuel ; sinon, il suit.</param>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" />qui spécifient la direction logique du <see cref="T:System.Windows.Documents.TextPointer" />retourné.</param>
        <summary>Renvoie un <see cref="T:System.Windows.Documents.TextPointer" /> à la position indiquée par l'offset spécifié, dans les symboles, à partir du début du <see cref="T:System.Windows.Documents.TextPointer" />actuel et dans la direction spécifiée.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> à la position indiquée par le décalage spécifié, ou <see langword="null" /> si le décalage s’étend au-delà de la fin du contenu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une balise d’ouverture ou de fermeture pour le <xref:System.Windows.Documents.TextElement> élément.  
  
-   A <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Renvoie du texte adjacent au <see cref="T:System.Windows.Documents.TextPointer" />actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle trouver et renvoyer tout texte adjacent.</param>
        <summary>Renvoie une chaîne contenant tout texte adjacent au <see cref="T:System.Windows.Documents.TextPointer" /> actuel dans la direction logique spécifiée.</summary>
        <returns>Une chaîne contenant tout texte adjacent dans la direction logique spécifiée, ou <see cref="F:System.String.Empty" /> si aucun texte adjacent n'est décelable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne uniquement les exécutions de texte ininterrompues.  Rien n’est retourné si un type de symbole autre que <xref:System.Windows.Documents.TextPointerContext.Text> est adjacent à actuel <xref:System.Windows.Documents.TextPointer> dans la direction spécifiée.  De même, le texte est renvoyé uniquement jusqu'à un symbole non textuelles suivant.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode. L’exemple utilise le <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> méthode pour implémenter un extracteur de texte simple.  La méthode renvoie une concaténation de chaînes de tout le texte entre deux spécifié <xref:System.Windows.Documents.TextPointer> instances.  
  
 Si l’exemple peut être utilisé pour extraire tout texte entre deux <xref:System.Windows.Documents.TextPointer> instances, il est destiné uniquement à des fins d’illustration et ne doit pas être utilisé dans le code de production.  Utilisez la propriété <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> à la place.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle trouver et copier tout texte adjacent.</param>
        <param name="textBuffer">Une mémoire tampon dans laquelle tout texte est copié.</param>
        <param name="startIndex">Index dans <c>textBuffer</c> auquel commencer l'écriture du texte copié.</param>
        <param name="count">Nombre maximum de caractères à copier.</param>
        <summary>Copie le nombre maximal spécifié de caractères à partir de tout texte adjacent dans la direction spécifiée dans un tableau de caractères fourni par un appelant.</summary>
        <returns>Nombre réel de caractères copiés dans <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne uniquement les exécutions de texte ininterrompues.  Rien n’est retourné si un type de symbole autre que <xref:System.Windows.Documents.TextPointerContext.Text> est adjacent à actuel <xref:System.Windows.Documents.TextPointer> dans la direction spécifiée.  De même, le texte est renvoyé uniquement jusqu'à un symbole non textuelles suivant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> est inférieur à 0 ou supérieur à la propriété <see cref="P:System.Array.Length" /> de <paramref name="textBuffer" />.  
  
 - ou -  
  
 <paramref name="count" /> est inférieur à 0 ou supérieur à l'espace restant dans <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> moins <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">L'une des valeurs <see cref="T:System.Windows.Documents.LogicalDirection" /> qui spécifient la direction logique dans laquelle compter le nombre de caractères.</param>
        <summary>Renvoie le nombre de caractères Unicode entre le <see cref="T:System.Windows.Documents.TextPointer" /> actuel et le prochain symbole de non-texte, dans la direction logique spécifiée.</summary>
        <returns>Le nombre de caractères Unicode entre le <see cref="T:System.Windows.Documents.TextPointer" /> actuel et le prochain symbole de non-texte.  Ce nombre peut être 0 s'il n'y a aucun texte adjacent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants est considéré comme un symbole :  
  
-   Une balise d’ouverture ou de fermeture pour le <xref:System.Windows.Documents.TextElement> élément.  
  
-   A <xref:System.Windows.UIElement> élément contenu dans un <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Notez que ce un <xref:System.Windows.UIElement> sont toujours comptabilisées comme unique symbole ; tout contenu supplémentaire ou les éléments contenus par le <xref:System.Windows.UIElement> ne sont pas comptés comme des symboles.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractère à l’intérieur d’un texte <xref:System.Windows.Documents.Run> élément.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le conteneur de texte associé à la position actuelle a une disposition valide (mise à jour).</summary>
        <value>
          <see langword="true" />si la disposition actuelle est valide ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cela est nécessaire, les opérations qui dépendent d’une disposition valide (comme le <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> (méthode), <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> (méthode), et <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriété) essayez de régénérer automatiquement une disposition valide avant de poursuivre l’opération.  Régénérer une disposition peut être une opération relativement coûteuse.  Utilisez cette propriété pour vérifier une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.  Pour plus d’informations, consultez [disposition](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Insère un saut de ligne à la position actuelle.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> positionné immédiatement après l'élément <see cref="T:System.Windows.Documents.LineBreak" /> a inséré par cette méthode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Insère un arrêt de paragraphe à la position actuelle.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> au début (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) du nouveau paragraphe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode est appelée lorsque la position actuelle est à l’intérieur d’un existant <xref:System.Windows.Documents.Paragraph> élément, le paragraphe existant et tout son contenu sont divisées en deux paragraphes à la position actuelle.  Si cette méthode est appelée lorsque la position actuelle n’est pas à l’intérieur d’un paragraphe existant, un nouveau paragraphe vide est inséré.  Si cette méthode est appelée à une position illisible pour fractionner ou l’insertion d’un paragraphe (par exemple, si la position actuelle est à l’intérieur d’un <xref:System.Windows.Documents.Hyperlink> élément), une exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette méthode est appelée sur une position ne pouvant pas être fractionnée pour accommoder un nouveau paragraphe, tel que dans la portée d'un <see cref="T:System.Windows.Documents.Hyperlink" /> ou <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Texte à insérer.</param>
        <summary>Insère le texte spécifié dans le texte <see cref="T:System.Windows.Documents.Run" /> à la position actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Documents.TextPointer> n’est pas limité par un <xref:System.Windows.Documents.Run> élément, un <xref:System.Windows.Documents.Run> est insérée avec la `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La position actuelle n'est pas dans un élément <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la position actuelle est une position d'insertion.</summary>
        <value>
          <see langword="true" /> si la position actuelle est une position d'insertion ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une position d’insertion est une position où le nouveau contenu peut être ajouté sans les règles sémantiques concernant le contenu associé.  Dans la pratique, une position d’insertion se trouve n’importe où dans le contenu où un point d’insertion peut être positionnée.  Un exemple de valide <xref:System.Windows.Documents.TextPointer> position qui n’est pas une position d’insertion est la position entre deux adjacents <xref:System.Windows.Documents.Paragraph> balises (autrement dit, entre la balise de fermeture du paragraphe précédent et la balise d’ouverture du paragraphe suivant).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la position actuelle est au début d'une ligne.</summary>
        <value>
          <see langword="true" /> si la position actuelle est au début d'une ligne; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Documents.TextPointer> pointe vers une position ambiguë, par exemple, entre deux lignes, la ligne dans la direction spécifiée par la <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriété est sélectionnée comme ligne de départ relative.  
  
 L’opération exécutée par cette propriété dépend de la validité de la disposition.  Lorsque cela est nécessaire, cette méthode essaie de régénérer automatiquement une disposition valide avant de poursuivre l’opération.  Régénérer une disposition peut être une opération relativement coûteuse.  Utilisez le <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriété à vérifier pour une disposition valide avant d’effectuer des opérations pouvant régénérer la disposition.  Pour plus d’informations, consultez [disposition](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">Un <see cref="T:System.Windows.Documents.TextPointer" /> qui spécifie une position à comparer à la position actuelle.</param>
        <summary>Indique si la position spécifiée est dans le même conteneur de texte que la  position actuelle.</summary>
        <returns>
          <see langword="true" /> si <paramref name="textPosition" /> indique une position qui est dans le même conteneur de texte que la position actuelle ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plupart des opérations qui impliquent plusieurs <xref:System.Windows.Documents.TextPointer> instances ne sont valides que si les instances en question indiquent les positions qui se trouvent dans la même étendue de conteneur de texte.  Par exemple le <xref:System.Windows.Documents.TextPointer.CompareTo%2A> et <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> méthodes ne peut pas être utilisés avec un <xref:System.Windows.Documents.TextPointer> à une position en dehors du conteneur de texte associé à la position actuelle.  Utilisez cette méthode pour vérifier que spécifié <xref:System.Windows.Documents.TextPointer> est compatible avec la position actuelle pour ces opérations.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de cette méthode.  L’exemple utilise le <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> méthode permettant de vérifier si un <xref:System.Windows.Documents.TextPointer> placé entre deux autres spécifié <xref:System.Windows.Documents.TextPointer> instances dans une situation lorsqu’il n’existe aucune garantie que les trois positions appartiennent au même conteneur de texte.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la direction logique associée à la position actuelle utilisée pour lever l'ambiguïté du contenu associé à la position actuelle.</summary>
        <value>La valeur <see cref="T:System.Windows.Documents.LogicalDirection" /> qui est associée à la position actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme exemple d’utilisation de cette propriété, le <xref:System.Windows.Documents.LogicalDirection> de la <xref:System.Windows.Documents.TextPointer> retourné par un test de positionnement méthode donne un accès entre deux caractères de texte. La direction logique spécifie lequel des deux caractères a été réellement atteint, la gauche ou la droite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le paragraphe dans la portée de la position actuelle, s'il en est.</summary>
        <value>Le <see cref="T:System.Windows.Documents.Paragraph" /> portant sur la position actuelle, ou <see langword="null" /> si aucun paragraphe de ce type n’existe.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le parent logique portant sur la position actuelle.</summary>
        <value>Le parent logique portant sur la position actuelle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ce type ou membre prend en charge l’infrastructure [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] et n’est pas destiné à être utilisé directement à partir de votre code.</summary>
        <returns>Chaîne qui représente l'objet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>