<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="84b5572cf9ba0ae76ee1c5c3bb7375f8ce499c04" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37521565" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un jeu standard de commandes d'édition connexes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant présente les commandes d’édition et la valeur par défaut associée mouvements clés (avec des noms de clé à partir de la <xref:System.Windows.Input.Key> et <xref:System.Windows.Input.ModifierKeys> énumérations).  
  
|Commande d’édition|Mouvement clé par défaut|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|Aucun mouvement clé par défaut|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|Aucun mouvement clé par défaut|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 Commandes du déplacement du signe insertion et sélection commandes en expansion partagent un ensemble commun de gestes de clé par défaut, la différence générale en cours de l’ajout de la <xref:System.Windows.Input.ModifierKeys.Shift> clé pour différencier les commandes de sélection des commandes de déplacement du signe insertion.  Par exemple, le <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> commande a un mouvement clé par défaut de <xref:System.Windows.Input.Key.Left>et le correspondantes <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> commande a un mouvement clé par défaut de <xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left>.  
  
 En général, les définitions de commande fournies par le <xref:System.Windows.Documents.EditingCommands> n’apportez pas de classe utilisent des paramètres de commande (la `parameter` paramètre attendu par le <xref:System.Windows.Input.ICommand.Execute%2A> méthode).  
  
 Pour plus d’informations sur les commandes et leur exécution, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" /> qui demande de centrer le paragraphe actuel ou une sélection de paragraphes.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="E" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande fonctionne au niveau de la <xref:System.Windows.Documents.Paragraph> niveau.  Si cette commande est appelée sur une sélection partielle du contenu au sein d’un paragraphe (y compris une sélection vide où le signe insertion se trouve dans un paragraphe), l’effet demandé est appliqué à l’ensemble du paragraphe.  Si cette commande est appelée sur une sélection qui s’étend sur plusieurs paragraphes, l’effet est appliqué à tout le contenu de chaque paragraphe qui participe à la sélection.  
  
 La figure suivante montre un exemple de contenu centré.  
  
 ![Capture d’écran : Valeur de la propriété TextAlign du centre](~/add/media/flowdoc-textalign-center.png "capture d’écran : valeur de la propriété TextAlign du centre")  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" /> qui demande de justifier le paragraphe actuel ou une sélection de paragraphes.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="J" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande fonctionne au niveau de la <xref:System.Windows.Documents.Paragraph> niveau.  Si cette commande est appelée sur une sélection partielle du contenu au sein d’un paragraphe (y compris une sélection vide où le signe insertion se trouve dans un paragraphe), l’effet demandé est appliqué à l’ensemble du paragraphe.  Si cette commande est appelée sur une sélection qui s’étend sur plusieurs paragraphes, l’effet est appliqué à tous les paragraphes dans la sélection.  
  
 Lorsque le contenu est justifié, l’espacement horizontal dans chaque ligne de contenu est ajusté afin que les lignes justifiées soient de largeur égale ou presque.  Contenu est généralement justifié de créer des bords lissés sur les côtés du contenu.  
  
 Comme il est souvent plus courte, la dernière ligne dans un paragraphe peut rester injustifiée après que cette commande est appelée.  
  
 L’illustration suivante est justifié de contenu (aligné à gauche).  
  
 ![Capture d’écran : Contenu non justifié](~/add/media/content-unjustified.png "capture d’écran : contenu non justifié")  
  
 La figure suivante montre le même contenu une fois justifié.  
  
 ![Capture d’écran de contenu justifié texte](~/add/media/content-justified.png "capture d’écran de contenu justifié de texte")  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" /> qui demande qu'une sélection de contenu soit alignée à gauche.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande fonctionne au niveau de la <xref:System.Windows.Documents.Paragraph> niveau.  Si cette commande est appelée sur une sélection partielle du contenu au sein d’un paragraphe (y compris une sélection vide où le signe insertion se trouve dans un paragraphe), l’effet demandé est appliqué à l’ensemble du paragraphe.  Si cette commande est appelée sur une sélection qui s’étend sur plusieurs paragraphes, l’effet est appliqué à tout le contenu de chaque paragraphe qui participe à la sélection.  
  
 La figure suivante montre un exemple de contenu aligné à gauche.  
  
 ![Capture d’écran : Valeur de la propriété TextAlign de gauche](~/add/media/flowdoc-textalign-left.png "capture d’écran : valeur de la propriété TextAlign de gauche")  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" /> qui demande qu'une sélection de contenu soit alignée à droite.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="R" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande fonctionne au niveau de la <xref:System.Windows.Documents.Paragraph> niveau.  Si cette commande est appelée sur une sélection partielle du contenu au sein d’un paragraphe (y compris une sélection vide où le signe insertion se trouve dans un paragraphe), l’effet demandé est appliqué à l’ensemble du paragraphe.  Si cette commande est appelée sur une sélection qui s’étend sur plusieurs paragraphes, l’effet est appliqué à tout le contenu de chaque paragraphe qui participe à la sélection.  
  
 La figure suivante montre un exemple de contenu aligné à droite.  
  
 ![Capture d’écran : TextAlign avec la valeur droite](~/add/media/flowdoc-textalign-right.png "capture d’écran : TextAlign avec la valeur de droite")  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.Backspace" /> qui demande d'entrer un retour arrière à la position actuelle ou sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’elle est appelée sur une sélection vide, cette commande supprime le caractère ou séparateur de paragraphe juste avant le signe insertion. Lorsqu’elle est appelée sur une sélection non vide, cette commande supprime la sélection.  
  
 Cette commande conserve toute mise en forme de la sélection supprimée pour du contenu immédiatement inséré au même emplacement après que cette commande est appelée.  Contraste avec le <xref:System.Windows.Documents.EditingCommands.Delete%2A> commande, qui ne conserve pas la mise en forme précédente.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" /> qui demande que tout mot mal orthographié à la position actuelle soit corrigé.</summary>
        <value>Commande demandée.  Cette commande n'a aucun mouvement clé par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" /> qui demande que la taille de police pour la sélection actuelle soit réduite d'1 point.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="OemOpenBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette commande est appelée sur une sélection vide où le signe insertion se trouve dans un mot, la sélection est automatiquement développée pour appliquer la commande au mot entier.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" /> qui demande que la mise en retrait pour le paragraphe actuel soit réduite d'1 taquet de tabulation.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Cette commande n’a aucun effet sur un élément de texte, sauf si le <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> propriété de l’élément de texte est définie sur `true`.  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.Delete" /> qui demande que la sélection actuelle soit supprimée.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande ignore toute mise en forme de la sélection supprimée.  Contraste avec le <xref:System.Windows.Documents.EditingCommands.Backspace%2A> commande, qui conserve la mise en forme de la sélection supprimée pour du contenu immédiatement inséré au même emplacement après que cette commande est appelée.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" /> qui demande que le prochain mot (relatif à une position actuelle) soit supprimé.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le signe insertion est dans un mot, le reste du mot entre la position actuelle et la fin du mot est supprimé.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" /> qui demande que le précédent mot (relatif à une position actuelle) soit supprimé.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le signe insertion est dans un mot, le reste du mot entre la position actuelle et le début du mot est supprimé.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" /> qui demande d'insérer un saut de ligne à la position actuelle ou sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les éditeurs qui prennent en charge le contenu de flux, tel que <xref:System.Windows.Controls.RichTextBox>, cette commande entraîne un <xref:System.Windows.Documents.LineBreak> élément à insérer à la position actuelle.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" /> qui demande d'insérer un saut de paragraphe à la position actuelle ou sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande est équivalente à l’utilisateur en appuyant sur la touche ENTRÉE.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox> (lorsque le <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> propriété est `true`).  
  
> [!IMPORTANT]
>  Cette commande n’a aucun effet sur un élément de texte, sauf si le <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> propriété de l’élément de texte est définie sur `true`.  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" /> qui demande qui toutes instances de mots mal orthographiés à la position actuelle ou dans la sélection actuelle soient ignorées.</summary>
        <value>Commande demandée.  Cette commande n'a aucun mouvement clé par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" /> qui demande que la taille de police pour la sélection actuelle soit augmentée d'1 point.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="OemCloseBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette commande est appelée sur une sélection vide où le signe insertion se trouve dans un mot, la sélection est développée pour appliquer la commande au mot entier.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" /> qui demande que la mise en retrait pour le paragraphe actuel soit augmentée d'1 taquet de tabulation.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Cette commande n’a aucun effet sur un élément de texte, sauf si le <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> propriété de l’élément de texte est définie sur `true`.  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" /> qui demande de descendre le signe insertion d'une ligne.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" /> qui demande de descendre le signe insertion d'une page.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" /> qui demande de descendre le signe insertion d'un paragraphe.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande place le signe insertion au début du paragraphe suivant.  
  
 Cette commande se comporte comme <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> lorsqu’elle est appelée sur un <xref:System.Windows.Controls.TextBox>.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" /> qui demande de décaler le signe insertion d'un caractère sur la gauche.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" /> qui demande de décaler le signe insertion d'un mot sur la gauche.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le signe insertion est dans un mot, cette commande déplace le signe insertion au début de ce mot.  Sinon, cette commande déplace le signe insertion au début du mot précédent.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" /> qui demande de décaler le signe insertion d'un caractère sur la droite.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" /> qui demande de décaler le signe insertion d'un mot sur la droite.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le signe insertion est dans un mot, cette commande déplace le signe insertion à la fin de ce mot.  Sinon, cette commande déplace le signe insertion au début du mot suivant.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" /> qui demande de déplacer le signe insertion jusqu'à la fin du contenu.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *conteneur de texte* est l’élément qui forme la bordure ultime pour le contenu disponible.  <xref:System.Windows.Controls.TextBlock> et <xref:System.Windows.Documents.FlowDocument> sont des exemples de conteneurs de texte.  Le contenu compris dans un conteneur de texte est appelé un *document*.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" /> qui demande de déplacer le signe insertion tout au début du contenu.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *conteneur de texte* est l’élément qui forme la bordure ultime pour le contenu disponible.  <xref:System.Windows.Controls.TextBlock> et <xref:System.Windows.Documents.FlowDocument> sont des exemples de conteneurs de texte.  Le contenu compris dans un conteneur de texte est appelé un *document*.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" /> qui demande de déplacer le signe insertion à la fin de la ligne actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" /> qui demande de déplacer le signe insertion au début de la ligne actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" /> qui demande de remonter le signe insertion d'une ligne.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" /> qui demande de remonter le signe insertion d'une page.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" /> qui demande de remonter le signe insertion d'un paragraphe.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande place le signe insertion au début du paragraphe suivant.  
  
 Cette commande se comporte comme <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> lorsqu’elle est appelée sur un <xref:System.Windows.Controls.TextBox>.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" /> qui demande d'étendre la sélection actuelle à la ligne suivante.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" /> qui demande d'étendre la sélection actuelle à une page suivante.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" /> qui demande d'étendre la sélection actuelle au paragraphe suivant.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande étend la sélection au début du paragraphe suivant.  Sinon, cette commande étend la sélection à la fin du paragraphe actuel.  La sélection étendue inclut le saut de paragraphe qui marque la fin du paragraphe.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" /> qui demande d'étendre la sélection actuelle d'un caractère sur la gauche.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" /> qui demande d'étendre la sélection actuelle d'un mot sur la gauche.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le signe insertion est dans un mot, cette commande étend la sélection au début de ce mot.  Sinon, cette commande étend la sélection au début du mot précédent.  
  
 La sélection étendue n’inclut pas le délimiteur de mot.  Comparez avec <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, qui inclut le délimiteur de mot dans la sélection étendue.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" /> qui demande d'étendre la sélection actuelle d'un caractère sur la droite.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" /> qui demande d'étendre la sélection actuelle d'un mot sur la droite.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le signe insertion est dans un mot, cette commande étend la sélection à la fin de ce mot.  Sinon, cette commande étend la sélection à la fin du mot suivant.  
  
 La sélection étendue inclut le délimiteur de mot.  Comparez avec <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> qui n’inclut pas le délimiteur de mot dans la sélection étendue.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" /> qui demande d'étendre la sélection actuelle jusqu'à la fin du contenu.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *conteneur de texte* est l’élément qui forme la bordure ultime pour le contenu disponible.  <xref:System.Windows.Controls.TextBlock> et <xref:System.Windows.Documents.FlowDocument> sont des exemples de conteneurs de texte.  Le contenu compris dans un conteneur de texte est appelé un *document*.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" /> qui demande d'étendre la sélection actuelle jusqu'au début du contenu.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *conteneur de texte* est l’élément qui forme la bordure ultime pour le contenu disponible.  <xref:System.Windows.Controls.TextBlock> et <xref:System.Windows.Documents.FlowDocument> sont des exemples de conteneurs de texte.  Le contenu compris dans un conteneur de texte est appelé un *document*.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" /> qui demande d'étendre la sélection actuelle jusqu'à la fin de la ligne actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" /> qui demande d'étendre la sélection actuelle jusqu'au début de la ligne actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" /> qui demande d'étendre la sélection actuelle à la ligne précédente.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" /> qui demande d'étendre la sélection actuelle d’une page.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" /> qui demande d'étendre la sélection actuelle au paragraphe précédent.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le signe insertion se trouve au début d’un paragraphe, cette commande étend la sélection au début du paragraphe précédent.  Sinon, cette commande étend la sélection au début du paragraphe actuel.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" />.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Shift" /> + <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement de cette commande dépend de la sélection actuelle. Si la sélection est vide, cette commande équivaut à <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>. Si le signe insertion se trouve dans une cellule de tableau (représenté par la <xref:System.Windows.Documents.TableCell> élément), cette commande déplace le signe insertion vers la cellule précédente. Sinon, un caractère de tabulation est inséré dans la position actuelle.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox> (lorsque le <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> propriété est `true`).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.TabForward" />.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement de cette commande dépend de la sélection actuelle. Si la sélection est vide, ou si la sélection est vide et la position actuelle du signe insertion se trouve au début d’un paragraphe, cette commande équivaut à <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>. Si le signe insertion se trouve dans une cellule de tableau (représenté par la <xref:System.Windows.Documents.TableCell> élément), cette commande déplace le signe insertion vers la cellule suivante. Si le signe insertion se trouve dans la dernière cellule d’une table, cette commande entraîne une nouvelle ligne à ajouter à la table, avec le signe insertion positionné dans la première cellule de la nouvelle ligne.  Sinon, un caractère de tabulation est inséré dans la position actuelle.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox> et <xref:System.Windows.Controls.TextBox> (lorsque le <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> propriété est `true`).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" /> qui demande que la mise en forme de <see cref="T:System.Windows.Documents.Bold" /> soit basculée sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="B" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.FontWeight> pour la sélection actuelle se trouve dans la plage comprise entre <xref:System.Windows.FontWeights.Thin%2A> à <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> est appliqué à la sélection actuelle.  Sinon, <xref:System.Windows.FontWeights.Normal%2A> est appliqué.  Pour une liste comparative de <xref:System.Windows.FontWeight> valeurs, consultez <xref:System.Windows.FontWeights>.  
  
 Lorsque la sélection est vide et le signe insertion est dans un mot, la sélection est étendue pour inclure le mot entier.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" /> qui demande que la mise en forme des listes non ordonnées, (également appelées listes à puce) soit basculée sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande fonctionne au niveau de la <xref:System.Windows.Documents.Paragraph> niveau.  Si cette commande est appelée sur une sélection partielle du contenu au sein d’un paragraphe (y compris une sélection vide où le signe insertion se trouve dans un paragraphe), l’effet demandé est appliqué à l’ensemble du paragraphe.  Si cette commande est appelée sur une sélection qui s’étend sur plusieurs paragraphes, l’effet est appliqué à tout le contenu de chaque paragraphe qui participe à la sélection.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" /> qui bascule le mode de frappe d'Insérer à Refrapper.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, et <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" /> qui demande que la mise en forme de <see cref="T:System.Windows.Documents.Italic" /> soit basculée sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="I" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.FontStyle> pour la sélection actuelle est <xref:System.Windows.FontStyles.Normal%2A>, <xref:System.Windows.FontStyles.Italic%2A> est appliqué à la sélection actuelle.  Sinon, <xref:System.Windows.FontStyles.Normal%2A> est appliqué.  
  
 Lorsque la sélection est vide et le signe insertion est dans un mot, la sélection est étendue pour inclure le mot entier.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" /> qui demande que la mise en forme des listes ordonnées (également appelées listes numérotées) soit basculée sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande fonctionne au niveau de la <xref:System.Windows.Documents.Paragraph> niveau.  Si cette commande est appelée sur une sélection partielle du contenu au sein d’un paragraphe (y compris une sélection vide où le signe insertion se trouve dans un paragraphe), l’effet demandé est appliqué à l’ensemble du paragraphe.  Si cette commande est appelée sur une sélection qui s’étend sur plusieurs paragraphes, l’effet est appliqué à tout le contenu de chaque paragraphe qui participe à la sélection.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" /> qui demande que la mise en forme d'indice soit basculée sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" /> qui demande que la mise en forme d'exposant soit basculée sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la commande <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" /> qui demande que la mise en forme de <see cref="T:System.Windows.Documents.Underline" /> soit basculée sur la sélection actuelle.</summary>
        <value>Commande demandée.  Le mouvement clé par défaut pour cette commande est <see langword="Ctrl" /> + <see langword="U" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque la sélection est vide et le signe insertion est dans un mot, la sélection est étendue pour inclure le mot entier.  
  
 Il n’est pas nécessairement une implémentation réelle qui répond à cette commande sur n’importe quel objet donné ; dans de nombreux cas, l’implémentation qui répond à une commande est la responsabilité de l’enregistreur de l’application.  
  
 Cette commande est prise en charge native <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une commande d’édition sur un objet qui prend en charge de la commande.  
  
 Pour cet exemple, un <xref:System.Windows.Controls.RichTextBox> sert de cible de commande.  Notez que <xref:System.Windows.Controls.RichTextBox> implémente le <xref:System.Windows.IInputElement> interface (héritée de <xref:System.Windows.FrameworkElement>), et qu’il inclut une prise en charge native de nombreuses commandes d’édition.  
  
 Le premier argument pour le <xref:System.Windows.Input.RoutedCommand.Execute%2A> méthode est un paramètre de commande.  Les commandes d’édition plus ignorent le paramètre de commande ; en règle générale, ce paramètre doit être `null` pour les commandes d’édition.  
  
 Le deuxième argument spécifie l’objet auquel la commande sera routée.  Cet objet doit implémenter le <xref:System.Windows.IInputElement> interface et doit inclure un gestionnaire pour la commande spécifiée.  En règle générale, une commande est ignorée lorsqu’elle est appelée sur un objet qui ne gère pas la commande.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>