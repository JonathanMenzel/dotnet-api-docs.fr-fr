<Type Name="RsaSecurityTokenParameters" FullName="System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="60c063e488010967f3c059d22671db8eac7b32f9" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37454492" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RsaSecurityTokenParameters : System.ServiceModel.Security.Tokens.SecurityTokenParameters" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RsaSecurityTokenParameters extends System.ServiceModel.Security.Tokens.SecurityTokenParameters" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters" />
  <TypeSignature Language="VB.NET" Value="Public Class RsaSecurityTokenParameters&#xA;Inherits SecurityTokenParameters" />
  <TypeSignature Language="C++ CLI" Value="public ref class RsaSecurityTokenParameters : System::ServiceModel::Security::Tokens::SecurityTokenParameters" />
  <TypeSignature Language="F#" Value="type RsaSecurityTokenParameters = class&#xA;    inherit SecurityTokenParameters" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Security.Tokens.SecurityTokenParameters</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente les paramètres pour un jeton de sécurité RSA.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe est une collection de propriétés de jeton et de méthodes. Elle est utilisée pour la création d’éléments de liaison et de jetons de sécurité qui utilisent le chiffrement RSA.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La différence entre ces surcharges est la provenance des valeurs de propriété d'instance. <xref:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.%23ctor%2A> leur affecte leurs valeurs par défaut. <xref:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.%23ctor%2A> les prend de l'instance référencée par le paramètre d'entrée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RsaSecurityTokenParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RsaSecurityTokenParameters();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs par défaut sont affectées aux nouvelles valeurs de propriété d'instance :  
  
-   <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode%2A> a la valeur <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode.Never>.  
  
-   <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.ReferenceStyle%2A> a la valeur <xref:System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle.Internal>.  
  
-   <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.RequireDerivedKeys%2A> a la valeur `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected RsaSecurityTokenParameters (System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters other);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.#ctor(System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (other As RsaSecurityTokenParameters)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; RsaSecurityTokenParameters(System::ServiceModel::Security::Tokens::RsaSecurityTokenParameters ^ other);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters : System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters -&gt; System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters" Usage="new System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters other" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="other">L'autre instance de cette classe.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les nouvelles valeurs de propriété d'instance ont les valeurs correspondantes dans `other`. <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode%2A> a la valeur <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override System.ServiceModel.Security.Tokens.SecurityTokenParameters CloneCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.ServiceModel.Security.Tokens.SecurityTokenParameters CloneCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.CloneCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CloneCore () As SecurityTokenParameters" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::ServiceModel::Security::Tokens::SecurityTokenParameters ^ CloneCore();" />
      <MemberSignature Language="F#" Value="override this.CloneCore : unit -&gt; System.ServiceModel.Security.Tokens.SecurityTokenParameters" Usage="rsaSecurityTokenParameters.CloneCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SecurityTokenParameters</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clone une autre instance de cette instance de la classe.</summary>
        <returns>Instance de <see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" /> qui représente la copie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les méthodes <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.Clone%2A> et <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.CloneCore%2A> suivent le modèle de design principal.  
  
 <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.CloneCore%2A> est une classe `abstract` substituée par <xref:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.CloneCore%2A>.  
  
 La méthode <xref:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.CloneCore%2A> appelle le constructeur <xref:System.ServiceModel.Security.Tokens.SslSecurityTokenParameters.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateKeyIdentifierClause">
      <MemberSignature Language="C#" Value="protected internal override System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateKeyIdentifierClause (System.IdentityModel.Tokens.SecurityToken token, System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle referenceStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityToken token, valuetype System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle referenceStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.CreateKeyIdentifierClause(System.IdentityModel.Tokens.SecurityToken,System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function CreateKeyIdentifierClause (token As SecurityToken, referenceStyle As SecurityTokenReferenceStyle) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateKeyIdentifierClause(System::IdentityModel::Tokens::SecurityToken ^ token, System::ServiceModel::Security::Tokens::SecurityTokenReferenceStyle referenceStyle);" />
      <MemberSignature Language="F#" Value="override this.CreateKeyIdentifierClause : System.IdentityModel.Tokens.SecurityToken * System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="rsaSecurityTokenParameters.CreateKeyIdentifierClause (token, referenceStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="referenceStyle" Type="System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle" />
      </Parameters>
      <Docs>
        <param name="token">Jeton.</param>
        <param name="referenceStyle">Style de référence du jeton de sécurité.</param>
        <summary>Crée une clause d'identificateur de clé pour un jeton.</summary>
        <returns>Clause d'identificateur de clé d'un jeton.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAsymmetricKey">
      <MemberSignature Language="C#" Value="protected internal override bool HasAsymmetricKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAsymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.HasAsymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property HasAsymmetricKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HasAsymmetricKey { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAsymmetricKey : bool" Usage="System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.HasAsymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le jeton a une clé asymétrique.</summary>
        <value>
          <see langword="true" /> si le jeton a une clé asymétrique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours `true`.  
  
 Les clés asymétriques sont utilisées dans le chiffrement de clé publique qui utilise deux clés (une clé publique et une clé privée) liées mathématiquement. La clé publique est largement distribuée, mais la clé privée est gardée secrète. Dans le chiffrement de clé publique, il n'y a pas besoin d'échanger de clé commune.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeSecurityTokenRequirement">
      <MemberSignature Language="C#" Value="protected internal override void InitializeSecurityTokenRequirement (System.IdentityModel.Selectors.SecurityTokenRequirement requirement);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void InitializeSecurityTokenRequirement(class System.IdentityModel.Selectors.SecurityTokenRequirement requirement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.InitializeSecurityTokenRequirement(System.IdentityModel.Selectors.SecurityTokenRequirement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub InitializeSecurityTokenRequirement (requirement As SecurityTokenRequirement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void InitializeSecurityTokenRequirement(System::IdentityModel::Selectors::SecurityTokenRequirement ^ requirement);" />
      <MemberSignature Language="F#" Value="override this.InitializeSecurityTokenRequirement : System.IdentityModel.Selectors.SecurityTokenRequirement -&gt; unit" Usage="rsaSecurityTokenParameters.InitializeSecurityTokenRequirement requirement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requirement" Type="System.IdentityModel.Selectors.SecurityTokenRequirement" />
      </Parameters>
      <Docs>
        <param name="requirement">Spécification du jeton de sécurité.</param>
        <summary>Initialise une exigence de jeton de sécurité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les propriétés suivantes de la <xref:System.IdentityModel.Selectors.SecurityTokenRequirement> sont initialisées:  
  
-   <xref:System.IdentityModel.Selectors.SecurityTokenRequirement.TokenType%2A> = <xref:System.IdentityModel.Tokens.SecurityTokenTypes.Rsa%2A>.  
  
-   <xref:System.IdentityModel.Selectors.SecurityTokenRequirement.RequireCryptographicToken%2A> = `true`.  
  
-   <xref:System.IdentityModel.Selectors.SecurityTokenRequirement.KeyType%2A> = <xref:System.IdentityModel.Tokens.SecurityKeyType.AsymmetricKey>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsClientAuthentication">
      <MemberSignature Language="C#" Value="protected internal override bool SupportsClientAuthentication { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsClientAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.SupportsClientAuthentication" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property SupportsClientAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool SupportsClientAuthentication { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsClientAuthentication : bool" Usage="System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.SupportsClientAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas d'implémentation, obtient une valeur qui indique si le jeton prend en charge l'authentification du client.</summary>
        <value>
          <see langword="true" /> si le jeton prend en charge l'authentification du client ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsClientWindowsIdentity">
      <MemberSignature Language="C#" Value="protected internal override bool SupportsClientWindowsIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsClientWindowsIdentity" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.SupportsClientWindowsIdentity" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property SupportsClientWindowsIdentity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool SupportsClientWindowsIdentity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsClientWindowsIdentity : bool" Usage="System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.SupportsClientWindowsIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas d'implémentation, obtient une valeur qui indique si le jeton prend en charge une identité Windows pour l'authentification.</summary>
        <value>
          <see langword="true" /> si le jeton prend en charge une identité Windows pour l'authentification ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsServerAuthentication">
      <MemberSignature Language="C#" Value="protected internal override bool SupportsServerAuthentication { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsServerAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.SupportsServerAuthentication" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property SupportsServerAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool SupportsServerAuthentication { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsServerAuthentication : bool" Usage="System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters.SupportsServerAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas d'implémentation, obtient une valeur qui indique si le jeton prend en charge l'authentification du serveur.</summary>
        <value>
          <see langword="true" /> si le jeton prend en charge l'authentification du serveur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>