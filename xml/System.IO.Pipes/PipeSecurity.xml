<Type Name="PipeSecurity" FullName="System.IO.Pipes.PipeSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58e6564b01438e16fc7cf5c70e68fbb3a3517ce2" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48688341" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PipeSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PipeSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeSecurity" />
  <TypeSignature Language="VB.NET" Value="Public Class PipeSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeSecurity : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type PipeSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente la sécurité de contrôle d’accès et d’audit pour un canal.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity> classe spécifie les droits d’accès pour un canal et la manière dont les tentatives d’accès sont auditées.  Cette classe représente des droits d’accès et d’audit sous la forme d’un ensemble de règles. Chaque règle d’accès est représenté par un <xref:System.IO.Pipes.PipeAccessRule> de l’objet, tandis que chaque règle d’audit est représentée par un <xref:System.IO.Pipes.PipeAuditRule> objet.  
  
 Le <xref:System.IO.Pipes.PipeSecurity> classe est une abstraction du système de sécurité des fichiers Microsoft Windows sous-jacent. Dans ce système, chaque canal a une liste de contrôle d’accès discrétionnaire (DACL), qui contrôle l’accès au canal et une liste de contrôle d’accès système (SACL), qui spécifie les tentatives de contrôle d’accès sont auditées.  Le <xref:System.IO.Pipes.PipeAccessRule> et <xref:System.IO.Pipes.PipeAuditRule> classes sont des abstractions des entrées de contrôle d’accès (ACE) qui comprennent les DACL et les SACL.  
  
 Le <xref:System.IO.Pipes.PipeSecurity> classe masque de nombreux détails des DACL et les SACL ; vous n’avez pas à vous soucier du classement ACE ou des DACL null.  
  
 Utilisez la <xref:System.IO.Pipes.PipeSecurity> classe à récupérer, ajouter ou modifier les règles d’accès qui représentent le DACL et les SACL d’un canal.  
  
 Pour conserver l’accès nouvelles ou modifiées ou de règles à un canal d’audit, utilisez le <xref:System.IO.Pipes.PipeStream.SetAccessControl%2A> (méthode). Pour récupérer un accès ou des règles d’audit à partir d’un fichier existant, utilisez la méthode <xref:System.IO.Pipes.PipeStream.GetAccessControl%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PipeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PipeSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Pipes.PipeSecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un vide <xref:System.IO.Pipes.PipeSecurity> objet qui n’est pas basé sur un canal existant. Vous pouvez remplir l’objet avec les informations de contrôle d’accès, puis l’appliquer à un canal.  
  
 Vous pouvez ajouter un accès ou d’audit pour le <xref:System.IO.Pipes.PipeSecurity> à l’aide de l’objet le <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> (méthode). Vous pouvez supprimer l’accès ou à l’aide de règles d’audit le <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> (méthode).  
  
 Pour conserver l’accès nouvelles ou modifiées ou de règles à un canal d’audit, utilisez le <xref:System.IO.Pipes.PipeStream.SetAccessControl%2A> (méthode). Pour récupérer un accès ou des règles d’audit à partir d’un fichier existant, utilisez la méthode <xref:System.IO.Pipes.PipeStream.GetAccessControl%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.IO.Pipes.PipeSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Type" /> de l’objet sécurisable associé à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <value>Type de l'objet sécurisable associé à l'objet <see cref="T:System.IO.Pipes.PipeSecurity" /> en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propriété et retournent le type qu’ils utilisent pour représenter des droits d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type d’énumération correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="pipeSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Identité à laquelle la règle d’accès s’applique. Il doit s’agir d’un objet pouvant être casté en tant qu’objet <see cref="T:System.Security.Principal.SecurityIdentifier" />.</param>
        <param name="accessMask">Masque d’accès de cette règle. Le masque d’accès est une collection 32 bits de bits anonymes, dont la signification est définie par les différents intégrateurs.</param>
        <param name="isInherited">
          <see langword="true" /> si cette règle est héritée d’un conteneur parent ; sinon « false ».</param>
        <param name="inheritanceFlags">Une des valeurs <see cref="T:System.Security.AccessControl.InheritanceFlags" /> qui spécifie les propriétés d’héritage de la règle d’accès.</param>
        <param name="propagationFlags">Une des valeurs <see cref="T:System.Security.AccessControl.PropagationFlags" /> qui spécifie si les règles d’accès héritées sont propagées automatiquement. Les indicateurs de propagation sont ignorés si <c>inheritanceFlags</c> a la valeur <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="type">Spécifie le type de contrôle d’accès valide.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.AccessRule" /> avec les valeurs spécifiées.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.AccessRule" /> créé par cette méthode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles de contrôle d’accès consiste à utiliser les constructeurs de la <xref:System.IO.Pipes.PipeAccessRule> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="type" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> n’est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d’un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.IO.Pipes.PipeSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Type" /> de l’objet associé aux règles d’accès de l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <value>Type de l'objet associé aux règles d'accès de l'objet <see cref="T:System.IO.Pipes.PipeSecurity" /> en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propriété et retournent le type qu’ils utilisent pour représenter des droits d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type d’énumération correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AddAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’accès à ajouter.</param>
        <summary>Ajoute une règle d’accès à la liste de contrôle d’accès discrétionnaire (DACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> méthode ajoute une nouvelle règle à la liste des règles qui un <xref:System.IO.Pipes.PipeSecurity> objet contient. Si une liste de contrôle d’accès (ACL) existe déjà pour la règle spécifiée, la <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> méthode sera toujours ajouter la règle, à une exception près : un <xref:System.IO.Pipes.PipeAccessRule> objet qui est créé à l’aide de la <xref:System.Security.AccessControl.AccessControlType.Deny> valeur remplace un objet qui est créé à l’aide de la <xref:System.Security.AccessControl.AccessControlType.Allow> valeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AddAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’audit à ajouter.</param>
        <summary>Ajoute une règle d'audit à la liste de contrôle d'accès système (SACL) associée à l'objet <see cref="T:System.IO.Pipes.PipeSecurity" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.AddAuditRule%2A> méthode ajoute une nouvelle règle d’audit à la liste des règles qui un <xref:System.IO.Pipes.PipeSecurity> objet contient.  
  
 Si une règle d’audit existe déjà pour la règle spécifiée, la <xref:System.IO.Pipes.PipeSecurity.AddAuditRule%2A> méthode sera toujours ajouter la règle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override sealed System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="pipeSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Identité à laquelle la règle d’accès s’applique. Il doit s’agir d’un objet pouvant être casté en tant qu’objet <see cref="T:System.Security.Principal.SecurityIdentifier" />.</param>
        <param name="accessMask">Masque d’accès de cette règle. Le masque d’accès est une collection 32 bits de bits anonymes, dont la signification est définie par les différents intégrateurs.</param>
        <param name="isInherited">
          <see langword="true" /> si cette règle est héritée d’un conteneur parent ; sinon « false ».</param>
        <param name="inheritanceFlags">Une des valeurs <see cref="T:System.Security.AccessControl.InheritanceFlags" /> qui spécifie les propriétés d’héritage de la règle d’accès.</param>
        <param name="propagationFlags">Une des valeurs <see cref="T:System.Security.AccessControl.PropagationFlags" /> qui spécifie si les règles d’accès héritées sont propagées automatiquement. Les indicateurs de propagation sont ignorés si <c>inheritanceFlags</c> a la valeur <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="flags">Une des valeurs <see cref="T:System.Security.AccessControl.AuditFlags" /> qui spécifie le type de contrôle d’accès valide.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.AuditRule" /> avec les valeurs spécifiées.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.AuditRule" /> créé par cette méthode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles d’audit consiste à utiliser les constructeurs de la <xref:System.IO.Pipes.PipeAuditRule> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Les propriétés <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="flags" /> spécifient une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">La propriété <paramref name="identityReference" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <paramref name="accessMask" /> est nulle.</exception>
        <exception cref="T:System.ArgumentException">La propriété <paramref name="identityReference" /> n’est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d’un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.IO.Pipes.PipeSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’objet <see cref="T:System.Type" /> associé aux règles d’audit de l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <value>Type de l'objet associé aux règles d'audit de l'objet <see cref="T:System.IO.Pipes.PipeSecurity" /> en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propriété et retournent le type qu’ils utilisent pour représenter des droits d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type d’énumération correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Persist">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Enregistre les sections spécifiées du descripteur de sécurité associé à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel dans un stockage permanent.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="protected internal void Persist (System.Runtime.InteropServices.SafeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Persist(class System.Runtime.InteropServices.SafeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.Persist(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Persist (handle As SafeHandle)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Persist(System::Runtime::InteropServices::SafeHandle ^ handle);" />
      <MemberSignature Language="F#" Value="member this.Persist : System.Runtime.InteropServices.SafeHandle -&gt; unit" Usage="pipeSecurity.Persist handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1;netcore-2.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de l’objet sécurisable auquel l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel est associé.</param>
        <summary>Enregistre les sections spécifiées du descripteur de sécurité associé à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel dans un stockage permanent.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="protected internal void Persist (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Persist(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.Persist(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Persist (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Persist(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.Persist : string -&gt; unit" Usage="pipeSecurity.Persist name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1;netcore-2.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’objet sécurisable auquel l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel est associé.</param>
        <summary>Enregistre les sections spécifiées du descripteur de sécurité associé à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel dans un stockage permanent.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As PipeAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.IO.Pipes.PipeAccessRule -&gt; bool" Usage="pipeSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’accès à supprimer.</param>
        <summary>Supprime une règle d’accès de la liste de contrôle d’accès discrétionnaire (DACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <returns>
          <see langword="true" /> si l'opération réussit ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> méthode supprime soit mise en correspondance tous les <xref:System.Security.AccessControl.AccessControlType.Deny> de règles d’accès ou de mise en correspondance tous les <xref:System.Security.AccessControl.AccessControlType.Allow> règles d’accès à partir du <xref:System.IO.Pipes.PipeSecurity> objet. Par exemple, vous pouvez utiliser cette méthode pour supprimer tous les <xref:System.Security.AccessControl.AccessControlType.Deny> règles d’accès pour un utilisateur en passant un <xref:System.IO.Pipes.PipeAccessRule> objet créé à l’aide de la <xref:System.Security.AccessControl.AccessControlType.Deny> valeur, le <xref:System.IO.Pipes.PipeAccessRights.Read> valeur et un compte d’utilisateur. Le <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> méthode supprime les règles de refus qui spécifient la <xref:System.IO.Pipes.PipeAccessRights.Read> valeur ou la <xref:System.IO.Pipes.PipeAccessRights.Write> valeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAccessRuleSpecific(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’accès à supprimer.</param>
        <summary>Supprime la règle d’accès spécifiée de la liste de contrôle d’accès discrétionnaire (DACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> méthode supprime soit mise en correspondance tous les <xref:System.Security.AccessControl.AccessControlType.Deny> de règles d’accès ou de mise en correspondance tous les <xref:System.Security.AccessControl.AccessControlType.Allow> règles d’accès à partir du <xref:System.IO.Pipes.PipeSecurity> objet. Par exemple, vous pouvez utiliser cette méthode pour supprimer tous les <xref:System.Security.AccessControl.AccessControlType.Deny> règles d’accès pour un utilisateur en passant un <xref:System.IO.Pipes.PipeAccessRule> objet créé à l’aide de la <xref:System.Security.AccessControl.AccessControlType.Deny> valeur, le <xref:System.IO.Pipes.PipeAccessRights.Read> valeur et un compte d’utilisateur. Le <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> méthode supprime les règles de refus qui spécifient la <xref:System.IO.Pipes.PipeAccessRights.Read> valeur ou la <xref:System.IO.Pipes.PipeAccessRights.Write> valeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As PipeAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.IO.Pipes.PipeAuditRule -&gt; bool" Usage="pipeSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’audit à supprimer.</param>
        <summary>Supprime une règle d’audit de la liste de contrôle d’accès système (SACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <returns>
          <see langword="true" /> si la règle d’audit a été supprimée ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRule%2A> méthode supprime soit mise en correspondance tous les <xref:System.Security.AccessControl.AccessControlType.Deny> de règles d’audit ou de toutes les correspondances <xref:System.Security.AccessControl.AccessControlType.Allow> règles d’audit d’actuel <xref:System.IO.Pipes.PipeSecurity> objet.  Par exemple, vous pouvez utiliser cette méthode pour supprimer tous les <xref:System.Security.AccessControl.AccessControlType.Deny> règles d’audit pour un utilisateur en passant un <xref:System.Security.AccessControl.FileSystemAuditRule> objet créé à l’aide de la <xref:System.Security.AccessControl.AccessControlType.Deny> valeur, le <xref:System.Security.AccessControl.AuditFlags.Failure> valeur et un compte d’utilisateur.  Lorsque vous effectuez cette opération, le <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRule%2A> méthode supprime les règles de refus qui spécifient la <xref:System.Security.AccessControl.AuditFlags.Failure> valeur ou la <xref:System.Security.AccessControl.AuditFlags.Success> valeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRuleAll(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’audit à supprimer.</param>
        <summary>Supprime toutes les règles d’audit qui ont le même identificateur de sécurité que la règle d’audit spécifiée dans la liste de contrôle d’accès système (SACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleAll%2A> méthode supprime toutes les règles d’audit pour l’utilisateur spécifié.  Il ignore toutes les valeurs dans le <xref:System.IO.Pipes.PipeAuditRule> objet sauf le compte d’utilisateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’audit à supprimer.</param>
        <summary>Supprime la règle d’audit spécifiée de la liste de contrôle d’accès système (SACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific%2A> méthode supprime la mise en correspondance spécifié <xref:System.Security.AccessControl.AccessControlType.Deny> d’audit de la règle ou la mise en correspondance spécifié <xref:System.Security.AccessControl.AccessControlType.Allow> règle d’audit à partir du <xref:System.IO.Pipes.PipeSecurity> objet.  Par exemple, vous pouvez utiliser cette méthode pour supprimer une certaine <xref:System.Security.AccessControl.AccessControlType.Deny> règle d’audit pour un utilisateur en passant un <xref:System.Security.AccessControl.FileSystemAuditRule> objet créé à l’aide de la <xref:System.Security.AccessControl.AccessControlType.Deny> valeur, le <xref:System.Security.AccessControl.AuditFlags.Failure> valeur et un compte d’utilisateur.  Lorsque vous effectuez cette opération, le <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific%2A> méthode supprime uniquement la règle de refus qui spécifie la <xref:System.Security.AccessControl.AuditFlags.Failure> valeur.  Elle ne supprime pas les règles de refus qui spécifient la <xref:System.Security.AccessControl.AuditFlags.Success> valeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.ResetAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’accès à ajouter.</param>
        <summary>Supprime toutes les règles de la liste de contrôle d’accès discrétionnaire (DACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel, puis ajoute la règle d’accès spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> méthode ajoute la règle liste (ACL) de contrôle d’accès spécifié ou remplace les règles ACL identiques qui correspondent à la `rule` paramètre.  Par exemple, si le `rule` paramètre spécifie un <xref:System.IO.Pipes.PipeAccessRights.Read> valeur et le <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> méthode recherche une règle ACL identique qui spécifie la <xref:System.IO.Pipes.PipeAccessRights.Read> valeur, la règle identique sera remplacée.  Si le <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> méthode recherche une règle ACL identique qui spécifie la <xref:System.IO.Pipes.PipeAccessRights.Write> valeur, la règle identique sera également remplacée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.SetAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle à définir.</param>
        <summary>Définit une règle d’accès dans la liste de contrôle d’accès discrétionnaire (DACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> méthode ajoute la règle liste (ACL) de contrôle d’accès spécifié ou remplace les règles ACL identiques qui correspondent à la <xref:System.IO.Pipes.PipeAccessRights> valeur de la `rule` paramètre.  Par exemple, si le `rule` paramètre spécifie un <xref:System.IO.Pipes.PipeAccessRights.Read> valeur et le <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> méthode recherche une règle ACL identique qui spécifie la <xref:System.IO.Pipes.PipeAccessRights.Read> valeur, la règle identique sera remplacée.  Si le <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> méthode recherche une règle ACL identique qui spécifie la <xref:System.IO.Pipes.PipeAccessRights.Write> valeur, la règle identique ne pourra être remplacée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.SetAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle à définir.</param>
        <summary>Établit une règle de vérification dans la liste de contrôle d’accès système (SACL) associée à l’objet <see cref="T:System.IO.Pipes.PipeSecurity" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> méthode ajoute la règle d’audit spécifiée ou remplace les règles d’audit identiques qui correspondent à la <xref:System.IO.Pipes.PipeAccessRights> valeur de la `rule` paramètre.  Par exemple, si le `rule` paramètre spécifie un <xref:System.IO.Pipes.PipeAccessRights.Read> valeur et le <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> méthode recherche une règle d’audit identique qui spécifie la <xref:System.IO.Pipes.PipeAccessRights.Read> valeur, la règle identique sera remplacée.  Si le <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> méthode recherche une règle d’audit identique qui spécifie la <xref:System.IO.Pipes.PipeAccessRights.Write> valeur, la règle identique ne pourra être remplacée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>