<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="994e2025e1f3a2359af6858e83f5ea135065e4f7" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48661821" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des services pour la gestion de la file d'attente des éléments de travail d'un thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Threading.Dispatcher> maintient une file d’attente prioritaire d’éléments de travail pour un thread spécifique.  
  
 Quand un <xref:System.Windows.Threading.Dispatcher> est créé sur un thread, il devient le seul <xref:System.Windows.Threading.Dispatcher> qui peut être associé au thread, même si le <xref:System.Windows.Threading.Dispatcher> est arrêté.  
  
 Si vous tentez d’obtenir le <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> pour le thread actuel et un <xref:System.Windows.Threading.Dispatcher> n’est pas associé au thread, un <xref:System.Windows.Threading.Dispatcher> sera créé. Un <xref:System.Windows.Threading.Dispatcher> est également créée lorsque vous créez un <xref:System.Windows.Threading.DispatcherObject>. Si vous créez un <xref:System.Windows.Threading.Dispatcher> sur un thread d’arrière-plan, veillez à arrêter le répartiteur avant de quitter le thread.  
  
 Si un <xref:System.Windows.Threading.Dispatcher> est arrêté, il ne peut pas être redémarré.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], un <xref:System.Windows.Threading.DispatcherObject> est uniquement accessible par le <xref:System.Windows.Threading.Dispatcher> lui est associée.  Par exemple, un thread d’arrière-plan ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui est associé le <xref:System.Windows.Threading.Dispatcher> sur la [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] thread.  Afin que le thread d’arrière-plan pour accéder à la <xref:System.Windows.Controls.ContentControl.Content%2A> propriété de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé à la [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] thread.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est appelée sur un <xref:System.Windows.Threading.Dispatcher> qui s’est arrêté, la propriété status de retourné <xref:System.Windows.Threading.DispatcherOperation> est défini sur <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 Toutes les méthodes sur <xref:System.Windows.Threading.Dispatcher>, à l’exception de <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, sont libres de threads.  
  
 Objets qui dérivent de <xref:System.Windows.Threading.DispatcherObject> ont une affinité de thread.  
  
 Objets qui dérivent de <xref:System.Windows.Freezable> sont libres de threads lorsqu’ils sont figés.  Pour plus d’informations, consultez [Vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment placer une opération sur un <xref:System.Windows.Threading.Dispatcher>.  Pour le code source complet de cet exemple, consultez [Single-Threaded Application avec Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Tout d’abord, un délégué est créé qui n’accepte aucun argument.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Ensuite, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> est appelée.  Cet appel à <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> accepte deux paramètres : la priorité, qui est définie sur <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>et le rappel, qui est passé dans une instance du délégué `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=160038">Application monothread avec Long-Running Calculation Sample</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute de façon asynchrone un délégué sur le thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone ; Par conséquent, contrôle immédiat à l’objet appelant après que qu’elle est appelée.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Retourne un <xref:System.Windows.Threading.DispatcherOperation> objet qui peut être utilisé pour interagir avec le délégué lorsque le délégué est dans cette file d’attente.  
  
 Le <xref:System.Windows.Threading.DispatcherOperation> objet retourné par <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> peut être utilisé de plusieurs façons d’interagir avec le délégué spécifié, tel que :  
  
-   Modification de la <xref:System.Windows.Threading.DispatcherPriority> du délégué en attente l’exécution de l’événement de file d’attente.  
  
-   Suppression du délégué de la file d’attente de l’événement.  
  
-   En attente de délégué à retourner.  
  
-   Obtention de la valeur retournée par le délégué après qu’il est exécuté.  
  
 Si plusieurs <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> appels sont effectués au même <xref:System.Windows.Threading.DispatcherPriority>, elles sont exécutées dans l’ordre les appels ont été apportées.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est appelée sur un <xref:System.Windows.Threading.Dispatcher> qui s’est arrêté, la propriété status de retourné <xref:System.Windows.Threading.DispatcherOperation> est défini sur <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Délégué d’une méthode qui prend les paramètres spécifiés dans <c>args</c>, qui fait l’objet d’un envoi (push) dans la file d’attente des événements de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="args">Tableau d’objets à passer comme arguments à la méthode donnée. Peut être <see langword="null" />.</param>
        <summary>Exécute de façon asynchrone le délégué spécifié avec les arguments spécifiés sur le thread sur lequel le <see cref="T:System.Windows.Threading.Dispatcher" /> spécifié a été créé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Threading.DispatcherOperation> objet retourné par <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> peut être utilisé de plusieurs façons d’interagir avec le délégué spécifié, tel que :  
  
-   Modification de la <xref:System.Windows.Threading.DispatcherPriority> du délégué en attente l’exécution de l’événement de file d’attente.  
  
-   Suppression du délégué de la file d’attente de l’événement.  
  
-   En attente de délégué à retourner.  
  
-   Obtention de la valeur retournée par le délégué après qu’il est exécuté.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone ; Par conséquent, contrôle immédiat à l’objet appelant après que qu’elle est appelée.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet. Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur. Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur. Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone. L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est appelée sur un <xref:System.Windows.Threading.Dispatcher> qui s’est arrêté, la propriété status de retourné <xref:System.Windows.Threading.DispatcherOperation> est défini sur <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="method">Délégué vers une méthode qui ne prend pas d'arguments, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Exécute le délégué spécifié de façon asynchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si plusieurs <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> appels sont effectués au même <xref:System.Windows.Threading.DispatcherPriority>, elles sont exécutées dans l’ordre les appels ont été apportées.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Retourne un <xref:System.Windows.Threading.DispatcherOperation> objet qui peut être utilisé pour interagir avec le délégué lorsque le délégué est dans cette file d’attente.  
  
 Le <xref:System.Windows.Threading.DispatcherOperation> objet retourné par <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> peut être utilisé de plusieurs façons d’interagir avec le délégué spécifié, tel que :  
  
-   Modification de la <xref:System.Windows.Threading.DispatcherPriority> du délégué en attente l’exécution de l’événement de file d’attente.  
  
-   Suppression du délégué de la file d’attente de l’événement.  
  
-   En attente de délégué à retourner.  
  
-   Obtention de la valeur retournée par le délégué après qu’il est exécuté.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone ; Par conséquent, contrôle immédiat à l’objet appelant après que qu’elle est appelée.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est appelée sur un <xref:System.Windows.Threading.Dispatcher> qui s’est arrêté, la propriété status de retourné <xref:System.Windows.Threading.DispatcherOperation> est défini sur <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 L’exemple suivant montre comment placer une opération sur un <xref:System.Windows.Threading.Dispatcher>.  Pour le code source complet de cet exemple, consultez [Single-Threaded Application avec Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Tout d’abord, un délégué est créé qui n’accepte aucun argument.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Ensuite, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> est appelée.  Étant donné que chaque <xref:System.Windows.Threading.DispatcherObject> a une propriété qui retourne le <xref:System.Windows.Threading.Dispatcher> il est associé, souhaité <xref:System.Windows.Threading.Dispatcher> est obtenu en interrogeant le <xref:System.Windows.Threading.DispatcherObject>, dans ce cas un <xref:System.Windows.Controls.Button> nommé `startStopButton`.   L’appel à <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> accepte deux paramètres : la priorité, qui est définie sur <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>et le rappel, qui est passé dans une instance du délégué `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> n’est pas un <see cref="T:System.Windows.Threading.DispatcherPriority" /> valide.</exception>
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=160038">Application monothread avec Long-Running Calculation Sample</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Délégué d’une méthode qui prend les paramètres spécifiés dans <c>args</c>, qui fait l’objet d’un envoi (push) dans la file d’attente des événements de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="args">Tableau d’objets à passer comme arguments à la méthode donnée. Peut être <see langword="null" />.</param>
        <summary>Exécute le délégué spécifié de façon asynchrone selon la priorité indiquée et avec les arguments définis, sur le  thread sur lequel <see cref="T:System.Windows.Threading.Dispatcher" /> a été créé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Threading.DispatcherOperation> objet retourné par <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> peut être utilisé de plusieurs façons d’interagir avec le délégué spécifié, tel que :  
  
-   Modification de la <xref:System.Windows.Threading.DispatcherPriority> du délégué en attente l’exécution de l’événement de file d’attente.  
  
-   Suppression du délégué de la file d’attente de l’événement.  
  
-   En attente de délégué à retourner.  
  
-   Obtention de la valeur retournée par le délégué après qu’il est exécuté.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone ; Par conséquent, contrôle immédiat à l’objet appelant après que qu’elle est appelée.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet. Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur. Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur. Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone. L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est appelée sur un <xref:System.Windows.Threading.Dispatcher> qui s’est arrêté, la propriété status de retourné <xref:System.Windows.Threading.DispatcherOperation> est défini sur <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="method">Délégué vers une méthode qui prend un argument, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objet à passer comme argument à la méthode spécifiée.</param>
        <summary>Exécute le délégué spécifié de façon asynchrone selon la priorité indiquée et avec l'argument défini au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` peut être `null` si aucun argument n’est nécessaire.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Retourne un <xref:System.Windows.Threading.DispatcherOperation> objet qui peut être utilisé pour interagir avec le délégué lorsque le délégué est dans cette file d’attente.  
  
 Le <xref:System.Windows.Threading.DispatcherOperation> objet retourné par <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> peut être utilisé de plusieurs façons d’interagir avec le délégué spécifié, tel que :  
  
-   Modification de la <xref:System.Windows.Threading.DispatcherPriority> du délégué en attente l’exécution de l’événement de file d’attente.  
  
-   Suppression du délégué de la file d’attente de l’événement.  
  
-   En attente de délégué à retourner.  
  
-   Obtention de la valeur retournée par le délégué après qu’il est exécuté.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone ; Par conséquent, contrôle immédiat à l’objet appelant après que qu’elle est appelée.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si plusieurs <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> appels sont effectués au même <xref:System.Windows.Threading.DispatcherPriority>, elles sont exécutées dans l’ordre les appels ont été apportées.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est appelée sur un <xref:System.Windows.Threading.Dispatcher> qui s’est arrêté, la propriété status de retourné <xref:System.Windows.Threading.DispatcherOperation> est défini sur <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 L’exemple suivant montre comment placer une opération sur un <xref:System.Windows.Threading.Dispatcher>.  
  
 Tout d’abord, un délégué est créé qui accepte un seul argument, dans ce cas une chaîne.  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 Ensuite, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> est appelée.  Étant donné que chaque <xref:System.Windows.Threading.DispatcherObject> a une propriété qui retourne le <xref:System.Windows.Threading.Dispatcher> il est associé, souhaité <xref:System.Windows.Threading.Dispatcher> est obtenu en interrogeant le <xref:System.Windows.Threading.DispatcherObject>, dans ce cas un <xref:System.Windows.Controls.Grid> nommé `tomorrowsWeather`. L’appel à <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> accepte trois paramètres : la priorité, qui est définie sur <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; le rappel, qui est passé dans une instance du délégué `OneArgDelegate`; et une chaîne nommée `weather`, qui est l’argument pour le rappel.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> n’est pas un <see cref="T:System.Windows.Threading.DispatcherPriority" /> valide.</exception>
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=160038">Application monothread avec Long-Running Calculation Sample</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="method">Délégué vers une méthode qui prend plusieurs arguments, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objet à passer comme argument à la méthode spécifiée.</param>
        <param name="args">Tableau d'objets à passer comme arguments à la méthode spécifiée.</param>
        <summary>Exécute le délégué spécifié de façon asynchrone selon la priorité indiquée et avec le tableau d'arguments défini au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente du <see cref="T:System.Windows.Threading.Dispatcher" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `arg` paramètre peut être `null` si aucun argument n’est nécessaire.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Retourne un <xref:System.Windows.Threading.DispatcherOperation> objet qui peut être utilisé pour interagir avec le délégué lorsque le délégué est dans cette file d’attente.  
  
 Le <xref:System.Windows.Threading.DispatcherOperation> objet retourné par <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> peut être utilisé de plusieurs façons d’interagir avec le délégué spécifié, tel que :  
  
-   Modification de la <xref:System.Windows.Threading.DispatcherPriority> du délégué en attente l’exécution de l’événement de file d’attente.  
  
-   Suppression du délégué de la file d’attente de l’événement.  
  
-   En attente de délégué à retourner.  
  
-   Obtention de la valeur retournée par le délégué après qu’il est exécuté.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone ; Par conséquent, contrôle immédiat à l’objet appelant après que qu’elle est appelée.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si plusieurs <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> appels sont effectués au même <xref:System.Windows.Threading.DispatcherPriority>, elles sont exécutées dans l’ordre les appels ont été apportées.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est appelée sur un <xref:System.Windows.Threading.Dispatcher> qui s’est arrêté, la propriété status de retourné <xref:System.Windows.Threading.DispatcherOperation> est défini sur <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Threading.DispatcherPriority" /> n'est pas une priorité valide.</exception>
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=160038">Application monothread avec Long-Running Calculation Sample</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité à laquelle l'arrêt du répartiteur doit commencer.</param>
        <summary>Initialise de façon asynchrone l'arrêt du <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A> les demandes sans restriction des autorisations de l’interface utilisateur.  
  
 Lorsque le <xref:System.Windows.Threading.Dispatcher> commence à arrêter, le <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> événement est déclenché et <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> est défini sur `true`.  
  
 Le <xref:System.Windows.Threading.Dispatcher> n’arrête pas complètement jusqu'à ce que la file d’attente de l’événement se déroule.  
  
 Lorsque le répartiteur termine en cours d’arrêt, le <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> événement est déclenché et le <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propriété est définie sur `true`.  
  
 Une fois que le processus d’arrêt commence, toutes les tâches en attente, les éléments dans la file d’attente sont abandonnées.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour arrêter le répartiteur.  Énumérations associées :  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si le thread appelant est le thread associé à ce <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>
          <see langword="true" /> si le thread appelant est le thread associé à ce <see cref="T:System.Windows.Threading.Dispatcher" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uniquement les <xref:System.Windows.Threading.Dispatcher> qui un <xref:System.Windows.Threading.DispatcherObject> est créé peut accéder l’objet.  Utilisez <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> pour accéder à l’objet d’un thread différent.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> peut être appelée à partir de n’importe quel thread.  
  
 La différence entre <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> et <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> est <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> retourne une valeur booléenne indiquant si le thread appelant a accès à la <xref:System.Windows.Threading.Dispatcher> et <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> lève une exception.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> pour déterminer si un thread a accès à un <xref:System.Windows.Controls.Button>.  Le <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> méthode sur le <xref:System.Windows.Threading.Dispatcher> associé à la <xref:System.Windows.Controls.Button> est appelée pour vérifier l’accès au thread.  Si le thread appelant a accès à la <xref:System.Windows.Threading.Dispatcher>, le <xref:System.Windows.Controls.Button> est mis à jour en accédant aux membres de la <xref:System.Windows.Controls.Button>; sinon, un délégué qui accepte un <xref:System.Windows.Controls.Button> en tant qu’argument, est placé sur le <xref:System.Windows.Threading.Dispatcher>.  Le <xref:System.Windows.Threading.Dispatcher> délègue le travail de mise à jour le <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Threading.Dispatcher" /> pour le thread en cours d'exécution et crée un nouveau <see cref="T:System.Windows.Threading.Dispatcher" /> si aucun n'est déjà associé au thread.</summary>
        <value>Répartiteur associé au thread actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.Windows.Threading.Dispatcher> n’est pas associé au thread actuel, un nouveau <xref:System.Windows.Threading.Dispatcher> sera créé.  Ce n'est pas le cas avec la méthode <xref:System.Windows.Threading.Dispatcher.FromThread%2A>.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A> retournera `null` si il n’existe pas de répartiteur associé au thread spécifié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désactive le traitement de la file d'attente du <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Structure utilisée pour réactiver le traitement du répartiteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Désactiver le traitement du répartiteur est une méthode avancée qui vise à éliminer le risque de réentrance non associée.  
  
 Les effets de la désactivation de traitement sont les suivantes :  
  
-   Verrous CLR ne seront pas pompe pas les messages en interne.  
  
-   <xref:System.Windows.Threading.DispatcherFrame> objets ne sont pas autorisés à être envoyées.  
  
-   Traitement des messages n’est pas autorisé.  
  
 Le <xref:System.Windows.Threading.DispatcherProcessingDisabled> qui structure <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> retourne lorsqu’elle est appelée peut être utilisé pour réactiver le traitement du répartiteur.  Appel <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> sur la <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure réactive le traitement.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> peut uniquement être appelée sur le thread du <xref:System.Windows.Threading.Dispatcher> est associé.  
  
   
  
## Examples  
 L’exemple suivant montre comment désactiver et réactiver le traitement du répartiteur.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> est appelé dans un **à l’aide de** instruction.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> Retourne un <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure qui est utilisé en tant que l’objet à supprimer après la **à l’aide de** exécution du bloc.  Lorsque <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> est appelée sur le <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure, le traitement du répartiteur est réactivé.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Demande la fermeture de tous les frames, y compris les frames imbriqués.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour appeler cette méthode. Énumérations associées :  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">Thread à partir duquel obtenir le <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Obtient le <see cref="T:System.Windows.Threading.Dispatcher" /> pour le thread spécifié.</summary>
        <returns>Répartiteur de <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un répartiteur n’est pas disponible pour le thread spécifié, `null` sera retourné.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> ne crée pas un <xref:System.Windows.Threading.Dispatcher> sur un thread qui n’a pas un <xref:System.Windows.Threading.Dispatcher>.   Un nouveau <xref:System.Windows.Threading.Dispatcher> est créé sur un thread qui n’a pas déjà un <xref:System.Windows.Threading.Dispatcher> lorsque vous tentez d’obtenir le <xref:System.Windows.Threading.Dispatcher> à l’aide de la <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si l'arrêt du <see cref="T:System.Windows.Threading.Dispatcher" /> a abouti.</summary>
        <value>
          <see langword="true" /> si l'arrêt du répartiteur a abouti ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Threading.Dispatcher> commence à arrêter, le <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> événement est déclenché et <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> est défini sur `true`.  
  
 Le <xref:System.Windows.Threading.Dispatcher> ne s’arrête pas complètement jusqu'à ce que la file d’attente de l’événement se déroule.  
  
 Lorsque le répartiteur termine en cours d’arrêt, le <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> événement est déclenché et le <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propriété est définie sur `true`.  
  
 Une fois que le processus d’arrêt commence, toutes les tâches en attente, les éléments dans la file d’attente sont abandonnées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si le processus d'arrêt du <see cref="T:System.Windows.Threading.Dispatcher" /> est en cours.</summary>
        <value>
          <see langword="true" /> si le processus d'arrêt du <see cref="T:System.Windows.Threading.Dispatcher" /> a commencé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Threading.Dispatcher> commence à arrêter, le <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> événement est déclenché et <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> est défini sur `true`.  
  
 Le <xref:System.Windows.Threading.Dispatcher> n’arrête pas complètement jusqu'à ce que la file d’attente de l’événement se déroule.  
  
 Lorsque le répartiteur termine en cours d’arrêt, le <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> événement est déclenché et le <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propriété est définie sur `true`.  
  
 Une fois que le processus d’arrêt commence, toutes les tâches en attente, les éléments dans la file d’attente sont abandonnées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de raccordements qui fournissent des informations d'événement supplémentaires sur le <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <value>Raccordements associés à ce <see cref="T:System.Windows.Threading.Dispatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Threading.DispatcherHooks> classe fournit des informations d’événement supplémentaires sur le <xref:System.Windows.Threading.Dispatcher>, par exemple lorsque le <xref:System.Windows.Threading.Dispatcher> est inactif ou quand une opération est terminée.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour obtenir cette propriété.  Énumérations associées :  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute le délégué spécifié de façon synchrone au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
   
  
## Examples  
 L’exemple suivant place un délégué sur un <xref:System.Windows.Threading.Dispatcher> à <xref:System.Windows.Threading.DispatcherPriority.Normal> à l’aide de <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <summary>Exécute l'objet <see cref="T:System.Action" /> spécifié de façon synchrone au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Exécute l'objet <see cref="T:System.Action" /> spécifié de façon synchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Délégué d’une méthode qui prend les paramètres spécifiés dans <c>args</c>, qui fait l’objet d’un envoi (push) dans la file d’attente des événements de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="args">Tableau d’objets à passer comme arguments à la méthode donnée. Peut être <see langword="null" />.</param>
        <summary>Exécute le délégué spécifié de façon synchrone avec les arguments spécifiés, sur le thread auquel <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet. Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur. Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur. Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone. L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="method">Délégué vers une méthode qui ne prend pas d'arguments, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Exécute le délégué spécifié de façon synchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
   
  
## Examples  
 L’exemple suivant place un délégué sur un <xref:System.Windows.Threading.Dispatcher> à <xref:System.Windows.Threading.DispatcherPriority.Normal> à l’aide de <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> est égal à <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> n'est pas une priorité valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Objet qui indique s'il est nécessaire d'annuler l'action.</param>
        <summary>Exécute l'objet <see cref="T:System.Action" /> spécifié de façon synchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Délégué d’une méthode qui prend les paramètres spécifiés dans <c>args</c>, qui fait l’objet d’un envoi (push) dans la file d’attente des événements de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="timeout">Durée maximale d'attente d'achèvement de l'opération.</param>
        <param name="args">Tableau d’objets à passer comme arguments à la méthode donnée. Peut être <see langword="null" />.</param>
        <summary>Exécute le délégué spécifié de façon synchrone, dans l'intervalle de temps spécifié, selon la priorité indiquée et avec les arguments définis sur le thread auquel <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet. Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur. Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur. Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone. L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Délégué d’une méthode qui prend les paramètres spécifiés dans <c>args</c>, qui fait l’objet d’un envoi (push) dans la file d’attente des événements de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="args">Tableau d’objets à passer comme arguments à la méthode donnée. Peut être <see langword="null" />.</param>
        <summary>Exécute le délégué spécifié de façon synchrone selon la priorité indiquée et avec les arguments définis au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet. Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur. Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur. Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone. L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="method">Délégué vers une méthode qui prend un argument, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objet à passer comme argument à la méthode donnée.</param>
        <summary>Exécute le délégué spécifié de façon synchrone selon la priorité indiquée et avec l'argument défini au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` peut être `null` si un argument n’est pas nécessaire.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> est égal à <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> n'est pas une priorité valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="timeout">Temps d'attente maximal pour l'aboutissement de l'opération.</param>
        <param name="method">Délégué vers une méthode qui ne prend pas d'arguments, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Exécute le délégué spécifié de façon synchrone selon la priorité indiquée et avec la valeur de délai d'attente définie au niveau du thread sur lequel le <see cref="T:System.Windows.Threading.Dispatcher" /> a été créé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Objet qui indique s'il est nécessaire d'annuler l'action.</param>
        <param name="timeout">Durée minimale d'attente de démarrage de l'opération.</param>
        <summary>Exécute l'objet <see cref="T:System.Action" /> spécifié de façon synchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Délégué d’une méthode qui prend les paramètres spécifiés dans <c>args</c>, qui fait l’objet d’un envoi (push) dans la file d’attente des événements de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="timeout">Durée maximale d'attente d'achèvement de l'opération.</param>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="args">Tableau d’objets à passer comme arguments à la méthode donnée. Peut être <see langword="null" />.</param>
        <summary>Exécute le délégué spécifié de façon synchrone, dans l'intervalle de temps spécifié, selon la priorité indiquée et avec les arguments définis sur le thread auquel <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet. Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur. Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur. Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone. L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="method">Délégué vers une méthode qui prend plusieurs arguments, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objet à passer comme argument à la méthode donnée.</param>
        <param name="args">Tableau d’objets à passer comme arguments à la méthode donnée.</param>
        <summary>Exécute le délégué spécifié de façon synchrone selon la priorité indiquée et avec les arguments définis au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` peut être `null` si un argument n’est pas nécessaire.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> est égal à <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> n'est pas une priorité valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="timeout">Temps d'attente maximal pour l'aboutissement de l'opération.</param>
        <param name="method">Délégué vers une méthode qui prend plusieurs arguments, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objet à passer comme argument à la méthode donnée. Peut être <see langword="null" /> si aucun argument n'est nécessaire.</param>
        <summary>Exécute le délégué spécifié de façon synchrone selon la priorité indiquée et avec l'argument défini au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` peut être `null` si un argument n’est pas nécessaire.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> est égal à <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> n'est pas une priorité valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorité, par rapport aux autres opérations en attente dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />, à laquelle la méthode spécifiée est appelée.</param>
        <param name="timeout">Temps d'attente maximal pour l'aboutissement de l'opération.</param>
        <param name="method">Délégué vers une méthode qui prend plusieurs arguments, qui fait l'objet d'un push dans la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objet à passer comme argument à la méthode spécifiée.</param>
        <param name="args">Tableau d'objets à passer comme arguments à la méthode spécifiée.</param>
        <summary>Exécute le délégué spécifié de façon synchrone selon la priorité indiquée et avec les arguments définis au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Valeur de retour du délégué appelé ou <see langword="null" /> si le délégué n'a pas de valeur de retour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` peut être `null` si un argument n’est pas nécessaire.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], uniquement le thread qui a créé un <xref:System.Windows.Threading.DispatcherObject> peuvent accéder à cet objet.  Par exemple, un thread d’arrière-plan qui est lancé à partir du thread d’interface utilisateur ne peut pas mettre à jour le contenu d’un <xref:System.Windows.Controls.Button> qui a été créé sur le thread d’interface utilisateur.  Afin que le thread d’arrière-plan accéder à la propriété de contenu de la <xref:System.Windows.Controls.Button>, le thread d’arrière-plan doit déléguer le travail à la <xref:System.Windows.Threading.Dispatcher> associé au thread d’interface utilisateur.  Cela est accompli en utilisant soit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est synchrone et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est asynchrone.  L’opération est ajoutée à la file d’attente des événements de la <xref:System.Windows.Threading.Dispatcher> à l’emplacement spécifié <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> est une opération synchrone ; Par conséquent, contrôle ne retourne pas à l’objet appelant jusqu'à ce qu’après le retour du rappel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> est égal à <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> n’est pas un <see cref="T:System.Windows.Threading.DispatcherPriority" /> valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de valeur de retour du délégué spécifié.</typeparam>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <summary>Exécute l'objet <see cref="T:System.Func`1" /> spécifié de façon synchrone au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de valeur de retour du délégué spécifié.</typeparam>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Exécute l'objet <see cref="T:System.Func`1" /> spécifié de façon synchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de valeur de retour du délégué spécifié.</typeparam>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Objet qui indique s'il est nécessaire d'annuler l'opération.</param>
        <summary>Exécute l'objet <see cref="T:System.Func`1" /> spécifié de façon synchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de valeur de retour du délégué spécifié.</typeparam>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Objet qui indique s'il est nécessaire d'annuler l'opération.</param>
        <param name="timeout">Durée minimale d'attente de démarrage de l'opération.</param>
        <summary>Exécute l'objet <see cref="T:System.Func`1" /> spécifié de façon synchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute le délégué spécifié de façon asynchrone au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <summary>Exécute l'objet <see cref="T:System.Action" /> spécifié de façon asynchrone au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Exécute l'objet <see cref="T:System.Action" /> spécifié de façon asynchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Objet qui indique s'il est nécessaire d'annuler l'action.</param>
        <summary>Exécute l'objet <see cref="T:System.Action" /> spécifié de façon asynchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de valeur de retour du délégué spécifié.</typeparam>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <summary>Exécute l'objet <see cref="T:System.Func`1" /> spécifié de façon asynchrone au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de valeur de retour du délégué spécifié.</typeparam>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Exécute l'objet <see cref="T:System.Func`1" /> spécifié de façon asynchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de valeur de retour du délégué spécifié.</typeparam>
        <param name="callback">Délégué permettant d'appeler via le répartiteur.</param>
        <param name="priority">La priorité qui détermine l'ordre d'exécution du rappel spécifié, est appelée par rapport aux autres opérations en attente dans <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Objet qui indique s'il est nécessaire d'annuler l'opération.</param>
        <summary>Exécute l'objet <see cref="T:System.Func`1" /> spécifié de façon asynchrone selon la priorité spécifiée au niveau du thread auquel le <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <returns>Objet qui est retourné immédiatement après l'appel de <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> et qui peut être utilisé pour interagir avec le délégué en attente d'exécution dans la file d'attente des événements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialise de façon synchrone le processus d'arrêt du <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A> les demandes sans restriction des autorisations de l’interface utilisateur.  
  
 Lorsque le <xref:System.Windows.Threading.Dispatcher> commence à arrêter, le <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> événement est déclenché et <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> est défini sur `true`.  
  
 Le <xref:System.Windows.Threading.Dispatcher> n’arrête pas complètement jusqu'à ce que la file d’attente de l’événement se déroule.  
  
 Lorsque le répartiteur termine en cours d’arrêt, le <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> événement est déclenché et le <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propriété est définie sur `true`.  
  
 Une fois que le processus d’arrêt commence, toutes les tâches en attente, les éléments dans la file d’attente sont abandonnées.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour arrêter le répartiteur.  Énumérations associées :  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">Frame que le répartiteur doit traiter.</param>
        <summary>Entame une boucle d'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Threading.DispatcherFrame> représente une boucle qui traite les éléments de travail en attente.  
  
 Le répartiteur traite la file d’attente des éléments de travail dans une boucle.  La boucle est appelée un frame.  La boucle initiale est généralement créée par l’application en appelant <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> entame une boucle représentée par le paramètre `frame`.  À chaque itération de la boucle, le <xref:System.Windows.Threading.Dispatcher> vérifiera la <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> propriété sur le <xref:System.Windows.Threading.DispatcherFrame> classe pour déterminer si la boucle doit continuer ou si elle doit s’arrêter.  
  
 <xref:System.Windows.Threading.DispatcherFrame> permet la <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> propriété à définir explicitement et respecte le <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> propriété sur le <xref:System.Windows.Threading.Dispatcher>.  Cela signifie que, lorsque le <xref:System.Windows.Threading.Dispatcher> commence à arrêter, les frames qui utilisent la valeur par défaut <xref:System.Windows.Threading.DispatcherFrame> implémentation s’arrête, ce qui permet à tous les frames imbriqués quitter.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Threading.DispatcherFrame> pour obtenir des résultats similaires en tant que le [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> (méthode).  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="frame" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> a la valeur <see langword="true" />.  
  
- ou - 
 <paramref name="frame" /> s'exécute sur un <see cref="T:System.Windows.Threading.Dispatcher" /> différent.  
  
- ou - 
Le traitement du répartiteur a été désactivé.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">pour pousser un frame d’exécution.  Énumérations associées :  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exécute un push du frame d'exécution principal au niveau de la file d'attente des événements du <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Threading.Dispatcher> traite la file d’attente d’événement dans une boucle.  La boucle est appelée un frame.  La boucle initiale est généralement créée par l’application en appelant <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 Le frame d’exécution principal continue jusqu'à ce que le <xref:System.Windows.Threading.Dispatcher> est arrêtée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit une fois l'arrêt du <see cref="T:System.Windows.Threading.Dispatcher" /> accompli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le processus d’arrêt d’un <xref:System.Windows.Threading.Dispatcher> est démarré, le <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> événement est déclenché et <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> est défini sur `true`.  
  
 Le <xref:System.Windows.Threading.Dispatcher> ne s’arrête pas complètement jusqu'à ce que la file d’attente de l’événement se déroule.  
  
 Lorsque le répartiteur termine en cours d’arrêt, le <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> événement est déclenché et le <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propriété est définie sur `true`.  
  
 Une fois que le processus d’arrêt commence, toutes les tâches en attente, les éléments dans la file d’attente sont abandonnées.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au début du processus d'arrêt du <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le processus d’arrêt d’un <xref:System.Windows.Threading.Dispatcher> est démarré, le <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> événement est déclenché et <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> est défini sur `true`.  
  
 Le <xref:System.Windows.Threading.Dispatcher> ne s’arrête pas complètement jusqu'à ce que la file d’attente de l’événement se déroule.  
  
 Lorsque le répartiteur termine en cours d’arrêt, le <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> événement est déclenché et le <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propriété est définie sur `true`.  
  
 Une fois que le processus d’arrêt commence, toutes les tâches en attente, les éléments dans la file d’attente sont abandonnées.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le thread auquel ce <see cref="T:System.Windows.Threading.Dispatcher" /> est associé.</summary>
        <value>Thread.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une exception de thread est levée et non interceptée pendant l'exécution d'un délégué au moyen de <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> ou de <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsqu’une exception a été levée pendant l’exécution d’un délégué au moyen de <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> n’est pas interceptée.  
  
 Un gestionnaire peut marquer l’exception comme étant géré, ce qui empêche le Gestionnaire d’exceptions interne qui est appelée.  
  
 Gestionnaires d’événements pour cet événement doivent être écrite avec précaution pour éviter de créer des exceptions secondaire et intercepter celles qui se produisent. Il est recommandé d’éviter d’allocation de mémoire ou pour effectuer des opérations intensives dans le Gestionnaire de n’importe quelle ressource.  
  
 Le <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> événement permet de ne pas déclencher la <xref:System.Windows.Threading.Dispatcher.UnhandledException> événement.  Le <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> événement est déclenché en premier et si <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> sur le <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> a la valeur `false`, le <xref:System.Windows.Threading.Dispatcher.UnhandledException> événement n’est pas déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une exception de thread est levée et non interceptée pendant l'exécution d'un délégué au moyen de <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> ou de <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> lors de l'étape de filtrage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché pendant l’étape de filtrage pour une exception est levée pendant l’exécution d’un délégué au moyen de <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> et n’est pas interceptée.  
  
 La pile des appels n’est pas déroulée à ce stade (exception de première chance).  
  
 Gestionnaires d’événements pour cet événement doivent être écrite avec précaution pour éviter de créer des exceptions secondaire et intercepter celles qui se produisent.  Il est recommandé d’éviter d’allocation de mémoire ou pour effectuer des opérations intensives dans le Gestionnaire de n’importe quelle ressource.  
  
 Le <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> événement permet de ne pas déclencher la <xref:System.Windows.Threading.Dispatcher.UnhandledException> événement.  Le <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> événement est déclenché en premier et si <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> sur le <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> a la valeur `false`, le <xref:System.Windows.Threading.Dispatcher.UnhandledException> événement n’est pas déclenché.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour ajouter ou supprimer un gestionnaire pour cet événement.  Énumérations associées :  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité à vérifier.</param>
        <param name="parameterName">Chaîne qui sera retournée par l'exception qui se produira si la priorité n'est pas valide.</param>
        <summary>Détermine si la priorité <see cref="T:System.Windows.Threading.DispatcherPriority" /> spécifiée est une priorité valide.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> n’est pas un <see cref="T:System.Windows.Threading.DispatcherPriority" /> valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si le thread appelant a accès à ce <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seul le thread le <xref:System.Windows.Threading.Dispatcher> est créé peut accéder le <xref:System.Windows.Threading.Dispatcher>.  
  
 Cette méthode est publique ; Par conséquent, n’importe quel thread peut vérifier s’il a accès à la <xref:System.Windows.Threading.Dispatcher>.  
  
 La différence entre <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> et <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> est <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> retourne une valeur booléenne si le thread appelant n’a pas accès à la <xref:System.Windows.Threading.Dispatcher> et <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> lève une exception.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> pour déterminer si un thread a accès au thread qui un <xref:System.Windows.Controls.Button> a été créé.  La méthode prend un objet en tant qu’argument, qui est casté en un <xref:System.Windows.Controls.Button>.  Le <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> méthode sur le <xref:System.Windows.Threading.Dispatcher> de la <xref:System.Windows.Controls.Button> est appelée pour vérifier l’accès au thread.  
  
 Si le thread appelant a accès à la <xref:System.Windows.Threading.Dispatcher>, le <xref:System.Windows.Controls.Button> est mis à jour par les membres de l’accès à la <xref:System.Windows.Controls.Button>.  
  
 Si le thread appelant n’a pas accès, un <xref:System.InvalidOperationException> est levée.  Cet exemple intercepte l’exception et exécute un push d’un délégué qui accepte un <xref:System.Windows.Controls.Button> en tant qu’argument, sur le <xref:System.Windows.Threading.Dispatcher> de la <xref:System.Windows.Controls.Button>.  Cela <xref:System.Windows.Threading.Dispatcher> effectuent l’opération de mise à jour le <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le thread appelant n'a pas accès à ce <see cref="T:System.Windows.Threading.Dispatcher" />.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet awaitable qui renvoie de façon asynchrone le contrôle au répartiteur actuel et offre la possibilité au répartiteur de gérer d'autres événements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet awaitable qui renvoie de façon asynchrone le contrôle au répartiteur actuel et offre la possibilité au répartiteur de gérer d'autres événements.</summary>
        <returns>Objet awaitable qui renvoie de façon asynchrone le contrôle au répartiteur actuel et offre la possibilité au répartiteur de gérer d'autres événements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit un moyen pour vous permettre de libérer temporairement de contrôle d’exécution au répartiteur actuel afin qu’il peut effectuer d’autres tâches, telles que gérer d’autres événements. Utilisez le `await`, ou `Await` en Visual Basic, l’opérateur sur la valeur de retour pour retourner le contrôle au répartiteur actuel. Utilisez cette méthode si souhaitez permettre à votre application pour traiter des événements pendant que votre application effectue beaucoup de travail sur le thread d’interface utilisateur. Par exemple, vous pouvez utiliser cette méthode dans une boucle d’exécution longue qui met à jour d’un contrôle.  
  
 Cette méthode équivaut à appeler le <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> (méthode) et en passant <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Priorité avec laquelle planifier la suite.</param>
        <summary>Crée un objet awaitable qui renvoie de façon asynchrone le contrôle au répartiteur actuel et offre la possibilité au répartiteur de gérer d'autres événements.  Travail qui se produit lorsqu'un contrôle retourne au code qui attend le résultat de cette méthode est planifiés avec la priorité spécifiée.</summary>
        <returns>Objet awaitable qui renvoie de façon asynchrone le contrôle au répartiteur actuel et offre la possibilité au répartiteur de gérer d'autres événements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit un moyen pour vous permettre de libérer temporairement de contrôle d’exécution au répartiteur actuel afin qu’il peut effectuer d’autres tâches, telles que gérer d’autres événements. Utilisez le `await`, ou `Await` en Visual Basic, l’opérateur sur la valeur de retour pour retourner le contrôle au répartiteur actuel. Utilisez cette méthode si souhaitez permettre à votre application pour traiter des événements pendant que votre application effectue beaucoup de travail sur le thread d’interface utilisateur. Par exemple, vous pouvez utiliser cette méthode dans une boucle d’exécution longue qui met à jour d’un contrôle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>