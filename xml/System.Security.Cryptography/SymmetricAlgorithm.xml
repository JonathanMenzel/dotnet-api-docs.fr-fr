<Type Name="SymmetricAlgorithm" FullName="System.Security.Cryptography.SymmetricAlgorithm">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d20969f0f8dd5914901bf0c98eb58e2cfb3c5219" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30501123" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SymmetricAlgorithm : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SymmetricAlgorithm extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.SymmetricAlgorithm" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SymmetricAlgorithm&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SymmetricAlgorithm abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente la classe de base abstraite dont toutes les implémentations des algorithmes symétriques doivent hériter.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.Cryptography.SymmetricAlgorithm> classe utilisent un mode de chaînage appelé chiffrement de blocs (CBC), de chaînage des propriétés qui requiert une clé (<xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A>) et un vecteur d’initialisation (<xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>) pour effectuer des transformations de chiffrement sur les données.  Pour déchiffrer les données chiffrées à l’aide d’une de la <xref:System.Security.Cryptography.SymmetricAlgorithm> classes, vous devez définir le <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> propriété et le <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> propriété sur les valeurs qui ont été utilisés pour le chiffrement.  Pour un algorithme symétrique soit utile, la clé secrète doit être connue uniquement à l’expéditeur et le récepteur.  
  
 <xref:System.Security.Cryptography.RijndaelManaged>, <xref:System.Security.Cryptography.DESCryptoServiceProvider>, <xref:System.Security.Cryptography.RC2CryptoServiceProvider>, et <xref:System.Security.Cryptography.TripleDESCryptoServiceProvider> sont des implémentations des algorithmes symétriques.  
  
 Notez que lors de l’utilisation de classes dérivées, il est insuffisant, des raisons de sécurité, pour forcer simplement un garbage collection une fois que vous avez fini d’utiliser l’objet. Vous devez appeler explicitement la <xref:System.Security.Cryptography.SymmetricAlgorithm.Clear%2A> méthode sur l’objet à zéro toutes les données sensibles dans l’objet avant sa publication. Notez que le garbage collection ne pas à zéro le contenu des objets récupérés mais marque simplement la mémoire comme étant disponibles pour les opérations de réallocation. Par conséquent, les données contenues dans un objet collectées garbage pouvant être toujours présentes dans le segment de mémoire dans la mémoire non allouée. Dans le cas d’objets de chiffrement, ces données peuvent contenir des informations sensibles telles que les données de clé ou un bloc de texte brut.  
  
 Toutes les classes de chiffrement .NET Framework qui contiennent des données sensibles implémentent un `Clear` (méthode). Lorsqu’elle est appelée, la `Clear` méthode remplace toutes les données sensibles dans l’objet avec les zéros et puis libère l’objet de sorte qu’il peut s’agir en toute sécurité par le garbage collecté. Lorsque l’objet a été mis à zéro et libéré, vous devez ensuite appeler la `Dispose` méthode avec la `disposing` paramètre la valeur `True` pour supprimer toutes les ressources managées et associés à l’objet.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Security.Cryptography.RijndaelManaged> classe avec l’objet <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> propriété et vecteur d’initialisation (<xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>) pour chiffrer un fichier spécifié par `inName`et génère le résultat chiffré vers le fichier spécifié par `outName`. Le `desKey` et `desIV` paramètres de la méthode sont des tableaux 8 octets. Vous devez disposer du pack de chiffrement élevé installé pour exécuter cet exemple.  
  
 [!code-cpp[Classic CryptoStream Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic CryptoStream Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CryptoStream Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic CryptoStream Example/CS/source.cs#1)]
 [!code-vb[Classic CryptoStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic CryptoStream Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Lorsque vous héritez de la <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> (classe), vous devez substituer les membres suivants : <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor(System.Byte[],System.Byte[])" />, <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor(System.Byte[],System.Byte[])" />, <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV" />, et <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SymmetricAlgorithm ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SymmetricAlgorithm();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas créer une instance d’une classe abstraite. Code de l’application crée une instance d’une classe dérivée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">L'implémentation de la classe dérivée de l'algorithme symétrique n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="BlockSize">
      <MemberSignature Language="C#" Value="public virtual int BlockSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BlockSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.BlockSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BlockSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int BlockSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de bloc, en bits, de l'opération de chiffrement.</summary>
        <value>Taille de bloc en bits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille de bloc est l’unité de base de données qui peuvent être chiffrées ou déchiffrées en une seule opération. Messages dépasse la taille de bloc sont gérés comme blocs successifs ; inférieure à la taille des blocs de messages doivent être complétées par des bits supplémentaires afin d’atteindre la taille d’un bloc. Tailles de bloc valides sont déterminées par l’algorithme symétrique utilisé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">La taille du bloc n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="BlockSizeValue">
      <MemberSignature Language="C#" Value="protected int BlockSizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 BlockSizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.BlockSizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected BlockSizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int BlockSizeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la taille de bloc, en bits, de l'opération de chiffrement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille de bloc est l’unité de base de données qui peuvent être chiffrées ou déchiffrées en une seule opération. Messages dépasse la taille de bloc sont gérés comme blocs successifs ; inférieure à la taille des blocs de messages doivent être complétées par des bits supplémentaires afin d’atteindre la taille d’un bloc. Tailles de bloc valides sont déterminées par l’algorithme symétrique utilisé.  
  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.BlockSize%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par la classe <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que lors de l’utilisation de classes dérivées, il est insuffisant, des raisons de sécurité, pour forcer simplement un garbage collection une fois que vous avez fini d’utiliser l’objet. Vous devez appeler explicitement la <xref:System.Security.Cryptography.SymmetricAlgorithm.Clear%2A> méthode sur l’objet à zéro toutes les données sensibles dans l’objet avant sa publication. Notez que le garbage collection ne pas à zéro le contenu des objets récupérés mais marque simplement la mémoire comme étant disponibles pour les opérations de réallocation. Par conséquent, les données contenues dans un objet collectées garbage pouvant être toujours présentes dans le segment de mémoire dans la mémoire non allouée. Dans le cas d’objets de chiffrement, ces données peuvent contenir des informations sensibles telles que les données de clé ou un bloc de texte brut.  
  
 Toutes les classes de chiffrement .NET Framework qui contiennent des données sensibles implémentent un `Clear` (méthode). Lorsqu’elle est appelée, la `Clear` méthode remplace toutes les données sensibles dans l’objet avec les zéros et puis libère l’objet de sorte qu’il peut s’agir en toute sécurité par le garbage collecté. Lorsque l’objet a été mis à zéro et libéré, vous devez ensuite appeler la `Dispose` méthode avec la `disposing` paramètre la valeur `True` pour supprimer toutes les ressources managées et associés à l’objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet de chiffrement pour exécuter l'algorithme symétrique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.SymmetricAlgorithm Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.SymmetricAlgorithm Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As SymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::SymmetricAlgorithm ^ Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.SymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet de chiffrement par défaut utilisé pour exécuter l'algorithme symétrique.</summary>
        <returns>Objet de chiffrement par défaut utilisé pour exécuter l'algorithme symétrique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Security.Cryptography.RijndaelManaged> classe avec l’objet <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> propriété et vecteur d’initialisation (<xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>) pour chiffrer un fichier spécifié par `inName`et génère le résultat chiffré vers le fichier spécifié par `outName`. Le `desKey` et `desIV` paramètres de la méthode sont des tableaux 8 octets. Vous devez disposer du pack de chiffrement élevé installé pour exécuter cet exemple.  
  
 [!code-cpp[Classic CryptoStream Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic CryptoStream Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CryptoStream Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic CryptoStream Example/CS/source.cs#1)]
 [!code-vb[Classic CryptoStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic CryptoStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.SymmetricAlgorithm Create (string algName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.SymmetricAlgorithm Create(string algName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algName As String) As SymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::SymmetricAlgorithm ^ Create(System::String ^ algName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.SymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algName">Nom de l'implémentation spécifique de la classe <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> à utiliser.</param>
        <summary>Crée l'objet de chiffrement spécifié utilisé pour exécuter l'algorithme symétrique.</summary>
        <returns>Objet de chiffrement utilisé pour exécuter l'algorithme symétrique.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDecryptor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet déchiffreur symétrique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDecryptor">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ICryptoTransform CreateDecryptor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.ICryptoTransform CreateDecryptor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDecryptor () As ICryptoTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ICryptoTransform ^ CreateDecryptor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ICryptoTransform</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet déchiffreur symétrique avec la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) actuels.</summary>
        <returns>Objet déchiffreur symétrique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode déchiffre un message chiffré créé à l’aide de la <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor%2A> avec la même signature de surcharge.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDecryptor">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ICryptoTransform CreateDecryptor (byte[] rgbKey, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.ICryptoTransform CreateDecryptor(unsigned int8[] rgbKey, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateDecryptor (rgbKey As Byte(), rgbIV As Byte()) As ICryptoTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::Cryptography::ICryptoTransform ^ CreateDecryptor(cli::array &lt;System::Byte&gt; ^ rgbKey, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ICryptoTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbKey" Type="System.Byte[]" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique.</param>
        <param name="rgbIV">Vecteur d'initialisation à utiliser pour l'algorithme symétrique.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un objet déchiffreur symétrique avec la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) spécifiés.</summary>
        <returns>Objet déchiffreur symétrique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode déchiffre un message chiffré créé à l’aide de la <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor%2A> avec les mêmes paramètres de surcharge.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEncryptor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet chiffreur symétrique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEncryptor">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ICryptoTransform CreateEncryptor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.ICryptoTransform CreateEncryptor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEncryptor () As ICryptoTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ICryptoTransform ^ CreateEncryptor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ICryptoTransform</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet chiffreur symétrique avec la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) actuels.</summary>
        <returns>Objet chiffreur symétrique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> propriété `null`, le <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey%2A> méthode est appelée pour créer un nouveau aléatoire <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A>. Si actuel <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> propriété `null`, le <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV%2A> méthode est appelée pour créer un nouveau aléatoire <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>.  
  
 Utilisez le <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor%2A> avec la même signature pour déchiffrer le résultat de cette méthode de surcharge.  
  
   
  
## Examples  
 L’exemple suivant chiffre une chaîne à l’aide de l’objet de transformation retourné à partir de la <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor%2A> (méthode).  
  
 [!code-cpp[System.Security.Cryptography.SymmetricAlgorithm#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm/cpp/encryptor.cpp#1)]
 [!code-csharp[System.Security.Cryptography.SymmetricAlgorithm#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm/cs/encryptor.cs#1)]
 [!code-vb[System.Security.Cryptography.SymmetricAlgorithm#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm/vb/encryptor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEncryptor">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ICryptoTransform CreateEncryptor (byte[] rgbKey, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.ICryptoTransform CreateEncryptor(unsigned int8[] rgbKey, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateEncryptor (rgbKey As Byte(), rgbIV As Byte()) As ICryptoTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::Cryptography::ICryptoTransform ^ CreateEncryptor(cli::array &lt;System::Byte&gt; ^ rgbKey, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ICryptoTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbKey" Type="System.Byte[]" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbKey">Clé secrète à utiliser pour l'algorithme symétrique.</param>
        <param name="rgbIV">Vecteur d'initialisation à utiliser pour l'algorithme symétrique.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un objet chiffreur symétrique avec la propriété <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> et le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) spécifiés.</summary>
        <returns>Objet chiffreur symétrique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor%2A> avec les mêmes paramètres pour déchiffrer le résultat de cette méthode de surcharge.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode `Dispose` une fois que vous avez terminé d'utiliser <xref:System.Security.Cryptography.SymmetricAlgorithm>. La méthode `Dispose` rend le <xref:System.Security.Cryptography.SymmetricAlgorithm> inutilisable. Après avoir appelé `Dispose`, vous devez libérer toutes les références à la <xref:System.Security.Cryptography.SymmetricAlgorithm> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Security.Cryptography.SymmetricAlgorithm> occupée.  
  
 Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours `Dispose` avant de libérer votre dernière référence à <xref:System.Security.Cryptography.SymmetricAlgorithm>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Security.Cryptography.SymmetricAlgorithm> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le `Finalize` (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`. `Finalize` appelle `Dispose` avec `disposing` la valeur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Security.Cryptography.SymmetricAlgorithm>. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un appel antérieur à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Pour plus d’informations sur <see langword="Dispose" /> et <see langword="Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FeedbackSize">
      <MemberSignature Language="C#" Value="public virtual int FeedbackSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FeedbackSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property FeedbackSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FeedbackSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille des commentaires, en bits, de l'opération de chiffrement.</summary>
        <value>Taille des commentaires en bits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille des commentaires détermine la quantité de données qui sont transmises à chiffrement successif ou des opérations de déchiffrement. La taille des commentaires ne peut pas être supérieure à la taille de bloc.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">La taille des commentaires est supérieure à la taille du bloc.</exception>
      </Docs>
    </Member>
    <Member MemberName="FeedbackSizeValue">
      <MemberSignature Language="C#" Value="protected int FeedbackSizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 FeedbackSizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected FeedbackSizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int FeedbackSizeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la taille des commentaires, en bits, de l'opération de chiffrement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille des commentaires détermine la quantité de données qui sont transmises à chiffrement successif ou des opérations de déchiffrement. La taille des commentaires ne peut pas être supérieure à la taille de bloc.  
  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateIV">
      <MemberSignature Language="C#" Value="public abstract void GenerateIV ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateIV() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub GenerateIV ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void GenerateIV();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, génère un vecteur d'initialisation aléatoire (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) à utiliser pour l'algorithme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En général, il est inutile d’utiliser cette méthode, car `CreateEncryptor()` ou `CreateEncryptor(null, null)` génère automatiquement un vecteur d’initialisation et une clé. Toutefois, vous souhaitez utiliser le <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV%2A> méthode pour réutiliser une instance de l’algorithme symétrique avec un vecteur d’initialisation différent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public abstract void GenerateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub GenerateKey ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void GenerateKey();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, génère une clé aléatoire (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" />) à utiliser pour l'algorithme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En général, il est inutile d’utiliser cette méthode, car `CreateEncryptor()` ou `CreateEncryptor(null, null)` génère automatiquement un vecteur d’initialisation et une clé. Toutefois, vous souhaitez utiliser le <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey%2A> méthode pour réutiliser une instance de l’algorithme symétrique avec une clé différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IV">
      <MemberSignature Language="C#" Value="public virtual byte[] IV { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] IV" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IV As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Byte&gt; ^ IV { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) pour l'algorithme symétrique.</summary>
        <value>Vecteur d'initialisation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> est automatiquement définie sur une nouvelle valeur aléatoire chaque fois que vous créez une nouvelle instance de l’un de la <xref:System.Security.Cryptography.SymmetricAlgorithm> classes ou lorsque vous appelez manuellement la <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV%2A> (méthode).  La taille de la <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> propriété doit être le même que le <xref:System.Security.Cryptography.SymmetricAlgorithm.BlockSize%2A> propriété divisé par 8.  
  
 Les classes qui dérivent de la <xref:System.Security.Cryptography.SymmetricAlgorithm> classe utilisent un mode de chaînage appelé chiffrement de blocs (CBC), de chaînage des propriétés qui requiert une clé et un vecteur d’initialisation pour effectuer des transformations de chiffrement sur les données.  Pour déchiffrer les données chiffrées à l’aide d’une de la <xref:System.Security.Cryptography.SymmetricAlgorithm> classes, vous devez définir le <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> propriété et <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> propriété sur les valeurs qui ont été utilisés pour le chiffrement.  
  
 Pour une clé secrète donnée *k*, un simple chiffrement par blocs qui n’utilise pas un vecteur d’initialisation chiffre le même bloc d’entrée de texte brut en bloc de sortie de texte de chiffrement. Si vous avez des blocs dupliqués au sein de votre flux de texte brut, vous aurez des blocs dupliqués au sein de votre flux de texte de chiffrement. Si les utilisateurs non autorisés connaissent la structure d’un bloc de votre texte brut, ils peuvent utiliser ces informations pour déchiffrer le bloc de texte de chiffrement connu et éventuellement récupérer votre clé. Pour résoudre ce problème, les informations du bloc précédent sont mélangées dans le processus de chiffrement du bloc suivant. Par conséquent, la sortie de deux blocs de texte brut identiques est différente. Étant donné que cette technique utilise le bloc précédent pour chiffrer le bloc suivant, un vecteur d’initialisation est nécessaire pour chiffrer le premier bloc de données.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Une tentative d'affecter la valeur <see langword="null" /> au vecteur d'initialisation a été effectuée.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Une tentative d'affecter une taille non valide au vecteur d'initialisation a été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="IVValue">
      <MemberSignature Language="C#" Value="protected byte[] IVValue;" />
      <MemberSignature Language="ILAsm" Value=".field family unsigned int8[] IVValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.IVValue" />
      <MemberSignature Language="VB.NET" Value="Protected IVValue As Byte() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Byte&gt; ^ IVValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le vecteur d'initialisation (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) pour l'algorithme symétrique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Key">
      <MemberSignature Language="C#" Value="public virtual byte[] Key { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Key" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.Key" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Key As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Byte&gt; ^ Key { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la clé secrète pour l'algorithme symétrique.</summary>
        <value>Clé secrète à utiliser pour l'algorithme symétrique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clé secrète est utilisée à la fois pour le chiffrement et de déchiffrement. Pour un algorithme symétrique réussisse, la clé secrète doit être connue uniquement à l’expéditeur et le récepteur. Les tailles de clé valides sont spécifiées par l’implémentation de l’algorithme symétrique particulière et sont répertoriées dans le <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> propriété.  
  
 Si cette propriété est `null` lorsqu’il est utilisé, le <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey%2A> méthode est appelée pour créer une nouvelle valeur aléatoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Une tentative d’affectation de la valeur <see langword="null" /> à la clé a été effectuée.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">La taille de la clé n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="KeySize">
      <MemberSignature Language="C#" Value="public virtual int KeySize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeySize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.KeySize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property KeySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeySize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille, en bits, de la clé secrète utilisée par l'algorithme symétrique.</summary>
        <value>Taille, en bits, de la clé secrète utilisée par l'algorithme symétrique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les tailles de clé valides sont spécifiées par l’implémentation de l’algorithme symétrique particulière et sont répertoriées dans le <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">La taille de la clé n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="KeySizeValue">
      <MemberSignature Language="C#" Value="protected int KeySizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 KeySizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.KeySizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected KeySizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int KeySizeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la taille, en bits, de la clé secrète utilisée par l'algorithme symétrique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les tailles de clé valides sont spécifiées par l’implémentation de l’algorithme symétrique particulière et sont répertoriées dans le <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> propriété.  
  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.KeySize%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyValue">
      <MemberSignature Language="C#" Value="protected byte[] KeyValue;" />
      <MemberSignature Language="ILAsm" Value=".field family unsigned int8[] KeyValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.KeyValue" />
      <MemberSignature Language="VB.NET" Value="Protected KeyValue As Byte() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Byte&gt; ^ KeyValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la clé secrète pour l'algorithme symétrique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clé secrète est utilisée à la fois pour le chiffrement et de déchiffrement. Pour un algorithme symétrique réussisse, la clé secrète doit être connue uniquement à l’expéditeur et le récepteur. Les tailles de clé valides sont spécifiées par l’implémentation de l’algorithme symétrique particulière et sont répertoriées dans le <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> propriété.  
  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalBlockSizes">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.KeySizes[] LegalBlockSizes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.KeySizes[] LegalBlockSizes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.LegalBlockSizes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LegalBlockSizes As KeySizes()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalBlockSizes { cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les tailles de bloc, en octets, prises en charge par l'algorithme symétrique.</summary>
        <value>Tableau qui contient les tailles de bloc prises en charge par l'algorithme.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’algorithme symétrique prend en charge uniquement les tailles de bloc qui correspondent à une entrée dans ce tableau.  
  
   
  
## Examples  
 L’exemple suivant affiche la valeur de <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalBlockSizes%2A> pour les algorithmes symétriques.  
  
 [!code-csharp[System.Security.Cryptography.SymmetricAlgorithm.BlockSize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm.blocksize/cs/program.cs#1)]
 [!code-vb[System.Security.Cryptography.SymmetricAlgorithm.BlockSize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm.blocksize/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalBlockSizesValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.KeySizes[] LegalBlockSizesValue;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Security.Cryptography.KeySizes[] LegalBlockSizesValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.LegalBlockSizesValue" />
      <MemberSignature Language="VB.NET" Value="Protected LegalBlockSizesValue As KeySizes() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalBlockSizesValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie les tailles de bloc, en octets, prises en charge par l'algorithme symétrique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’algorithme symétrique prend en charge uniquement les tailles de bloc qui correspondent à une entrée dans ce tableau.  
  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalBlockSizes%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalKeySizes">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.KeySizes[] LegalKeySizes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.KeySizes[] LegalKeySizes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LegalKeySizes As KeySizes()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalKeySizes { cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les tailles de clé, en octets, prises en charge par l'algorithme symétrique.</summary>
        <value>Tableau qui contient les tailles de clé prises en charge par l'algorithme.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’algorithme symétrique prend en charge uniquement les tailles de clé qui correspondent à une entrée dans ce tableau.  
  
   
  
## Examples  
 L’exemple suivant affiche la valeur de <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> pour les algorithmes symétriques.  
  
 [!code-csharp[System.Security.Cryptography.SymmetricAlgorithm.BlockSize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm.blocksize/cs/program.cs#1)]
 [!code-vb[System.Security.Cryptography.SymmetricAlgorithm.BlockSize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm.blocksize/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalKeySizesValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.KeySizes[] LegalKeySizesValue;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Security.Cryptography.KeySizes[] LegalKeySizesValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizesValue" />
      <MemberSignature Language="VB.NET" Value="Protected LegalKeySizesValue As KeySizes() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalKeySizesValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie les tailles de clé, en octets, prises en charge par l'algorithme symétrique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’algorithme symétrique prend en charge uniquement les tailles de clé qui correspondent à une entrée dans ce tableau.  
  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.CipherMode Mode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.CipherMode Mode" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Mode As CipherMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::CipherMode Mode { System::Security::Cryptography::CipherMode get(); void set(System::Security::Cryptography::CipherMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode de fonctionnement pour l'algorithme symétrique.</summary>
        <value>Mode de fonctionnement de l'algorithme symétrique. La valeur par défaut est <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez <xref:System.Security.Cryptography.CipherMode> pour obtenir une description des modes spécifiques.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Le mode de chiffrement ne fait pas partie des valeurs <see cref="T:System.Security.Cryptography.CipherMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ModeValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.CipherMode ModeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family valuetype System.Security.Cryptography.CipherMode ModeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.ModeValue" />
      <MemberSignature Language="VB.NET" Value="Protected ModeValue As CipherMode " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Security::Cryptography::CipherMode ModeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode de chiffrement utilisé dans l'algorithme symétrique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez <xref:System.Security.Cryptography.CipherMode> pour obtenir une description des modes spécifiques.  
  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.Mode%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.PaddingMode Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.PaddingMode Padding" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Padding As PaddingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::PaddingMode Padding { System::Security::Cryptography::PaddingMode get(); void set(System::Security::Cryptography::PaddingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.PaddingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode de remplissage utilisé dans l'algorithme symétrique.</summary>
        <value>Mode de remplissage utilisé dans l'algorithme symétrique. La valeur par défaut est <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plupart des messages en texte brut ne consistent pas d’un nombre d’octets qui remplit entièrement les blocs. Souvent, il ne sont pas suffisamment d’octets pour remplir le dernier bloc. Dans ce cas, une chaîne de remplissage est ajoutée au texte. Par exemple, si la longueur du bloc est de 64 bits et le dernier bloc contient seulement 40 bits, 24 bits de remplissage sont ajoutés. Consultez le <xref:System.Security.Cryptography.PaddingMode> pour obtenir une description des modes spécifiques.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Le mode de remplissage ne fait pas partie des valeurs <see cref="T:System.Security.Cryptography.PaddingMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PaddingValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.PaddingMode PaddingValue;" />
      <MemberSignature Language="ILAsm" Value=".field family valuetype System.Security.Cryptography.PaddingMode PaddingValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.PaddingValue" />
      <MemberSignature Language="VB.NET" Value="Protected PaddingValue As PaddingMode " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Security::Cryptography::PaddingMode PaddingValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.PaddingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode de remplissage utilisé dans l'algorithme symétrique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plupart des messages en texte brut ne consistent pas d’un nombre d’octets qui remplit entièrement les blocs. Souvent, il ne sont pas suffisamment d’octets pour remplir le dernier bloc. Dans ce cas, une chaîne de remplissage est ajoutée au texte. Par exemple, si la longueur du bloc est de 64 bits et le dernier bloc contient seulement 40 bits, 24 bits de remplissage sont ajoutés. Consultez le <xref:System.Security.Cryptography.PaddingMode> pour obtenir une description des modes spécifiques.  
  
 Ce champ est accessible via la <xref:System.Security.Cryptography.SymmetricAlgorithm.Padding%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidKeySize">
      <MemberSignature Language="C#" Value="public bool ValidKeySize (int bitLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValidKeySize(int32 bitLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.ValidKeySize(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ValidKeySize (bitLength As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValidKeySize(int bitLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bitLength">Longueur, en bits, à vérifier pour une taille de clé valide.</param>
        <summary>Détermine si la taille de clé spécifiée est valide pour l'algorithme actuel.</summary>
        <returns>
          <see langword="true" /> si la taille de clé spécifiée est valide pour l'algorithme en cours ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>