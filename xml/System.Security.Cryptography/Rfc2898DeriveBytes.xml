<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Rfc2898DeriveBytes.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9575d09f-9d72-4690-889e-b83c405ca456fb88d38ba71eab51c03b25070016871c9628d94b.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fb88d38ba71eab51c03b25070016871c9628d94b</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">254e16ae65e82f4aa59360cd8572b36b6b5b2f80</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/05/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA1" /&gt;</ph>.</source>
          <target state="translated">Implémente une fonctionnalité de dérivation de clé basée sur mot de passe, PBKDF2, en utilisant un générateur de nombres pseudo-aléatoires basé sur <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> takes a password, a salt, and an iteration count, and then generates keys through calls to the <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> prend un mot de passe, un salt et un nombre d’itérations, puis génère des clés via des appels à la <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">La RFC 2898 comporte des méthodes pour la création d’un vecteur de clé et d’initialisation (IV) à partir d’un mot de passe et le salt.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Vous pouvez utiliser PBKDF2, une fonction de dérivation de clé basée sur mot de passe, pour dériver les clés à l’aide d’une fonction pseudo-aléatoire qui permet des clés de longueur virtuellement illimitée à générer.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe peut être utilisée pour produire une clé dérivée d’une clé de base et d’autres paramètres.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">Dans une fonction de dérivation de clé basée sur mot de passe, la clé de base est un mot de passe et les autres paramètres sont une valeur salt et un nombre d’itérations.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Pour plus d’informations sur PBKDF2, consultez la RFC 2898, « PKCS #5 : Password-Based Cryptography Specification Version 2.0, » disponible sur le <bpt id="p1">[</bpt>demande pour le site Web de commentaires<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Pour plus d’informations, consultez la section 5.2, « PBKDF2, ».</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Ne codez jamais un mot de passe dans votre code source.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Les mots de passe codés en dur peuvent être récupérés à partir d’un assembly à l’aide de la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, à l’aide d’un éditeur hexadécimal, ou en ouvrant simplement l’assembly dans un éditeur de texte tel que Notepad.exe.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class to create two identical keys for the <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> class.</source>
          <target state="translated">Le code suivant utilise des exemple le <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clés de la classe pour créer deux identiques pour le <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>It then encrypts and decrypts some data using the keys.</source>
          <target state="translated">Puis, il chiffre et déchiffre des données à l’aide de clés.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The password used to derive the key.</source>
          <target state="translated">Mot de passe utilisé pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The key salt used to derive the key.</source>
          <target state="translated">Salt de clé utilisé pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using a password and salt to derive the key.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> à l'aide d'un mot de passe et d'un salt pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The salt size must be 8 bytes or larger.</source>
          <target state="translated">La taille du salt doit être de 8 octets ou plus.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">La RFC 2898 comporte des méthodes pour la création d’un vecteur de clé et d’initialisation (IV) à partir d’un mot de passe et le salt.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Vous pouvez utiliser PBKDF2, une fonction de dérivation de clé basée sur mot de passe, pour dériver les clés à l’aide d’une fonction pseudo-aléatoire qui permet des clés de longueur virtuellement illimitée à générer.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe peut être utilisée pour produire une clé dérivée d’une clé de base et d’autres paramètres.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">Dans une fonction de dérivation de clé basée sur mot de passe, la clé de base est un mot de passe et les autres paramètres sont une valeur salt et un nombre d’itérations.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Pour plus d’informations sur PBKDF2, consultez la RFC 2898, « PKCS #5 : Password-Based Cryptography Specification Version 2.0, » disponible sur le <bpt id="p1">[</bpt>demande pour le site Web de commentaires<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Pour plus d’informations, consultez la section 5.2, « PBKDF2, ».</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Ne codez jamais un mot de passe dans votre code source.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Les mots de passe codés en dur peuvent être récupérés à partir d’un assembly à l’aide de la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, à l’aide d’un éditeur hexadécimal, ou en ouvrant simplement l’assembly dans un éditeur de texte tel que Notepad.exe.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class to create two identical keys for the <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> class.</source>
          <target state="translated">Le code suivant utilise des exemple le <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clés de la classe pour créer deux identiques pour le <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>It then encrypts and decrypts some data using the keys.</source>
          <target state="translated">Puis, il chiffre et déchiffre des données à l’aide de clés.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</source>
          <target state="translated">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le mot de passe ou le salt est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The password used to derive the key.</source>
          <target state="translated">Mot de passe utilisé pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The size of the random salt that you want the class to generate.</source>
          <target state="translated">Taille du salt aléatoire que vous souhaitez que la classe génère.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using the password and salt size to derive the key.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> à l'aide du mot de passe et de la taille de salt pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The salt size must be 8 bytes or larger.</source>
          <target state="translated">La taille du salt doit être de 8 octets ou plus.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">La RFC 2898 comporte des méthodes pour la création d’un vecteur de clé et d’initialisation (IV) à partir d’un mot de passe et le salt.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Vous pouvez utiliser PBKDF2, une fonction de dérivation de clé basée sur mot de passe, pour dériver les clés à l’aide d’une fonction pseudo-aléatoire qui permet des clés de longueur virtuellement illimitée à générer.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe peut être utilisée pour produire une clé dérivée d’une clé de base et d’autres paramètres.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">Dans une fonction de dérivation de clé basée sur mot de passe, la clé de base est un mot de passe et les autres paramètres sont une valeur salt et un nombre d’itérations.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Pour plus d’informations sur PBKDF2, consultez la RFC 2898, « PKCS #5 : Password-Based Cryptography Specification Version 2.0, » disponible sur le <bpt id="p1">[</bpt>demande pour le site Web de commentaires<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Pour plus d’informations, consultez la section 5.2, « PBKDF2, ».</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Ne codez jamais un mot de passe dans votre code source.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Les mots de passe codés en dur peuvent être récupérés à partir d’un assembly à l’aide de la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, à l’aide d’un éditeur hexadécimal, ou en ouvrant simplement l’assembly dans un éditeur de texte tel que Notepad.exe.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The specified salt size is smaller than 8 bytes.</source>
          <target state="translated">La taille de salt spécifiée est inférieure à 8 octets.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le mot de passe ou le salt est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The password used to derive the key.</source>
          <target state="translated">Mot de passe utilisé pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The key salt used to derive the key.</source>
          <target state="translated">Salt de clé utilisé pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The number of iterations for the operation.</source>
          <target state="translated">Nombre d'itérations pour l'opération.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using a password, a salt, and number of iterations to derive the key.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> à l'aide d'un mot de passe, d'un salt et d'un nombre d'itérations pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</source>
          <target state="translated">La taille du salt doit être de 8 octets ou plus et le nombre d’itérations doit être supérieur à zéro.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The minimum recommended number of iterations is 1000.</source>
          <target state="translated">Le nombre minimal recommandé d’itérations est 1000.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">La RFC 2898 comporte des méthodes pour la création d’un vecteur de clé et d’initialisation (IV) à partir d’un mot de passe et le salt.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Vous pouvez utiliser PBKDF2, une fonction de dérivation de clé basée sur mot de passe, pour dériver les clés à l’aide d’une fonction pseudo-aléatoire qui permet des clés de longueur virtuellement illimitée à générer.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe peut être utilisée pour produire une clé dérivée d’une clé de base et d’autres paramètres.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">Dans une fonction de dérivation de clé basée sur mot de passe, la clé de base est un mot de passe et les autres paramètres sont une valeur salt et un nombre d’itérations.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Pour plus d’informations sur PBKDF2, consultez la RFC 2898, « PKCS #5 : Password-Based Cryptography Specification Version 2.0, » disponible sur le <bpt id="p1">[</bpt>demande pour le site Web de commentaires<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Pour plus d’informations, consultez la section 5.2, « PBKDF2, ».</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Ne codez jamais un mot de passe dans votre code source.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Les mots de passe codés en dur peuvent être récupérés à partir d’un assembly à l’aide de la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, à l’aide d’un éditeur hexadécimal, ou en ouvrant simplement l’assembly dans un éditeur de texte tel que Notepad.exe.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</source>
          <target state="translated">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le mot de passe ou le salt est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The password used to derive the key.</source>
          <target state="translated">Mot de passe utilisé pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The key salt used to derive the key.</source>
          <target state="translated">Salt de clé utilisé pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The number of iterations for the operation.</source>
          <target state="translated">Nombre d'itérations pour l'opération.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using a password, a salt, and number of iterations to derive the key.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> à l'aide d'un mot de passe, d'un salt et d'un nombre d'itérations pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</source>
          <target state="translated">La taille du salt doit être de 8 octets ou plus et le nombre d’itérations doit être supérieur à zéro.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The minimum recommended number of iterations is 1000.</source>
          <target state="translated">Le nombre minimal recommandé d’itérations est 1000.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">La RFC 2898 comporte des méthodes pour la création d’un vecteur de clé et d’initialisation (IV) à partir d’un mot de passe et le salt.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Vous pouvez utiliser PBKDF2, une fonction de dérivation de clé basée sur mot de passe, pour dériver les clés à l’aide d’une fonction pseudo-aléatoire qui permet des clés de longueur virtuellement illimitée à générer.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe peut être utilisée pour produire une clé dérivée d’une clé de base et d’autres paramètres.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">Dans une fonction de dérivation de clé basée sur mot de passe, la clé de base est un mot de passe et les autres paramètres sont une valeur salt et un nombre d’itérations.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Pour plus d’informations sur PBKDF2, consultez la RFC 2898, « PKCS #5 : Password-Based Cryptography Specification Version 2.0, » disponible sur le <bpt id="p1">[</bpt>demande pour le site Web de commentaires<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Pour plus d’informations, consultez la section 5.2, « PBKDF2, ».</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Ne codez jamais un mot de passe dans votre code source.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Les mots de passe codés en dur peuvent être récupérés à partir d’un assembly à l’aide de la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, à l’aide d’un éditeur hexadécimal, ou en ouvrant simplement l’assembly dans un éditeur de texte tel que Notepad.exe.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class to create two identical keys for the <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> class.</source>
          <target state="translated">Le code suivant utilise des exemple le <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clés de la classe pour créer deux identiques pour le <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>It then encrypts and decrypts some data using the keys.</source>
          <target state="translated">Puis, il chiffre et déchiffre des données à l’aide de clés.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</source>
          <target state="translated">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le mot de passe ou le salt est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The password used to derive the key.</source>
          <target state="translated">Mot de passe utilisé pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The size of the random salt that you want the class to generate.</source>
          <target state="translated">Taille du salt aléatoire que vous souhaitez que la classe génère.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The number of iterations for the operation.</source>
          <target state="translated">Nombre d'itérations pour l'opération.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using a password, a salt size, and number of iterations to derive the key.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> à l'aide d'un mot de passe, d'une taille de salt et d'un nombre d'itérations pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</source>
          <target state="translated">La taille du salt doit être de 8 octets ou plus et le nombre d’itérations doit être supérieur à zéro.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The minimum recommended number of iterations is 1000.</source>
          <target state="translated">Le nombre minimal recommandé d’itérations est 1000.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">La RFC 2898 comporte des méthodes pour la création d’un vecteur de clé et d’initialisation (IV) à partir d’un mot de passe et le salt.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Vous pouvez utiliser PBKDF2, une fonction de dérivation de clé basée sur mot de passe, pour dériver les clés à l’aide d’une fonction pseudo-aléatoire qui permet des clés de longueur virtuellement illimitée à générer.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe peut être utilisée pour produire une clé dérivée d’une clé de base et d’autres paramètres.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">Dans une fonction de dérivation de clé basée sur mot de passe, la clé de base est un mot de passe et les autres paramètres sont une valeur salt et un nombre d’itérations.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>For more information on PBKDF2, see RFC 2898,"PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Pour plus d’informations sur PBKDF2, consultez la RFC 2898, « PKCS #5 : Password-Based Cryptography Specification Version 2.0, » disponible sur le <bpt id="p1">[</bpt>demande pour le site Web de commentaires<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Pour plus d’informations, consultez la section 5.2, « PBKDF2, ».</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Ne codez jamais un mot de passe dans votre code source.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Les mots de passe codés en dur peuvent être récupérés à partir d’un assembly à l’aide de la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, à l’aide d’un éditeur hexadécimal, ou en ouvrant simplement l’assembly dans un éditeur de texte tel que Notepad.exe.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</source>
          <target state="translated">La taille de salt spécifiée est inférieure à 8 octets ou le nombre d'itérations est inférieur à 1.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le mot de passe ou le salt est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="iterations" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="iterations" /&gt;</ph> est hors limites.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>This parameter requires a non-negative number.</source>
          <target state="translated">Ce paramètre requiert un nombre non négatif.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The algorithm name for which to derive the key.</source>
          <target state="translated">Nom de l'algorithme pour lequel la clé doit être dérivée.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The hash algorithm name to use to derive the key.</source>
          <target state="translated">Nom de l'algorithme de hachage à utiliser pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The size of the key, in bits, to derive.</source>
          <target state="translated">Taille de la clé à dériver, en bits.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The initialization vector (IV) to use to derive the key.</source>
          <target state="translated">Vecteur d'initialisation (IV) à utiliser pour dériver la clé.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>Derives a cryptographic key from the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> object.</source>
          <target state="translated">Dérive une clé de chiffrement de l'objet <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The derived key.</source>
          <target state="translated">Clé dérivée.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>This function is a wrapper for the Crypto API function CryptDeriveKey(), and is intended to offer interoperability with applications using the Crypto API.</source>
          <target state="translated">Cette fonction est un wrapper pour la fonction d’API de chiffrement CryptDeriveKey() et est destinée à offrir une interopérabilité avec les applications à l’aide de l’API de chiffrement.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>If the <ph id="ph1">`keySize`</ph> parameter is set to 0 bits, the default key size for the specified algorithm is used.</source>
          <target state="translated">Si le <ph id="ph1">`keySize`</ph> bits 0 est affectée, la taille de clé par défaut pour l’algorithme spécifié est utilisée.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The <ph id="ph1">&lt;paramref name="keySize" /&gt;</ph> parameter is incorrect.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="keySize" /&gt;</ph> est incorrect.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The cryptographic service provider (CSP) cannot be acquired.</source>
          <target state="translated">Le fournisseur de services de chiffrement ne peut pas être acquis.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The <ph id="ph1">&lt;paramref name="algname" /&gt;</ph> parameter is not a valid algorithm name.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="algname" /&gt;</ph> n'est pas un nom d'algorithme valide.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The <ph id="ph1">&lt;paramref name="alghashname" /&gt;</ph> parameter is not a valid hash algorithm name.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="alghashname" /&gt;</ph> n'est pas un nom d'algorithme de hachage valide.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour libérer les ressources managées et non managées ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour ne libérer que les ressources non managées.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class and optionally releases the managed resources.</source>
          <target state="translated">Libère les ressources non managées utilisées par la classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> et libère éventuellement les ressources managées.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Cette méthode est appelée par le public <ph id="ph1">`Dispose()`</ph> (méthode) et le <ph id="ph2">`Finalize`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> appelle la méthode protégée <ph id="ph2">`Dispose(Boolean)`</ph> méthode avec la <ph id="ph3">`disposing`</ph> paramètre la valeur <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source><ph id="ph1">`Finalize`</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> appelle <ph id="ph2">`Dispose`</ph> avec <ph id="ph3">`disposing`</ph> la valeur <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> references.</source>
          <target state="translated">Si le paramètre <ph id="ph1">`disposing`</ph> a la valeur <ph id="ph2">`true`</ph>, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <ph id="ph3">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">Cette méthode appelle la méthode <ph id="ph1">`Dispose()`</ph> de chaque objet référencé.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> peut être appelée plusieurs fois par d'autres objets.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated">Lors de la substitution <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un appel antérieur à <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’implémentation <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, consultez <bpt id="p1">[</bpt>implémentant une méthode de suppression<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see langword="Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> et <ph id="ph2">&lt;see langword="Finalize" /&gt;</ph>, consultez <bpt id="p1">[</bpt>de nettoyage des ressources non managées<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>The number of pseudo-random key bytes to generate.</source>
          <target state="translated">Nombre d'octets de clé pseudo-aléatoires à générer.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>Returns the pseudo-random key for this object.</source>
          <target state="translated">Retourne la clé pseudo-aléatoire de cet objet.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>A byte array filled with pseudo-random key bytes.</source>
          <target state="translated">Tableau d'octets rempli avec des octets de clé pseudo-aléatoires.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class implements PBKDF2 functionality by using a pseudorandom number generator based on <ph id="ph2">&lt;xref:System.Security.Cryptography.HMACSHA1&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe implémente la fonctionnalité PBKDF2 en utilisant un générateur de nombres pseudo-aléatoires basé sur <ph id="ph2">&lt;xref:System.Security.Cryptography.HMACSHA1&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class takes a password, a salt, and an iteration count, and then generates keys through calls to the <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe accepte un mot de passe, d’un salt et d’un nombre d’itérations, puis génère des clés via des appels à la <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>Repeated calls to this method will not generate the same key; instead, appending two calls of the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method with a <ph id="ph2">`cb`</ph> parameter value of <ph id="ph3">`20`</ph> is the equivalent of calling the <ph id="ph4">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method once with a <ph id="ph5">`cb`</ph> parameter value of <ph id="ph6">`40`</ph>.</source>
          <target state="translated">Les appels répétés à cette méthode ne génèrent pas la même clé. au lieu de cela, l’ajout de deux appels de la <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> méthode avec un <ph id="ph2">`cb`</ph> valeur de paramètre de <ph id="ph3">`20`</ph> est l’équivalent de l’appel de la <ph id="ph4">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> méthode une fois avec un <ph id="ph5">`cb`</ph> valeur de paramètre de <ph id="ph6">`40`</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method to get the key for an instance of <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph>.</source>
          <target state="translated">L’exemple suivant montre comment utiliser le <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> pour obtenir la clé d’une instance de méthode <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="cb" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cb" /&gt;</ph> est hors limites.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>This parameter requires a non-negative number.</source>
          <target state="translated">Ce paramètre requiert un nombre non négatif.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>Gets or sets the number of iterations for the operation.</source>
          <target state="translated">Obtient ou définit le nombre d'itérations pour l'opération.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>The number of iterations for the operation.</source>
          <target state="translated">Nombre d'itérations pour l'opération.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>Iteration count is the number of times an operation is performed.</source>
          <target state="translated">Nombre d’itérations est le nombre de fois où qu'une opération est effectuée.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>For this method, the count should be greater than zero.</source>
          <target state="translated">Pour cette méthode, le nombre doit être supérieur à zéro.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>The minimum recommended number of iterations is 1000.</source>
          <target state="translated">Le nombre minimal recommandé d’itérations est 1000.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A&gt;</ph> property to display the number of iterations used in the generation of the key.</source>
          <target state="translated">L’exemple suivant montre comment utiliser le <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A&gt;</ph> propriété pour afficher le nombre d’itérations utilisées dans la génération de la clé.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>The number of iterations is less than 1.</source>
          <target state="translated">Le nombre d'itérations est inférieur à 1.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
          <source>Resets the state of the operation.</source>
          <target state="translated">Rétablit l'état de l'opération.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
          <source>This method is automatically called if the salt or iteration count is modified.</source>
          <target state="translated">Cette méthode est appelée automatiquement si le nombre d’itérations ou de salt est modifié.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A&gt;</ph> method.</source>
          <target state="translated">L'exemple suivant illustre l'utilisation de la méthode <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>Gets or sets the key salt value for the operation.</source>
          <target state="translated">Obtient ou définit la valeur salt de clé pour l'opération.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>The key salt value for the operation.</source>
          <target state="translated">Valeur salt de clé pour l'opération.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>Salt, a random set of bytes, is used to make unauthorized decrypting of a message more difficult.</source>
          <target state="translated">Salt, jeu aléatoire d’octets, est utilisé pour effectuer un déchiffrement non autorisé d’un message plus difficile.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>A dictionary attack is an attack in which the attacker attempts to decrypt an encrypted message by comparing the encrypted value with previously computed encrypted values for the most likely keys.</source>
          <target state="translated">Une attaque par dictionnaire est une attaque dans laquelle l’attaquant tente de déchiffrer un message chiffré en comparant la valeur chiffrée avec des valeurs chiffrées précédemment calculées pour les clés les plus probables.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>This attack is made much more difficult by the introduction of salt, or random bytes, at the end of the password before the key derivation.</source>
          <target state="translated">Cette attaque est rendue beaucoup plus difficile par l’introduction d’octets de salt, ou de façon aléatoires, à la fin du mot de passe avant la dérivation de clé.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>The specified salt size is smaller than 8 bytes.</source>
          <target state="translated">La taille de salt spécifiée est inférieure à 8 octets.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>The salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le salt est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>