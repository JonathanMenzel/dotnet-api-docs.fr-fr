<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="21e8d4ef3662555c3b91cf266991168a0da9fc42" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48707022" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une classe de base pour un service qui fera partie d'une application de service. <see cref="T:System.ServiceProcess.ServiceBase" /> doit être dérivé lors de la création d'une classe de service.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dériver de <xref:System.ServiceProcess.ServiceBase> lors de la définition de votre classe de service dans une application de service. Tout service utile substitue le <xref:System.ServiceProcess.ServiceBase.OnStart%2A> et <xref:System.ServiceProcess.ServiceBase.OnStop%2A> méthodes. Pour des fonctionnalités supplémentaires, vous pouvez remplacer <xref:System.ServiceProcess.ServiceBase.OnPause%2A> et <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> avec un comportement spécifique en réponse aux modifications d’état du service.  
  
 Un service est un exécutable de longs qui ne prend pas en charge une interface utilisateur, et qui ne peut pas s’exécuter sous le compte d’utilisateur connecté. Le service peut s’exécuter sans tout utilisateur connecté à l’ordinateur.  
  
 Par défaut, les services s’exécutent sous le compte système, ce qui n’est pas le même que le compte d’administrateur. Vous ne pouvez pas modifier les droits du compte système. Vous pouvez également utiliser un <xref:System.ServiceProcess.ServiceProcessInstaller> pour spécifier un compte d’utilisateur sous lequel le service s’exécutera.  
  
 Un exécutable peut contenir plusieurs services, mais doit contenir un distinct <xref:System.ServiceProcess.ServiceInstaller> pour chaque service. Le <xref:System.ServiceProcess.ServiceInstaller> instance inscrit le service avec le système. Le programme d’installation associe également chaque service à un journal des événements que vous pouvez utiliser pour enregistrer les commandes de service. Le `main()` fonction dans le fichier exécutable définit quels services doivent s’exécuter. Le répertoire de travail actuelle du service est le répertoire système, et non au répertoire dans lequel se trouve l’exécutable.  
  
 Lorsque vous démarrez un service, le système trouve l’exécutable et exécute la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> méthode pour ce service, contenu dans le fichier exécutable. Toutefois, le service en cours d’exécution n’est pas le même que le fichier exécutable en cours d’exécution. L’exécutable charge uniquement le service. L’accès au service (par exemple, démarrés et arrêtés) par le biais du Gestionnaire de contrôle de Service.  
  
 L’exécutable appelle le <xref:System.ServiceProcess.ServiceBase> dérivée fois de constructeur le premier de la classe que vous appelez Start sur le service. Le <xref:System.ServiceProcess.ServiceBase.OnStart%2A> méthode de gestion de la commande est appelée immédiatement après l’exécution du constructeur. Le constructeur n’est pas exécuté à nouveau après la première fois que le service a été chargé, il est donc nécessaire de séparer le traitement effectué par le constructeur de celle effectuée par <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Toutes les ressources qui peuvent être libérées par <xref:System.ServiceProcess.ServiceBase.OnStop%2A> doit être créée dans <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Création de ressources dans le constructeur empêche la leur création correctement si le service est démarré après avoir <xref:System.ServiceProcess.ServiceBase.OnStop%2A> a publié les ressources.  
  
 Le Gestionnaire de contrôle des services (SCM) fournit un moyen d’interagir avec le service. Vous pouvez utiliser le SCM pour passer de démarrer, arrêter, suspendre, continuer ou des commandes personnalisées dans le service. Le SCM utilise les valeurs de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> et <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> pour déterminer si le service accepte les arrêter, suspendre ou continuer de commandes. Arrêter, suspendre et continuer sont activées dans uniquement si de SCM contexte menus la propriété correspondante <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ou <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `true` dans la classe de service. Si activé, la commande est transmise au service, et <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> est appelée. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, ou <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `false`, la méthode correspondante de la gestion des commandes (telles que <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) ne pas être traitée, même si vous avez implémenté la méthode.  
  
 Vous pouvez utiliser la <xref:System.ServiceProcess.ServiceController> classe faire par programmation quelles le SCM effectue à l’aide d’une interface utilisateur. Vous pouvez automatiser les tâches disponibles dans la console. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, ou <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `true` , mais vous n’avez pas implémenté une méthode de gestion de commande correspondante (tel que <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) le système lève une exception et ignore la commande.  
  
 Vous n’avez pas à implémenter <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, ou toute autre méthode dans <xref:System.ServiceProcess.ServiceBase>. Toutefois, le comportement du service est décrit dans <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, de sorte que, au minimum, ce membre doit être substitué. Le `main()` fonction de l’exécutable inscrit le service dans le fichier exécutable avec le Gestionnaire de contrôle de Service en appelant le <xref:System.ServiceProcess.ServiceBase.Run%2A> (méthode). Le <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> propriété de la <xref:System.ServiceProcess.ServiceBase> objet passé à la <xref:System.ServiceProcess.ServiceBase.Run%2A> méthode doit correspondre à la <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> propriété du programme d’installation de service pour ce service.  
  
 Vous pouvez utiliser `InstallUtil.exe` pour installer les services sur votre système.  
  
> [!NOTE]
>  Vous pouvez spécifier un journal autre que le journal des événements pour recevoir des notifications d’appels de service, mais aucune ne le <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ni le <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propriété peut écrire dans un journal personnalisé. Définissez <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> à `false` si vous ne souhaitez pas utiliser la journalisation automatique.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ne créez pas une instance de la <xref:System.ServiceProcess.ServiceBase> classe. Au lieu de cela, dérivent <xref:System.ServiceProcess.ServiceBase> et instancier votre classe dérivée. La valeur minimale que vous avez besoin d’implémenter dans le constructeur pour une classe héritée de <xref:System.ServiceProcess.ServiceBase> consiste à définir le <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> sur votre composant. Aucun autre traitement n’est particulièrement nécessaire dans le constructeur. Vous devez gérer la plupart des initialisation dans <xref:System.ServiceProcess.ServiceBase.OnStart%2A> plutôt que dans le constructeur. Sinon, il n’existe aucune garantie que les objets seront réinitialisés lorsque vous redémarrez un service après avoir été arrêté.  
  
 Si vous remplacez le constructeur dans votre classe dérivée, appelez le constructeur de classe de base dans votre code.  
  
 Le <xref:System.ServiceProcess.ServiceBase> constructeur affecte <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> à `true`. Si vous ne souhaitez pas enregistrer automatiquement les appels au service de gestionnaire de contrôle des services (SCM), définissez <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> à `false`.  
  
 Si le fichier exécutable contient un seul service, le système appelle le constructeur du service lorsque le démarrage est sélectionné dans SCM et exécute le destructeur si Stop est appelée.  
  
 Si le fichier exécutable contient plusieurs services, l’appel de démarrer sur un service entraîne les constructeurs d’être appelée pour tous les services dans le fichier exécutable, mais uniquement le service spécifié est démarré. Destructeurs pour les services sont exécutent ensemble lorsque tous les services ont été arrêtés, plutôt qu’individuellement lorsque chaque service est arrêté.  
  
> [!NOTE]
>  Si vous remplacez le constructeur de classe de base, vous devez l’appeler explicitement dans le constructeur de votre classe dérivée.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique s'il faut signaler les commandes Démarrer, Arrêter, Suspendre et Continuer dans le journal des événements.</summary>
        <value>
          <see langword="true" /> pour enregistrer les informations dans le journal des événements ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Paramètre <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> à `true` indique au service d’utiliser le journal des événements pour signaler les échecs de commande, ainsi que les informations de changement d’état pour démarrer, arrêter, suspendre et continuer d’événements sur le service. Le nom du service est utilisé en tant que le journal <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Pour signaler des informations à un journal des événements personnalisé plutôt que dans le journal des applications, définissez <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> à `false` et écrire les instructions décrites dans les méthodes de la gestion des commandes <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A> à valider dans le journal approprié.  
  
> [!NOTE]
>  Le <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, qui fournit la chaîne source du journal des événements, doit être définie avant que le service tente d’écrire dans le journal des événements. Tentative d’accès du journal des événements avant de définie le nom de source lève une exception.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le service peut gérer les notifications de changement d'état de l'alimentation de l'ordinateur.</summary>
        <value>
          <see langword="true" /> si le service gère les changements d'état de l'alimentation de l'ordinateur indiqués dans la classe <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque les changements d’état d’alimentation ordinateur, le Gestionnaire de contrôle des services (SCM) vérifie si le service accepte les commandes d’événement d’alimentation à l’aide de la valeur de <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> est `true`, la commande est passée au service et la <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> méthode est appelée s’il est défini. Si <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> n’est pas implémentée dans la classe dérivée, le SCM gère l’événement d’alimentation via la classe de base vide <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette propriété est modifiée après le démarrage du service.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le service peut gérer les événements de modification de session envoyés à partir d'une session Terminal Server.</summary>
        <value>
          <see langword="true" /> si le service peut gérer des événements de modification de session Terminal Server ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Cette propriété est modifiée après le démarrage du service.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le service accepte les pauses et les reprises.</summary>
        <value>
          <see langword="true" /> si le service peut être suspendu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez la valeur de la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propriété dans le constructeur pour le service.  
  
 Lorsqu’un service est suspendu, il interrompt son utilité. Si vous continuez, le service (via le Gestionnaire de contrôle de Service ou par programmation), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> s’exécute.  
  
 Envoyer une demande de suspension au service peut économiser les ressources système. Pause ne peut pas libérer toutes les ressources de système, contrairement à arrêter. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> et <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> sont souvent implémentées pour effectuer le moins de traitement que <xref:System.ServiceProcess.ServiceBase.OnStop%2A> et <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Lorsque <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `true`, substituez <xref:System.ServiceProcess.ServiceBase.OnPause%2A> et <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> pour spécifier le traitement qui doit se produire lorsque le Gestionnaire de contrôle des services (SCM) passe une demande Suspendre ou continuer à votre service. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> doit être implémenté pour annuler le traitement dans <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `false`, le SCM ne passe pas suspendre ou continuer des demandes au service, par conséquent, le <xref:System.ServiceProcess.ServiceBase.OnPause%2A> et <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> méthodes ne sont pas appelées même si elles sont implémentées. Dans le SCM, le `Pause` et `Continue` contrôles sont désactivés lorsque <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le service a déjà été démarré. La propriété <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> ne peut pas être modifiée une fois que le service a démarré.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le service doit être averti de l'arrêt du système.</summary>
        <value>
          <see langword="true" /> si le service doit être averti de l'arrêt du système ; sinon, <see langword="false" />.  La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> est `true`, le service est notifié lorsque le système s’arrête. Lors de l’arrêt, la <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> méthode est appelée si elle a été implémentée dans votre classe dérivée.  
  
> [!NOTE]
>  Seul le système peut provoquer le <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> méthode à exécuter ; le service peut l’appeler, mais cela n’est pas recommandé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le service a déjà été démarré. La propriété <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> ne peut pas être modifiée une fois que le service a démarré.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le service peut être arrêté une fois qu'il a démarré.</summary>
        <value>
          <see langword="true" /> si le service peut être arrêté et la méthode <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> appelée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors de l’arrêt est appelée sur un service, le Gestionnaire de contrôle des services (SCM) vérifie si le service accepte cette commande à l’aide de la valeur de <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Pour la plupart des services, la valeur de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> est `true`, mais certains services du système d’exploitation, par exemple, ne permettent pas de l’utilisateur pour les arrêter.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> est `true`, la commande Arrêter est passée au service et la <xref:System.ServiceProcess.ServiceBase.OnStop%2A> méthode est appelée si elle est définie. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> n’est pas implémentée dans la classe dérivée, le SCM gère la commande Arrêter via la classe de base vide <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le service a déjà été démarré. La propriété <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> ne peut pas être modifiée une fois que le service a démarré.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources (autres que la mémoire) utilisées par <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez <xref:System.ServiceProcess.ServiceBase.Dispose%2A> dans votre classe dérivée (et par son intermédiaire, dans le <xref:System.ServiceProcess.ServiceBase> classe) lorsque vous avez terminé à l’aide de la classe dérivée. Le <xref:System.ServiceProcess.ServiceBase.Dispose%2A> méthode rend la classe dérivée dans un état inutilisable. Après avoir appelé <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, vous devez libérer toutes les références à la classe dérivée et <xref:System.ServiceProcess.ServiceBase> afin que la mémoire, elles occupaient peut être récupérée par le garbage collection.  
  
> [!NOTE]
>  Appelez toujours <xref:System.ServiceProcess.ServiceBase.Dispose%2A> avant de libérer votre dernière référence à la classe dérivée de <xref:System.ServiceProcess.ServiceBase>. Sinon, les ressources <xref:System.ServiceProcess.ServiceBase> et la classe dérivée utilisent seront ne pas libérées tant que le garbage collection appelle les destructeurs des objets.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> est souvent implémenté pour traiter le code dans <xref:System.ServiceProcess.ServiceBase.OnPause%2A>combiné avec un appel à <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Si vous choisissez d’effectuer cette opération dans votre classe dérivée, il est courant d’implémenter <xref:System.ServiceProcess.ServiceBase.OnStart%2A> allouer tout ce qui <xref:System.ServiceProcess.ServiceBase.Dispose%2A> publié.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un journal des événements que vous pouvez utiliser pour écrire la notification des appels de commande de service comme Démarrer et Arrêter dans le journal des événements de l'application.</summary>
        <value>Instance de <see cref="T:System.Diagnostics.EventLog" /> dont la source est inscrite dans le journal des applications.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur initialise la <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propriété à une instance avec le <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> et <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> jeu de propriétés. La source est le <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> du service, et le journal est le journal des applications de l’ordinateur. Ces valeurs sont définies automatiquement et ne peut pas être modifiés pour la journalisation automatique de commandes de service.  
  
 Lorsque <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> est `true`, Démarrer, arrêter, suspendre, continuer et des commandes personnalisées sont enregistrées automatiquement dans le journal des événements Application. Vous pouvez utiliser le <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propriété à écrire des messages supplémentaires dans ce journal. Les appels de composant <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> à l’aide de ce <xref:System.ServiceProcess.ServiceBase.EventLog%2A> membre.  
  
 Pour signaler des informations à un journal des événements personnalisé plutôt que dans le journal des applications, définissez <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> à `false` et écrire les instructions décrites dans les méthodes de la gestion des commandes <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A> à valider dans le journal approprié.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le code de sortie du service.</summary>
        <value>Code de sortie du service.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> propriété à une valeur différente de zéro avant d’arrêter le service pour indiquer une erreur au Gestionnaire de contrôle de Service.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Indique la taille maximale d'un nom de service.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName et DisplayName attribuer les restrictions de taille doivent être respectées lors de la définition des propriétés sur votre classe de service.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si elle est implémentée dans une classe dérivée, la méthode <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> s'exécute lorsqu'une commande Continuer est envoyée au service par le Gestionnaire de contrôle des services (SCM). Spécifie les actions à effectuer lorsqu'un service reprend son fonctionnement normal après avoir été suspendu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentez <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> pour mettre en miroir de la réponse de votre application à <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Si vous continuez, le service (via la console Services ou par programme), le <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> traitement s’exécute et le service redevient actif.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> est censée être remplacée lorsque la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propriété est `true`.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `false`, le SCM ne passe pas suspendre ou continuer des demandes au service, par conséquent, le <xref:System.ServiceProcess.ServiceBase.OnPause%2A> et <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> méthodes ne sont pas appelées même si elles sont implémentées. Dans le SCM, le `Pause` et `Continue` contrôles sont désactivés lorsque <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Message de commande envoyé au service.</param>
        <summary>Si elle est implémentée dans une classe dérivée, la méthode <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> s'exécute lorsque le Gestionnaire de contrôle des services (SCM) passe une commande personnalisée au service. Spécifie les actions à effectuer lorsqu'une commande a la valeur de paramètre spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> vous permet de spécifier des fonctionnalités supplémentaires au-delà de démarrage, arrêt, suspension et reprise des services.  
  
 Le SCM n’examine pas la commande personnalisée pour vérifier si le service prend en charge la `command` paramètre passé. Il passe la commande personnalisée directement au service. Si le service ne reconnaît pas le `command` paramètre, elle ne fait rien.  
  
 Commandes personnalisées sont déclenchées par un <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> instruction dans un <xref:System.ServiceProcess.ServiceController> composant. Utiliser une instruction switch ou si... Then pour gérer les commandes personnalisées que vous définissez sur votre service.  
  
 Les seules valeurs pour une commande personnalisée que vous pouvez définir dans votre application ou utiliser dans <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> sont celles comprises entre 128 et 255. Les entiers inférieurs à 128 correspondent aux valeurs réservées du système.  
  
 Si le <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> propriété est `true`, des commandes personnalisées, ainsi que toutes les autres commandes, écrivent des entrées dans le journal des événements pour signaler si l’exécution de la méthode a réussi ou échoué.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si elle est implémentée dans une classe dérivée, cette méthode s'exécute lorsqu'une commande Suspendre est envoyée au service par le Gestionnaire de contrôle des services (SCM). Spécifie les actions à effectuer lorsqu'un service est suspendu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.ServiceProcess.ServiceBase.OnPause%2A> pour spécifier le traitement qui se produit lorsque le service reçoit une commande de suspension. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> est censée être remplacée lorsque la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propriété est `true`.  
  
 Lorsque vous reprenez un service précédemment interrompu (via la console Services ou par programmation), le <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> traitement est exécuté, et le service redevient actif.  
  
 La commande Pause permet uniquement à votre application de réagir à un événement spécifique. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> ne fait rien pour le service que vous ne définissez pas à effectuer.  
  
 Envoyer une demande de suspension au service peut économiser les ressources de système, car la suspension ne libère pas forcément toutes les ressources système. Par exemple, si les threads ont été ouverts par le processus, une suspension du service plutôt que l’arrêt il peut permettre aux threads de rester ouverts, ce qui vous évite la nécessité de réallouer lorsque le service continue. Si vous définissez Suspendre pour libérer toutes les ressources système, il se comporte comme une commande d’arrêt.  
  
 Définissez <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> à `true`et remplacer <xref:System.ServiceProcess.ServiceBase.OnPause%2A> et <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> pour spécifier le traitement qui doit se produire lorsque le GCL passe une demande Suspendre ou continuer à votre service. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> doit être implémenté pour annuler le traitement dans <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `false`, le SCM ne passe pas suspendre ou continuer des demandes au service, par conséquent, le <xref:System.ServiceProcess.ServiceBase.OnPause%2A> et <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> méthodes ne sont pas appelées même si implémenté. Dans le SCM, le `Pause` et `Continue` contrôles sont désactivés lorsque <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> est `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">
          <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> qui indique une notification émise par le système à propos de l'état de son alimentation.</param>
        <summary>Si cette méthode est implémentée dans une classe dérivée, elle s'exécute lorsque l'alimentation de l'ordinateur change d'état. Cela concerne les ordinateurs portables lorsqu'ils passent en mode suspendu (différent d'un arrêt du système).</summary>
        <returns>Une fois implémentés dans une classe dérivée, les besoins de votre application déterminent la valeur à retourner. Par exemple, si un état de diffusion <see langword="QuerySuspend" /> est passé, vous pouvez obliger votre application à rejeter la requête en retournant <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> pour spécifier le traitement qui se produit lorsque l’événement système indiqué dans le <xref:System.ServiceProcess.PowerBroadcastStatus> énumération se produit--par exemple, lorsque l’ordinateur est placé en mode suspendu ou indique peu d’énergie.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> est censée être remplacée lorsque la <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> propriété est `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Structure identifiant le type de modification.</param>
        <summary>S'exécute lorsqu'un événement de modification est reçu d'une session Terminal Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez définir le <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> propriété `true` pour permettre l’exécution de cette méthode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si cette méthode est implémentée dans une classe dérivée, elle s'exécute lorsque le système s'arrête. Spécifie ce qui doit se produire juste avant l'arrêt du système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> pour spécifier le traitement qui se produit lorsque le système s’arrête.  
  
 Cet événement se produit uniquement lorsque le système d’exploitation est arrêté, pas lorsque l’ordinateur est éteint.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> est censée être remplacée lorsque la <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> propriété est `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Données passées par la commande de démarrage.</param>
        <summary>Si elle est implémentée dans une classe dérivée, cette méthode s'exécute lorsqu'une commande Démarrer est envoyée au service par le Gestionnaire de contrôle des services (SCM) ou lorsque le système d'exploitation démarre (pour un service qui démarre automatiquement). Spécifie les actions à effectuer lorsque le service démarre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.ServiceProcess.ServiceBase.OnStart%2A> pour spécifier le traitement qui se produit lorsque le service reçoit une commande de démarrage. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> est la méthode dans laquelle vous spécifiez le comportement du service. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> peut accepter des arguments comme un moyen de passer des données, mais cette utilisation est rare.  
  
> [!CAUTION]
>  N’utilisez pas le constructeur pour exécuter le traitement doit se trouver dans <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Utilisez <xref:System.ServiceProcess.ServiceBase.OnStart%2A> pour gérer l’initialisation de votre service. Le constructeur est appelé lorsque l’exécutable de l’application s’exécute, pas lorsque le service s’exécute. L’exécutable s’exécute avant <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Lorsque vous continuez, par exemple, le constructeur n’est pas appelé à nouveau, car le SCM conserve déjà l’objet en mémoire. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> libère les ressources allouées dans le constructeur plutôt que dans <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, les ressources nécessaires ne seraient pas créés de la deuxième fois que le service est appelé.  
  
 Services peuvent être configurés pour démarrer automatiquement lorsque l’ordinateur redémarre en définissant le <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> sur le programme d’installation du service à <xref:System.ServiceProcess.ServiceStartMode.Automatic>. Dans ce cas, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> est appelé au démarrage du système.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> doit être substitué dans la classe dérivée. Pour le service soit utile, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> et <xref:System.ServiceProcess.ServiceBase.OnStop%2A> doit être implémentées dans votre classe de service.  
  
 Traiter les arguments de l’initialisation pour le service dans le <xref:System.ServiceProcess.ServiceBase.OnStart%2A> (méthode), pas dans la méthode Main. Les arguments dans le `args` tableau de paramètres peut être défini manuellement dans la fenêtre Propriétés pour le service dans la console Services. Les arguments entrés dans la console ne sont pas enregistrées ; ils sont passés au service de manière ponctuelle lorsque le service est démarré à partir du panneau. Les arguments qui doivent être présents lorsque le service est démarré automatiquement peuvent être placés dans la valeur de chaîne ImagePath de la clé de Registre du service (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\ * \< nom du service >*). Vous pouvez obtenir les arguments du Registre à l’aide de la <xref:System.Environment.GetCommandLineArgs%2A> méthode, par exemple : `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si elle est implémentée dans une classe dérivée, cette méthode s'exécute lorsqu'une commande Arrêter est envoyée au service par le Gestionnaire de contrôle des services (SCM). Spécifie les actions à effectuer lorsqu'un service cesse de s'exécuter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.ServiceProcess.ServiceBase.OnStop%2A> pour spécifier le traitement qui se produit lorsque le service reçoit une commande d’arrêt.  
  
 Lorsque le SCM reçoit une commande d’arrêt, il utilise la valeur de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> pour vérifier si le service accepte cette commande. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> est `true`, la commande d’arrêt est transmise au service et le <xref:System.ServiceProcess.ServiceBase.OnStop%2A> méthode est appelée si elle est définie. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> n’est pas implémentée dans le service, le SCM gère la commande d’arrêt.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> est `false`, le SCM ignore la commande d’arrêt. Il n’est pas transmis au service. La commande d’arrêt retourne et lève une exception.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> doit être substitué dans la classe dérivée. Pour le service soit utile, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> et <xref:System.ServiceProcess.ServiceBase.OnStop%2A> doit être implémentées dans votre classe de service.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Heure demandée en millisecondes.</param>
        <summary>Demande la durée supplémentaire d'une opération en attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> méthode est destinée à être appelée par substituées <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A> méthodes pour demander plus de temps pour une opération en attente, pour empêcher le Gestionnaire de contrôle des services (SCM) de marquage du service en tant que ne répond ne pas.  Si l’opération en attente n’est pas un continuer, de suspendre, démarrer ou arrêter, un <xref:System.InvalidOperationException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le service n'est pas en état d'attente.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fournit le point d'entrée principal pour un exécutable de service.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.ServiceProcess.ServiceBase" /> qui indique le service à démarrer.</param>
        <summary>Inscrit l'exécutable d'un service à l'aide du Gestionnaire de contrôle des services.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette surcharge dans le `main()` fonction de l’exécutable du service pour inscrire le service avec le Gestionnaire de contrôle de Service. Après avoir appelé <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, le Gestionnaire de contrôle de Service émet une commande de démarrage, ce qui entraîne un appel à la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> méthode dans le service. Le service n’est pas démarré jusqu'à ce que la commande de démarrage est exécutée.  
  
 Le <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> méthode est appelée dans la même façon que <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> pour les applications Windows Forms.  
  
 Si <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> est `true`, une entrée est écrite dans le journal des événements si le service spécifié par le `service` paramètre ne parvient pas à démarrer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Tableau d'instances de ServiceBase qui indique les services à démarrer.</param>
        <summary>Inscrit l'exécutable de plusieurs services à l'aide du Gestionnaire de contrôle des services.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette surcharge dans le `main()` fonction de l’exécutable du service pour inscrire les services avec le Gestionnaire de contrôle de Service. Après avoir appelé <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, le Gestionnaire de contrôle de Service émet des commandes de démarrage, ce qui entraîne des appels à la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> méthodes dans les services. Les services ne sont pas démarrés jusqu'à ce que les commandes de démarrage sont exécutées.  
  
 Le <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> méthode est appelée dans la même façon que le <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> méthode pour les applications Windows Forms.  
  
 Si <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> est `true`, une entrée est écrite dans le journal des événements si n’importe quel service dans le tableau ne parvient pas à démarrer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Vous n'avez pas spécifié le service à démarrer. Le tableau peut être <see langword="null" /> ou vide.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle du contrôle du service.</summary>
        <value>Structure <see cref="T:System.IntPtr" /> contenant le handle du contrôle du service.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le handle du contrôle est utilisé pour communiquer avec le Gestionnaire de contrôle des services (SCM).  Le handle peut être utilisé pour mettre à jour les informations d’état du Gestionnaire de contrôle de service pour le service d’appel à l’aide de non managé `SetServiceStatus` (fonction).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">Nombre d'arguments dans le tableau d'arguments.</param>
        <param name="argPointer">Structure <see cref="T:System.IntPtr" /> qui désigne un tableau d'arguments.</param>
        <summary>Inscrit le gestionnaire de commandes et démarre le service.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom court utilisé pour identifier le service sur le système.</summary>
        <value>Nom du service.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifie le service pour le Gestionnaire de contrôle de Service. La valeur de cette propriété doit être identique au nom enregistré pour le service dans le <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> propriété de la classe de programme d’installation correspondante. Dans le code, le <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> du service est généralement définie dans le `main()` fonction de l’exécutable.  
  
 Le <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> est également utilisé pour spécifier le <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> associé à la <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propriété. Cela <xref:System.ServiceProcess.ServiceBase.EventLog%2A> est une instance qui écrit les informations de commande de service dans le journal des applications.  
  
 Le <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, qui fournit la chaîne source du journal des événements, doit être définie avant que le service écrit dans le journal des événements. Tentative d’accès du journal des événements avant de définie le nom de source provoque une exception levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le service a déjà été démarré. La propriété <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> ne peut pas être modifiée une fois que le service a démarré.</exception>
        <exception cref="T:System.ArgumentException">Le nom spécifié est une chaîne de longueur nulle ou est plus long que <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, ou le nom spécifié contient des barres obliques ou des barres obliques inverses.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête le service en cours d'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceProcess.ServiceBase.Stop%2A> méthode définit l’état du service pour indiquer un arrêt est en attente et appelle le <xref:System.ServiceProcess.ServiceBase.OnStop%2A> (méthode).  Une fois que l’application est arrêtée, l’état du service est défini sur arrêté. Si l’application est un service hébergé, le domaine d’application est déchargé.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>