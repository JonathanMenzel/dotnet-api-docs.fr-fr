<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8fb289e3db8f78e3c0d8ab3e407138cd550b88bd" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30351173" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit des objets <see cref="T:Microsoft.Win32.RegistryKey" /> qui représentent les clés racine du Registre Windows et des méthodes <see langword="static" /> permettant d'accéder à des paires clé/valeur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe fournit l’ensemble des clés racine standard présentes dans le Registre sur les ordinateurs exécutant Windows. Le Registre est un support de stockage pour plus d’informations sur les applications, les utilisateurs et les paramètres système par défaut. Par exemple, applications peuvent utiliser le Registre pour stocker les informations qui doivent être conservés après la fermeture de l’application et accéder aux informations mêmes lorsque l’application est rechargée. Par exemple, vous pouvez stocker les préférences de couleurs, les emplacements à l’écran ou la taille de la fenêtre. Vous pouvez contrôler ces données pour chaque utilisateur en stockant les informations dans un autre emplacement dans le Registre.  
  
 La base, ou racine <xref:Microsoft.Win32.RegistryKey> instances qui sont exposées par la `Registry` classe définissent le mécanisme de stockage de base pour les sous-clés et valeurs dans le Registre. Toutes les clés sont en lecture seule, car le Registre dépend de leur existence. Les clés exposées par `Registry` sont :  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Stocke des informations sur les préférences de l’utilisateur.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Stocke les informations de configuration de l’ordinateur local.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Stocke des informations sur les types (et classes) et leurs propriétés.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Stocke des informations sur la configuration de l’utilisateur par défaut.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Stocke les informations de performances pour les composants logiciels.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Stocke les informations de matériel de non spécifiques à l’utilisateur.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Stocke les données dynamiques.  
  
 Une fois que vous avez identifié la clé racine sous lequel vous souhaitez stocker/récupérer des informations à partir du Registre, vous pouvez utiliser la <xref:Microsoft.Win32.RegistryKey> classe pour ajouter ou supprimer des sous-clés et manipuler les valeurs d’une clé spécifique.  
  
 Périphériques matériels peuvent placer des informations dans le Registre automatiquement à l’aide de l’interface de Plug-and-Play. Logiciels pour installer des pilotes de périphérique peuvent placer des informations dans le Registre en écrivant dans les API standard.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Méthodes statiques pour obtenir et définir des valeurs  
 Dans le .NET Framework version 2.0, le <xref:Microsoft.Win32.Registry> classe contient également `static` <xref:Microsoft.Win32.Registry.GetValue%2A> et <xref:Microsoft.Win32.Registry.SetValue%2A> méthodes pour définir et récupérer les valeurs de clés de Registre. Ces méthodes ouvrant et d’une clé de Registre fermer chaque fois qu’elles sont utilisées, ils n’effectuent pas ainsi que des méthodes analogues dans le <xref:Microsoft.Win32.RegistryKey> (classe), lorsque vous accédez à un grand nombre de valeurs.  
  
 La <xref:Microsoft.Win32.RegistryKey> classe fournit également des méthodes qui vous permettent de définir la sécurité de contrôle d’accès Windows pour les clés de Registre, de tester le type de données d’une valeur avant de les récupérer et de supprimer des clés.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple illustre les clés racines, et le deuxième exemple montre le `static` <xref:Microsoft.Win32.Registry.GetValue%2A> et <xref:Microsoft.Win32.Registry.SetValue%2A> méthodes.  
  
 Exemple 1  
  
 L’exemple de code suivant montre comment récupérer les sous-clés de la clé HKEY_USERS et imprimer leurs noms à l’écran. Utilisez la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans `RegistryKey` pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Exemple 2  
  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, comme il le fait, puis récupère et affiche les valeurs de création de la clé. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` lorsque une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit les types (ou classes) de documents ainsi que les propriétés associées à ces types. Ce champ lit la clé de base HKEY_CLASSES_ROOT du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les applications classiques et les applications OLE utilisent des données qui sont stockées sous cette clé. Cette clé fournit également une compatibilité descendante avec la base de données d’inscription Windows 3.1 en stockant des informations pour la prise en charge DDE et OLE. Visionneuses de fichiers et extensions de l’interface utilisateur stockent leurs identificateurs de classe OLE dans cette clé, et les serveurs de traitement sont enregistrés dans cette clé.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et affiche leurs noms à l’écran. Utilisez la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient des informations de configuration concernant le matériel qui ne sont pas spécifiques à l'utilisateur. Ce champ lit la clé de base HKEY_CURRENT_CONFIG du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est mappé à une sous-clé dans <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Un exemple d’utilisation de ce membre est une application qui stocke un nom de serveur différent pour ses données selon que le système est attaché à un réseau.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et affiche leurs noms à l’écran. Utilisez la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient les informations relatives aux préférences de l'utilisateur en cours. Ce champ lit la clé de base HKEY_CURRENT_USER du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les informations stockées dans cette clé comprend les paramètres des variables d’environnement et les données sur les groupes de programmes, les couleurs, les imprimantes, connexions réseau et les préférences de l’application. Cette clé rend plus facile de déterminer les paramètres de l’utilisateur actuel. Dans cette clé, les éditeurs de logiciels stockent les préférences spécifiques à l’utilisateur actuels à utiliser dans leurs applications. Microsoft, par exemple, crée la clé HKEY_CURRENT_USER\Software\Microsoft de ses applications à utiliser avec chaque application crée sa propre sous-clé sous la clé de Microsoft.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et affiche leurs noms à l’écran. Utilisez la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient les données dynamiques du Registre. Ce champ lit la clé de base HKEY_DYN_DATA du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Registre Windows 98/Windows Me prend en charge les données statiques (qui sont stockées sur le disque dans le Registre) et les données dynamiques (qui changent souvent, telles que les statistiques de performances). Cette zone de données dynamiques est le mécanisme qui permet des pilotes de périphériques virtuels (VxDs) pour fournir des données en temps réel pour les applications Win32 qui peuvent s’exécuter à distance, ainsi que localement. Il permet également le Moniteur système fournir des statistiques de performances sur les systèmes distants Windows 98/Windows Me.  
  
 VxDs n’êtes pas limités aux données de performances. Elles peuvent fournir des données à passer de l’anneau 0 à l’anneau 3 efficacement sans monopoliser l’UC. Le Registre prend en charge les données dynamiques en stockant un pointeur vers une fonction qui retourne une valeur (ou nombre de valeurs). Lorsqu’une valeur de requêtes d’appel du Registre associé à une clé dynamique, que la fonction est appelée pour retourner la valeur de votre choix ou les valeurs.  
  
> [!NOTE]
>  Les clés dynamiques ont été introduites dans Microsoft Windows 95 pour gérer les données dynamiques du Registre. Elles sont prises en charge uniquement sur Windows 98 et Windows Me.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et affiche leurs noms à l’écran. Utilisez la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé. Notez que cet exemple peut ne retourner aucun résultat, car il ne peut pas être dynamique des données disponibles, ou vous pouvez exécuter pas à Windows 98 / Me. À l’aide de cette clé peut provoquer une erreur sur d’autres systèmes.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le système d'exploitation ne prend pas en charge les données dynamiques ; autrement dit, il ne s'agit pas de Windows 98, Windows 98 Deuxième Édition ou Windows Millennium (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Chemin de Registre complet de la clé, commençant avec une racine de Registre valide, comme « HKEY_CURRENT_USER ».</param>
        <param name="valueName">Nom de la paire nom/valeur.</param>
        <param name="defaultValue">Valeur à retourner si <c>valueName</c> n’existe pas.</param>
        <summary>Récupère la valeur associée au nom spécifié, dans la clé de Registre spécifiée. Si le nom est introuvable dans la clé spécifiée, retourne une valeur par défaut que vous fournissez ou la valeur <see langword="null" /> si la clé spécifiée n'existe pas.</summary>
        <returns>
          <see langword="null" /> si la sous-clé spécifiée par <paramref name="keyName" /> n'existe pas ; autrement, la valeur associée à <paramref name="valueName" /> ou <paramref name="defaultValue" /> si <paramref name="valueName" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne `valueName` ne respecte pas la casse.  
  
> [!NOTE]
>  Une clé de Registre permettre contenir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour récupérer cette valeur sans nom, spécifiez `null` ou une chaîne vide (« ») pour `valuName`.  
  
 Les noms de racine valide sont HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG et HKEY_DYN_DATA. Par exemple, la chaîne « HKEY_CURRENT_USER\MyTestKey » accède aux paires clé/valeur de la sous-clé « MyTestKey » dans la racine HKEY_CURRENT_USER en Visual Basic.  
  
 Lorsque le <xref:Microsoft.Win32.RegistryKey.GetValue%2A> méthode extrait les valeurs de chaîne extensible (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), elle étend des chaînes d’environnement à l’aide des données à partir de l’environnement local. Si une valeur contenant des références extensibles à des variables d’environnement a été stockée sous forme de chaîne (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), plutôt que comme une chaîne extensible (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> ne s’étend pas. Vous pouvez développer une telle chaîne après qu’il a été récupéré en appelant le <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> (méthode).  
  
> [!NOTE]
>  La méthode recommandée pour récupérer des données à partir de HKEY_PERFORMANCE_DATA consiste à utiliser le <xref:System.Diagnostics.PerformanceCounter> classe plutôt que <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> (méthode).  
  
 Le <xref:Microsoft.Win32.Registry.GetValue%2A> et <xref:Microsoft.Win32.Registry.SetValue%2A> ouvrent des méthodes et des clés de Registre fermer chaque fois qu’elles sont utilisées, elles n’effectuent pas, ainsi que les méthodes de la <xref:Microsoft.Win32.RegistryKey> classe si vous accédez à un grand nombre de valeurs.  
  
 <xref:Microsoft.Win32.RegistryKey> fournit également des méthodes qui permettent d’ajouter une liste de contrôle d’accès (ACL) à une clé de Registre, de tester le type de données d’une valeur avant de les récupérer et de supprimer des clés.  
  
   
  
## Examples  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, comme il le fait, puis récupère et affiche les valeurs de création de la clé. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` lorsque une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire dans la clé de Registre.</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée a été marqué pour suppression.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> ne commence pas par une racine de Registre valide.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour lire à partir du Registre. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">lire une clé de Registre de type REG_EXPAND_SZ. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient les informations de configuration pour l'ordinateur local. Ce champ lit la clé de base HKEY_LOCAL_MACHINE du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` contient les cinq clés :  
  
 Matériel  
 Décrit le matériel physique de l’ordinateur, la façon de pilotes de périphériques utilisent ce matériel et les mappages et les données associées qui lient les pilotes en mode noyau avec du code en mode utilisateur. Toutes les données de cette clé est recréée chaque fois que le système est démarré. La sous-clé Description décrit le matériel réel de l’ordinateur. La sous-clé DeviceMap contient diverses données dans des formats spécifiques aux classes particulières de pilotes. La sous-clé ResourceMap décrit les pilotes de périphérique de revendication les ressources matérielles. Le programme de Diagnostics Windows NT (Winmsdp.exe) peut signaler à son contenu dans une forme facile à lire.  
  
 SAM  
 La base de données des services de répertoire des informations de sécurité pour les comptes d’utilisateur et groupe et pour les domaines Windows 2000 Server (SAM est le Gestionnaire de comptes de sécurité connus en tant que la base de données des services de répertoire).  
  
 Sécurité  
 Contient la stratégie de sécurité locale, telles que les droits d’utilisateur spécifique. Cette clé est utilisée uniquement par le sous-système de sécurité de Windows 2000.  
  
 Logiciels  
 La base de données du logiciel par ordinateur. Cette clé contient des données concernant les logiciels installés sur l’ordinateur local, ainsi que divers éléments de données de configuration.  
  
 Système  
 Contrôle le démarrage du système, lors du chargement du pilote de périphérique, les services Windows 2000 et comportement du système d’exploitation.  
  
 Par convention, si des données similaires existent sous <xref:Microsoft.Win32.Registry.CurrentUser> et sous <xref:Microsoft.Win32.Registry.LocalMachine>, les données de <xref:Microsoft.Win32.Registry.CurrentUser> est prioritaire. Toutefois, les valeurs de cette clé peuvent également étendre (plutôt que remplacer) données dans Registry.LocalMachine. En outre, certains éléments (par exemple, le chargement des entrées de pilote de périphérique) sont inutiles si elles se produisent en dehors de Registry.LocalMachine.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et affiche leurs noms à l’écran. Utilisez la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient des informations sur les performances des composants logiciels. Ce champ lit la clé de base HKEY_PERFORMANCE_DATA du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque composant logiciel crée des clés pour ses objets et compteurs lorsqu’il est installé et écrit les données de compteur pendant son exécution. Vous pouvez accéder à ces données comme vous accéderiez à toutes les autres données de Registre à l’aide de la <xref:Microsoft.Win32.RegistryKey> fonctions.  
  
 Bien que vous utilisez le Registre pour collecter des données de performances, les données ne sont pas stockées dans la base de données du Registre. Au lieu de cela, l’accès au Registre avec cette clé entraîne le système collecter les données à partir des gestionnaires d’objet système appropriés.  
  
 Pour obtenir les données de performances à partir du système local, utilisez le <xref:Microsoft.Win32.RegistryKey.GetValue%2A> méthode, avec la clé Registry.PerformanceData. Le premier appel ouvre la clé (vous n’avez pas besoin pour tout d’abord ouvrir la clé explicitement). Toutefois, veillez à utiliser le <xref:Microsoft.Win32.RegistryKey.Close%2A> méthode pour fermer le handle de la clé lorsque vous avez terminé de l’obtention des données de performances. L’utilisateur ne peut pas installer ou supprimer un composant logiciel alors que ses données de performances sont en cours d’utilisation.  
  
 Pour obtenir des données de performances à partir d’un système distant, vous devez utiliser le <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> méthode, avec le nom d’ordinateur du système distant et la clé Registry.PerformanceData. Cet appel récupère une clé représentant les données de performances pour le système distant. Pour récupérer les données, appelez <xref:Microsoft.Win32.RegistryKey.GetValue%2A> à l’aide de cette clé, plutôt que la clé Registry.PerformanceData.  
  
> [!NOTE]
>  Sur Windows Server 2003, un utilisateur doit appartenir au moins au groupe utilisateurs d’analyse de performances afin d’accéder à des sous-clés de cette clé de base.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et affiche leurs noms à l’écran. Utilisez la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé. Notez que cet exemple peut retourner aucun résultat, car il ne peut y avoir aucune donnée de performances.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit la valeur d'une paire nom/valeur dans une clé de Registre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, comme il le fait, puis récupère et affiche les valeurs de création de la clé. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` lorsque une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Chemin de Registre complet de la clé, commençant avec une racine de Registre valide, comme « HKEY_CURRENT_USER ».</param>
        <param name="valueName">Nom de la paire nom/valeur.</param>
        <param name="value">Valeur à stocker.</param>
        <summary>Définit la paire nom/valeur spécifiée sur la clé de Registre spécifiée. Si la clé spécifiée n'existe pas, elle est créée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le `valueName` paramètre n’est plus limité à un maximum de 255 caractères ; Toutefois, le `keyName` paramètre continue à disposer de la restriction de 255 caractères.  
  
 Nombre de valeurs pouvant être stockées dans chaque clé de Registre, vous devez utiliser le `valueName` pour spécifier la valeur particulière à définir.  
  
> [!NOTE]
>  Une clé de Registre permettre contenir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour définir cette valeur sans nom, spécifiez `null` ou une chaîne vide (« ») pour `valueName`.  
  
 Si `valueName` n’existe pas dans la clé, il est créé et la valeur associée est définie à `value`.  
  
 Si `keyName` spécifie une sous-clé qui n’existe pas, la sous-clé est créée dans la racine spécifiée. Par exemple, en Visual Basic, la chaîne « HKEY_CURRENT_USER\MyTestKey » crée la sous-clé « MyTestKey » dans la racine HKEY_CURRENT_USER. La chaîne « HKEY_CURRENT_USER\MyTestKey\Key2\Key3 » crée les sous-clés imbriquées « MyTestKey », « MyTestKey\Key2 » et « MyTestKey\Key2\Key3 ».  
  
 Les noms de racine valide incluent HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG et HKEY_DYN_DATA.  
  
> [!NOTE]
>  Le <xref:Microsoft.Win32.Registry.SetValue%2A> méthode ouvre une clé de Registre, définit la valeur et ferme la clé chaque fois qu’elle est appelée. Si vous devez modifier un grand nombre de valeurs, la <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> méthode peut offrir de meilleures performances. La <xref:Microsoft.Win32.RegistryKey> classe fournit également des méthodes qui permettent d’ajouter une liste de contrôle d’accès (ACL) à une clé de Registre, de tester le type de données d’une valeur avant de les récupérer et de supprimer des clés.  
  
 Cette surcharge de <xref:Microsoft.Win32.Registry.SetValue%2A> stocke les entiers de 64 bits en tant que chaînes (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Pour stocker les nombres de 64 bits en tant que <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> valeurs, utilisez la <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> surcharge de méthode.  
  
 Cette surcharge de <xref:Microsoft.Win32.Registry.SetValue%2A> stocke toutes les valeurs de chaîne en tant que <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> d’objets, même s’ils contiennent des références extensibles à des variables d’environnement. Pour enregistrer les valeurs de chaîne peut être développés comme chaînes (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), utilisez la <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> surcharge de méthode.  
  
 Cette surcharge revient à appeler la <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> surcharge de méthode avec <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sur Windows 98 et Windows Millennium Edition (Windows Me), le Registre n’est pas Unicode, et tous les caractères Unicode sont valides pour toutes les pages de code. Caractère Unicode qui n’est pas valide pour la page de codes actuelle est remplacée par la meilleure correspondance disponible. Aucune exception n'est levée.  
  
   
  
## Examples  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, comme il le fait, puis récupère et affiche les valeurs de création de la clé. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` lorsque une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> ne commence pas par une racine de Registre valide.  
  
 - ou -  
  
 La longueur de <paramref name="keyName" /> est supérieure à la longueur maximale autorisée (255 caractères).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> étant en lecture seule, elle n'est pas accessible en écriture ; il s'agit par exemple d'un nœud de niveau racine.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour créer ou modifier des clés de Registre.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour modifier la clé de Registre spécifiée si elle existe, ou pour créer la clé de Registre si elle n’existe pas déjà. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">Chemin de Registre complet de la clé, commençant avec une racine de Registre valide, comme « HKEY_CURRENT_USER ».</param>
        <param name="valueName">Nom de la paire nom/valeur.</param>
        <param name="value">Valeur à stocker.</param>
        <param name="valueKind">Type de données de Registre à utiliser lors du stockage des données.</param>
        <summary>Définit la paire nom/valeur sur la clé de Registre spécifiée, à l'aide du type de données de Registre spécifié. Si la clé spécifiée n'existe pas, elle est créée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le `valueName` paramètre n’est plus limité à un maximum de 255 caractères ; Toutefois, le `keyName` paramètre continue de la limitation à 255 caractères.  
  
 Nombre de valeurs pouvant être stockées dans chaque clé de Registre, vous devez utiliser le `valueName` pour spécifier la valeur particulière à définir.  
  
> [!NOTE]
>  Une clé de Registre permettre contenir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour définir cette valeur sans nom, spécifiez `null` ou une chaîne vide (« ») pour `valueName`.  
  
 Si `valueName` n’existe pas dans la clé, il est créé et la valeur associée est définie à `value`.  
  
 Si `keyName` spécifie une sous-clé qui n’existe pas, la sous-clé est créée dans la racine spécifiée. Par exemple, en Visual Basic, la chaîne « HKEY_CURRENT_USER\MyTestKey » crée la sous-clé « MyTestKey » dans la racine HKEY_CURRENT_USER. La chaîne « HKEY_CURRENT_USER\MyTestKey\Key2\Key3 » crée les sous-clés imbriquées « MyTestKey », « MyTestKey\Key2 » et « MyTestKey\Key2\Key3 ».  
  
 Les noms de racine valide incluent HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG et HKEY_DYN_DATA.  
  
> [!NOTE]
>  Le <xref:Microsoft.Win32.Registry.SetValue%2A> méthode ouvre une clé de Registre, définit la valeur et ferme la clé chaque fois qu’elle est appelée. Si vous devez modifier un grand nombre de valeurs, la <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> méthode peut offrir de meilleures performances. La <xref:Microsoft.Win32.RegistryKey> classe fournit également des méthodes qui permettent d’ajouter une liste de contrôle d’accès (ACL) à une clé de Registre, de tester le type de données d’une valeur avant de les récupérer et de supprimer des clés.  
  
 Si le type spécifié `value` ne correspondent pas à la chaîne `valueKind`, et les données ne peut pas être converti, <xref:System.ArgumentException> est levée. Par exemple, vous pouvez stocker un <xref:System.Int64?displayProperty=nameWithType> comme un <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, mais uniquement si sa valeur est inférieure à la valeur maximale d’un <xref:System.Int32?displayProperty=nameWithType>. Vous ne pouvez pas stocker une valeur de chaîne unique en tant qu’un <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Si des valeurs boxed sont passées <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, la conversion s’effectue à l’aide de la culture dite indifférente.  
  
> [!NOTE]
>  Sur Windows 98 et Windows Millennium Edition (Windows Me), le Registre n’est pas Unicode, et tous les caractères Unicode sont valides pour toutes les pages de code. Caractère Unicode qui n’est pas valide pour la page de codes actuelle est remplacée par la meilleure correspondance disponible. Aucune exception n'est levée.  
  
   
  
## Examples  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, comme il le fait, puis récupère et affiche les valeurs de création de la clé. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` lorsque une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> ne commence pas par une racine de Registre valide.  
  
 - ou -  
  
 La longueur de <paramref name="keyName" /> est supérieure à la longueur maximale autorisée (255 caractères).  
  
 - ou -  
  
 Le type de <paramref name="value" /> ne correspondait pas au type de données de Registre spécifié par <paramref name="valueKind" />, par conséquent les données n'ont pas pu être converties correctement.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> étant en lecture seule, elle n'est pas accessible en écriture ; il s'agit par exemple d'un nœud de niveau racine ou bien la clé n'a pas été ouverte avec un accès en écriture.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour créer ou modifier des clés de Registre.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour modifier la clé de Registre spécifiée si elle existe, ou pour créer la clé de Registre si elle n’existe pas déjà. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient les informations relatives à la configuration utilisateur par défaut. Ce champ lit la clé de base HKEY_USERS du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette clé contient une branche pour chaque utilisateur de l’ordinateur. La configuration par défaut est fournie pour les nouveaux utilisateurs sur l’ordinateur local et pour l’utilisateur actuel par défaut si l’utilisateur n’a pas changé préférences. Étant donné que Windows 98 / ME prend également en charge Registry.Users, les applications peuvent accéder aux informations spécifiques à l’utilisateur de la même façon que sous Windows 2000. Les informations de chaque utilisateur sont stockées dans un fichier distinct, qui peut être stocké localement ou sur un serveur réseau. Windows 98 / ME peut copier ce fichier pour le système actuel de l’utilisateur afin que les paramètres peuvent déplacer un ordinateur vers un autre avec l’utilisateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et affiche leurs noms à l’écran. Utilisez la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>