<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="027df2560decd6d6c9ebcebde62e2318d304d218" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55329324" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit des objets <see cref="T:Microsoft.Win32.RegistryKey" /> qui représentent les clés racine du Registre Windows et des méthodes <see langword="static" /> permettant d'accéder à des paires clé/valeur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe fournit l’ensemble des clés racine standard trouvé dans le Registre sur les ordinateurs exécutant Windows. Le Registre est une fonctionnalité de stockage pour plus d’informations sur les applications, les utilisateurs et les paramètres système par défaut. Par exemple, les applications peuvent utiliser le Registre pour stocker les informations qui doivent être conservés après la fermeture de l’application et accéder à ces mêmes informations lors du rechargement de l’application. Par exemple, vous pouvez stocker les préférences de couleur, emplacements de l’écran ou la taille de la fenêtre. Vous pouvez contrôler ces données pour chaque utilisateur en stockant les informations dans un autre emplacement dans le Registre.  
  
 La base, ou racine <xref:Microsoft.Win32.RegistryKey> instances qui sont exposées par le `Registry` classe définissent le mécanisme de stockage de base pour les sous-clés et valeurs dans le Registre. Toutes les clés sont en lecture seule, car le Registre dépend de leur existence. Les clés exposées par `Registry` sont :  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Stocke des informations sur les préférences de l’utilisateur.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Stocke les informations de configuration de l’ordinateur local.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Stocke des informations sur les types (et classes) et leurs propriétés.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Stocke des informations sur la configuration d’utilisateur par défaut.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Stocke les informations de performances pour les composants logiciels.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Stocke les informations de matériel de non-spécifiques à l’utilisateur.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Stocke les données dynamiques.  
  
 Une fois que vous avez identifié la clé racine sous lequel vous souhaitez stocker/récupérer des informations à partir du Registre, vous pouvez utiliser la <xref:Microsoft.Win32.RegistryKey> classe pour ajouter ou supprimer des sous-clés et manipuler les valeurs d’une clé donnée.  
  
 Périphériques matériels peuvent placer des informations dans le Registre automatiquement à l’aide de l’interface de Plug-and-Play. Logiciel pour installer des pilotes de périphérique peut placer des informations dans le Registre en écrivant dans des API standard.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Méthodes statiques pour obtenir et définir des valeurs  
 Dans le .NET Framework version 2.0, le <xref:Microsoft.Win32.Registry> classe contient également `static` <xref:Microsoft.Win32.Registry.GetValue%2A> et <xref:Microsoft.Win32.Registry.SetValue%2A> méthodes pour définir et extraire des valeurs de clés de Registre. Ouvrent ces méthodes et des clés de Registre fermer chaque fois qu’elles sont utilisées, elles n’effectuent pas, ainsi que des méthodes analogues dans la <xref:Microsoft.Win32.RegistryKey> (classe), lorsque vous accédez à un grand nombre de valeurs.  
  
 Le <xref:Microsoft.Win32.RegistryKey> classe fournit également des méthodes qui vous permettent de définir la sécurité de contrôle d’accès Windows pour les clés de Registre, de tester le type de données d’une valeur avant de les récupérer et de supprimer des clés.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple illustre les clés racines, et le deuxième exemple illustre la `static` <xref:Microsoft.Win32.Registry.GetValue%2A> et <xref:Microsoft.Win32.Registry.SetValue%2A> méthodes.  
  
 Exemple 1  
  
 L’exemple de code suivant montre comment récupérer les sous-clés de la clé HKEY_USERS et imprimer leurs noms à l’écran. Utilisez le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans `RegistryKey` pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Exemple 2  
  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, création de la clé comme il le fait, puis récupère et affiche les valeurs. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` quand une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit les types (ou classes) de documents ainsi que les propriétés associées à ces types. Ce champ lit la clé de base HKEY_CLASSES_ROOT du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les applications classiques et les applications OLE utilisent les données qui sont stockées sous cette clé. Cette clé fournit également une compatibilité descendante avec la base de données d’inscription Windows 3.1 en stockant des informations pour la prise en charge DDE et OLE. Visionneuses de fichiers et les extensions d’interface utilisateur stockent leurs identificateurs de classe OLE dans cette clé, et les serveurs de traitement sont inscrits dans cette clé.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et imprime leurs noms à l’écran. Utilisez le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient des informations de configuration concernant le matériel qui ne sont pas spécifiques à l'utilisateur. Ce champ lit la clé de base HKEY_CURRENT_CONFIG du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est mappé à une sous-clé dans <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Un exemple d’utilisation de ce membre est une application qui stocke un autre nom de serveur pour ses données en fonction de si le système est attaché à un réseau.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et imprime leurs noms à l’écran. Utilisez le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient les informations relatives aux préférences de l'utilisateur en cours. Ce champ lit la clé de base HKEY_CURRENT_USER du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les informations stockées dans cette clé incluent les paramètres de variables d’environnement et les données sur les groupes de programmes, des couleurs, des imprimantes, des connexions réseau et des préférences de l’application. Cette clé rend plus facile établir des paramètres de l’utilisateur actuel. Dans cette clé, les éditeurs de logiciels stockent les préférences spécifiques à l’utilisateur actuels au sein de leurs applications. Microsoft, par exemple, crée la clé HKEY_CURRENT_USER\Software\Microsoft pour ses applications à utiliser avec chaque application crée sa propre sous-clé sous la clé de Microsoft.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et imprime leurs noms à l’écran. Utilisez le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient les données dynamiques du Registre. Ce champ lit la clé de base HKEY_DYN_DATA du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Registre Windows 98/Windows Me prend en charge des données statiques (qui sont stockées sur le disque dans le Registre) et les données dynamiques (qui changent fréquemment, telles que les statistiques de performances). Cette zone de données dynamiques est le mécanisme qui permet des pilotes de périphériques virtuels (VxDs) pour fournir des données en temps réel aux applications Win32 qui peuvent s’exécuter à distance localement. Il permet également le Moniteur système fournir des statistiques de performances sur les systèmes distants Windows 98/Windows Me.  
  
 VxDs ne sont pas limitées aux données de performances. Ils peuvent fournir des données à passer de l’anneau 0 à l’anneau 3 efficacement sans monopoliser l’UC. Le Registre prend en charge les données dynamiques en stockant un pointeur vers une fonction qui retourne une valeur (ou nombreuses valeurs). Quand un valeurs de requêtes d’appel du Registre associé à une clé dynamique, que la fonction est appelée pour retourner l’ou les valeurs souhaitées.  
  
> [!NOTE]
>  Les clés dynamiques ont été introduites dans Microsoft Windows 95 pour gérer les données dynamiques du Registre. Elles sont prises en charge uniquement sur Windows 98/Windows Me.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et imprime leurs noms à l’écran. Utilisez le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé. Notez que cet exemple peut ne retourner aucun résultat, dans la mesure où il peut-être pas dynamique des données disponibles, ou vous ne s’exécute pas Windows 98 / Me. À l’aide de cette clé peut provoquer une erreur sur d’autres systèmes.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le système d'exploitation ne prend pas en charge les données dynamiques ; autrement dit, il ne s'agit pas de Windows 98, Windows 98 Deuxième Édition ou Windows Millennium (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Chemin de Registre complet de la clé, commençant avec une racine de Registre valide, comme « HKEY_CURRENT_USER ».</param>
        <param name="valueName">Nom de la paire nom/valeur.</param>
        <param name="defaultValue">Valeur à retourner si <paramref name="valueName" /> n'existe pas.</param>
        <summary>Récupère la valeur associée au nom spécifié, dans la clé de Registre spécifiée. Si le nom est introuvable dans la clé spécifiée, retourne une valeur par défaut que vous fournissez ou la valeur <see langword="null" /> si la clé spécifiée n'existe pas.</summary>
        <returns><see langword="null" /> si la sous-clé spécifiée par <paramref name="keyName" /> n'existe pas ; autrement, la valeur associée à <paramref name="valueName" /> ou <paramref name="defaultValue" /> si <paramref name="valueName" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne `valueName` ne respecte pas la casse.  
  
> [!NOTE]
>  Une clé de Registre permettre contenir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour récupérer cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `valuName`.  
  
 Noms de racine valide sont HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG et HKEY_DYN_DATA. Par exemple, la chaîne « HKEY_CURRENT_USER\MyTestKey » accède aux paires clé/valeur pour la sous-clé « MyTestKey » dans la racine HKEY_CURRENT_USER en Visual Basic.  
  
 Lorsque le <xref:Microsoft.Win32.RegistryKey.GetValue%2A> méthode récupère les valeurs de chaîne extensible (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), il développe des chaînes d’environnement à l’aide de données à partir de l’environnement local. Si une valeur contenant des références extensibles aux variables d’environnement a été stockée sous forme de chaîne (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), plutôt que comme une chaîne extensible (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> ne s’étend pas. Vous pouvez développer une telle chaîne après qu’il a été récupéré en appelant le <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> (méthode).  
  
> [!NOTE]
>  La méthode recommandée pour récupérer des données à partir de HKEY_PERFORMANCE_DATA consiste à utiliser le <xref:System.Diagnostics.PerformanceCounter> classe plutôt que <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> (méthode).  
  
 Le <xref:Microsoft.Win32.Registry.GetValue%2A> et <xref:Microsoft.Win32.Registry.SetValue%2A> ouvrent des méthodes et des clés de Registre fermer chaque fois qu’elles sont utilisées, elles n’effectuent pas, ainsi que les méthodes de la <xref:Microsoft.Win32.RegistryKey> classe si vous accédez à un grand nombre de valeurs.  
  
 <xref:Microsoft.Win32.RegistryKey> fournit également des méthodes qui vous permettent d’ajouter une liste de contrôle d’accès (ACL) à une clé de Registre, de tester le type de données d’une valeur avant de les récupérer et de supprimer des clés.  
  
   
  
## Examples  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, création de la clé comme il le fait, puis récupère et affiche les valeurs. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` quand une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire dans la clé de Registre.</exception>
        <exception cref="T:System.IO.IOException"><see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée a été marqué pour suppression.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> ne commence pas par une racine de Registre valide.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour lire à partir du Registre. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour lire une clé de Registre de type REG_EXPAND_SZ. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient les informations de configuration pour l'ordinateur local. Ce champ lit la clé de base HKEY_LOCAL_MACHINE du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` contient cinq clés :  
  
 Matériel  
 Décrit le matériel physique de l’ordinateur, la façon de pilotes de périphériques utilisent ce matériel et les mappages et les données associées qui lient les pilotes en mode noyau avec le code en mode utilisateur. Toutes les données de cette clé est recréé chaque fois que le système est démarré. La sous-clé Description décrit le matériel réel. La sous-clé DeviceMap contient diverses données dans des formats de classes de pilotes spécifiques. La sous-clé ResourceMap décrit les pilotes de périphérique de revendication les ressources matérielles. Le programme de Diagnostics Windows NT (Winmsdp.exe) peut signaler son contenu dans une forme facile à lire.  
  
 SAM  
 La base de données des services de répertoire des informations de sécurité pour les comptes d’utilisateur et groupe et pour les domaines dans Windows 2000 Server (SAM est le Gestionnaire de comptes de sécurité, appelé base de données directory services).  
  
 Sécurité  
 Contient la stratégie de sécurité locale, telles que des droits d’utilisateur spécifiques. Cette clé est utilisée uniquement par le sous-système de sécurité de Windows 2000.  
  
 Logiciels  
 La base de données de logiciels par ordinateur. Cette clé contient des données sur les logiciels installés sur l’ordinateur local, ainsi que divers éléments de données de configuration.  
  
 Système  
 Contrôle le démarrage du système, lors du chargement du pilote de périphérique, Windows 2000 services et comportement du système d’exploitation.  
  
 Par convention, si des données similaires existent sous <xref:Microsoft.Win32.Registry.CurrentUser> et sous <xref:Microsoft.Win32.Registry.LocalMachine>, les données dans <xref:Microsoft.Win32.Registry.CurrentUser> est prioritaire. Toutefois, les valeurs dans cette clé peuvent également étendre (plutôt que remplacer) les données dans Registry.LocalMachine. En outre, certains éléments (tels que le chargement des entrées de pilote de périphérique) sont inutiles s’ils se produisent en dehors de Registry.LocalMachine.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et imprime leurs noms à l’écran. Utilisez le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient des informations sur les performances des composants logiciels. Ce champ lit la clé de base HKEY_PERFORMANCE_DATA du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque composant logiciel crée des clés pour ses objets, les compteurs de lorsqu’il est installé et écrit les données de compteur pendant son exécution. Vous pouvez accéder à ces données comme vous accéderiez toutes les autres données de Registre, à l’aide de la <xref:Microsoft.Win32.RegistryKey> fonctions.  
  
 Bien que vous utilisez le Registre pour collecter des données de performances, les données ne sont pas stockées dans la base de données de Registre. Au lieu de cela, l’accès au Registre avec cette clé entraîne le collecter les données à partir des gestionnaires d’objet système appropriés.  
  
 Pour obtenir les données de performances à partir du système local, utilisez le <xref:Microsoft.Win32.RegistryKey.GetValue%2A> (méthode), avec la clé Registry.PerformanceData. Le premier appel ouvre la clé (il est inutile d’ouvrir explicitement la clé tout d’abord). Toutefois, veillez à utiliser le <xref:Microsoft.Win32.RegistryKey.Close%2A> méthode pour fermer le handle de la clé lorsque vous avez terminé d’obtention de données de performances. L’utilisateur ne peut pas installer ou supprimer un composant logiciel tandis que ses données de performances sont en cours d’utilisation.  
  
 Pour obtenir des données de performances à partir d’un système distant, vous devez utiliser le <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> (méthode), avec le nom d’ordinateur du système distant et la clé Registry.PerformanceData. Cet appel récupère une clé représentant les données de performances pour le système distant. Pour récupérer les données, appelez <xref:Microsoft.Win32.RegistryKey.GetValue%2A> à l’aide de cette clé, au lieu de la clé Registry.PerformanceData.  
  
> [!NOTE]
>  Sur Windows Server 2003, un utilisateur doit appartenir au moins au groupe utilisateurs de l’analyseur performances afin d’accéder aux sous-clés de cette clé de base.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et imprime leurs noms à l’écran. Utilisez le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé. Notez que cet exemple ne peut souvent retourner aucun résultat, dans la mesure où il ne peut y avoir aucune donnée de performances.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit la valeur d'une paire nom/valeur dans une clé de Registre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, création de la clé comme il le fait, puis récupère et affiche les valeurs. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` quand une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Chemin de Registre complet de la clé, commençant avec une racine de Registre valide, comme « HKEY_CURRENT_USER ».</param>
        <param name="valueName">Nom de la paire nom/valeur.</param>
        <param name="value">Valeur à stocker.</param>
        <summary>Définit la paire nom/valeur spécifiée sur la clé de Registre spécifiée. Si la clé spécifiée n'existe pas, elle est créée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le `valueName` paramètre n’est plus limité à un maximum de 255 caractères ; Toutefois, le `keyName` paramètre continue à disposer de la restriction de 255 caractères.  
  
 Nombre de valeurs pouvant être stockées dans chaque clé dans le Registre, vous devez utiliser le `valueName` paramètre pour spécifier la valeur particulière que vous souhaitez définir.  
  
> [!NOTE]
>  Une clé de Registre permettre contenir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour définir cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `valueName`.  
  
 Si `valueName` n’existe pas dans la clé, il est créé et la valeur associée est définie sur `value`.  
  
 Si `keyName` spécifie une sous-clé qui n’existe pas, la sous-clé est créée dans la racine spécifiée. Par exemple, en Visual Basic, la chaîne « HKEY_CURRENT_USER\MyTestKey » crée la sous-clé « MyTestKey » dans la racine HKEY_CURRENT_USER. La chaîne « HKEY_CURRENT_USER\MyTestKey\Key2\Key3 » crée les sous-clés imbriquées « MyTestKey », « MyTestKey\Key2 » et « MyTestKey\Key2\Key3 ».  
  
 Les noms de racine valide inclure HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG et HKEY_DYN_DATA.  
  
> [!NOTE]
>  Le <xref:Microsoft.Win32.Registry.SetValue%2A> méthode ouvre une clé de Registre, définit la valeur et ferme la clé chaque fois qu’elle est appelée. Si vous devez modifier un grand nombre de valeurs, le <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> méthode peut offrir de meilleures performances. Le <xref:Microsoft.Win32.RegistryKey> classe fournit également des méthodes qui vous permettent d’ajouter une liste de contrôle d’accès (ACL) à une clé de Registre, de tester le type de données d’une valeur avant de les récupérer et de supprimer des clés.  
  
 Cette surcharge de <xref:Microsoft.Win32.Registry.SetValue%2A> stocke les entiers 64 bits sous forme de chaînes (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Pour stocker les nombres de 64 bits en tant que <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> valeurs, utilisez le <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> surcharge de méthode.  
  
 Cette surcharge de <xref:Microsoft.Win32.Registry.SetValue%2A> stocke toutes les valeurs de chaîne comme <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> objets, même s’ils contiennent des références extensibles aux variables d’environnement. Pour enregistrer les valeurs de chaîne extensibles comme chaînes (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), utilisez le <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> surcharge de méthode.  
  
 Cette surcharge revient à appeler le <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> surcharge de méthode avec <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sur Windows 98 et Windows Millennium Edition (Windows Me), le Registre n’est pas Unicode, et pas tous les caractères Unicode sont valides pour toutes les pages de code. Un caractère Unicode qui n’est pas valide pour la page de codes actuelle est remplacée par la meilleure correspondance disponible. Aucune exception n'est levée.  
  
   
  
## Examples  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, création de la clé comme il le fait, puis récupère et affiche les valeurs. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` quand une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> ne commence pas par une racine de Registre valide.  
  
ou 
 La longueur de <paramref name="keyName" /> est supérieure à la longueur maximale autorisée (255 caractères).</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> étant en lecture seule, elle n'est pas accessible en écriture ; il s'agit par exemple d'un nœud de niveau racine.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour créer ou modifier des clés de Registre.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour modifier la clé de Registre spécifiée si elle existe, ou pour créer la clé de Registre si elle n’existe pas déjà. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Chemin de Registre complet de la clé, commençant avec une racine de Registre valide, comme « HKEY_CURRENT_USER ».</param>
        <param name="valueName">Nom de la paire nom/valeur.</param>
        <param name="value">Valeur à stocker.</param>
        <param name="valueKind">Type de données de Registre à utiliser lors du stockage des données.</param>
        <summary>Définit la paire nom/valeur sur la clé de Registre spécifiée, à l'aide du type de données de Registre spécifié. Si la clé spécifiée n'existe pas, elle est créée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le `valueName` paramètre n’est plus limité à un maximum de 255 caractères ; Toutefois, le `keyName` paramètre continue la limitation à 255 caractères.  
  
 Nombre de valeurs pouvant être stockées dans chaque clé dans le Registre, vous devez utiliser le `valueName` paramètre pour spécifier la valeur particulière que vous souhaitez définir.  
  
> [!NOTE]
>  Une clé de Registre permettre contenir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour définir cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `valueName`.  
  
 Si `valueName` n’existe pas dans la clé, il est créé et la valeur associée est définie sur `value`.  
  
 Si `keyName` spécifie une sous-clé qui n’existe pas, la sous-clé est créée dans la racine spécifiée. Par exemple, en Visual Basic, la chaîne « HKEY_CURRENT_USER\MyTestKey » crée la sous-clé « MyTestKey » dans la racine HKEY_CURRENT_USER. La chaîne « HKEY_CURRENT_USER\MyTestKey\Key2\Key3 » crée les sous-clés imbriquées « MyTestKey », « MyTestKey\Key2 » et « MyTestKey\Key2\Key3 ».  
  
 Les noms de racine valide inclure HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG et HKEY_DYN_DATA.  
  
> [!NOTE]
>  Le <xref:Microsoft.Win32.Registry.SetValue%2A> méthode ouvre une clé de Registre, définit la valeur et ferme la clé chaque fois qu’elle est appelée. Si vous devez modifier un grand nombre de valeurs, le <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> méthode peut offrir de meilleures performances. Le <xref:Microsoft.Win32.RegistryKey> classe fournit également des méthodes qui vous permettent d’ajouter une liste de contrôle d’accès (ACL) à une clé de Registre, de tester le type de données d’une valeur avant de les récupérer et de supprimer des clés.  
  
 Si le type de l’objet `value` ne correspond pas à spécifié `valueKind`, et les données ne peut pas être converti, <xref:System.ArgumentException> est levée. Par exemple, vous pouvez stocker un <xref:System.Int64?displayProperty=nameWithType> comme un <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, mais uniquement si sa valeur est inférieure à la valeur maximale d’un <xref:System.Int32?displayProperty=nameWithType>. Vous ne pouvez pas stocker une valeur de chaîne unique comme un <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Si des valeurs boxed sont passées pour <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, la conversion s’effectue à l’aide de la culture dite indifférente.  
  
> [!NOTE]
>  Sur Windows 98 et Windows Millennium Edition (Windows Me), le Registre n’est pas Unicode, et pas tous les caractères Unicode sont valides pour toutes les pages de code. Un caractère Unicode qui n’est pas valide pour la page de codes actuelle est remplacée par la meilleure correspondance disponible. Aucune exception n'est levée.  
  
   
  
## Examples  
 L’exemple de code suivant stocke les valeurs de plusieurs types de données dans un exemple de clé, création de la clé comme il le fait, puis récupère et affiche les valeurs. L’exemple illustre le stockage et la récupération de la paire nom/valeur (sans nom) par défaut et l’utilisation de `defaultValue` quand une paire nom/valeur n’existe pas.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> ne commence pas par une racine de Registre valide.  
  
ou 
 La longueur de <paramref name="keyName" /> est supérieure à la longueur maximale autorisée (255 caractères).  
  
ou 
Le type de <paramref name="value" /> ne correspondait pas au type de données de Registre spécifié par <paramref name="valueKind" />, par conséquent les données n'ont pas pu être converties correctement.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> étant en lecture seule, elle n'est pas accessible en écriture ; il s'agit par exemple d'un nœud de niveau racine ou bien la clé n'a pas été ouverte avec un accès en écriture.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour créer ou modifier des clés de Registre.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour modifier la clé de Registre spécifiée si elle existe, ou pour créer la clé de Registre si elle n’existe pas déjà. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient les informations relatives à la configuration utilisateur par défaut. Ce champ lit la clé de base HKEY_USERS du Registre Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette clé contient une branche pour chaque utilisateur de l’ordinateur. La configuration par défaut est fournie pour les nouveaux utilisateurs sur l’ordinateur local et pour l’utilisateur actuel par défaut si l’utilisateur n’a pas changé préférences. Étant donné que Windows 98 / ME prend également en charge Registry.Users, les applications peuvent accéder aux informations spécifiques à l’utilisateur de la même façon que sous Windows 2000. Les informations de chaque utilisateur sont stockées dans un fichier distinct, qui peut être stocké localement ou sur un serveur réseau. Windows 98 / ME peut copier ce fichier pour le système actuel de l’utilisateur afin que les paramètres peuvent déplacer un ordinateur vers un autre avec l’utilisateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les sous-clés de cette clé et imprime leurs noms à l’écran. Utilisez le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour créer une instance de la sous-clé qui vous intéresse. Vous pouvez ensuite utiliser d’autres opérations dans <xref:Microsoft.Win32.RegistryKey> pour manipuler cette clé.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>