<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d99d25be1d24abd932081d3e03fd39286f0da69" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037639" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit l'accès aux notifications d'événements système. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:Microsoft.Win32.SystemEvents> classe fournit la possibilité de répondre à des types spécifiques d’événements système.  
  
 Lorsqu’un événement système est déclenché, les délégués attachés à l’événement sont appelées à l’aide du thread qui surveille les événements système. Par conséquent, vous devez effectuer tous les appels à partir de vos gestionnaires événement thread-safe. Si vous avez besoin d’appeler un événement système qui n’est pas exposé en tant que membre de cette classe, vous pouvez utiliser la <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> (méthode).  
  
> [!CAUTION]
>  N’effectuez pas de traitement du temps sur le thread qui déclenche un gestionnaire d’événements système, car cela pourrait empêcher les autres applications de fonctionner.  
  
> [!NOTE]
>  Certains événements système ne peuvent pas être déclenchés sur [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Veillez à vérifier que votre application fonctionne comme prévu sur [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Cette section contient deux exemples. Le premier exemple montre comment utiliser des événements système dans une application ordinaire, et le deuxième exemple montre comment utiliser des événements système dans un service Windows.  
  
 **Exemple 1**  
  
 L’exemple de code suivant s’intéresse à certains événements système, puis attend que ces événements se produisent. La sortie se produit si l’utilisateur modifie la résolution d’affichage.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Exemple 2**  
  
 L’exemple de code suivant illustre un service Windows très simple qui gère la <xref:Microsoft.Win32.SystemEvents.TimeChanged> et <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> les événements. L’exemple inclut un service nommé `SimpleService`, un formulaire nommé `HiddenForm`et un programme d’installation. Le formulaire fournit la boucle de messages qui est requis par les événements système.  
  
> [!NOTE]
>  Services n’ont pas de boucles de message, sauf s’ils sont autorisés à interagir avec le bureau. Si la boucle de message n’est pas fournie par un formulaire masqué, comme dans cet exemple, le service doit être exécuté sous le compte système local, et une intervention manuelle est requise pour permettre l’interaction avec le bureau. Autrement dit, l’administrateur doit vérifier manuellement la **autoriser le service à interagir avec le bureau** case à cocher sur la **ouvrir une session** onglet de la boîte de dialogue Propriétés du service. Dans ce cas, une boucle de message est automatiquement fournie. Cette option est disponible uniquement lorsque le service est exécuté sous le compte système local. Interaction avec le bureau ne peut pas être activée par programme.  
  
 Dans cet exemple, le service démarre un thread qui exécute une instance de `HiddenForm`. Les événements sont raccordées et gérés dans le formulaire. Les événements doivent être rattachées dans l’événement de chargement du formulaire, pour vous assurer que le formulaire est complètement chargé en premier ; Sinon, les événements ne seront pas déclenchés.  
  
> [!NOTE]
>  L’exemple fournit tout le code nécessaire, y compris le code d’initialisation du formulaire habituellement généré par les concepteurs Visual Studio. Si vous développez votre service dans Visual Studio, vous pouvez omettre la deuxième classe partielle et utiliser la **propriétés** fenêtre pour définir la hauteur et la largeur du formulaire caché à zéro, le style de bordure à <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>et à l’état de fenêtre <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Pour exécuter l’exemple :  
  
1.  Compilez le code à partir de la ligne de commande. Le nom que vous utilisez pour le fichier source n’est pas important.  
  
2.  Installer le service à partir de la ligne de commande à l’aide de la [Installutil.exe (outil Installer)](~/docs/framework/tools/installutil-exe-installer-tool.md) utilitaire. Par exemple, `InstallUtil example.exe` si le nom du fichier source est `example.cs` ou `example.vb`. Vous devez être un administrateur pour installer le service.  
  
3.  Utilisez la console Services pour démarrer le service.  
  
4.  Modifier l’heure système, ou modifier les préférences de l’utilisateur, telles que les propriétés de la souris.  
  
5.  Afficher les messages dans la **Application** catégorie de l’Observateur d’événements.  
  
6.  Utilisez la console Services pour arrêter le service.  
  
7.  Désinstallez le service à partir de la ligne de commande à l’aide de la `/u` option. Par exemple, `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeurs de demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. État associé :</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Spécifie l'intervalle entre des notifications de minuterie, en millisecondes.</param>
        <summary>Crée une nouvelle minuterie de fenêtre associée à la fenêtre d'événements système.</summary>
        <returns>ID de la nouvelle minuterie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">L'intervalle est inférieur ou égal à zéro.</exception>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système ou la tentative de création de la minuterie a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur modifie les paramètres d'affichage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment surveiller le <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> événement. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque les paramètres d'affichage changent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit avant que le thread qui écoute les événements système ne soit terminé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque le thread qui écoute les événements système est sur le point de se terminer. Délégués d’événement système sont appelés à l’aide du thread qui écoute les événements système.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur ajoute des polices au système ou en supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Délégué à appeler à l'aide du thread qui écoute les événements système.</param>
        <summary>Appelle le délégué spécifié à l'aide du thread qui écoute les événements système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode chaque fois que vous avez besoin de gérer un événement système qui n’est pas exposée dans le cas contraire par le <xref:Microsoft.Win32.SystemEvents> classe.  
  
 Lorsque vous appelez cette méthode, le délégué spécifié est appelé par le thread à l’aide de votre application pour traiter les événements système.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">ID de la minuterie à arrêter.</param>
        <summary>Arrête la minuterie spécifiée par l'ID donné.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système ou la tentative d'arrêt de la minuterie a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la mémoire vive devient insuffisante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement encapsule le message WM_COMPACTING. Ce message est envoyé à toutes les fenêtres de niveau supérieur lorsque le système détecte plus de 12,5 % de temps système sur un intervalle de 30 à 60 secondes est consacré à compresser la mémoire. Cela indique que la mémoire système est insuffisante.  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <block subset="none" type="usage">
          <para>Ce message est fourni uniquement pour la compatibilité avec les applications Windows 16 bits.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur bascule vers une application qui utilise une palette différente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment surveiller le <xref:Microsoft.Win32.SystemEvents.PaletteChanged> événement. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur interrompt ou redémarre le système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur ferme une session ou le système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur essaie de fermer une session ou d'arrêter le système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement peut être annulé. Définition de la <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> propriété `true` demande que la session continue de s’exécuter. Il ne garantit pas que la session se terminera pas.  
  
 Si vous utilisez <xref:Microsoft.Win32.SystemEvents.SessionEnding> dans un Windows form pour détecter une fermeture de session ou le redémarrage, il n’existe aucun moyen déterministe de décider si le <xref:System.Windows.Forms.Form.Closing> événement se déclenche avant cet événement.  
  
 Si vous souhaitez effectuer des tâches particulières avant <xref:System.Windows.Forms.Form.Closing> est déclenché, vous devez vous assurer que <xref:Microsoft.Win32.SystemEvents.SessionEnding> se déclenche avant <xref:System.Windows.Forms.Form.Closing>. Pour ce faire, vous devez intercepter le `WM_QUERYENDSESSION` dans l’écran en substituant le `WndProc` (fonction).  Cet exemple montre comment effectuer cette opération.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Les applications console ne déclenchent pas le <xref:Microsoft.Win32.SystemEvents.SessionEnding> événement.  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur actuellement connecté a changé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur modifie l'heure de l'horloge système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit suite à l'expiration d'une minuterie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une préférence utilisateur est modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une préférence utilisateur est modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cet événement est déclenché uniquement si la pompe de messages est en cours d’exécution. Dans un service Windows, sauf si un formulaire masqué est utilisé ou la pompe de messages a été démarrée manuellement, cet événement n’est pas déclenché. Pour obtenir un exemple de code qui montre comment gérer les événements système à l’aide d’un formulaire caché dans un service Windows, consultez la <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Comme il s’agit d’un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, ou entraînent des fuites de mémoire.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment surveiller le <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> événement. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les notifications d'événements système ne sont pas prises en compte dans le contexte actuel. Les processus serveur, par exemple, risquent de ne pas prendre en charge les notifications d'événements système globaux.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">La tentative de création d'un thread de fenêtre des événements système a échoué.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>