<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de7a53beeda19e530806d2978aadf945a5d39e91" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52247539" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indique que la méthode avec attributs est exposée par une bibliothèque de liens dynamiques (DLL) non managée comme point d'entrée statique.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez appliquer cet attribut aux méthodes.  
  
 Le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut fournit les informations nécessaires pour appeler une fonction exportée à partir d’une DLL non managée. Au minimum, vous devez fournir le nom de la DLL contenant le point d’entrée.  
  
 Vous appliquez cet attribut directement à c# et définitions de la méthode C++ ; Toutefois, le compilateur Visual Basic émet cet attribut lorsque vous utilisez la `Declare` instruction. Pour les définitions de méthode complexe qui incluent <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, ou <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champs, vous appliquez cet attribut directement à des définitions de méthode Visual Basic.  
  
 **Remarque** JScript ne prend pas en charge cet attribut. Vous pouvez utiliser c# ou Visual Basic des classes wrapper pour accéder aux méthodes d’API non managées à partir de programmes JScript.  
  
 Pour plus d’informations sur l’utilisation de la plateforme appeler le service pour accéder aux fonctions dans des DLL non managées, consultez [consommation de fonctions DLL non managées](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  Le <xref:System.Runtime.InteropServices.DllImportAttribute> ne prend pas en charge le marshaling de types génériques.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut importer Win32 `MessageBox` (fonction).  L’exemple de code appelle ensuite la méthode importée.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nom de la DLL contenant la méthode non managée. Cela peut inclure le nom complet d'un assembly, si la DLL est incluse dans un assembly.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> avec le nom de la DLL contenant la méthode à importer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un fichier DLL non managé est inclus dans un assembly, par exemple, à l’aide de l’éditeur de liens ou le `/linkresource` option du compilateur, vous pouvez spécifier le nom complet d’assembly dans le cadre de `dllName`. Par exemple, si une DLL non managée nommée `unmanaged.dll` est inclus dans un assembly managé nommé `MyAssembly`, l’attribut peut être spécifié comme indiqué dans le code suivant.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut importer Win32 `MessageBox` (fonction).  L’exemple de code appelle ensuite la méthode importée.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Active ou désactive le comportement de mappage ajusté lors de la conversion de caractères Unicode en caractères ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `true`, ajusté comportement de mappage est activée ; sinon, il est désactivé. Le <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> champ est `true` par défaut. Paramètres pour ce champ remplacent les paramètres de n’importe quel niveau pour le <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attribut.  
  
 Le common language runtime convertit en caractères ANSI que tous les caractères Unicode passés à une méthode non managée qui s’exécute sur Windows 98 ou Windows Me. managés Le mappage ajusté permet le marshaleur d’interopérabilité fournir un caractère de correspondance proche lorsqu’il n’existe aucune correspondance exacte. Par exemple, le marshaleur convertit le caractère de copyright Unicode à « c » pour les méthodes non managées qui acceptent des caractères ANSI. Certains caractères ne disposent pas d’une représentation ajustée ; ces caractères sont appelés mappables. Caractères non mappables sont généralement convertis en la valeur par défaut ' ?' Caractère ANSI.  
  
> [!CAUTION]
>  Certains caractères Unicode sont convertis en caractères dangereuses, telles que la barre oblique inverse '\\' caractère, qui peut modifier par inadvertance un chemin d’accès. En définissant le <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champ `true`, vous pouvez indiquer la présence d’un caractère non mappable à l’appelant en levant une exception.  
  
> [!CAUTION]
>  Vous ne pouvez pas modifier les valeurs par défaut fournies par le <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> et <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champs lorsque le passage d’un tableau managé dont les éléments est des caractères ANSI ou des LPSTR à un tableau sécurisé non managé. Le mappage ajusté est toujours activé et aucune exception n’est levée. N’oubliez pas que cette combinaison peut compromettre votre modèle de sécurité.  
  
   
  
## Examples  
 Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu du `Declare` instruction, pour définir une fonction DLL dans du code managé. Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> champ est un de ces cas. L’exemple suivant montre comment appliquer le plus strict sécurité de mappage de caractères à une plateforme appeler des définitions de méthode en spécifiant le jeu de caractères ANSI, la désactivation du comportement de mappage ajusté et lever une exception sur des caractères Unicode non mappés.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Marshaling d’interopérabilité</related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique la convention d'appel d'un point d'entrée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous définissez ce champ à un de le <xref:System.Runtime.InteropServices.CallingConvention> membres de l’énumération. La valeur par défaut pour le <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> champ est <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, qui à son tour utilise par défaut <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convention.  
  
 Pour plus d’informations, consultez Convention d’appel dans MSDN library.  
  
   
  
## Examples  
 Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu du `Declare` instruction, pour définir une fonction DLL dans du code managé. Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> champ est un de ces cas.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique comment marshaler les paramètres de chaîne vers la méthode et contrôle la composition des noms.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce champ avec un membre de la <xref:System.Runtime.InteropServices.CharSet> énumération pour spécifier le comportement de marshaling des paramètres de chaîne et préciser le nom de point d’entrée à appeler (le nom exact attribué ou un nom se terminant par « A » ou « W »). Le membre d’énumération par défaut pour c# et Visual Basic est `CharSet.Ansi` et le membre d’énumération par défaut pour C++ est `CharSet.None`, ce qui équivaut à `CharSet.Ansi`. Dans Visual Basic, vous utilisez le `Declare` instruction pour spécifier le `CharSet` champ.  
  
 Le <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> champ influence le comportement de la `CharSet` champ déterminer quel nom de point d’entrée à appeler. Pour obtenir une description détaillée et des exemples du marshaling des chaînes et correspondance comportement associé à la `CharSet` champ, consultez [spécifiant un jeu de caractères](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut importer Win32 `MessageBox` (fonction).  L’exemple de code appelle ensuite la méthode importée.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique le nom ou le numéro du point d'entrée de DLL à appeler.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez spécifier le nom de point d’entrée en fournissant une chaîne indiquant le nom de la DLL contenant le point d’entrée, ou vous pouvez identifier le point d’entrée par son ordinal. Les ordinaux sont précédés du signe #, par exemple, #1. Si vous omettez ce champ, le common language runtime utilise le nom de méthode.NET marqué avec le <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Pour plus d’informations, consultez [identifiant les fonctions des DLL](~/docs/framework/interop/identifying-functions-in-dlls.md). Pour obtenir des exemples montrant comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> champ, consultez [en spécifiant un Point d’entrée](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut importer Win32 `MessageBox` (fonction).  L’exemple de code utilise le <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> propriété pour spécifier la fonction à importer, puis modifie le nom à `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contrôle si le champ <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> déclenche la recherche de noms, par le Common Language Runtime, de points d'entrée autres que celui spécifié dans la DLL non managée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `false`, le nom de point d’entrée ajouté par la lettre A est appelé lorsque le <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> champ est défini sur `CharSet.Ansi`, et le nom de point d’entrée ajouté par la lettre W est appelé lorsque le <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> champ est défini sur le `CharSet.Unicode`. En règle générale, les compilateurs managés définissent ce champ.  
  
 Le tableau suivant montre la relation entre la <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> et <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> champs, en fonction des valeurs par défaut imposées par le langage de programmation. Vous pouvez remplacer le paramètre par défaut, mais avec précaution.  
  
|Langue|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling : = True|ExactSpelling : = True|ExactSpelling:=False|  
|C#|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
|C++|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
  
   
  
## Examples  
 Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu d’utiliser la `Declare` instruction, pour définir une fonction DLL dans du code managé. Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> champ est un de ces cas.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si les méthodes non managées qui ont les valeurs de retour <see langword="HRESULT" /> ou <see langword="retval" /> sont traduites directement ou si les valeurs de retour <see langword="HRESULT" /> ou <see langword="retval" /> sont automatiquement converties en exceptions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ `true` permet de traduire directement les signatures non gérées avec `HRESULT` ou `retval` valeurs ; affectez-lui `false` convertir automatiquement `HRESULT` ou `retval` valeurs aux exceptions. Par défaut, le <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ est `true`.  
  
 Lorsque `true`, la signature de méthode résultante retourne une valeur entière qui contient le `HRESULT` valeur.  Dans ce cas, vous devez manuellement inspecter la valeur de retour et réagir en conséquence dans votre application.  
  
 Lorsque vous définissez la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ `false`, la signature de méthode résultante contient un type de retour void au lieu d’un entier (`HRESULT`) type de retour.  Quand la méthode non managée produit un `HRESULT`, le runtime ignore automatiquement une valeur de retour de `S_OK` (ou 0) et ne lève pas d’exception.  Pour `HRESULT`autres que `S_OK`, le runtime levait automatiquement une exception qui correspond à la `HRESULT`.  Notez que le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut effectue uniquement cette conversion pour les méthodes qui retournent un `HRESULT`.  
  
 Vous pouvez décider de modifier le comportement de rapport d’erreurs par défaut `HRESULT`s aux exceptions dans les cas où des exceptions conviennent mieux à la structure de votre application de signalement d’erreurs.  
  
 Ce champ est similaire à la <xref:System.Runtime.InteropServices.PreserveSigAttribute>; Toutefois, contrairement à la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ, la valeur par défaut pour l’attribut est `false`.  
  
 Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu d’utiliser la `Declare` instruction, pour définir une fonction DLL dans du code managé. Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ est un de ces cas.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Runtime.InteropServices.DllImportAttribute> pour importer non managée `SHAutoComplete` fonction une fois avec le <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ la valeur `true` et à nouveau avec le <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ la valeur `false`.  L’exemple de code suivant génère le `SHAutoComplete` fonction permettant de générer des erreurs avec une exception une fois et une `HRESULT` suivant.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si l'appelé appelle la fonction API Win32 <see langword="SetLastError" /> avant de retourner la valeur à partir de la méthode avec attributs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` pour indiquer que l’appelé appellera `SetLastError`; sinon, `false`. La valeur par défaut est `false`.  
  
 Le marshaleur runtime appelle `GetLastError` et met en cache la valeur retournée pour l’empêcher d’être remplacé par d’autres appels d’API. Vous pouvez récupérer le code d’erreur en appelant <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu d’utiliser la `Declare` instruction, pour définir une fonction DLL dans du code managé. Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> champ est un de ces cas.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Active ou désactive la levée d'une exception sur un caractère Unicode non mappable converti en caractère ANSI "?".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` pour indiquer qu’une exception est levée chaque fois que le marshaleur d’interopérabilité convertit un caractère non mappable ; `false` pour indiquer que le <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champ est désactivé. Ce champ est `false` par défaut.  
  
 Le common language runtime convertit en caractères ANSI que tous les caractères Unicode passés à une méthode non managée qui s’exécute sur Windows 98 ou Windows Me. managés Le mappage ajusté permet le marshaleur d’interopérabilité fournir un caractère de correspondance proche lorsqu’il n’existe aucune correspondance exacte. Par exemple, le marshaleur convertit le caractère de copyright Unicode à « c » pour les méthodes non managées qui acceptent des caractères ANSI. Certains caractères ne disposent pas d’une représentation ajustée ; ces caractères sont appelés mappables. Caractères non mappables sont généralement convertis en la valeur par défaut ' ?' Caractère ANSI.  
  
> [!CAUTION]
>  Certains caractères Unicode sont convertis en caractères dangereuses, telles que la barre oblique inverse '\\' caractère, qui peut modifier par inadvertance un chemin d’accès. En définissant le <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champ `true`, vous pouvez indiquer la présence d’un caractère non mappable à l’appelant en levant une exception.  
  
> [!CAUTION]
>  Vous ne pouvez pas modifier les valeurs par défaut fournies par le <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> et <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champs lorsque le passage d’un tableau managé dont les éléments est des caractères ANSI ou des LPSTR à un tableau sécurisé non managé. Le mappage ajusté est toujours activé et aucune exception n’est levée. N’oubliez pas que cette combinaison peut compromettre votre modèle de sécurité.  
  
   
  
## Examples  
 Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute> pour définir une fonction DLL en code managé, au lieu d’utiliser la `Declare` instruction. Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champ est un de ces cas. L’exemple suivant montre comment appliquer le plus strict sécurité de mappage de caractères à une plateforme appeler des définitions de méthode en spécifiant le jeu de caractères ANSI, la désactivation du comportement de mappage ajusté et lever une exception sur des caractères Unicode non mappés.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Marshaling d’interopérabilité</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom du fichier DLL contenant le point d'entrée.</summary>
        <value>Nom du fichier DLL contenant le point d'entrée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez fournir un chemin d’accès complet ou relatif. Si vous ne fournissez aucun chemin d’accès, la DLL doit être dans le chemin d’accès actuel au moment de l’exécution, sauf si la DLL est chargée par d’autres moyens. Sachez, toutefois, qu’à l’aide d’un chemin d’accès qualifié complet peut introduire imprécision si la DLL est déplacée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>