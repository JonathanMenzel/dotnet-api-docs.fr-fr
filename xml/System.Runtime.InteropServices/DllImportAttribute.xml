<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="de7a53beeda19e530806d2978aadf945a5d39e91" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52247539" /></Metadata><TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e5b46-101">Indique que la méthode avec attributs est exposée par une bibliothèque de liens dynamiques (DLL) non managée comme point d'entrée statique.</span><span class="sxs-lookup"><span data-stu-id="e5b46-101">Indicates that the attributed method is exposed by an unmanaged dynamic-link library (DLL) as a static entry point.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-102">Vous pouvez appliquer cet attribut aux méthodes.</span><span class="sxs-lookup"><span data-stu-id="e5b46-102">You can apply this attribute to methods.</span></span>  
  
 <span data-ttu-id="e5b46-103">Le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut fournit les informations nécessaires pour appeler une fonction exportée à partir d’une DLL non managée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-103">The <xref:System.Runtime.InteropServices.DllImportAttribute> attribute provides the information needed to call a function exported from an unmanaged DLL.</span></span> <span data-ttu-id="e5b46-104">Au minimum, vous devez fournir le nom de la DLL contenant le point d’entrée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-104">As a minimum requirement, you must supply the name of the DLL containing the entry point.</span></span>  
  
 <span data-ttu-id="e5b46-105">Vous appliquez cet attribut directement à c# et définitions de la méthode C++ ; Toutefois, le compilateur Visual Basic émet cet attribut lorsque vous utilisez la `Declare` instruction.</span><span class="sxs-lookup"><span data-stu-id="e5b46-105">You apply this attribute directly to C# and C++ method definitions; however, the Visual Basic compiler emits this attribute when you use the `Declare` statement.</span></span> <span data-ttu-id="e5b46-106">Pour les définitions de méthode complexe qui incluent <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, ou <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champs, vous appliquez cet attribut directement à des définitions de méthode Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e5b46-106">For complex method definitions that include <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, or <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields, you apply this attribute directly to Visual Basic method definitions.</span></span>  
  
 <span data-ttu-id="e5b46-107">**Remarque** JScript ne prend pas en charge cet attribut.</span><span class="sxs-lookup"><span data-stu-id="e5b46-107">**Note** JScript does not support this attribute.</span></span> <span data-ttu-id="e5b46-108">Vous pouvez utiliser c# ou Visual Basic des classes wrapper pour accéder aux méthodes d’API non managées à partir de programmes JScript.</span><span class="sxs-lookup"><span data-stu-id="e5b46-108">You can use C# or Visual Basic wrapper classes to access unmanaged API methods from JScript programs.</span></span>  
  
 <span data-ttu-id="e5b46-109">Pour plus d’informations sur l’utilisation de la plateforme appeler le service pour accéder aux fonctions dans des DLL non managées, consultez [consommation de fonctions DLL non managées](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span><span class="sxs-lookup"><span data-stu-id="e5b46-109">For additional information about using the platform invoke service to access functions in unmanaged DLLs, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e5b46-110">Le <xref:System.Runtime.InteropServices.DllImportAttribute> ne prend pas en charge le marshaling de types génériques.</span><span class="sxs-lookup"><span data-stu-id="e5b46-110">The <xref:System.Runtime.InteropServices.DllImportAttribute> does not support marshaling of generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-111">L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut importer Win32 `MessageBox` (fonction).</span><span class="sxs-lookup"><span data-stu-id="e5b46-111">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="e5b46-112">L’exemple de code appelle ensuite la méthode importée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-112">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName"><span data-ttu-id="e5b46-113">Nom de la DLL contenant la méthode non managée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-113">The name of the DLL that contains the unmanaged method.</span></span> <span data-ttu-id="e5b46-114">Cela peut inclure le nom complet d'un assembly, si la DLL est incluse dans un assembly.</span><span class="sxs-lookup"><span data-stu-id="e5b46-114">This can include an assembly display name, if the DLL is included in an assembly.</span></span></param>
        <summary><span data-ttu-id="e5b46-115">Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> avec le nom de la DLL contenant la méthode à importer.</span><span class="sxs-lookup"><span data-stu-id="e5b46-115">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> class with the name of the DLL containing the method to import.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-116">Si un fichier DLL non managé est inclus dans un assembly, par exemple, à l’aide de l’éditeur de liens ou le `/linkresource` option du compilateur, vous pouvez spécifier le nom complet d’assembly dans le cadre de `dllName`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-116">If an unmanaged DLL file is included in an assembly, for example, by using the linker or the `/linkresource` compiler option, you can specify the assembly display name as part of `dllName`.</span></span> <span data-ttu-id="e5b46-117">Par exemple, si une DLL non managée nommée `unmanaged.dll` est inclus dans un assembly managé nommé `MyAssembly`, l’attribut peut être spécifié comme indiqué dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="e5b46-117">For example, if an unmanaged DLL named `unmanaged.dll` is included in a managed assembly named `MyAssembly`, the attribute might be specified as shown in the following code.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-118">L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut importer Win32 `MessageBox` (fonction).</span><span class="sxs-lookup"><span data-stu-id="e5b46-118">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="e5b46-119">L’exemple de code appelle ensuite la méthode importée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-119">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-120">Active ou désactive le comportement de mappage ajusté lors de la conversion de caractères Unicode en caractères ANSI.</span><span class="sxs-lookup"><span data-stu-id="e5b46-120">Enables or disables best-fit mapping behavior when converting Unicode characters to ANSI characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-121">Si `true`, ajusté comportement de mappage est activée ; sinon, il est désactivé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-121">If `true`, best-fit mapping behavior is enabled; otherwise, best-fit mapping is disabled.</span></span> <span data-ttu-id="e5b46-122">Le <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> champ est `true` par défaut.</span><span class="sxs-lookup"><span data-stu-id="e5b46-122">The <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> field is `true` by default.</span></span> <span data-ttu-id="e5b46-123">Paramètres pour ce champ remplacent les paramètres de n’importe quel niveau pour le <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attribut.</span><span class="sxs-lookup"><span data-stu-id="e5b46-123">Settings for this field override the any level settings for the <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attribute.</span></span>  
  
 <span data-ttu-id="e5b46-124">Le common language runtime convertit en caractères ANSI que tous les caractères Unicode passés à une méthode non managée qui s’exécute sur Windows 98 ou Windows Me. managés</span><span class="sxs-lookup"><span data-stu-id="e5b46-124">The common language runtime converts to ANSI characters any managed Unicode characters passed to an unmanaged method executing on Windows 98 or Windows Me.</span></span> <span data-ttu-id="e5b46-125">Le mappage ajusté permet le marshaleur d’interopérabilité fournir un caractère de correspondance proche lorsqu’il n’existe aucune correspondance exacte.</span><span class="sxs-lookup"><span data-stu-id="e5b46-125">Best-fit mapping enables the interop marshaler to provide a close-matching character when no exact match exists.</span></span> <span data-ttu-id="e5b46-126">Par exemple, le marshaleur convertit le caractère de copyright Unicode à « c » pour les méthodes non managées qui acceptent des caractères ANSI.</span><span class="sxs-lookup"><span data-stu-id="e5b46-126">For example, the marshaler converts the Unicode copyright character to 'c' for unmanaged methods that accept ANSI characters.</span></span> <span data-ttu-id="e5b46-127">Certains caractères ne disposent pas d’une représentation ajustée ; ces caractères sont appelés mappables.</span><span class="sxs-lookup"><span data-stu-id="e5b46-127">Some characters lack a best-fit representation; these characters are called unmappable.</span></span> <span data-ttu-id="e5b46-128">Caractères non mappables sont généralement convertis en la valeur par défaut ' ?' Caractère ANSI.</span><span class="sxs-lookup"><span data-stu-id="e5b46-128">Unmappable characters are usually converted to the default '?' ANSI character.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e5b46-129">Certains caractères Unicode sont convertis en caractères dangereuses, telles que la barre oblique inverse '\\' caractère, qui peut modifier par inadvertance un chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="e5b46-129">Certain Unicode characters are converted to dangerous characters, such as the backslash '\\' character, which can inadvertently change a path.</span></span> <span data-ttu-id="e5b46-130">En définissant le <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champ `true`, vous pouvez indiquer la présence d’un caractère non mappable à l’appelant en levant une exception.</span><span class="sxs-lookup"><span data-stu-id="e5b46-130">By setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field to `true`, you can signal the presence of an unmappable character to the caller by throwing an exception.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e5b46-131">Vous ne pouvez pas modifier les valeurs par défaut fournies par le <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> et <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champs lorsque le passage d’un tableau managé dont les éléments est des caractères ANSI ou des LPSTR à un tableau sécurisé non managé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-131">You cannot change the default values provided by the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> and <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields when passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged safe array.</span></span> <span data-ttu-id="e5b46-132">Le mappage ajusté est toujours activé et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-132">Best-fit mapping is always enabled and no exception is thrown.</span></span> <span data-ttu-id="e5b46-133">N’oubliez pas que cette combinaison peut compromettre votre modèle de sécurité.</span><span class="sxs-lookup"><span data-stu-id="e5b46-133">Be aware that this combination can compromise your security model.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-134">Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu du `Declare` instruction, pour définir une fonction DLL dans du code managé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-134">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="e5b46-135">Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> champ est un de ces cas.</span><span class="sxs-lookup"><span data-stu-id="e5b46-135">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> field is one of those cases.</span></span> <span data-ttu-id="e5b46-136">L’exemple suivant montre comment appliquer le plus strict sécurité de mappage de caractères à une plateforme appeler des définitions de méthode en spécifiant le jeu de caractères ANSI, la désactivation du comportement de mappage ajusté et lever une exception sur des caractères Unicode non mappés.</span><span class="sxs-lookup"><span data-stu-id="e5b46-136">The following example shows how to apply the strictest character mapping security to a platform invoke method definitions by specifying the ANSI character set, disabling best fit mapping behavior, and throwing an exception on unmapped Unicode characters.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a"><span data-ttu-id="e5b46-137">Marshaling d’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="e5b46-137">Interop Marshaling</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-138">Indique la convention d'appel d'un point d'entrée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-138">Indicates the calling convention of an entry point.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-139">Vous définissez ce champ à un de le <xref:System.Runtime.InteropServices.CallingConvention> membres de l’énumération.</span><span class="sxs-lookup"><span data-stu-id="e5b46-139">You set this field to one of the <xref:System.Runtime.InteropServices.CallingConvention> enumeration members.</span></span> <span data-ttu-id="e5b46-140">La valeur par défaut pour le <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> champ est <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, qui à son tour utilise par défaut <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convention.</span><span class="sxs-lookup"><span data-stu-id="e5b46-140">The default value for the <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> field is <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, which in turn defaults to <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convention.</span></span>  
  
 <span data-ttu-id="e5b46-141">Pour plus d’informations, consultez Convention d’appel dans MSDN library.</span><span class="sxs-lookup"><span data-stu-id="e5b46-141">For more information, see Calling Convention in the MSDN library.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-142">Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu du `Declare` instruction, pour définir une fonction DLL dans du code managé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-142">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="e5b46-143">Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> champ est un de ces cas.</span><span class="sxs-lookup"><span data-stu-id="e5b46-143">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> field is one of those cases.</span></span>  
  
 <span data-ttu-id="e5b46-144">System.Runtime.InteropServices.DllImportAttribute#1</span><span class="sxs-lookup"><span data-stu-id="e5b46-144">System.Runtime.InteropServices.DllImportAttribute#1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-145">Indique comment marshaler les paramètres de chaîne vers la méthode et contrôle la composition des noms.</span><span class="sxs-lookup"><span data-stu-id="e5b46-145">Indicates how to marshal string parameters to the method and controls name mangling.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-146">Utilisez ce champ avec un membre de la <xref:System.Runtime.InteropServices.CharSet> énumération pour spécifier le comportement de marshaling des paramètres de chaîne et préciser le nom de point d’entrée à appeler (le nom exact attribué ou un nom se terminant par « A » ou « W »).</span><span class="sxs-lookup"><span data-stu-id="e5b46-146">Use this field with a member of the <xref:System.Runtime.InteropServices.CharSet> enumeration to specify the marshaling behavior of string parameters and to specify which entry-point name to invoke (the exact name given or a name ending with "A" or "W").</span></span> <span data-ttu-id="e5b46-147">Le membre d’énumération par défaut pour c# et Visual Basic est `CharSet.Ansi` et le membre d’énumération par défaut pour C++ est `CharSet.None`, ce qui équivaut à `CharSet.Ansi`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-147">The default enumeration member for C# and Visual Basic is `CharSet.Ansi` and the default enumeration member for C++ is `CharSet.None`, which is equivalent to `CharSet.Ansi`.</span></span> <span data-ttu-id="e5b46-148">Dans Visual Basic, vous utilisez le `Declare` instruction pour spécifier le `CharSet` champ.</span><span class="sxs-lookup"><span data-stu-id="e5b46-148">In Visual Basic, you use the `Declare` statement to specify the `CharSet` field.</span></span>  
  
 <span data-ttu-id="e5b46-149">Le <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> champ influence le comportement de la `CharSet` champ déterminer quel nom de point d’entrée à appeler.</span><span class="sxs-lookup"><span data-stu-id="e5b46-149">The <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> field influences the behavior of the `CharSet` field in determining which entry-point name to invoke.</span></span> <span data-ttu-id="e5b46-150">Pour obtenir une description détaillée et des exemples du marshaling des chaînes et correspondance comportement associé à la `CharSet` champ, consultez [spécifiant un jeu de caractères](~/docs/framework/interop/specifying-a-character-set.md).</span><span class="sxs-lookup"><span data-stu-id="e5b46-150">For a detailed description and examples of the string marshaling and name matching behavior associated with the `CharSet` field, see [Specifying a Character Set](~/docs/framework/interop/specifying-a-character-set.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-151">L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut importer Win32 `MessageBox` (fonction).</span><span class="sxs-lookup"><span data-stu-id="e5b46-151">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="e5b46-152">L’exemple de code appelle ensuite la méthode importée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-152">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-153">Indique le nom ou le numéro du point d'entrée de DLL à appeler.</span><span class="sxs-lookup"><span data-stu-id="e5b46-153">Indicates the name or ordinal of the DLL entry point to be called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-154">Vous pouvez spécifier le nom de point d’entrée en fournissant une chaîne indiquant le nom de la DLL contenant le point d’entrée, ou vous pouvez identifier le point d’entrée par son ordinal.</span><span class="sxs-lookup"><span data-stu-id="e5b46-154">You can specify the entry-point name by supplying a string indicating the name of the DLL containing the entry point, or you can identify the entry point by its ordinal.</span></span> <span data-ttu-id="e5b46-155">Les ordinaux sont précédés du signe #, par exemple, #1.</span><span class="sxs-lookup"><span data-stu-id="e5b46-155">Ordinals are prefixed with the # sign, for example, #1.</span></span> <span data-ttu-id="e5b46-156">Si vous omettez ce champ, le common language runtime utilise le nom de méthode.NET marqué avec le <xref:System.Runtime.InteropServices.DllImportAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e5b46-156">If you omit this field, the common language runtime uses the name of the.NET method marked with the <xref:System.Runtime.InteropServices.DllImportAttribute>.</span></span>  
  
 <span data-ttu-id="e5b46-157">Pour plus d’informations, consultez [identifiant les fonctions des DLL](~/docs/framework/interop/identifying-functions-in-dlls.md).</span><span class="sxs-lookup"><span data-stu-id="e5b46-157">For additional information, see [Identifying Functions in DLLs](~/docs/framework/interop/identifying-functions-in-dlls.md).</span></span> <span data-ttu-id="e5b46-158">Pour obtenir des exemples montrant comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> champ, consultez [en spécifiant un Point d’entrée](~/docs/framework/interop/specifying-an-entry-point.md).</span><span class="sxs-lookup"><span data-stu-id="e5b46-158">For examples showing how to use the <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> field, see [Specifying an Entry Point](~/docs/framework/interop/specifying-an-entry-point.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-159">L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut importer Win32 `MessageBox` (fonction).</span><span class="sxs-lookup"><span data-stu-id="e5b46-159">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="e5b46-160">L’exemple de code utilise le <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> propriété pour spécifier la fonction à importer, puis modifie le nom à `MyNewMessageBoxMethod`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-160">The code example uses the <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> property to specify the function to import and then changes the name to `MyNewMessageBoxMethod`.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-161">Contrôle si le champ <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> déclenche la recherche de noms, par le Common Language Runtime, de points d'entrée autres que celui spécifié dans la DLL non managée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-161">Controls whether the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> field causes the common language runtime to search an unmanaged DLL for entry-point names other than the one specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-162">Si `false`, le nom de point d’entrée ajouté par la lettre A est appelé lorsque le <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> champ est défini sur `CharSet.Ansi`, et le nom de point d’entrée ajouté par la lettre W est appelé lorsque le <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> champ est défini sur le `CharSet.Unicode`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-162">If `false`, the entry point name appended with the letter A is invoked when the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> field is set to `CharSet.Ansi`, and the entry-point name appended with the letter W is invoked when the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> field is set to the `CharSet.Unicode`.</span></span> <span data-ttu-id="e5b46-163">En règle générale, les compilateurs managés définissent ce champ.</span><span class="sxs-lookup"><span data-stu-id="e5b46-163">Typically, managed compilers set this field.</span></span>  
  
 <span data-ttu-id="e5b46-164">Le tableau suivant montre la relation entre la <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> et <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> champs, en fonction des valeurs par défaut imposées par le langage de programmation.</span><span class="sxs-lookup"><span data-stu-id="e5b46-164">The following table shows the relationship between the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> and <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> fields, based on default values imposed by the programming language.</span></span> <span data-ttu-id="e5b46-165">Vous pouvez remplacer le paramètre par défaut, mais avec précaution.</span><span class="sxs-lookup"><span data-stu-id="e5b46-165">You can override the default setting, but do so with caution.</span></span>  
  
|<span data-ttu-id="e5b46-166">Langue</span><span class="sxs-lookup"><span data-stu-id="e5b46-166">Language</span></span>|<span data-ttu-id="e5b46-167">ANSI</span><span class="sxs-lookup"><span data-stu-id="e5b46-167">ANSI</span></span>|<span data-ttu-id="e5b46-168">Unicode</span><span class="sxs-lookup"><span data-stu-id="e5b46-168">Unicode</span></span>|<span data-ttu-id="e5b46-169">Auto</span><span class="sxs-lookup"><span data-stu-id="e5b46-169">Auto</span></span>|  
|--------------|----------|-------------|----------|  
|<span data-ttu-id="e5b46-170">Visual Basic</span><span class="sxs-lookup"><span data-stu-id="e5b46-170">Visual Basic</span></span>|<span data-ttu-id="e5b46-171">ExactSpelling : = True</span><span class="sxs-lookup"><span data-stu-id="e5b46-171">ExactSpelling:=True</span></span>|<span data-ttu-id="e5b46-172">ExactSpelling : = True</span><span class="sxs-lookup"><span data-stu-id="e5b46-172">ExactSpelling:=True</span></span>|<span data-ttu-id="e5b46-173">ExactSpelling:=False</span><span class="sxs-lookup"><span data-stu-id="e5b46-173">ExactSpelling:=False</span></span>|  
|<span data-ttu-id="e5b46-174">C#</span><span class="sxs-lookup"><span data-stu-id="e5b46-174">C#</span></span>|<span data-ttu-id="e5b46-175">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="e5b46-175">ExactSpelling=false</span></span>|<span data-ttu-id="e5b46-176">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="e5b46-176">ExactSpelling=false</span></span>|<span data-ttu-id="e5b46-177">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="e5b46-177">ExactSpelling=false</span></span>|  
|<span data-ttu-id="e5b46-178">C++</span><span class="sxs-lookup"><span data-stu-id="e5b46-178">C++</span></span>|<span data-ttu-id="e5b46-179">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="e5b46-179">ExactSpelling=false</span></span>|<span data-ttu-id="e5b46-180">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="e5b46-180">ExactSpelling=false</span></span>|<span data-ttu-id="e5b46-181">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="e5b46-181">ExactSpelling=false</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-182">Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu d’utiliser la `Declare` instruction, pour définir une fonction DLL dans du code managé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-182">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="e5b46-183">Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> champ est un de ces cas.</span><span class="sxs-lookup"><span data-stu-id="e5b46-183">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> field is one of those cases.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-184">Indique si les méthodes non managées qui ont les valeurs de retour <see langword="HRESULT" /> ou <see langword="retval" /> sont traduites directement ou si les valeurs de retour <see langword="HRESULT" /> ou <see langword="retval" /> sont automatiquement converties en exceptions.</span><span class="sxs-lookup"><span data-stu-id="e5b46-184">Indicates whether unmanaged methods that have <see langword="HRESULT" /> or <see langword="retval" /> return values are directly translated or whether <see langword="HRESULT" /> or <see langword="retval" /> return values are automatically converted to exceptions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-185">Définir le <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ `true` permet de traduire directement les signatures non gérées avec `HRESULT` ou `retval` valeurs ; affectez-lui `false` convertir automatiquement `HRESULT` ou `retval` valeurs aux exceptions.</span><span class="sxs-lookup"><span data-stu-id="e5b46-185">Set the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field to `true` to directly translate unmanaged signatures with `HRESULT` or `retval` values; set it to `false` to automatically convert `HRESULT` or `retval` values to exceptions.</span></span> <span data-ttu-id="e5b46-186">Par défaut, le <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ est `true`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-186">By default, the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field is `true`.</span></span>  
  
 <span data-ttu-id="e5b46-187">Lorsque `true`, la signature de méthode résultante retourne une valeur entière qui contient le `HRESULT` valeur.</span><span class="sxs-lookup"><span data-stu-id="e5b46-187">When `true`, the resulting method signature returns an integer value that contains the `HRESULT` value.</span></span>  <span data-ttu-id="e5b46-188">Dans ce cas, vous devez manuellement inspecter la valeur de retour et réagir en conséquence dans votre application.</span><span class="sxs-lookup"><span data-stu-id="e5b46-188">In this case, you must manually inspect the return value and respond accordingly in your application.</span></span>  
  
 <span data-ttu-id="e5b46-189">Lorsque vous définissez la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ `false`, la signature de méthode résultante contient un type de retour void au lieu d’un entier (`HRESULT`) type de retour.</span><span class="sxs-lookup"><span data-stu-id="e5b46-189">When you set the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field to `false`, the resulting method signature contains a void return type instead of an integer (`HRESULT`) return type.</span></span>  <span data-ttu-id="e5b46-190">Quand la méthode non managée produit un `HRESULT`, le runtime ignore automatiquement une valeur de retour de `S_OK` (ou 0) et ne lève pas d’exception.</span><span class="sxs-lookup"><span data-stu-id="e5b46-190">When the unmanaged method produces an `HRESULT`, the runtime automatically ignores a return value of `S_OK` (or 0) and does not throw an exception.</span></span>  <span data-ttu-id="e5b46-191">Pour `HRESULT`autres que `S_OK`, le runtime levait automatiquement une exception qui correspond à la `HRESULT`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-191">For `HRESULT`s other than `S_OK`, the runtime automatically throws an exception that corresponds to the `HRESULT`.</span></span>  <span data-ttu-id="e5b46-192">Notez que le <xref:System.Runtime.InteropServices.DllImportAttribute> attribut effectue uniquement cette conversion pour les méthodes qui retournent un `HRESULT`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-192">Note that the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute only performs this conversion to methods that return an `HRESULT`.</span></span>  
  
 <span data-ttu-id="e5b46-193">Vous pouvez décider de modifier le comportement de rapport d’erreurs par défaut `HRESULT`s aux exceptions dans les cas où des exceptions conviennent mieux à la structure de votre application de signalement d’erreurs.</span><span class="sxs-lookup"><span data-stu-id="e5b46-193">You might decide to change the default error reporting behavior from `HRESULT`s to exceptions in cases where exceptions better fit the error reporting structure of your application.</span></span>  
  
 <span data-ttu-id="e5b46-194">Ce champ est similaire à la <xref:System.Runtime.InteropServices.PreserveSigAttribute>; Toutefois, contrairement à la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ, la valeur par défaut pour l’attribut est `false`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-194">This field is similar to the <xref:System.Runtime.InteropServices.PreserveSigAttribute>; however, in contrast to the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field, the default value for the attribute is `false`.</span></span>  
  
 <span data-ttu-id="e5b46-195">Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu d’utiliser la `Declare` instruction, pour définir une fonction DLL dans du code managé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-195">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="e5b46-196">Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ est un de ces cas.</span><span class="sxs-lookup"><span data-stu-id="e5b46-196">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field is one of those cases.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-197">Le code suivant exemple utilise le <xref:System.Runtime.InteropServices.DllImportAttribute> pour importer non managée `SHAutoComplete` fonction une fois avec le <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ la valeur `true` et à nouveau avec le <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> champ la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-197">The following code example uses the <xref:System.Runtime.InteropServices.DllImportAttribute> to import the unmanaged `SHAutoComplete` function once with the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field set to `true` and again with the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field set to `false`.</span></span>  <span data-ttu-id="e5b46-198">L’exemple de code suivant génère le `SHAutoComplete` fonction permettant de générer des erreurs avec une exception une fois et une `HRESULT` suivant.</span><span class="sxs-lookup"><span data-stu-id="e5b46-198">This code example causes the `SHAutoComplete` function to generate any errors with an exception one time and an `HRESULT` the next.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-199">Indique si l'appelé appelle la fonction API Win32 <see langword="SetLastError" /> avant de retourner la valeur à partir de la méthode avec attributs.</span><span class="sxs-lookup"><span data-stu-id="e5b46-199">Indicates whether the callee calls the <see langword="SetLastError" /> Win32 API function before returning from the attributed method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-200">`true` pour indiquer que l’appelé appellera `SetLastError`; sinon, `false`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-200">`true` to indicate that the callee will call `SetLastError`; otherwise, `false`.</span></span> <span data-ttu-id="e5b46-201">La valeur par défaut est `false`.</span><span class="sxs-lookup"><span data-stu-id="e5b46-201">The default is `false`.</span></span>  
  
 <span data-ttu-id="e5b46-202">Le marshaleur runtime appelle `GetLastError` et met en cache la valeur retournée pour l’empêcher d’être remplacé par d’autres appels d’API.</span><span class="sxs-lookup"><span data-stu-id="e5b46-202">The runtime marshaler calls `GetLastError` and caches the value returned to prevent it from being overwritten by other API calls.</span></span> <span data-ttu-id="e5b46-203">Vous pouvez récupérer le code d’erreur en appelant <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.</span><span class="sxs-lookup"><span data-stu-id="e5b46-203">You can retrieve the error code by calling <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-204">Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute>, au lieu d’utiliser la `Declare` instruction, pour définir une fonction DLL dans du code managé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-204">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="e5b46-205">Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> champ est un de ces cas.</span><span class="sxs-lookup"><span data-stu-id="e5b46-205">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> field is one of those cases.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-206">Active ou désactive la levée d'une exception sur un caractère Unicode non mappable converti en caractère ANSI "?".</span><span class="sxs-lookup"><span data-stu-id="e5b46-206">Enables or disables the throwing of an exception on an unmappable Unicode character that is converted to an ANSI "?" character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-207">`true` pour indiquer qu’une exception est levée chaque fois que le marshaleur d’interopérabilité convertit un caractère non mappable ; `false` pour indiquer que le <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champ est désactivé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-207">`true` to indicate that an exception is thrown each time the interop marshaler converts an unmappable character; `false` to indicate that the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field is disabled.</span></span> <span data-ttu-id="e5b46-208">Ce champ est `false` par défaut.</span><span class="sxs-lookup"><span data-stu-id="e5b46-208">This field is `false` by default.</span></span>  
  
 <span data-ttu-id="e5b46-209">Le common language runtime convertit en caractères ANSI que tous les caractères Unicode passés à une méthode non managée qui s’exécute sur Windows 98 ou Windows Me. managés</span><span class="sxs-lookup"><span data-stu-id="e5b46-209">The common language runtime converts to ANSI characters any managed Unicode characters passed to an unmanaged method executing on Windows 98 or Windows Me.</span></span> <span data-ttu-id="e5b46-210">Le mappage ajusté permet le marshaleur d’interopérabilité fournir un caractère de correspondance proche lorsqu’il n’existe aucune correspondance exacte.</span><span class="sxs-lookup"><span data-stu-id="e5b46-210">Best-fit mapping enables the interop marshaler to provide a close-matching character when no exact match exists.</span></span> <span data-ttu-id="e5b46-211">Par exemple, le marshaleur convertit le caractère de copyright Unicode à « c » pour les méthodes non managées qui acceptent des caractères ANSI.</span><span class="sxs-lookup"><span data-stu-id="e5b46-211">For example, the marshaler converts the Unicode copyright character to 'c' for unmanaged methods that accept ANSI characters.</span></span> <span data-ttu-id="e5b46-212">Certains caractères ne disposent pas d’une représentation ajustée ; ces caractères sont appelés mappables.</span><span class="sxs-lookup"><span data-stu-id="e5b46-212">Some characters lack a best-fit representation; these characters are called unmappable.</span></span> <span data-ttu-id="e5b46-213">Caractères non mappables sont généralement convertis en la valeur par défaut ' ?' Caractère ANSI.</span><span class="sxs-lookup"><span data-stu-id="e5b46-213">Unmappable characters are usually converted to the default '?' ANSI character.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e5b46-214">Certains caractères Unicode sont convertis en caractères dangereuses, telles que la barre oblique inverse '\\' caractère, qui peut modifier par inadvertance un chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="e5b46-214">Certain Unicode characters are converted to dangerous characters, such as the backslash '\\' character, which can inadvertently change a path.</span></span> <span data-ttu-id="e5b46-215">En définissant le <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champ `true`, vous pouvez indiquer la présence d’un caractère non mappable à l’appelant en levant une exception.</span><span class="sxs-lookup"><span data-stu-id="e5b46-215">By setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field to `true`, you can signal the presence of an unmappable character to the caller by throwing an exception.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e5b46-216">Vous ne pouvez pas modifier les valeurs par défaut fournies par le <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> et <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champs lorsque le passage d’un tableau managé dont les éléments est des caractères ANSI ou des LPSTR à un tableau sécurisé non managé.</span><span class="sxs-lookup"><span data-stu-id="e5b46-216">You cannot change the default values provided by the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> and <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields when passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged safe array.</span></span> <span data-ttu-id="e5b46-217">Le mappage ajusté est toujours activé et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-217">Best-fit mapping is always enabled and no exception is thrown.</span></span> <span data-ttu-id="e5b46-218">N’oubliez pas que cette combinaison peut compromettre votre modèle de sécurité.</span><span class="sxs-lookup"><span data-stu-id="e5b46-218">Be aware that this combination can compromise your security model.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5b46-219">Dans certains cas, les développeurs Visual Basic utilisent les <xref:System.Runtime.InteropServices.DllImportAttribute> pour définir une fonction DLL en code managé, au lieu d’utiliser la `Declare` instruction.</span><span class="sxs-lookup"><span data-stu-id="e5b46-219">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute> to define a DLL function in managed code, instead of using the `Declare` statement.</span></span> <span data-ttu-id="e5b46-220">Définition de la <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> champ est un de ces cas.</span><span class="sxs-lookup"><span data-stu-id="e5b46-220">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field is one of those cases.</span></span> <span data-ttu-id="e5b46-221">L’exemple suivant montre comment appliquer le plus strict sécurité de mappage de caractères à une plateforme appeler des définitions de méthode en spécifiant le jeu de caractères ANSI, la désactivation du comportement de mappage ajusté et lever une exception sur des caractères Unicode non mappés.</span><span class="sxs-lookup"><span data-stu-id="e5b46-221">The following example shows how to apply the strictest character mapping security to a platform invoke method definitions by specifying the ANSI character set, disabling best fit mapping behavior, and throwing an exception on unmapped Unicode characters.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a"><span data-ttu-id="e5b46-222">Marshaling d’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="e5b46-222">Interop Marshaling</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e5b46-223">Obtient le nom du fichier DLL contenant le point d'entrée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-223">Gets the name of the DLL file that contains the entry point.</span></span></summary>
        <value><span data-ttu-id="e5b46-224">Nom du fichier DLL contenant le point d'entrée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-224">The name of the DLL file that contains the entry point.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5b46-225">Vous pouvez fournir un chemin d’accès complet ou relatif.</span><span class="sxs-lookup"><span data-stu-id="e5b46-225">You can provide a full or relative path.</span></span> <span data-ttu-id="e5b46-226">Si vous ne fournissez aucun chemin d’accès, la DLL doit être dans le chemin d’accès actuel au moment de l’exécution, sauf si la DLL est chargée par d’autres moyens.</span><span class="sxs-lookup"><span data-stu-id="e5b46-226">If you provide no path, the DLL must be in the current path at run time, unless the DLL is loaded by some other means.</span></span> <span data-ttu-id="e5b46-227">Sachez, toutefois, qu’à l’aide d’un chemin d’accès qualifié complet peut introduire imprécision si la DLL est déplacée.</span><span class="sxs-lookup"><span data-stu-id="e5b46-227">Be aware, however, that using a fully qualified path can introduce inaccuracy if the DLL is moved.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>